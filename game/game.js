/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 2039:
/***/ (() => {

{
	/**全局卡牌 */
	let { game, ui, get, ai, lib, _status } = vkCore
	let groupCard = {
		type: 'faction',
		fullskin: true
	}
	lib.card = {
		list: [],
		//石头剪刀布
		pss_paper: {
			type: 'pss',
			fullskin: true,
		},
		pss_scissor: {
			type: 'pss',
			fullskin: true,
		},
		pss_stone: {
			type: 'pss',
			fullskin: true,
		},
		//区域废弃标志
		feichu_equip1: {
			type: "equip",
			subtype: "equip1",
		},
		feichu_equip2: {
			type: "equip",
			subtype: "equip2",
		},
		feichu_equip3: {
			type: "equip",
			subtype: "equip3",
		},
		feichu_equip4: {
			type: "equip",
			subtype: "equip4",
		},
		feichu_equip5: {
			type: "equip",
			subtype: "equip5",
		},
		disable_judge: {},
		//势力卡牌
		group_wei: { ...groupCard },
		group_shu: { ...groupCard },
		group_wu: { ...groupCard },
		group_qun: { ...groupCard },
		group_key: { ...groupCard },
		group_jin: { ...groupCard },
		group_holo: { ...groupCard, },
		group_nijisanji: { ...groupCard, },
		group_VirtuaReal: { ...groupCard, },
		group_upd8: { ...groupCard, },
		group_paryi: { ...groupCard, },
		group_kagura: { ...groupCard, },
		group_nanashi: { ...groupCard, },
		group_psp: { ...groupCard, },
		group_asoul: { ...groupCard, },
		group_nori: { ...groupCard, },
		group_vwp: { ...groupCard, },
		group_chaos: { ...groupCard, },
		group_xuyan: { ...groupCard, },
		group_xuefeng: { ...groupCard, },
		group_Providence: { ...groupCard, },
		group_HappyEl: { ...groupCard, },
		group_RedC: { ...groupCard, },
	}
}

/***/ }),

/***/ 8129:
/***/ (() => {

{
    /**
     *表情基础设置 
     * @namespace
     */
	let { game, ui, get, ai, lib, _status } = vkCore
    lib.emotionList = {
        xiaowu_emotion: 14,
        shibing_emotion: 15,
        guojia_emotion: 20,
        zhenji_emotion: 20,
        xiaosha_emotion: 20,
        xiaotao_emotion: 20,
        xiaojiu_emotion: 20,
        Diana_emotion: 6,
    }
}

/***/ }),

/***/ 5062:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _card__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2039);
/* harmony import */ var _card__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_card__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _emotionList__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8129);
/* harmony import */ var _emotionList__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_emotionList__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _menu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(732);
/* harmony import */ var _menu__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_menu__WEBPACK_IMPORTED_MODULE_2__);




/***/ }),

/***/ 8430:
/***/ ((module) => {

module.exports = {
	/**
	 * 武将牌势力
	 * |string|Group Name|
	 * |:----:|:--------:|
	 * |vtuber|企业|
	 * |clubs|社团|
	 * |wei|魏|
	 * |shu|蜀|
	 * |wu|吴|
	 * |qun|群|
	 * |jin|晋|
	 * |shen|神、特典|
	 * |holo|Hololive|
	 * |nijisanji|虹|
	 * |dotlive|点|
	 * |upd8|U|
	 * |eilene|艾琳|
	 * |paryi|帕里|
	 * |kagura|神楽|
	 * |nori|苔|
	 * |vwp|神椿|
	 * |nanashi|774 inc.|
	 * |VirtuaReal|VirtuaReal|
	 * |psp|psplive|
	 * |asoul|A-SOUL|
	 * |chaos|Chaos Live|
	 * |xuefeng|雪风军团|
	 * |vshojo|Vshojo|
	 * @type {string}
	 */
	group: [
		'wei', 'shu', 'wu', 'qun', 'jin', 'western', 'key', 'shen',
		'holo', 'nijisanji', 'dotlive', 'upd8', 'eilene', 'paryi', 'kagura', 'nori', 'vwp', 'nanashi',
		'VirtuaReal', 'HappyEl', 'psp', 'asoul', 'xuyan', 'chaos', 'xuefeng', 'Providence', 'NetEase', 'hunmiao', 'ego', 'Tencent', 'lucca', 'RedC',
		'vshojo',
		'vtuber', 'clubs'
	],
	/**
	 * shen势力可选的武将牌势力
	 * 较group去除了企业、社团、三国势力
	 * @type {string}
	 */
	group2: ['qun', 'holo', 'nijisanji', 'VirtuaReal', 'HappyEl', 'nori', 'paryi', 'upd8', 'kagura', 'nanashi',
		'psp', 'asoul', 'vwp', 'xuyan', 'chaos', 'xuefeng', 'Providence'],
	/**
	 * 势力对应属性
	 * @constant
	 */
	groupnature: {
		shen: 'thunder',
		wei: 'water',
		shu: 'soil',
		wu: 'wood',
		qun: 'metal',
		western: 'thunder',
		key: 'key',
		jin: 'thunder',
		ye: 'thunder',
		holo: 'water',
		upd8: 'metal',
		dotlive: 'wood',
		nijisanji: 'water',
		VirtuaReal: 'thunder',
		HappyEl: 'orange',
		eilene: 'thunder',
		paryi: 'ice',
		kagura: 'ocean',
		nanashi: 'wood',
		psp: 'fire',
		asoul: 'fire',
		nori: 'key',
		vwp: 'key',
		vshojo: 'metal',
		xuyan: 'ice',
		chaos: 'yami',
		xuefeng: 'orange',
		Providence: 'yami',
		NetEase: 'fire',
		hunmiao: 'ocean',
		ego: 'ocean',
		Tencent: 'yami',
		lucca: 'wood',
		RedCircle: 'fire',

		vtuber: 'metal',
		clubs: 'ice',
	}
}

/***/ }),

/***/ 4270:
/***/ ((module) => {

module.exports = {
    /**
     * 卡牌属性
     * @type {('fire'|'thunder'|'poison'|'ocean'|'ice'|'kami'|'yami')}
     */
    nature: ['fire', 'thunder', 'poison', 'ocean', 'ice', 'kami', 'yami'],
    /**
     * 可被铁索传递的属性 - TODO
     * @type {string}
     */
    linked: ['fire', 'thunder', 'ocean', 'ice', 'kami', 'yami'],
}

/***/ }),

/***/ 8456:
/***/ ((module) => {

module.exports = {
	/**
	 * 词汇翻译
	 * 翻译文本
	 * @type {!Object}
	 */
	translate: {
		faction: ' ',
		
		sc: '打钱',
		ship: '上舰',
		flower: '鲜花',
		egg: '鸡蛋',
		wine: '酒杯',
		shoe: '拖鞋',
		yuxisx: '玉玺',
		shoukao: '枷锁',
		junk: '平凡',

		common: '普通',
		rare: '精品',
		epic: '史诗',
		legend: '传说',

		beginner: '简单',

		default: "默认",
		special: '特殊',
		zhenfa: '阵法',
		aozhan: "鏖战",
		mode_derivation_card_config: '衍生',
		mode_banned_card_config: '禁卡',
		mode_favourite_character_config: '收藏',
		mode_banned_character_config: '禁将',
		suit: '花色',
		heart: "♥︎",
		diamond: "♦︎",
		spade: "♠︎",
		club: "♣︎",
		ghujia: '护甲',
		ghujia_bg: '甲',
		heart2: "红桃",
		diamond2: "方片",
		spade2: "黑桃",
		club2: "梅花",
		color: '颜色',
		red: '红色',
		black: '黑色',
		none: '无色',

		number: '点数',
		cardname: '牌名',

		ok: "确定",
		ok2: "确定",
		cancel: "取消",
		cancel2: "取消",
		restart: "重新开始",
		setting: "设置",
		start: "开始",
		random: "随机",
		_out: '无效',
		agree: '同意',
		refuse: '拒绝',
		fire: "火",
		thunder: "雷",
		poison: "毒",
		kami: '神',
		ocean: '海',
		ice: '冰',
		yami: '暗',

		fire_ab: '火焰',
		thunder_ab: '雷电',
		ocean_ab: '海洋',
		ice_ab: '冰冻',
		yami_ab: '暗影',

		vtuber: '企',
		clubs: '社',
		vtuber2: '企业联合',
		clubs2: '社团联合',

		wei: '魏',
		shu: '蜀',
		wu: '吴',
		qun: '群',
		shen: '皇',
		western: '西',
		key: 'N',
		holo: '杏',
		dotlive: '点',
		nijisanji: '虹',
		VirtuaReal: '维阿',
		HappyEl: '乐',
		NetEase: '网',
		upd8: 'U',
		eilene: '艾琳',
		paryi: '帕',
		kagura: '神楽',
		nanashi: '774',
		psp: 'P',
		asoul: 'A',
		nori: '苔',
		vwp: '神椿',
		vshojo: 'V',
		xuyan: '虚',
		chaos: 'C',
		xuefeng: '雪',
		Providence: '普',
		hunmiao: '魂',
		ego: '复',
		Tencent: '腾',
		lucca: 'L',
		RedC: '红',
		double: '多',
		wei2: '魏国',
		shu2: '蜀国',
		wu2: '吴国',
		qun2: '群雄',
		shen2: '特典',
		western2: '西方',
		key2: 'KEY',
		holo2: 'Hololive',
		upd82: 'Upd8',
		dotlive2: '.live',
		nijisanji2: 'Nijisanji',
		VirtuaReal2: 'VirtuaReal',
		HappyEl2: '乐元素',
		NetEase2: '网易',
		eilene2: '艾琳一家',
		paryi2: '帕里坡',
		kagura2: '神楽组',
		nanashi2: '774inc',
		psp2: 'psplive',
		asoul2: 'A-SOUL',
		nori2: 'Noripro',
		vwp2: '神椿市',
		vshojo2: 'Vshojo',
		xuyan2: '虚研社',
		chaos2: 'ChaosLive',
		xuefeng2: '雪风军团',
		Providence2: '普罗维登',
		hunmiao2: '魂喵科技',
		ego2: 'Egolive',
		Tencent2: '腾讯',
		lucca2: 'Lucca事务所',
		RedC2: 'RedCircle',
		double2: '多势力',
		male: '男',
		female: '女',
		mad: '混乱',
		mad_bg: '疯',

		hp: '体力',

		draw_card: '摸牌',
		discard_card: '弃牌',
		take_damage: '受伤害',
		reset_character: '复原武将牌',
		recover_hp: '回复体力',
		lose_hp: '流失体力',
		get_damage: '受伤害',
		weiColor: "#b0d0e2",
		shuColor: "#ffddb9",
		wuColor: "#b2d9a9",
		qunColor: "#f6f6f6",
		shenColor: "#ffe14c",
		westernColor: "#ffe14c",
		jinColor: "#ffe14c",
		keyColor: "#c9b1fd",
		holoColor: "#38ABE0",
		nijisanjiColor: "#b0d0e2",
		dotliveColor: "#b2d9a9",
		upd8Color: "#ffe14c",
		eileneColor: "#DB7093",
		paryiColor: "#DDAAAF",
		VirtuaRealColor: "#77aaee",
		HappyElColor: "#60ACC8",
		kaguraColor: "#55deef",
		nanashiColor: "#e27b6b",
		pspColor: "#4d3d11",
		asoulColor: "#ffddcc",
		noriColor: "#a8ddaa",
		basic: '基本',
		equip: '装备',
		trick: '锦囊',
		delay: '延时锦囊',
		character: '角色',
		revive: '复活',
		equip1: '武器',
		equip2: '防具',
		equip3: '防御载具',
		equip4: '攻击载具',
		equip5: '宝物',
		equip6: '坐骑',
		zero: '零',
		one: '一',
		two: '二',
		three: '三',
		four: '四',
		five: '五',
		six: '六',
		seven: '七',
		eight: '八',
		nine: '九',
		ten: '十',
		_chongzhu: '重铸',
		_lianhuan: '连环',
		_lianhuan2: '连环',
		_kamisha: '神杀',
		_oceansha: '海杀',
		_icesha: '冰杀',
		_yamisha: '暗杀',
		_yamisha2: '暗影',
		_shengjie: '升阶',
		qianxing: '潜行',
		mianyi: '免疫',
		fengyin: '封印',
		baiban: '白板',
		_disableJudge: "判定区",
		pileTop: '牌堆顶',
		pileBottom: '牌堆底',

		xiaowu_emotion: '小无表情',
		guojia_emotion: '郭嘉表情',
		zhenji_emotion: '甄姬表情',
		shibing_emotion: '士兵表情',
		xiaosha_emotion: '小杀表情',
		xiaotao_emotion: '小桃表情',
		xiaojiu_emotion: '小酒表情',
		Diana_emotion: '嘉然表情',

		pause: '暂停',
		config: '选项',
		auto: '托管',

		unknown: '未知',
		unknown0: '一号位',
		unknown1: '二号位',
		unknown2: '三号位',
		unknown3: '四号位',
		unknown4: '五号位',
		unknown5: '六号位',
		unknown6: '七号位',
		unknown7: '八号位',

		feichu_equip1: "已废除",
		feichu_equip1_info: "武器栏已废除",
		feichu_equip2: "已废除",
		feichu_equip2_info: "防具栏已废除",
		feichu_equip3: "已废除",
		feichu_equip3_info: "防御坐骑栏已废除",
		feichu_equip4: "已废除",
		feichu_equip4_info: "攻击坐骑栏已废除",
		feichu_equip5: "已废除",
		feichu_equip5_info: "宝物栏已废除",
		feichu_equip1_bg: "废",
		feichu_equip2_bg: "废",
		feichu_equip3_bg: "废",
		feichu_equip4_bg: "废",
		feichu_equip5_bg: "废",
		disable_judge: '已废除',
		disable_judge_info: '判定区已废除',
		disable_judge_bg: '废',
		pss: '手势',
		pss_paper: '布',
		pss_scissor: '剪刀',
		pss_stone: '石头',
		pss_paper_info: '石头剪刀布时的一种手势。克制石头，但被剪刀克制。',
		pss_scissor_info: '石头剪刀布时的一种手势。克制布，但被石头克制。',
		pss_stone_info: '石头剪刀布时的一种手势。克制剪刀，但被布克制。',

		phaseZhunbei: `准备阶段`,
		phaseJudge: `判定阶段`,
		phaseDraw: `摸牌阶段`,
		phaseUse: `出牌阶段`,
		phaseDiscard: `弃牌阶段`,
		phaseJieshu: `结束阶段`,

		group_wei: "魏势力",
		group_shu: "蜀势力",
		group_wu: "吴势力",
		group_jin: "晋势力",
		group_qun: "群势力",
		group_key: "键势力",
		group_holo: "木口势力",
		group_nijisanji: "彩虹势力",
		group_VirtuaReal: "维阿势力",
		group_upd8: "U势力",
		group_paryi: "帕里势力",
		group_kagura: "神楽势力",
		group_nanashi: "774",
		group_psp: "PSP",
		group_asoul: "一个魂",
		group_nori: "苔势力",
		group_vwp: "神椿势力",
		group_chaos: "混沌社",
		group_xuyan: "虚研社",
		group_xuefeng: "雪风军团",
		group_Providence: "普罗维登",
		group_HappyEl: "乐元素",
		group_RedC: "红圈",
		group_wei_bg: "魏",
		group_shu_bg: "蜀",
		group_wu_bg: "吴",
		group_qun_bg: "群",
		group_jin_bg: "晋",
		group_key_bg: "键",
		group_holo_bg: "杏",
		group_nijisanji_bg: "虹",
		group_VirtuaReal_bg: "维",
		group_upd8_bg: "U",
		group_paryi_bg: "帕",
		group_kagura_bg: "咩",
		group_nanashi_bg: "な",
		group_psp_bg: "な",
		group_asoul_bg: "魂",
		group_nori_bg: "苔",
		group_vwp_bg: "椿",
		group_chaos_bg: "潮",
		group_xuyan_bg: "虚",
		group_xuefeng_bg: "雪",
		group_Providence_bg: "罗",
		group_HappyEl_bg: "乐",
		group_RedC_bg: "红",
	}
}

/***/ }),

/***/ 732:
/***/ (() => {

{
    /**
     * 游戏菜单
     * @name configMenu
     * @namespace
     * @type {!Object}
     */
    let { game, ui, get, ai, lib, _status } = vkCore
    lib.configMenu = {
        /**
         * 通用设置
         * @name configMenu.general
         * @type {!Object}
         */
        general: {
            name: '通用',
            config: {
                low_performance: {
                    name: '流畅模式',
                    init: false,
                    intro: '减少部分游戏特效，提高游戏速度',
                    onclick: function (bool) {
                        game.saveConfig('low_performance', bool);
                        if (bool) {
                            ui.window.classList.add('low_performance');
                        }
                        else {
                            ui.window.classList.remove('low_performance');
                        }
                    }
                },
                compatiblemode: {
                    name: '兼容模式',
                    init: false,
                    intro: '开启兼容模式可防止扩展使游戏卡死并提高对旧扩展的兼容性，但对游戏速度有一定影响，若无不稳定或不兼容的扩展建议关闭',
                    onclick: function (bool) {
                        game.saveConfig('compatiblemode', bool);
                        if (bool) {
                            ui.window.classList.add('compatiblemode');
                        }
                        else {
                            ui.window.classList.remove('compatiblemode');
                        }
                    }
                },
                confirm_exit: {
                    name: '确认退出',
                    init: false,
                    unfrequent: true,
                    intro: '离开游戏前弹出确认对话框',
                },
                keep_awake: {
                    name: '屏幕常亮',
                    init: false,
                    unfrequent: true,
                    intro: '防止屏幕自动关闭<br>注：旧版本通过NoSleep.js实现的屏幕常亮可能会影响外置音频的音量',
                    onclick: function (bool) {
                        game.saveConfig('keep_awake', bool);
                        if (bool) {
                            if (window.plugins && window.plugins.insomnia) window.plugins.insomnia.keepAwake();
                            else if (window.noSleep) {
                                document.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', function enableNoSleepX() {
                                    document.removeEventListener(lib.config.touchscreen ? 'touchend' : 'click', enableNoSleepX, false);
                                    window.noSleep.enable();
                                }, false);
                            }
                        }
                        else {
                            if (window.plugins && window.plugins.insomnia) window.plugins.insomnia.allowSleepAgain();
                            else if (window.noSleep) window.noSleep.disable();
                        }
                    }
                },
                auto_confirm: {
                    name: '自动确认',
                    init: true,
                    unfrequent: true,
                    intro: '当候选目标只有1个时，点击目标后无需再点击确认',
                },
                skip_shan: {
                    name: '无闪自动取消',
                    init: false,
                    unfrequent: true,
                    intro: '当自己需要使用或打出【闪】时，若自己没有【闪】，则跳过该步骤',
                },
                unauto_choose: {
                    name: '拆顺手牌选择',
                    init: false,
                    unfrequent: true,
                    intro: '拆牌或者顺牌时，就算只能选择对方的手牌依然手动选择',
                },
                wuxie_self: {
                    name: '不无懈自己',
                    init: true,
                    unfrequent: true,
                    intro: '自己使用的单目标普通锦囊即将生效时，不询问无懈',
                },
                tao_enemy: {
                    name: '不对敌方出桃',
                    init: false,
                    intro: '双方阵营明确的模式中（如对决），敌方角色濒死时不询问出桃',
                    unfrequent: true,
                },
                enable_drag: {
                    name: '启用拖拽',
                    init: true,
                    intro: '按住卡牌后可将卡牌拖至目标',
                    unfrequent: true,
                },
                enable_dragline: {
                    name: '拖拽指示线',
                    init: true,
                    unfrequent: true,
                    intro: '拖拽时显示虚线，可能降低游戏速度',
                },
                enable_touchdragline: {
                    name: '拖拽指示线',
                    init: false,
                    unfrequent: true,
                    intro: '拖拽时显示虚线，可能降低游戏速度',
                },
                // enable_pressure:{
                //     name:'启用压感',
                //     init:false,
                //     intro:'开启后可通过按压执行操作',
                //     unfrequent:true,
                // },
                // pressure_taptic:{
                //     name:'触觉反馈',
                //     init:false,
                //     intro:'开启后按压操作执行时将产生震动',
                //     unfrequent:true,
                // },
                // pressure_click:{
                //     name:'按压操作',
                //     init:'pause',
                //     intro:'在空白区域按压时的操作',
                //     unfrequent:true,
                //     item:{
                //         pause:'暂停',
                //         config:'选项',
                //         auto:'托管',
                //     }
                // },
                touchscreen: {
                    name: '触屏模式',
                    init: false,
                    restart: true,
                    unfrequent: true,
                    intro: '开启后可使触屏设备反应更快，但无法使用鼠标操作',
                    onclick: function (bool) {
                        if (get.is.nomenu('touchscreen', bool)) return false;
                        game.saveConfig('touchscreen', bool);
                    }
                },
                swipe: {
                    name: '滑动手势',
                    init: true,
                    unfrequent: true,
                    intro: '在非滚动区域向四个方向滑动可执行对应操作',
                },
                swipe_down: {
                    name: '下划操作',
                    init: 'menu',
                    unfrequent: true,
                    intro: '向下滑动时执行的操作',
                    item: {
                        system: '显示按钮',
                        menu: '打开菜单',
                        pause: '切换暂停',
                        auto: '切换托管',
                        chat: '显示聊天',
                        off: '关闭',
                    },
                    onclick: function (item) {
                        if (get.is.nomenu('swipe_down', item)) return false;
                        game.saveConfig('swipe_down', item);
                    }
                },
                swipe_up: {
                    name: '上划操作',
                    intro: '向上滑动时执行的操作',
                    init: 'auto',
                    unfrequent: true,
                    item: {
                        system: '显示按钮',
                        menu: '打开菜单',
                        pause: '切换暂停',
                        auto: '切换托管',
                        chat: '显示聊天',
                        off: '关闭',
                    },
                    onclick: function (item) {
                        if (get.is.nomenu('swipe_up', item)) return false;
                        game.saveConfig('swipe_up', item);
                    }
                },
                swipe_left: {
                    name: '左划操作',
                    intro: '向左滑动时执行的操作',
                    init: 'system',
                    unfrequent: true,
                    item: {
                        system: '显示按钮',
                        menu: '打开菜单',
                        pause: '切换暂停',
                        auto: '切换托管',
                        chat: '显示聊天',
                        off: '关闭',
                    },
                    onclick: function (item) {
                        if (get.is.nomenu('swipe_left', item)) return false;
                        game.saveConfig('swipe_left', item);
                    }
                },
                swipe_right: {
                    name: '右划操作',
                    intro: '向右滑动时执行的操作',
                    init: 'system',
                    unfrequent: true,
                    item: {
                        system: '显示按钮',
                        menu: '打开菜单',
                        pause: '切换暂停',
                        auto: '切换托管',
                        chat: '显示聊天',
                        off: '关闭',
                    },
                    onclick: function (item) {
                        if (get.is.nomenu('swipe_right', item)) return false;
                        game.saveConfig('swipe_right', item);
                    }
                },
                round_menu_func: {
                    name: '触屏按钮操作',
                    intro: '点击屏幕中圆形按钮时执行的操作',
                    init: 'system',
                    unfrequent: true,
                    item: {
                        system: '显示按钮',
                        menu: '打开菜单',
                        pause: '切换暂停',
                        auto: '切换托管'
                    },
                    onclick: function (item) {
                        if (get.is.nomenu('round_menu_func', item)) return false;
                        game.saveConfig('round_menu_func', item);
                    },
                },
                show_splash: {
                    name: '显示开始界面',
                    intro: '游戏开始前进入模式选择画面',
                    init: 'init',
                    item: {
                        off: '关闭',
                        init: '首次启动',
                        always: '保持开启',
                    }
                },
                game_speed: {
                    name: '游戏速度',
                    init: 'mid',
                    item: {
                        vslow: '慢',
                        slow: '较慢',
                        mid: '中',
                        fast: '较快',
                        vfast: '快',
                        vvfast: '很快',
                    },
                    intro: '设置不同游戏操作间的时间间隔'
                },
                sync_speed: {
                    name: '限制结算速度',
                    intro: '在动画结算完成前不执行下一步操作，开启后游戏操作的间隔更长但画面更浏畅，在游戏较卡时建议开启',
                    init: true
                },
                enable_vibrate: {
                    name: '开启震动',
                    intro: '回合开始时使手机震动',
                    init: false
                },
                right_click: {
                    name: '右键操作',
                    init: 'pause',
                    intro: '在空白区域点击右键时的操作',
                    unfrequent: true,
                    item: {
                        pause: '暂停',
                        shortcut: '工具',
                        config: '选项',
                        auto: '托管',
                    },
                    onclick: function (item) {
                        if (get.is.nomenu('right_click', item)) return false;
                        game.saveConfig('right_click', item);
                    }
                },
                longpress_info: {
                    name: '长按显示信息',
                    init: true,
                    unfrequent: true,
                    restart: true,
                    intro: '长按后弹出菜单',
                },
                right_info: {
                    name: '右键显示信息',
                    init: true,
                    unfrequent: true,
                    restart: true,
                    intro: '右键点击后弹出菜单',
                },
                hover_all: {
                    name: '悬停显示信息',
                    init: true,
                    unfrequent: true,
                    restart: true,
                    intro: '悬停后弹出菜单',
                },
                hover_handcard: {
                    name: '悬停手牌显示信息',
                    init: true,
                    unfrequent: true,
                    intro: '悬停手牌后弹出菜单',
                },
                hoveration: {
                    name: '悬停菜单弹出时间',
                    unfrequent: true,
                    intro: '鼠标移至目标到弹出菜单的时间间隔',
                    init: '1000',
                    item: {
                        '500': '0.5秒',
                        '700': '0.7秒',
                        '1000': '1秒',
                        '1500': '1.5秒',
                        '2500': '2.5秒',
                    }
                },
                doubleclick_intro: {
                    name: '双击显示武将资料',
                    init: true,
                    unfrequent: true,
                    intro: '双击武将头像后显示其资料卡',
                },
                video: {
                    name: '保存录像',
                    init: '20',
                    intro: '游戏结束后保存录像在最大条数，超过后将从最早的录像开始删除（已收藏的录像不计入条数）',
                    item: {
                        '0': '关闭',
                        '5': '五局',
                        '10': '十局',
                        '20': '二十局',
                        '50': '五十局',
                        '10000': '无限',
                    },
                    unfrequent: true,
                },
                max_loadtime: {
                    name: '最长载入时间',
                    intro: '设置游戏从启动到完成载入所需的最长时间，超过此时间未完成载入会报错，若设备较慢或安装了较多扩展可适当延长此时间',
                    init: '10000',
                    unfrequent: true,
                    item: {
                        5000: '5秒',
                        10000: '10秒',
                        20000: '20秒',
                        60000: '60秒'
                    },
                    onclick: function (item) {
                        game.saveConfig('max_loadtime', item);
                        if (item == '5000') {
                            localStorage.removeItem(lib.configprefix + 'loadtime');
                        }
                        else {
                            localStorage.setItem(lib.configprefix + 'loadtime', item);
                        }
                    }
                },
                mousewheel: {
                    name: '滚轮控制手牌',
                    init: true,
                    unfrequent: true,
                    intro: '开启后滚轮可使手牌横向滚动，在mac等可横向滚动的设备上建议关闭',
                    onclick: function (bool) {
                        game.saveConfig('mousewheel', bool);
                        if (lib.config.touchscreen) return;
                        if (lib.config.mousewheel) {
                            ui.handcards1Container.onmousewheel = ui.click.mousewheel;
                            ui.handcards2Container.onmousewheel = ui.click.mousewheel;
                        }
                        else {
                            ui.handcards1Container.onmousewheel = null;
                            ui.handcards2Container.onmousewheel = null;
                        }
                    }
                },
                auto_check_update: {
                    name: '自动检查游戏更新',
                    intro: '进入游戏时检查更新',
                    init: true,
                    unfrequent: true
                },
                lucky_star: {
                    name: '幸运星模式',
                    intro: '在涉及随机数等的技能中，必定得到效果最好的结果。（联机模式无效）',
                    init: false,
                    unfrequent: true
                },
                dev: {
                    name: '开发者模式',
                    intro: '开启后可使用浏览器控制台控制游戏，同时可更新到开发版',
                    init: false,
                    onclick: function (bool) {
                        game.saveConfig('dev', bool);
                        if (_status.connectMode) return;
                        if (bool) {
                            lib.cheat.i();
                        }
                        else {
                            delete window.cheat;
                            delete window.game;
                            delete window.ui;
                            delete window.get;
                            delete window.ai;
                            delete window.lib;
                            delete window._status;
                        }
                    },
                    unfrequent: true,
                },
                errstop: {
                    name: '出错时停止游戏',
                    init: false,
                    unfrequent: true
                },
                update_link: {
                    name: '更新地址',
                    init: 'coding',
                    unfrequent: true,
                    item: {
                        coding: 'Coding',
                        // github: 'GitHub',
                    },
                    onclick: function (item) {
                        game.saveConfig('update_link', item);
                        lib.updateURL = lib.updateURLS[item] || lib.updateURLS.coding;
                    },
                },
                //https://raw.githubusercontent.com/libccy/noname-extension/master/
                extension_source: {
                    name: '获取扩展地址',
                    init: 'Coding',
                    unfrequent: true,
                    item: {},
                    intro: function () {
                        return '获取在线扩展时的地址。当前地址：<br>' + lib.config.extension_sources[lib.config.extension_source];
                    },
                    onclick: function (item) {
                        game.saveConfig('extension_source', item);
                    },
                },
                extension_create: {
                    name: '添加获取扩展地址',
                    clear: true,
                    unfrequent: true,
                    onclick: function () {
                        game.prompt('请输入地址名称', function (str) {
                            if (str) {
                                var map = lib.config.extension_sources;
                                game.prompt('请输入' + str + '的地址', function (str2) {
                                    if (str2) {
                                        delete map[str];
                                        map[str] = str2;
                                        game.saveConfig('extension_sources', map);
                                        game.saveConfig('extension_source', str);
                                        var nodexx = ui.extension_source;
                                        nodexx.updateInner();
                                        var nodeyy = nodexx._link.menu;
                                        var nodezz = nodexx._link.config;
                                        for (var i = 0; i < nodeyy.childElementCount; i++) {
                                            if (nodeyy.childNodes[i]._link == str) {
                                                nodeyy.childNodes[i].remove();
                                                break;
                                            }
                                        }
                                        var textMenu = ui.create.div('', str, nodeyy, function () {
                                            var node = this.parentNode._link;
                                            var config = node._link.config;
                                            node._link.current = this.link;
                                            var tmpName = node.lastChild.innerHTML;
                                            node.lastChild.innerHTML = config.item[this._link];
                                            if (config.onclick) {
                                                if (config.onclick.call(node, this._link, this) === false) {
                                                    node.lastChild.innerHTML = tmpName;
                                                }
                                            }
                                            if (config.update) {
                                                config.update();
                                            }
                                        });
                                        textMenu._link = str;
                                        nodezz.item[name] = str;
                                        alert('已添加扩展地址：' + str);
                                    }
                                })
                            }
                        });
                    },
                },
                extension_delete: {
                    name: '删除当前扩展地址',
                    clear: true,
                    unfrequent: true,
                    onclick: function () {
                        var bool = false, map = lib.config.extension_sources;
                        for (var i in map) {
                            if (i != lib.config.extension_source) {
                                bool = true;
                                break;
                            }
                        }
                        if (!bool) {
                            alert('不能删除最后一个扩展地址！');
                            return;
                        }
                        var name = lib.config.extension_source;
                        game.saveConfig('extension_source', i);
                        delete map[name];
                        game.saveConfig('extension_sources', map);
                        var nodexx = ui.extension_source;
                        nodexx.updateInner();
                        var nodeyy = nodexx._link.menu;
                        var nodezz = nodexx._link.config;
                        for (var i = 0; i < nodeyy.childElementCount; i++) {
                            if (nodeyy.childNodes[i]._link == name) {
                                nodeyy.childNodes[i].remove();
                                break;
                            }
                        }
                        delete nodezz.item[name];
                        alert('已删除扩展地址：' + name);
                    },
                },
                update: function (config, map) {
                    if ('ontouchstart' in document) {
                        map.touchscreen.show();
                    }
                    else {
                        map.touchscreen.hide();
                    }
                    if (lib.device || lib.node) {
                        map.auto_check_update.show();
                    }
                    else {
                        map.auto_check_update.hide();
                    }
                    if (lib.device) {
                        map.enable_vibrate.show();
                        map.keep_awake.show();
                    }
                    else {
                        map.enable_vibrate.hide();
                        map.keep_awake.hide();
                    }
                    // if(config.enable_pressure){
                    //     map.pressure_click.show();
                    //     if(lib.device){
                    //         map.pressure_taptic.show();
                    //     }
                    //     else{
                    //         map.pressure_taptic.hide();
                    //     }
                    // }
                    // else{
                    //     map.pressure_click.hide();
                    //     map.pressure_taptic.hide();
                    // }
                    if (lib.config.touchscreen) {
                        map.mousewheel.hide();
                        map.hover_all.hide();
                        map.hover_handcard.hide();
                        map.hoveration.hide();
                        map.right_info.hide();
                        map.right_click.hide();
                        map.longpress_info.show();
                        map.swipe.show();
                        if (lib.config.swipe) {
                            map.swipe_up.show();
                            map.swipe_down.show();
                            map.swipe_left.show();
                            map.swipe_right.show();
                        }
                        else {
                            map.swipe_up.hide();
                            map.swipe_down.hide();
                            map.swipe_left.hide();
                            map.swipe_right.hide();
                        }
                    }
                    else {
                        map.mousewheel.show();
                        map.hover_all.show();
                        map.right_info.show();
                        map.right_click.show();
                        map.longpress_info.hide();
                        if (!config.hover_all) {
                            map.hover_handcard.hide();
                            map.hoveration.hide();
                        }
                        else {
                            map.hover_handcard.show();
                            map.hoveration.show();
                        }
                        map.swipe.hide();
                        map.swipe_up.hide();
                        map.swipe_down.hide();
                        map.swipe_left.hide();
                        map.swipe_right.hide();
                    }
                    if (lib.config.enable_drag) {
                        if (lib.config.touchscreen) {
                            map.enable_dragline.hide();
                            map.enable_touchdragline.show();
                        }
                        else {
                            map.enable_dragline.show();
                            map.enable_touchdragline.hide();
                        }
                    }
                    else {
                        map.enable_dragline.hide();
                        map.enable_touchdragline.hide();
                    }
                    if (!get.is.phoneLayout()) {
                        map.round_menu_func.hide();
                    }
                    else {
                        map.round_menu_func.show();
                    }
                    if (!lib.node && lib.device != 'ios') {
                        map.confirm_exit.show();
                    }
                    else {
                        map.confirm_exit.hide();
                    }
                    if (config.dev) {
                        map.errstop.show();
                    }
                    else {
                        map.errstop.hide();
                    }
                }
            }
        },
        /**
         * 外观设置
         * @name configMenu.appearence
         * @type {!Object}
         */
        appearence: {
            name: '外观',
            config: {
                theme: {
                    name: '主题',
                    init: 'vk',
                    item: {},
                    visualMenu: function (node, link) {
                        if (!node.menu) {
                            node.className = 'button character themebutton ' + link;
                            node.menu = ui.create.div(node, '', '<div></div><div></div><div></div><div></div>');
                        }
                    },
                    onclick: function (theme) {
                        game.saveConfig('theme', theme);
                        ui.arena.hide();
                        lib.init.background();
                        if (lib.config.autostyle) {
                            if (theme == 'simple') {
                                lib.configMenu.appearence.config.player_border.onclick('slim');
                            }
                            else {
                                lib.configMenu.appearence.config.player_border.onclick('normal');
                            }
                        }
                        setTimeout(function () {
                            var theme = ui.css.theme;
                            ui.css.theme = lib.init.css(lib.assetURL + 'theme/' + lib.config.theme, 'style');
                            theme.remove();
                            setTimeout(function () { ui.arena.show(); }, 100);
                        }, 500);
                    }
                },
                /**
                 * 游戏布局
                 * @name configMenu.appearence.layout
                 */
                layout: {
                    name: '布局',
                    init: 'mobile',
                    item: {
                        default: '旧版',
                        newlayout: '对称',
                        mobile: '默认',
                        long: '宽屏',
                        long2: '手杀',
                        nova: '新版'
                    },
                    visualMenu: function (node, link) {
                        node.className = 'button character themebutton ' + lib.config.theme;
                        if (!node.created) {
                            node.created = true;
                            node.style.overflow = 'hidden';
                            node.firstChild.style.display = 'none';
                            var me = ui.create.div(node);
                            me.style.top = 'auto';
                            if (link == 'default' || link == 'newlayout') {
                                me.style.width = 'calc(100% - 6px)';
                                me.style.left = '3px';
                                me.style.bottom = '3px';
                                me.style.height = '25px';
                                if (link == 'newlayout') {
                                    me.style.height = '23px';
                                    me.style.bottom = '4px';
                                }
                            }
                            else if (link == 'long2' || link == 'nova') {
                                me.style.display = 'none';
                            }
                            else {
                                me.style.width = '120%';
                                me.style.left = '-10%';
                                me.style.bottom = '0';
                                me.style.height = '22px';
                            }
                            me.style.borderRadius = '2px';
                            var list = ['KizunaAI', 'MiraiAkari', 'Siro', 'Nekomasu'];
                            for (var i = 0; i < 4; i++) {
                                var player = ui.create.div('.fakeplayer', node);
                                ui.create.div('.avatar', player).setBackground(list.randomRemove(), 'character');
                                player.style.borderRadius = '2px';
                                if (i != 3) {
                                    player.style.top = 'auto';
                                }
                                if (link == 'default') {
                                    player.style.height = '19px';
                                    player.style.width = '38px';
                                    player.classList.add('oldlayout')
                                }
                                else if (link == 'mobile' || link == 'newlayout') {
                                    player.style.width = '24px';
                                    player.style.height = '29px';
                                }
                                else if (link == 'nova') {
                                    player.style.width = '20px';
                                    player.style.height = '24px';
                                }
                                else {
                                    player.style.width = '20px';
                                    player.style.height = '34px';
                                }
                                if (i == 1) {
                                    player.style.left = '3px';
                                }
                                if (i == 2) {
                                    player.style.left = 'auto';
                                    player.style.right = '3px';
                                }
                                if (i == 3) {
                                    player.style.top = '3px';
                                }
                                if (link == 'default') {
                                    if (i == 0) {
                                        player.style.bottom = '6px';
                                    }
                                    if (i == 0 || i == 3) {
                                        player.style.left = 'calc(50% - 18px)';
                                    }
                                    if (i == 1 || i == 2) {
                                        player.style.bottom = '36px';
                                    }
                                }
                                else if (link == 'newlayout') {
                                    if (i == 0) {
                                        player.style.bottom = '1px';
                                    }
                                    if (i == 0 || i == 3) {
                                        player.style.left = 'calc(50% - 12px)';
                                    }
                                    if (i == 1 || i == 2) {
                                        player.style.bottom = '32px';
                                    }
                                }
                                else if (link == 'mobile') {
                                    if (i == 0 || i == 3) {
                                        player.style.left = 'calc(50% - 12px)';
                                    }
                                    if (i == 1 || i == 2) {
                                        player.style.bottom = '30px';
                                    }
                                }
                                else if (link == 'long') {
                                    if (i == 0 || i == 3) {
                                        player.style.left = 'calc(50% - 10px)';
                                    }
                                    if (i == 1 || i == 2) {
                                        player.style.bottom = '45px';
                                    }
                                }
                                else if (link == 'long2') {
                                    if (i == 0) {
                                        player.style.bottom = '2px';
                                        player.style.left = '3px';
                                    }
                                    if (i == 3) {
                                        player.style.left = 'calc(50% - 10px)';
                                    }
                                    if (i == 1 || i == 2) {
                                        player.style.bottom = '45px';
                                    }
                                }
                                else if (link == 'nova') {
                                    if (i == 0) {
                                        player.style.bottom = '2px';
                                        player.style.left = '3px';
                                    }
                                    if (i == 3) {
                                        player.style.left = 'calc(50% - 10px)';
                                    }
                                    if (i == 1 || i == 2) {
                                        player.style.left = '3px';
                                        player.style.bottom = (i * 30) + 'px';
                                    }
                                }

                                if (i == 0 && (link == 'mobile' || link == 'long')) {
                                    player.classList.add('me');
                                    player.style.borderRadius = '0px';
                                    player.style.width = '25px';
                                    player.style.height = '25px';
                                    player.style.bottom = '-3px';
                                    player.style.left = '-3px';
                                }
                            }
                        }
                    },
                    onclick: function (layout) {
                        if (lib.layoutfixed.contains(lib.config.mode)) {
                            game.saveConfig('layout', layout);
                        }
                        else {
                            lib.init.layout(layout);
                        }
                    }
                },
                // fewplayer:{
                //     name:'启用人数',
                //     intro:'设置启用新版布局的最小人数（不足时切换至默认布局）',
                //     init:'3',
                //     // unfrequent:true,
                //     item:{
                //                  '2':'两人',
                //                  '3':'三人',
                //                  '4':'四人',
                //                  '5':'五人',
                //                  '6':'六人',
                //                  '7':'七人',
                //                  '8':'八人',
                //     },
                //     onclick:function(item){
                //                  game.saveConfig('fewplayer',item);
                //                  if(ui.arena) ui.arena.setNumber(ui.arena.dataset.number);
                //     }
                // },
                player_height: {
                    name: '角色高度',
                    init: 'long',
                    // unfrequent:true,
                    item: {
                        short: '矮',
                        default: '中',
                        long: '高',
                    },
                    onclick: function (item) {
                        game.saveConfig('player_height', item);
                        ui.arena.dataset.player_height = item;
                    }
                },
                player_height_nova: {
                    name: '角色高度',
                    init: 'short',
                    item: {
                        // auto:'自动',
                        short: '矮',
                        default: '中',
                        long: '高',
                    },
                    onclick: function (item) {
                        game.saveConfig('player_height_nova', item);
                        // if(item=='auto'){
                        //     if(parseInt(ui.arena.dataset.number)>=7){
                        //         ui.arena.dataset.player_height_nova='short';
                        //     }
                        //     else{
                        //         ui.arena.dataset.player_height_nova='default';
                        //     }
                        // }
                        // else{
                        ui.arena.dataset.player_height_nova = item;
                        // }
                    }
                },
                // background_color_music:{
                //     name:'背景色',
                //     init:'black',
                //     item:{
                //         blue:'蓝色',
                //         black:'黑色',
                //     },
                //     onclick:function(color){
                //         game.saveConfig('background_color_music',color);
                //         document.body.dataset.background_color_music=color;
                //     }
                // },
                // background_color_wood:{
                //     name:'背景色',
                //     init:'blue',
                //     item:{
                //         blue:'蓝色',
                //         black:'黑色',
                //     },
                //     onclick:function(color){
                //         game.saveConfig('background_color_wood',color);
                //         document.body.dataset.background_color_wood=color;
                //     }
                // },
                // theme_color_music:{
                //     name:'主题色',
                //     init:'black',
                //     item:{
                //         blue:'蓝色',
                //         black:'黑色',
                //     },
                //     onclick:function(color){
                //         game.saveConfig('theme_color_music',color);
                //         document.body.dataset.theme_color_music=color;
                //     }
                // },
                ui_zoom: {
                    name: '界面缩放',
                    unfrequent: true,
                    init: 'normal',
                    item: {
                        esmall: '80%',
                        vsmall: '90%',
                        small: '95%',
                        normal: '100%',
                        big: '105%',
                        vbig: '110%',
                        ebig: '120%',
                    },
                    onclick: function (zoom) {
                        game.saveConfig('ui_zoom', zoom);
                        switch (zoom) {
                            case 'esmall': zoom = 0.8; break;
                            case 'vsmall': zoom = 0.9; break;
                            case 'small': zoom = 0.93; break;
                            case 'big': zoom = 1.05; break;
                            case 'vbig': zoom = 1.1; break;
                            case 'ebig': zoom = 1.2; break;
                            default: zoom = 1;
                        }
                        game.documentZoom = game.deviceZoom * zoom;
                        ui.updatez();
                    }
                },
                image_background: {
                    name: '游戏背景',
                    init: 'default',
                    item: {},
                    visualBar: function (node, item, create) {
                        if (node.created) {
                            node.lastChild.classList.remove('active');
                            return;
                        }
                        node.created = true;
                        ui.create.filediv('.menubutton', '添加背景', node, function (file) {
                            if (file) {
                                var name = file.name;
                                if (name.indexOf('.') != -1) {
                                    name = name.slice(0, name.indexOf('.'));
                                }
                                var link = (game.writeFile ? 'cdv_' : 'custom_') + name;
                                if (item[link]) {
                                    for (var i = 1; i < 1000; i++) {
                                        if (!item[link + '_' + i]) {
                                            link = link + '_' + i; break;
                                        }
                                    }
                                }
                                item[link] = name;
                                var callback = function () {
                                    create(link, node.parentNode.defaultNode);
                                    node.parentNode.updateBr();
                                    lib.config.customBackgroundPack.add(link);
                                    game.saveConfig('customBackgroundPack', lib.config.customBackgroundPack);
                                };
                                if (game.writeFile) {
                                    game.writeFile(file, 'image/background', link + '.jpg', callback);
                                }
                                else {
                                    game.putDB('image', link, file, callback);
                                }
                                if (node.lastChild.classList.contains('active')) {
                                    editbg.call(node.lastChild);
                                }
                            }
                        }).inputNode.accept = 'image/*';
                        var editbg = function () {
                            this.classList.toggle('active');
                            var page = this.parentNode.parentNode;
                            for (var i = 0; i < page.childElementCount; i++) {
                                if (page.childNodes[i].classList.contains('button')) {
                                    var link = page.childNodes[i]._link;
                                    if (link && link != 'default') {
                                        var str;
                                        if (this.classList.contains('active')) {
                                            if (link.indexOf('custom_') == 0 || link.indexOf('cdv_') == 0) {
                                                str = '删除';
                                            }
                                            else {
                                                str = '隐藏';
                                            }
                                        }
                                        else {
                                            str = item[link];
                                        }
                                        page.childNodes[i].firstChild.innerHTML = get.verticalStr(str);
                                    }
                                }
                            }
                        };
                        ui.create.div('.menubutton', '编辑背景', node, editbg);
                    },
                    visualMenu: function (node, link, name, config) {
                        node.className = 'button character';
                        node.style.backgroundImage = '';
                        node.style.backgroundSize = '';
                        if (node.firstChild) {
                            node.firstChild.innerHTML = get.verticalStr(name);
                        }
                        if (link == 'default' || link.indexOf('custom_') == 0) {
                            node.style.backgroundImage = 'none';
                            node.classList.add('dashedmenubutton');
                            if (link.indexOf('custom_') == 0) {
                                game.getDB('image', link, function (fileToLoad) {
                                    if (!fileToLoad) return;
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                        var data = fileLoadedEvent.target.result;
                                        node.style.backgroundImage = 'url(' + data + ')';
                                        node.style.backgroundSize = 'cover';
                                        node.classList.remove('dashedmenubutton');
                                    };
                                    fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                });
                            }
                            else {
                                node.parentNode.defaultNode = node;
                            }
                        }
                        else {
                            if (link.indexOf('svg_') == 0) {
                                node.setBackgroundImage('image/background/' + link.slice(4) + '.svg');
                            }
                            else {
                                node.setBackgroundImage('image/background/' + link + '.jpg');
                            }
                            node.style.backgroundSize = 'cover';
                        }
                    },
                    onclick: function (background, node) {
                        if (node && node.firstChild) {
                            var menu = node.parentNode;
                            if (node.firstChild.innerHTML == get.verticalStr('隐藏')) {
                                menu.parentNode.noclose = true;
                                node.remove();
                                menu.updateBr();
                                if (!lib.config.prompt_hidebg) {
                                    alert('隐藏的背景可通过选项-其它-重置隐藏内容恢复');
                                    game.saveConfig('prompt_hidebg', true);
                                }
                                lib.config.hiddenBackgroundPack.add(background);
                                game.saveConfig('hiddenBackgroundPack', lib.config.hiddenBackgroundPack);
                                delete lib.configMenu.appearence.config.image_background.item[background];
                                if (lib.config.image_background == background) {
                                    background = 'default';
                                    this.lastChild.innerHTML = '默认';
                                }
                                else {
                                    this.lastChild.innerHTML = lib.configMenu.appearence.config.image_background.item[lib.config.image_background];
                                    return;
                                }
                            }
                            else if (node.firstChild.innerHTML == get.verticalStr('删除')) {
                                menu.parentNode.noclose = true;
                                if (confirm('是否删除此背景？（此操作不可撤销）')) {
                                    node.remove();
                                    menu.updateBr();
                                    lib.config.customBackgroundPack.remove(background);
                                    game.saveConfig('customBackgroundPack', lib.config.customBackgroundPack);
                                    if (background.indexOf('cdv_') == 0) {
                                        game.removeFile('image/background/' + background + '.jpg');
                                    }
                                    else {
                                        game.deleteDB('image', background);
                                    }
                                    delete lib.configMenu.appearence.config.image_background.item[background];
                                    if (lib.config.image_background == background) {
                                        background = 'default';
                                        this.lastChild.innerHTML = '默认';
                                    }
                                    else {
                                        this.lastChild.innerHTML = lib.configMenu.appearence.config.image_background.item[lib.config.image_background];
                                        return;
                                    }
                                }
                            }
                        }
                        var animate = lib.config.image_background == 'default';
                        game.saveConfig('image_background', background);
                        lib.init.background();
                        ui.background.delete();
                        ui.background = ui.create.div('.background');

                        if (lib.config.image_background_blur) {
                            ui.background.style.filter = 'blur(8px)';
                            ui.background.style.webkitFilter = 'blur(8px)';
                            ui.background.style.transform = 'scale(1.05)';
                        }
                        else {
                            ui.background.style.filter = '';
                            ui.background.style.webkitFilter = '';
                            ui.background.style.transform = '';
                        }

                        document.body.insertBefore(ui.background, document.body.firstChild);
                        if (animate) ui.background.animate('start');
                        if (lib.config.image_background == 'default') {
                            ui.background.style.backgroundImage = "none";
                        }
                        else if (lib.config.image_background.indexOf('custom_') == 0) {
                            ui.background.style.backgroundImage = "none";
                            game.getDB('image', lib.config.image_background, function (fileToLoad) {
                                if (!fileToLoad) return;
                                var fileReader = new FileReader();
                                fileReader.onload = function (fileLoadedEvent) {
                                    var data = fileLoadedEvent.target.result;
                                    ui.background.style.backgroundImage = 'url(' + data + ')';
                                };
                                fileReader.readAsDataURL(fileToLoad, "UTF-8");
                            });
                        }
                        else {
                            if (lib.config.image_background.indexOf('svg_') == 0) {
                                ui.background.setBackgroundImage('image/background/' + lib.config.image_background.slice(4) + '.svg');
                                if(ui.backgroundFlash){
                                    ui.backgroundFlash.delete()
                                    delete ui.backgroundFlash
                                }
                            }
                            else {
                                ui.background.setBackgroundImage('image/background/' + lib.config.image_background + '.jpg');
                                if(!ui.backgroundFlash){
                                    ui.backgroundFlash = ui.create.div('.background', ui.background);
                                    ui.backgroundFlash.style.backgroundImage = `linear-gradient(to bottom, rgba(255, 255, 255, 0.1),rgba(255, 255, 255, 0.4) 60%,rgba(255, 255, 255, 0.6))`;
                                    ui.backgroundFlash.style.mixBlendMode = 'overlay';
                                    ui.backgroundSVG = ui.create.div('.background.slow_flash', ui.backgroundFlash);
                                    ui.backgroundSVG.style.backgroundImage = `url("${lib.assetURL}image/background/simple1_bg.svg")`;
                                }
                            }
                        }
                        ui.background.style.backgroundSize = 'cover';
                        ui.background.style.backgroundPosition = '50% 50%';
                    },
                },
                image_background_random: {
                    name: '随机背景',
                    init: false,
                    onclick: function (bool) {
                        game.saveConfig('image_background_random', bool);
                        lib.init.background();
                    }
                },
                image_background_blur: {
                    name: '背景模糊',
                    init: false,
                    onclick: function (bool) {
                        game.saveConfig('image_background_blur', bool);
                        if (lib.config.image_background_blur) {
                            ui.background.style.filter = 'blur(8px)';
                            ui.background.style.webkitFilter = 'blur(8px)';
                            ui.background.style.transform = 'scale(1.05)';
                        }
                        else {
                            ui.background.style.filter = '';
                            ui.background.style.webkitFilter = '';
                            ui.background.style.transform = '';
                        }
                    },
                },
                phonelayout: {
                    name: '触屏布局',
                    init: false,
                    onclick: function (bool) {
                        if (get.is.nomenu('phonelayout', bool)) return false;
                        game.saveConfig('phonelayout', bool);
                        if (get.is.phoneLayout()) {
                            ui.css.phone.href = lib.assetURL + 'layout/default/phone.css';
                            ui.arena.classList.add('phone');
                        }
                        else {
                            ui.css.phone.href = '';
                            ui.arena.classList.remove('phone');
                        }
                    }
                },
                change_skin: {
                    name: '开启换肤',
                    init: true,
                    intro: '在武将的右键菜单中换肤，皮肤可在选项-文件-图片文件-皮肤图片中添加'
                },
                change_skin_auto: {
                    name: '自动换肤',
                    init: 'off',
                    item: {
                        'off': '关闭',
                        '30000': '半分钟',
                        '60000': '一分钟',
                        '120000': '两分钟',
                        '300000': '五分钟',
                    },
                    intro: '游戏每进行一段时间自动为一个随机角色更换皮肤',
                    onclick: function (item) {
                        game.saveConfig('change_skin_auto', item);
                        clearTimeout(_status.skintimeout);
                        if (item != 'off') {
                            _status.skintimeout = setTimeout(ui.click.autoskin, parseInt(item));
                        }
                    }
                },
                card_style: {
                    name: '卡牌样式',
                    init: 'default',
                    intro: '设置正面朝上的卡牌的样式',
                    item: {
                        wood: '木纹',
                        music: '音乐',
                        simple: '原版',
                        ol: '手杀',
                        // new:'新版',
                        custom: '自定',
                        default: '默认',
                    },
                    visualBar: function (node, item, create, switcher) {
                        if (node.created) {
                            return;
                        }
                        var button;
                        for (var i = 0; i < node.parentNode.childElementCount; i++) {
                            if (node.parentNode.childNodes[i]._link == 'custom') {
                                button = node.parentNode.childNodes[i];
                            }
                        }
                        if (!button) {
                            return;
                        }
                        node.created = true;
                        var deletepic;
                        ui.create.filediv('.menubutton', '添加图片', node, function (file) {
                            if (file) {
                                game.putDB('image', 'card_style', file, function () {
                                    game.getDB('image', 'card_style', function (fileToLoad) {
                                        if (!fileToLoad) return;
                                        var fileReader = new FileReader();
                                        fileReader.onload = function (fileLoadedEvent) {
                                            var data = fileLoadedEvent.target.result;
                                            button.style.backgroundImage = 'url(' + data + ')';
                                            button.className = 'button card fullskin';
                                            node.classList.add('showdelete');
                                        };
                                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                    });
                                });
                            }
                        }).inputNode.accept = 'image*';
                        deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
                            if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
                                game.deleteDB('image', 'card_style');
                                button.style.backgroundImage = 'none';
                                button.className = 'button character dashedmenubutton';
                                node.classList.remove('showdelete');
                                if (lib.config.card_style == 'custom') {
                                    lib.configMenu.appearence.config.card_style.onclick('default');
                                    switcher.lastChild.innerHTML = '默认';
                                }
                                button.classList.add('transparent');
                            }
                        });
                    },
                    visualMenu: function (node, link, name, config) {
                        node.className = 'button card fullskin';
                        node.style.backgroundSize = '100% 100%';
                        switch (link) {
                            case 'default': case 'custom': {
                                if (lib.config.theme == 'simple') {
                                    node.style.backgroundImage = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4))';
                                    node.className = 'button character';
                                }
                                else {
                                    node.style.backgroundImage = 'none';
                                    node.className = 'button character dashedmenubutton';
                                }
                                break;
                            }
                            case 'new': node.setBackgroundImage('theme/style/card/image/new.png'); break;
                            case 'ol': node.setBackgroundImage('theme/style/card/image/ol.png'); break;
                            case 'wood': node.setBackgroundImage('theme/woodden/wood.jpg'); node.style.backgroundSize = 'initial'; break;
                            case 'music': node.setBackgroundImage('theme/music/wood3.png'); break;
                            case 'simple': node.setBackgroundImage('theme/simple/card.png'); break;
                        }
                        if (link == 'custom') {
                            node.classList.add('transparent');
                            game.getDB('image', 'card_style', function (fileToLoad) {
                                if (!fileToLoad) return;
                                var fileReader = new FileReader();
                                fileReader.onload = function (fileLoadedEvent) {
                                    var data = fileLoadedEvent.target.result;
                                    node.style.backgroundImage = 'url(' + data + ')';
                                    node.className = 'button card fullskin';
                                    node.parentNode.lastChild.classList.add('showdelete');
                                };
                                fileReader.readAsDataURL(fileToLoad, "UTF-8");
                            });
                        }
                    },
                    onclick: function (layout) {
                        game.saveConfig('card_style', layout);
                        var style = ui.css.card_style;
                        ui.css.card_style = lib.init.css(lib.assetURL + 'theme/style/card', lib.config.card_style);
                        style.remove();
                        if (ui.css.card_stylesheet) {
                            ui.css.card_stylesheet.remove();
                            delete ui.css.card_stylesheet;
                        }
                        if (layout == 'custom') {
                            game.getDB('image', 'card_style', function (fileToLoad) {
                                if (!fileToLoad) return;
                                var fileReader = new FileReader();
                                fileReader.onload = function (fileLoadedEvent) {
                                    if (ui.css.card_stylesheet) {
                                        ui.css.card_stylesheet.remove();
                                    }
                                    ui.css.card_stylesheet = lib.init.sheet('.card:not(*:empty){background-image:url(' + fileLoadedEvent.target.result + ')}');
                                };
                                fileReader.readAsDataURL(fileToLoad, "UTF-8");
                            });
                        }
                    },
                    unfrequent: true,
                },
                cardback_style: {
                    name: '卡背样式',
                    intro: '设置背面朝上的卡牌的样式',
                    init: 'default',
                    item: {
                        // wood:'木纹',
                        // music:'音乐',
                        vk: 'V杀',
                        official: '原版',
                        // new:'新版',
                        feicheng: '废城',
                        liusha: '流沙',
                        ol: '手杀',
                        custom: '自定',
                        default: '默认',
                    },
                    visualBar: function (node, item, create, switcher) {
                        if (node.created) {
                            return;
                        }
                        var button;
                        for (var i = 0; i < node.parentNode.childElementCount; i++) {
                            if (node.parentNode.childNodes[i]._link == 'custom') {
                                button = node.parentNode.childNodes[i];
                            }
                        }
                        if (!button) {
                            return;
                        }
                        node.created = true;
                        var deletepic;
                        ui.create.filediv('.menubutton', '添加图片', node, function (file) {
                            if (file) {
                                game.putDB('image', 'cardback_style', file, function () {
                                    game.getDB('image', 'cardback_style', function (fileToLoad) {
                                        if (!fileToLoad) return;
                                        var fileReader = new FileReader();
                                        fileReader.onload = function (fileLoadedEvent) {
                                            var data = fileLoadedEvent.target.result;
                                            button.style.backgroundImage = 'url(' + data + ')';
                                            button.className = 'button character';
                                            node.classList.add('showdelete');
                                        };
                                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                    });
                                });
                            }
                        }).inputNode.accept = 'image/*';
                        ui.create.filediv('.menubutton.deletebutton.addbutton', '添加翻转图片', node, function (file) {
                            if (file) {
                                game.putDB('image', 'cardback_style2', file, function () {
                                    node.classList.add('hideadd');
                                });
                            }
                        }).inputNode.accept = 'image/*';
                        deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
                            if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
                                game.deleteDB('image', 'cardback_style');
                                game.deleteDB('image', 'cardback_style2');
                                button.style.backgroundImage = 'none';
                                button.className = 'button character dashedmenubutton';
                                node.classList.remove('showdelete');
                                node.classList.remove('hideadd');
                                if (lib.config.cardback_style == 'custom') {
                                    lib.configMenu.appearence.config.cardback_style.onclick('default');
                                    switcher.lastChild.innerHTML = '默认';
                                }
                                button.classList.add('transparent');
                            }
                        });
                    },
                    visualMenu: function (node, link, name, config) {
                        node.style.backgroundSize = '100% 100%';
                        switch (link) {
                            case 'default': case 'custom': {
                                node.style.backgroundImage = 'none';
                                node.className = 'button character dashedmenubutton';
                                break;
                            }
                            case 'vk': node.className = 'button character'; node.setBackgroundImage('theme/style/cardback/image/vk.png'); break;
                            case 'new': node.className = 'button character'; node.setBackgroundImage('theme/style/cardback/image/new.png'); break;
                            case 'feicheng': node.className = 'button character'; node.setBackgroundImage('theme/style/cardback/image/feicheng.png'); break;
                            case 'official': node.className = 'button character'; node.setBackgroundImage('theme/style/cardback/image/official.png'); break;
                            case 'liusha': node.className = 'button character'; node.setBackgroundImage('theme/style/cardback/image/liusha.png'); break;
                            case 'ol': node.className = 'button character'; node.setBackgroundImage('theme/style/cardback/image/ol.png'); break;
                            case 'wood': node.className = 'button card fullskin'; node.setBackgroundImage('theme/woodden/wood.jpg'); node.style.backgroundSize = 'initial'; break;
                            case 'music': node.className = 'button card fullskin'; node.setBackgroundImage('theme/music/wood3.png'); break;
                        }
                        if (link == 'custom') {
                            node.classList.add('transparent');
                            game.getDB('image', 'cardback_style', function (fileToLoad) {
                                if (!fileToLoad) return;
                                var fileReader = new FileReader();
                                fileReader.onload = function (fileLoadedEvent) {
                                    var data = fileLoadedEvent.target.result;
                                    node.style.backgroundImage = 'url(' + data + ')';
                                    node.className = 'button character';
                                    node.parentNode.lastChild.classList.add('showdelete');
                                    game.getDB('image', 'cardback_style2', function (file) {
                                        if (file) {
                                            node.parentNode.lastChild.classList.add('hideadd');
                                        }
                                    });
                                };
                                fileReader.readAsDataURL(fileToLoad, "UTF-8");
                            });
                        }
                    },
                    onclick: function (layout) {
                        game.saveConfig('cardback_style', layout);
                        var style = ui.css.cardback_style;
                        ui.css.cardback_style = lib.init.css(lib.assetURL + 'theme/style/cardback', lib.config.cardback_style);
                        style.remove();
                        if (ui.css.cardback_stylesheet) {
                            ui.css.cardback_stylesheet.remove();
                            delete ui.css.cardback_stylesheet;
                        }
                        if (ui.css.cardback_stylesheet2) {
                            ui.css.cardback_stylesheet2.remove();
                            delete ui.css.cardback_stylesheet2;
                        }
                        if (layout == 'custom') {
                            game.getDB('image', 'cardback_style', function (fileToLoad) {
                                if (!fileToLoad) return;
                                var fileReader = new FileReader();
                                fileReader.onload = function (fileLoadedEvent) {
                                    if (ui.css.cardback_stylesheet) {
                                        ui.css.cardback_stylesheet.remove();
                                    }
                                    ui.css.cardback_stylesheet = lib.init.sheet('.card:empty,.card.infohidden{background-image:url(' + fileLoadedEvent.target.result + ')}');
                                    game.getDB('image', 'cardback_style2', function (fileToLoad) {
                                        if (!fileToLoad) return;
                                        var fileReader = new FileReader();
                                        fileReader.onload = function (fileLoadedEvent) {
                                            if (ui.css.cardback_stylesheet2) {
                                                ui.css.cardback_stylesheet2.remove();
                                            }
                                            ui.css.cardback_stylesheet2 = lib.init.sheet('.card.infohidden:not(.infoflip){background-image:url(' + fileLoadedEvent.target.result + ')}');
                                        };
                                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                    });
                                };
                                fileReader.readAsDataURL(fileToLoad, "UTF-8");
                            });
                        }
                    },
                    unfrequent: true,
                },
                hp_style: {
                    name: '体力条样式',
                    init: 'VK',
                    item: {
                        vk: 'VK',
                        default: '默认',
                        emotion: '表情',
                        glass: '勾玉',
                        round: '国战',
                        ol: '手杀',
                        xinglass: '双鱼',
                        xinround: 'OL',
                        custom: '自定',
                    },
                    visualBar: function (node, item, create, switcher) {
                        if (node.created) {
                            return;
                        }
                        var button;
                        for (var i = 0; i < node.parentNode.childElementCount; i++) {
                            if (node.parentNode.childNodes[i]._link == 'custom') {
                                button = node.parentNode.childNodes[i];
                            }
                        }
                        if (!button) {
                            return;
                        }
                        node.created = true;
                        var deletepic;
                        ui.create.filediv('.menubutton.addbutton', '添加图片', node, function (file) {
                            if (file && node.currentDB) {
                                game.putDB('image', 'hp_style' + node.currentDB, file, function () {
                                    game.getDB('image', 'hp_style' + node.currentDB, function (fileToLoad) {
                                        if (!fileToLoad) return;
                                        var fileReader = new FileReader();
                                        fileReader.onload = function (fileLoadedEvent) {
                                            var data = fileLoadedEvent.target.result;
                                            button.childNodes[node.currentDB - 1].style.backgroundImage = 'url(' + data + ')';
                                            button.classList.add('shown');
                                            node.classList.add('showdelete');
                                            node.currentDB++;
                                            if (node.currentDB > 4) {
                                                node.classList.add('hideadd');
                                                button.classList.remove('transparent');
                                                delete node.currentDB;
                                            }
                                        };
                                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                    });
                                });
                            }
                        }).inputNode.accept = 'image/*';
                        deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
                            if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
                                game.deleteDB('image', 'hp_style1');
                                game.deleteDB('image', 'hp_style2');
                                game.deleteDB('image', 'hp_style3');
                                game.deleteDB('image', 'hp_style4');
                                for (var i = 0; i < button.childElementCount; i++) {
                                    button.childNodes[i].style.backgroundImage = 'none';
                                }
                                node.classList.remove('showdelete');
                                node.classList.remove('hideadd');
                                if (lib.config.hp_style == 'custom') {
                                    lib.configMenu.appearence.config.hp_style.onclick('default');
                                    switcher.lastChild.innerHTML = '默认';
                                }
                                button.classList.add('transparent');
                                button.classList.remove('shown');
                                node.currentDB = 1;
                            }
                        });
                    },
                    visualMenu: function (node, link, name, config) {
                        node.className = 'button hpbutton dashedmenubutton';
                        node.innerHTML = '';
                        for (var i = 1; i <= 4; i++) {
                            var div = ui.create.div(node);
                            if (link == 'default') {
                                ui.create.div(div);
                            }
                            else if (link != 'custom') {
                                div.setBackgroundImage('theme/style/hp/image/' + link + i + '.png');
                            }
                            if (i == 4) {
                                div.style.webkitFilter = 'grayscale(1)';
                            }
                        }
                        if (link == 'custom') {
                            node.classList.add('transparent');
                            var getDB = function (num) {
                                node.parentNode.lastChild.currentDB = num;
                                game.getDB('image', 'hp_style' + num, function (fileToLoad) {
                                    if (!fileToLoad) return;
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                        var data = fileLoadedEvent.target.result;
                                        node.childNodes[num - 1].style.backgroundImage = 'url(' + data + ')';
                                        node.classList.add('shown');
                                        node.parentNode.lastChild.classList.add('showdelete');
                                        if (num < 4) {
                                            getDB(num + 1);
                                        }
                                        else {
                                            node.parentNode.lastChild.classList.add('hideadd');
                                            node.classList.remove('transparent');
                                            delete node.parentNode.firstChild.currentDB;
                                        }
                                    };
                                    fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                });
                            }
                            getDB(1);
                        }
                    },
                    onclick: function (layout) {
                        game.saveConfig('hp_style', layout);
                        var style = ui.css.hp_style;
                        ui.css.hp_style = lib.init.css(lib.assetURL + 'theme/style/hp', lib.config.hp_style);
                        style.remove();
                        if (ui.css.hp_stylesheet1) {
                            ui.css.hp_stylesheet1.remove();
                            delete ui.css.hp_stylesheet1;
                        }
                        if (ui.css.hp_stylesheet2) {
                            ui.css.hp_stylesheet2.remove();
                            delete ui.css.hp_stylesheet2;
                        }
                        if (ui.css.hp_stylesheet3) {
                            ui.css.hp_stylesheet3.remove();
                            delete ui.css.hp_stylesheet3;
                        }
                        if (ui.css.hp_stylesheet4) {
                            ui.css.hp_stylesheet4.remove();
                            delete ui.css.hp_stylesheet4;
                        }
                        if (layout == 'custom') {
                            game.getDB('image', 'hp_style1', function (fileToLoad) {
                                if (!fileToLoad) return;
                                var fileReader = new FileReader();
                                fileReader.onload = function (fileLoadedEvent) {
                                    if (ui.css.hp_stylesheet1) {
                                        ui.css.hp_stylesheet1.remove();
                                    }
                                    ui.css.hp_stylesheet1 = lib.init.sheet('.hp:not(.text):not(.actcount)[data-condition="high"]>div:not(.lost){background-image:url(' + fileLoadedEvent.target.result + ')}');
                                };
                                fileReader.readAsDataURL(fileToLoad, "UTF-8");
                            });
                            game.getDB('image', 'hp_style2', function (fileToLoad) {
                                if (!fileToLoad) return;
                                var fileReader = new FileReader();
                                fileReader.onload = function (fileLoadedEvent) {
                                    if (ui.css.hp_stylesheet2) {
                                        ui.css.hp_stylesheet2.remove();
                                    }
                                    ui.css.hp_stylesheet2 = lib.init.sheet('.hp:not(.text):not(.actcount)[data-condition="mid"]>div:not(.lost){background-image:url(' + fileLoadedEvent.target.result + ')}');
                                };
                                fileReader.readAsDataURL(fileToLoad, "UTF-8");
                            });
                            game.getDB('image', 'hp_style3', function (fileToLoad) {
                                if (!fileToLoad) return;
                                var fileReader = new FileReader();
                                fileReader.onload = function (fileLoadedEvent) {
                                    if (ui.css.hp_stylesheet3) {
                                        ui.css.hp_stylesheet3.remove();
                                    }
                                    ui.css.hp_stylesheet3 = lib.init.sheet('.hp:not(.text):not(.actcount)[data-condition="low"]>div:not(.lost){background-image:url(' + fileLoadedEvent.target.result + ')}');
                                };
                                fileReader.readAsDataURL(fileToLoad, "UTF-8");
                            });
                            game.getDB('image', 'hp_style4', function (fileToLoad) {
                                if (!fileToLoad) return;
                                var fileReader = new FileReader();
                                fileReader.onload = function (fileLoadedEvent) {
                                    if (ui.css.hp_stylesheet4) {
                                        ui.css.hp_stylesheet4.remove();
                                    }
                                    ui.css.hp_stylesheet4 = lib.init.sheet('.hp:not(.text):not(.actcount)>.lost{background-image:url(' + fileLoadedEvent.target.result + ')}');
                                };
                                fileReader.readAsDataURL(fileToLoad, "UTF-8");
                            });
                        }
                    },
                    unfrequent: true,
                },
                player_style: {
                    name: '角色背景',
                    init: 'simple',
                    intro: '设置角色的背景图片',
                    item: {
                        wood: '木纹',
                        music: '音乐',
                        simple: '简约',
                        custom: '自定',
                        default: '默认',
                    },
                    visualBar: function (node, item, create, switcher) {
                        if (node.created) {
                            return;
                        }
                        var button;
                        for (var i = 0; i < node.parentNode.childElementCount; i++) {
                            if (node.parentNode.childNodes[i]._link == 'custom') {
                                button = node.parentNode.childNodes[i];
                            }
                        }
                        if (!button) {
                            return;
                        }
                        node.created = true;
                        var deletepic;
                        ui.create.filediv('.menubutton', '添加图片', node, function (file) {
                            if (file) {
                                game.putDB('image', 'player_style', file, function () {
                                    game.getDB('image', 'player_style', function (fileToLoad) {
                                        if (!fileToLoad) return;
                                        var fileReader = new FileReader();
                                        fileReader.onload = function (fileLoadedEvent) {
                                            var data = fileLoadedEvent.target.result;
                                            button.style.backgroundImage = 'url(' + data + ')';
                                            button.className = 'button character';
                                            button.style.backgroundSize = '100% 100%';
                                            node.classList.add('showdelete');
                                        };
                                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                    });
                                });
                            }
                        }).inputNode.accept = 'image/*';
                        deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
                            if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
                                game.deleteDB('image', 'player_style');
                                button.style.backgroundImage = 'none';
                                button.className = 'button character dashedmenubutton';
                                node.classList.remove('showdelete');
                                if (lib.config.player_style == 'custom') {
                                    lib.configMenu.appearence.config.player_style.onclick('default');
                                    switcher.lastChild.innerHTML = '默认';
                                }
                                button.classList.add('transparent');
                            }
                        });
                    },
                    visualMenu: function (node, link, name, config) {
                        node.className = 'button character';
                        node.style.backgroundSize = '';
                        node.style.height = '108px';
                        switch (link) {
                            case 'default': case 'custom': {
                                node.style.backgroundImage = 'none';
                                node.className = 'button character dashedmenubutton';
                                break;
                            }
                            case 'wood': node.setBackgroundImage('theme/woodden/wood.jpg'); break;
                            case 'music': node.style.backgroundImage = 'linear-gradient(#4b4b4b, #464646)'; break;
                            case 'simple': node.style.backgroundImage = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4))'; break;
                        }
                        if (link == 'custom') {
                            node.classList.add('transparent');
                            game.getDB('image', 'player_style', function (fileToLoad) {
                                if (!fileToLoad) return;
                                var fileReader = new FileReader();
                                fileReader.onload = function (fileLoadedEvent) {
                                    var data = fileLoadedEvent.target.result;
                                    node.style.backgroundImage = 'url(' + data + ')';
                                    node.className = 'button character';
                                    node.parentNode.lastChild.classList.add('showdelete');
                                    node.style.backgroundSize = '100% 100%';
                                };
                                fileReader.readAsDataURL(fileToLoad, "UTF-8");
                            });
                        }
                    },
                    onclick: function (layout) {
                        game.saveConfig('player_style', layout);
                        if (ui.css.player_stylesheet) {
                            ui.css.player_stylesheet.remove();
                            delete ui.css.player_stylesheet;
                        }
                        if (layout == 'custom') {
                            game.getDB('image', 'player_style', function (fileToLoad) {
                                if (!fileToLoad) return;
                                var fileReader = new FileReader();
                                fileReader.onload = function (fileLoadedEvent) {
                                    if (ui.css.player_stylesheet) {
                                        ui.css.player_stylesheet.remove();
                                    }
                                    ui.css.player_stylesheet = lib.init.sheet('#window .player{background-image:url("' + fileLoadedEvent.target.result + '");background-size:100% 100%;}');
                                };
                                fileReader.readAsDataURL(fileToLoad, "UTF-8");
                            });
                        }
                        else if (layout != 'default') {
                            var str = '';
                            switch (layout) {
                                case 'wood': str = 'url("' + lib.assetURL + 'theme/woodden/wood.jpg")'; break;
                                case 'music': str = 'linear-gradient(#4b4b4b, #464646)'; break;
                                case 'simple': str = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4))'; break;
                            }
                            ui.css.player_stylesheet = lib.init.sheet('#window .player{background-image:' + str + '}');
                        }
                    },
                    unfrequent: true,
                },
                border_style: {
                    name: '角色边框',
                    init: 'auto',
                    intro: '设置角色边框的样式，当设为自动时，样式将随着一局游戏中伤害或击杀的数量自动改变',
                    item: {
                        gold: '金框',
                        silver: '银框',
                        bronze: '铜框',
                        dragon_gold: '金龙',
                        dragon_silver: '银龙',
                        dragon_bronze: '玉龙',
                        custom: '自定',
                        auto: '自动',
                        default: '默认',
                    },
                    visualBar: function (node, item, create, switcher) {
                        if (node.created) {
                            return;
                        }
                        var button;
                        for (var i = 0; i < node.parentNode.childElementCount; i++) {
                            if (node.parentNode.childNodes[i]._link == 'custom') {
                                button = node.parentNode.childNodes[i];
                            }
                        }
                        if (!button) {
                            return;
                        }
                        node.created = true;
                        var deletepic;
                        ui.create.filediv('.menubutton', '添加图片', node, function (file) {
                            if (file) {
                                game.putDB('image', 'border_style', file, function () {
                                    game.getDB('image', 'border_style', function (fileToLoad) {
                                        if (!fileToLoad) return;
                                        var fileReader = new FileReader();
                                        fileReader.onload = function (fileLoadedEvent) {
                                            var data = fileLoadedEvent.target.result;
                                            button.style.backgroundImage = 'url(' + data + ')';
                                            button.className = 'button character';
                                            button.style.backgroundSize = '100% 100%';
                                            node.classList.add('showdelete');
                                        };
                                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                    });
                                });
                            }
                        }).inputNode.accept = 'image/*';
                        deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
                            if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
                                game.deleteDB('image', 'border_style');
                                button.style.backgroundImage = 'none';
                                button.className = 'button character dashedmenubutton';
                                node.classList.remove('showdelete');
                                if (lib.config.border_style == 'custom') {
                                    lib.configMenu.appearence.config.border_style.onclick('default');
                                    switcher.lastChild.innerHTML = '默认';
                                }
                                button.classList.add('transparent');
                            }
                        });
                    },
                    visualMenu: function (node, link, name, config) {
                        node.className = 'button character';
                        node.style.backgroundSize = '';
                        node.style.height = '108px';
                        node.dataset.decoration = '';
                        if (link == 'default' || link == 'custom' || link == 'auto') {
                            node.style.backgroundImage = 'none';
                            node.className = 'button character dashedmenubutton';
                        }
                        else {
                            if (link.indexOf('dragon_') == 0) {
                                link = link.slice(7);
                                node.dataset.decoration = link;
                            }
                            node.setBackgroundImage('theme/style/player/' + link + '1.png');
                            node.style.backgroundSize = '100% 100%';
                        }
                        if (link == 'custom') {
                            node.classList.add('transparent');
                            game.getDB('image', 'border_style', function (fileToLoad) {
                                if (!fileToLoad) return;
                                var fileReader = new FileReader();
                                fileReader.onload = function (fileLoadedEvent) {
                                    var data = fileLoadedEvent.target.result;
                                    node.style.backgroundImage = 'url(' + data + ')';
                                    node.className = 'button character';
                                    node.parentNode.lastChild.classList.add('showdelete');
                                    node.style.backgroundSize = '100% 100%';
                                };
                                fileReader.readAsDataURL(fileToLoad, "UTF-8");
                            });
                        }
                    },
                    onclick: function (layout) {
                        game.saveConfig('border_style', layout);
                        if (ui.css.border_stylesheet) {
                            ui.css.border_stylesheet.remove();
                            delete ui.css.border_stylesheet;
                        }
                        if (layout == 'custom') {
                            game.getDB('image', 'border_style', function (fileToLoad) {
                                if (!fileToLoad) return;
                                var fileReader = new FileReader();
                                fileReader.onload = function (fileLoadedEvent) {
                                    if (ui.css.border_stylesheet) {
                                        ui.css.border_stylesheet.remove();
                                    }
                                    ui.css.border_stylesheet = lib.init.sheet();
                                    ui.css.border_stylesheet.sheet.insertRule('#window .player>.framebg{display:block;background-image:url("' + fileLoadedEvent.target.result + '")}', 0);
                                    ui.css.border_stylesheet.sheet.insertRule('.player>.count{z-index: 3 !important;border-radius: 2px !important;text-align: center !important;}', 0);
                                };
                                fileReader.readAsDataURL(fileToLoad, "UTF-8");
                            });
                        }
                        else if (layout != 'default' && layout != 'auto') {
                            ui.css.border_stylesheet = lib.init.sheet();
                            if (layout.indexOf('dragon_') == 0) {
                                layout = layout.slice(7);
                                ui.arena.dataset.framedecoration = layout;
                            }
                            else {
                                ui.arena.dataset.framedecoration = '';
                            }
                            ui.css.border_stylesheet.sheet.insertRule('#window .player>.framebg,#window #arena.long.mobile:not(.fewplayer) .player[data-position="0"]>.framebg{display:block;background-image:url("' + lib.assetURL + 'theme/style/player/' + layout + '1.png")}', 0);
                            ui.css.border_stylesheet.sheet.insertRule('#window #arena.long:not(.fewplayer) .player>.framebg, #arena.oldlayout .player>.framebg{background-image:url("' + lib.assetURL + 'theme/style/player/' + layout + '3.png")}', 0);
                            ui.css.border_stylesheet.sheet.insertRule('.player>.count{z-index: 3 !important;border-radius: 2px !important;text-align: center !important;}', 0);
                        }
                    },
                    unfrequent: true,
                },
                autoborder_count: {
                    name: '边框升级方式',
                    intro: '<strong>击杀</strong> 每击杀一人，边框提升两级<br><strong>伤害</strong> 每造成两点伤害，边框提升一级<br><strong>混合</strong> 击杀量决定边框颜色，伤害量决定边框装饰',
                    init: 'mix',
                    item: {
                        kill: '击杀',
                        damage: '伤害',
                        mix: '混合',
                    },
                    unfrequent: true,
                },
                autoborder_start: {
                    name: '基础边框颜色',
                    init: 'bronze',
                    item: {
                        bronze: '铜',
                        silver: '银',
                        gold: '金'
                    },
                    unfrequent: true
                },
                player_border: {
                    name: '边框宽度',
                    init: 'normal',
                    intro: '设置角色的边框宽度',
                    unfrequent: true,
                    item: {
                        slim: '细',
                        narrow: '窄',
                        normal: '中',
                        wide: '宽'
                    },
                    onclick: function (item) {
                        game.saveConfig('player_border', item);
                        if (item != 'wide' || game.layout == 'long' || game.layout == 'long2') {
                            ui.arena.classList.add('slim_player');
                        }
                        else {
                            ui.arena.classList.remove('slim_player');
                        }
                        if (item == 'slim') {
                            ui.arena.classList.add('uslim_player');
                        }
                        else {
                            ui.arena.classList.remove('uslim_player');
                        }
                        if (item == 'narrow') {
                            ui.arena.classList.add('mslim_player');
                        }
                        else {
                            ui.arena.classList.remove('mslim_player');
                        }
                        if (item == 'normal' && lib.config.mode != 'brawl' && (game.layout == 'long' || game.layout == 'long2')) {
                            ui.arena.classList.add('lslim_player');
                        }
                        else {
                            ui.arena.classList.remove('lslim_player');
                        }
                        ui.window.dataset.player_border = item;
                    }
                },
                menu_style: {
                    name: '菜单背景',
                    init: 'default',
                    item: {
                        wood: '木纹',
                        music: '音乐',
                        simple: '简约',
                        custom: '自定',
                        default: '默认',
                    },
                    visualBar: function (node, item, create, switcher) {
                        if (node.created) {
                            return;
                        }
                        var button;
                        for (var i = 0; i < node.parentNode.childElementCount; i++) {
                            if (node.parentNode.childNodes[i]._link == 'custom') {
                                button = node.parentNode.childNodes[i];
                            }
                        }
                        if (!button) {
                            return;
                        }
                        node.created = true;
                        var deletepic;
                        ui.create.filediv('.menubutton', '添加图片', node, function (file) {
                            if (file) {
                                game.putDB('image', 'menu_style', file, function () {
                                    game.getDB('image', 'menu_style', function (fileToLoad) {
                                        if (!fileToLoad) return;
                                        var fileReader = new FileReader();
                                        fileReader.onload = function (fileLoadedEvent) {
                                            var data = fileLoadedEvent.target.result;
                                            button.style.backgroundImage = 'url(' + data + ')';
                                            button.style.backgroundSize = 'cover';
                                            button.className = 'button character';
                                            node.classList.add('showdelete');
                                        };
                                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                    });
                                });
                            }
                        }).inputNode.accept = 'image/*';
                        deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
                            if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
                                game.deleteDB('image', 'menu_style');
                                button.style.backgroundImage = 'none';
                                button.style.backgroundSize = 'auto';
                                button.className = 'button character dashedmenubutton';
                                node.classList.remove('showdelete');
                                if (lib.config.menu_style == 'custom') {
                                    lib.configMenu.appearence.config.menu_style.onclick('default');
                                    switcher.lastChild.innerHTML = '默认';
                                }
                                button.classList.add('transparent');
                            }
                        });
                    },
                    visualMenu: function (node, link, name, config) {
                        node.className = 'button character';
                        node.style.backgroundSize = 'auto';
                        switch (link) {
                            case 'default': case 'custom': {
                                node.style.backgroundImage = 'none';
                                node.classList.add('dashedmenubutton');
                                break;
                            }
                            case 'wood': node.setBackgroundImage('theme/woodden/wood2.png'); break;
                            case 'music': node.style.backgroundImage = 'linear-gradient(#4b4b4b, #464646)'; break;
                            case 'simple': node.style.backgroundImage = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4))'; break;
                        }
                        if (link == 'custom') {
                            node.classList.add('transparent');
                            game.getDB('image', 'menu_style', function (fileToLoad) {
                                if (!fileToLoad) return;
                                var fileReader = new FileReader();
                                fileReader.onload = function (fileLoadedEvent) {
                                    var data = fileLoadedEvent.target.result;
                                    node.style.backgroundImage = 'url(' + data + ')';
                                    node.style.backgroundSize = 'cover';
                                    node.className = 'button character';
                                    node.parentNode.lastChild.classList.add('showdelete');
                                };
                                fileReader.readAsDataURL(fileToLoad, "UTF-8");
                            });
                        }
                    },
                    onclick: function (layout) {
                        game.saveConfig('menu_style', layout);
                        if (ui.css.menu_stylesheet) {
                            ui.css.menu_stylesheet.remove();
                            delete ui.css.menu_stylesheet;
                        }
                        if (layout == 'custom') {
                            game.getDB('image', 'menu_style', function (fileToLoad) {
                                if (!fileToLoad) return;
                                var fileReader = new FileReader();
                                fileReader.onload = function (fileLoadedEvent) {
                                    if (ui.css.menu_stylesheet) {
                                        ui.css.menu_stylesheet.remove();
                                    }
                                    ui.css.menu_stylesheet = lib.init.sheet('html #window>.dialog.popped,html .menu,html .menubg{background-image:url("' + fileLoadedEvent.target.result + '");background-size:cover}');
                                };
                                fileReader.readAsDataURL(fileToLoad, "UTF-8");
                            });
                        }
                        else if (layout != 'default') {
                            var str = '';
                            switch (layout) {
                                case 'wood': str = 'url("' + lib.assetURL + 'theme/woodden/wood2.png")'; break;
                                case 'music': str = 'linear-gradient(#4b4b4b, #464646);color:white;text-shadow:black 0 0 2px'; break;
                                case 'simple': str = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4));color:white;text-shadow:black 0 0 2px'; break;
                            }
                            ui.css.menu_stylesheet = lib.init.sheet('html #window>.dialog.popped,html .menu,html .menubg{background-image:' + str + '}');
                        }
                    },
                    unfrequent: true,
                },
                control_style: {
                    name: '按钮背景',
                    init: 'default',
                    item: {
                        wood: '木纹',
                        music: '音乐',
                        simple: '简约',
                        custom: '自定',
                        default: '默认',
                    },
                    visualBar: function (node, item, create, switcher) {
                        if (node.created) {
                            return;
                        }
                        var button;
                        for (var i = 0; i < node.parentNode.childElementCount; i++) {
                            if (node.parentNode.childNodes[i]._link == 'custom') {
                                button = node.parentNode.childNodes[i];
                            }
                        }
                        if (!button) {
                            return;
                        }
                        node.created = true;
                        var deletepic;
                        ui.create.filediv('.menubutton', '添加图片', node, function (file) {
                            if (file) {
                                game.putDB('image', 'control_style', file, function () {
                                    game.getDB('image', 'control_style', function (fileToLoad) {
                                        if (!fileToLoad) return;
                                        var fileReader = new FileReader();
                                        fileReader.onload = function (fileLoadedEvent) {
                                            var data = fileLoadedEvent.target.result;
                                            button.style.backgroundImage = 'url(' + data + ')';
                                            button.className = 'button character controlbutton';
                                            node.classList.add('showdelete');
                                        };
                                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                    });
                                });
                            }
                        }).inputNode.accept = 'image/*';
                        deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
                            if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
                                game.deleteDB('image', 'control_style');
                                button.style.backgroundImage = 'none';
                                button.className = 'button character controlbutton dashedmenubutton';
                                node.classList.remove('showdelete');
                                if (lib.config.control_style == 'custom') {
                                    lib.configMenu.appearence.config.control_style.onclick('default');
                                    switcher.lastChild.innerHTML = '默认';
                                }
                                button.classList.add('transparent');
                            }
                        });
                    },
                    visualMenu: function (node, link, name, config) {
                        node.className = 'button character controlbutton';
                        node.style.backgroundSize = '';
                        switch (link) {
                            case 'default': case 'custom': {
                                node.style.backgroundImage = 'none';
                                node.classList.add('dashedmenubutton');
                                break;
                            }
                            case 'wood': node.setBackgroundImage('theme/woodden/wood.jpg'); break;
                            case 'music': node.style.backgroundImage = 'linear-gradient(#4b4b4b, #464646)'; break;
                            case 'simple': node.style.backgroundImage = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4))'; break;
                        }
                        if (link == 'custom') {
                            node.classList.add('transparent');
                            game.getDB('image', 'control_style', function (fileToLoad) {
                                if (!fileToLoad) return;
                                var fileReader = new FileReader();
                                fileReader.onload = function (fileLoadedEvent) {
                                    var data = fileLoadedEvent.target.result;
                                    node.style.backgroundImage = 'url(' + data + ')';
                                    node.className = 'button character controlbutton';
                                    node.parentNode.lastChild.classList.add('showdelete');
                                };
                                fileReader.readAsDataURL(fileToLoad, "UTF-8");
                            });
                        }
                    },
                    onclick: function (layout) {
                        game.saveConfig('control_style', layout);
                        if (ui.css.control_stylesheet) {
                            ui.css.control_stylesheet.remove();
                            delete ui.css.control_stylesheet;
                        }
                        if (layout == 'custom') {
                            game.getDB('image', 'control_style', function (fileToLoad) {
                                if (!fileToLoad) return;
                                var fileReader = new FileReader();
                                fileReader.onload = function (fileLoadedEvent) {
                                    if (ui.css.control_stylesheet) {
                                        ui.css.control_stylesheet.remove();
                                    }
                                    ui.css.control_stylesheet = lib.init.sheet('#window .control,.menubutton:not(.active):not(.highlight):not(.red):not(.blue),#window #system>div>div{background-image:url("' + fileLoadedEvent.target.result + '")}');
                                };
                                fileReader.readAsDataURL(fileToLoad, "UTF-8");
                            });
                        }
                        else if (layout != 'default') {
                            var str = '';
                            switch (layout) {
                                case 'wood': str = 'url("' + lib.assetURL + 'theme/woodden/wood.jpg")'; break;
                                case 'music': str = 'linear-gradient(#4b4b4b, #464646);color:white;text-shadow:black 0 0 2px'; break;
                                case 'simple': str = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4));color:white;text-shadow:black 0 0 2px'; break;
                            }
                            if (layout == 'wood') {
                                ui.css.control_stylesheet = lib.init.sheet('#window .control,#window .menubutton,#window #system>div>div,#window #system>div>.pressdown2{background-image:' + str + '}');
                            }
                            else {
                                ui.css.control_stylesheet = lib.init.sheet('#window .control,.menubutton:not(.active):not(.highlight):not(.red):not(.blue),#window #system>div>div{background-image:' + str + '}');
                            }
                        }
                    },
                    unfrequent: true,
                },
                custom_button: {
                    name: '自定义按钮高度',
                    init: false,
                    unfrequent: true,
                    onclick: function (bool) {
                        if (bool !== 'skip') {
                            game.saveConfig('custom_button', bool);
                        }
                        if (ui.css.buttonsheet) {
                            ui.css.buttonsheet.remove();
                        }
                        if (lib.config.custom_button) {
                            var cbnum1 = 6 + (parseInt(lib.config.custom_button_system_top) || 0);
                            var cbnum2 = 6 + (parseInt(lib.config.custom_button_system_bottom) || 0);
                            var cbnum3 = 3 + (parseInt(lib.config.custom_button_control_top) || 0);
                            var cbnum4 = 3 + (parseInt(lib.config.custom_button_control_bottom) || 0);
                            var cbnum5 = 2;
                            var cbnum6 = 2;
                            if (cbnum3 < 0) {
                                cbnum5 += cbnum3;
                                cbnum3 = 0;
                            }
                            if (cbnum4 < 0) {
                                cbnum6 += cbnum4;
                                cbnum4 = 0;
                            }
                            ui.css.buttonsheet = lib.init.sheet(
                                '#system>div>div, .caption>div>.tdnode{padding-top:' + cbnum1 + 'px !important;padding-bottom:' + cbnum2 + 'px !important}',
                                '#control>.control>div{padding-top:' + cbnum3 + 'px;padding-bottom:' + cbnum4 + 'px}',
                                '#control>.control{padding-top:' + cbnum5 + 'px;padding-bottom:' + cbnum6 + 'px}'
                            );
                        }
                    }
                },
                custom_button_system_top: {
                    name: '菜单上部高度',
                    init: '0x',
                    item: {
                        '-5x': '-5px',
                        '-4x': '-4px',
                        '-3x': '-3px',
                        '-2x': '-2px',
                        '-1x': '-1px',
                        '0x': '默认',
                        '1x': '1px',
                        '2x': '2px',
                        '3x': '3px',
                        '4x': '4px',
                        '5x': '5px',
                    },
                    unfrequent: true,
                    onclick: function (item) {
                        game.saveConfig('custom_button_system_top', item);
                        lib.configMenu.appearence.config.custom_button.onclick('skip');
                    }
                },
                custom_button_system_bottom: {
                    name: '菜单下部高度',
                    init: '0x',
                    item: {
                        '-5x': '-5px',
                        '-4x': '-4px',
                        '-3x': '-3px',
                        '-2x': '-2px',
                        '-1x': '-1px',
                        '0x': '默认',
                        '1x': '1px',
                        '2x': '2px',
                        '3x': '3px',
                        '4x': '4px',
                        '5x': '5px',
                    },
                    unfrequent: true,
                    onclick: function (item) {
                        game.saveConfig('custom_button_system_bottom', item);
                        lib.configMenu.appearence.config.custom_button.onclick('skip');
                    }
                },
                custom_button_control_top: {
                    name: '技能上部高度',
                    init: '0x',
                    item: {
                        '-5x': '-5px',
                        '-4x': '-4px',
                        '-3x': '-3px',
                        '-2x': '-2px',
                        '-1x': '-1px',
                        '0x': '默认',
                        '1x': '1px',
                        '2x': '2px',
                        '3x': '3px',
                        '4x': '4px',
                        '5x': '5px',
                    },
                    unfrequent: true,
                    onclick: function (item) {
                        game.saveConfig('custom_button_control_top', item);
                        lib.configMenu.appearence.config.custom_button.onclick('skip');
                    }
                },
                custom_button_control_bottom: {
                    name: '技能下部高度',
                    init: '0x',
                    item: {
                        '-5x': '-5px',
                        '-4x': '-4px',
                        '-3x': '-3px',
                        '-2x': '-2px',
                        '-1x': '-1px',
                        '0x': '默认',
                        '1x': '1px',
                        '2x': '2px',
                        '3x': '3px',
                        '4x': '4px',
                        '5x': '5px',
                    },
                    unfrequent: true,
                    onclick: function (item) {
                        game.saveConfig('custom_button_control_bottom', item);
                        lib.configMenu.appearence.config.custom_button.onclick('skip');
                    }
                },
                radius_size: {
                    name: '圆角大小',
                    init: 'default',
                    item: {
                        off: '关闭',
                        reduce: '减小',
                        default: '默认',
                        increase: '增大',
                    },
                    unfrequent: true,
                    onclick: function (item) {
                        game.saveConfig('radius_size', item);
                        ui.window.dataset.radius_size = item;
                    }
                },
                glow_phase: {
                    name: '当前回合角色高亮',
                    unfrequent: true,
                    init: 'yellow',
                    intro: '设置当前回合角色的边框颜色',
                    item: {
                        none: '无',
                        yellow: '黄色',
                        green: '绿色',
                        purple: '紫色',
                    },
                    onclick: function (bool) {
                        game.saveConfig('glow_phase', bool);
                        lib.init.cssstyles();
                    }
                },
                fold_card: {
                    name: '折叠手牌',
                    init: true,
                    unfrequent: true,
                },
                fold_mode: {
                    name: '折叠模式菜单',
                    intro: '关闭后模式菜单中“更多”内的项目将直接展开',
                    init: true,
                    unfrequent: true,
                },
                seperate_control: {
                    name: '分离选项条',
                    init: true,
                    unfrequent: true,
                    intro: '开启后玩家在进行选择时不同的选项将分开，而不是连在一起',
                },
                blur_ui: {
                    name: '模糊效果',
                    intro: '在暂停或打开菜单时开启模糊效果',
                    init: false,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('blur_ui', bool);
                        if (bool) {
                            ui.window.classList.add('blur_ui');
                        }
                        else {
                            ui.window.classList.remove('blur_ui');
                        }
                    }
                },
                glass_ui: {
                    name: '玻璃主题',
                    intro: '为游戏主题打开玻璃效果（手机暂不支持）',
                    init: false,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('glass_ui', bool);
                        if (bool) {
                            ui.window.classList.add('glass_ui');
                        }
                        else {
                            ui.window.classList.remove('glass_ui');
                        }
                    }
                },
                damage_shake: {
                    name: '伤害抖动',
                    intro: '角色受到伤害时的抖动效果',
                    init: true,
                    unfrequent: true,
                },
                // button_press: {
                //     name: '按钮效果',
                //     intro: '选项条被按下时将有按下效果',
                //     init: true,
                //     unfrequent: true,
                // },
                jiu_effect: {
                    name: '喝酒效果',
                    init: true,
                    unfrequent: true,
                },
                animation: {
                    name: '游戏特效',
                    intro: '开启后出现属性伤害、回复体力等情况时会显示动画',
                    init: false,
                    unfrequent: true,
                },
                skill_animation_type: {
                    name: '技能特效',
                    intro: '开启后觉醒技、限定技将显示全屏文字',
                    init: 'default',
                    unfrequent: true,
                    item: {
                        default: '默认',
                        old: '旧版',
                        off: '关闭'
                    }
                },
                die_move: {
                    name: '阵亡效果',
                    intro: '阵亡后武将的显示效果',
                    init: 'flip',
                    unfrequent: true,
                    item: {
                        off: '关闭',
                        move: '移动',
                        flip: '翻面',
                    }
                },
                target_shake: {
                    name: '目标效果',
                    intro: '一名玩家成为卡牌或技能的目标时的显示效果',
                    init: 'off',
                    item: {
                        off: '关闭',
                        zoom: '缩放',
                        shake: '抖动',
                    },
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('target_shake', bool);
                        ui.arena.dataset.target_shake = bool;
                    }
                },
                turned_style: {
                    name: '翻面文字',
                    intro: '角色被翻面时显示“翻面”',
                    init: true,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('turned_style', bool);
                        if (bool) {
                            ui.arena.classList.remove('hide_turned');
                        }
                        else {
                            ui.arena.classList.add('hide_turned');
                        }
                    }
                },
                link_style2: {
                    name: '横置样式',
                    intro: '设置角色被横置时的样式',
                    init: 'chain',
                    unfrequent: true,
                    item: {
                        chain: '铁索',
                        rotate: '横置',
                        mark: '标记'
                    },
                    onclick: function (style) {
                        var list = [];
                        for (var i = 0; i < game.players.length; i++) {
                            if (game.players[i].isLinked()) {
                                list.push(game.players[i]);
                            }
                        }
                        game.saveConfig('link_style2', style);
                        for (var i = 0; i < list.length; i++) {
                            if (get.is.linked2(list[i])) {
                                list[i].classList.add('linked2');
                                list[i].classList.remove('linked');
                            }
                            else {
                                list[i].classList.add('linked');
                                list[i].classList.remove('linked2');
                            }
                        }
                        if (style == 'chain') {
                            ui.arena.classList.remove('nolink');
                        }
                        else {
                            ui.arena.classList.add('nolink');
                        }
                        ui.updatem();
                    }
                },
                cardshape: {
                    name: '手牌显示',
                    intro: '将手牌设置为正方形或长方形',
                    init: 'default',
                    unfrequent: true,
                    item: {
                        default: '默认',
                        oblong: '长方',
                    },
                    onclick: function (item) {
                        var linked = false;
                        if (game.me && game.me.isLinked()) {
                            linked = true;
                        }
                        game.saveConfig('cardshape', item);
                        if (item == 'oblong' && (game.layout == 'long' || game.layout == 'mobile' || game.layout == 'long2' || game.layout == 'nova')) {
                            ui.arena.classList.add('oblongcard');
                            ui.window.classList.add('oblongcard');
                        }
                        else {
                            ui.arena.classList.remove('oblongcard');
                            ui.window.classList.remove('oblongcard');
                        }
                        if (linked) {
                            if (get.is.linked2(game.me)) {
                                game.me.classList.remove('linked');
                                game.me.classList.add('linked2');
                            }
                            else {
                                game.me.classList.add('linked');
                                game.me.classList.remove('linked2');
                            }
                        }
                    }
                },
                cardtempname: {
                    name: '视为卡牌名称显示',
                    intro: '显示强制视为类卡牌（如武魂）等名称的显示方式',
                    init: 'default',
                    unfrequent: true,
                    item: {
                        default: '纵向',
                        horizon: '横向',
                        off: '禁用',
                    },
                    onclick: function (item) {
                        game.saveConfig('cardtempname', item);
                        if (!game.me || !game.me.getCards) return;
                        var hs = game.me.getCards('h');
                        for (var i = 0; i < hs.length; i++) {
                            if (hs[i]._tempName) {
                                switch (item) {
                                    case 'default':
                                        var node = hs[i]._tempName;
                                        node.innerHTML = get.verticalStr(node.tempname);
                                        break;
                                    case 'horizon':
                                        var node = hs[i]._tempName;
                                        node.innerHTML = node.tempname;
                                        break;
                                    default:
                                        hs[i]._tempName.delete();
                                        delete hs[i]._tempName;
                                }
                            }
                        }
                    }
                },
                // textequip: {
                //     name: '装备显示',
                //     init: 'image',
                //     unfrequent: true,
                //     item: {
                //         image: '图片',
                //         text: '文字',
                //     },
                //     onclick: function (item) {
                //         game.saveConfig('textequip', item);
                //         if (item == 'text' && (game.layout == 'long' || game.layout == 'mobile')) {
                //             ui.arena.classList.add('textequip');
                //         }
                //         else {
                //             ui.arena.classList.remove('textequip');
                //         }
                //     }
                // },
                buttoncharacter_style: {
                    name: '选将样式',
                    init: 'default',
                    item: {
                        default: '默认',
                        simple: '精简',
                        old: '旧版'
                    },
                    unfrequent: true,
                },
                name_font: {
                    name: '人名字体',
                    init: 'Tiejili',
                    unfrequent: true,
                    item: {},
                    textMenu: function (node, link) {
                        if (link != 'default') {
                            node.style.fontFamily = link;
                        }
                        node.style.fontSize = '20px';
                    },
                    onclick: function (font) {
                        game.saveConfig('name_font', font);
                        lib.init.cssstyles();
                    }
                },
                identity_font: {
                    name: '身份字体',
                    init: 'hyk2gj',
                    unfrequent: true,
                    item: {},
                    textMenu: function (node, link) {
                        if (link != 'default') {
                            node.style.fontFamily = link;
                        }
                        node.style.fontSize = '20px';
                    },
                    onclick: function (font) {
                        game.saveConfig('identity_font', font);
                        lib.init.cssstyles();
                    }
                },
                cardtext_font: {
                    name: '卡牌字体',
                    init: 'Tiejili',
                    unfrequent: true,
                    item: {},
                    textMenu: function (node, link) {
                        if (link != 'default') {
                            node.style.fontFamily = link;
                        }
                        node.style.fontSize = '20px';
                    },
                    onclick: function (font) {
                        game.saveConfig('cardtext_font', font);
                        lib.init.cssstyles();
                    }
                },
                global_font: {
                    name: '界面字体',
                    init: 'default',
                    unfrequent: true,
                    item: {},
                    textMenu: function (node, link) {
                        if (link != 'default') {
                            node.style.fontFamily = link;
                        }
                        else {
                            node.style.fontFamily = "'STHeiti','SimHei','Microsoft JhengHei','Microsoft YaHei','WenQuanYi Micro Hei',Helvetica,Arial,sans-serif";
                        }
                        node.style.fontSize = '20px';
                    },
                    onclick: function (font) {
                        game.saveConfig('global_font', font);
                        lib.init.cssstyles();
                    }
                },
                update: function (config, map) {
                    if (lib.config.custom_button) {
                        map.custom_button_system_top.show();
                        map.custom_button_system_bottom.show();
                        map.custom_button_control_top.show();
                        map.custom_button_control_bottom.show();
                    }
                    else {
                        map.custom_button_system_top.hide();
                        map.custom_button_system_bottom.hide();
                        map.custom_button_control_top.hide();
                        map.custom_button_control_bottom.hide();
                    }
                    if (lib.config.change_skin) {
                        map.change_skin_auto.show();
                    }
                    else {
                        map.change_skin_auto.hide();
                    }
                    if (lib.config.image_background_random) {
                        map.image_background_blur.show();
                        map.image_background.hide();
                        // map.import_background.hide();
                    }
                    else {
                        map.image_background.show();
                        if (lib.config.image_background == 'default') {
                            map.image_background_blur.hide();
                        }
                        else {
                            map.image_background_blur.show();
                        }
                        // if(lib.config.image_background=='custom'&&lib.db){
                        //     map.import_background.show();
                        // }
                        // else{
                        //     map.import_background.hide();
                        // }
                    }
                    if (lib.config.layout == 'long' || lib.config.layout == 'mobile') {
                        // map.textequip.show();
                        map.cardshape.show();
                        map.phonelayout.show();
                    }
                    else {
                        // map.textequip.hide();
                        if (lib.config.layout == 'long2' || lib.config.layout == 'nova') {
                            map.phonelayout.show();
                            map.cardshape.show();
                        }
                        else {
                            map.phonelayout.hide();
                            map.cardshape.hide();
                        }
                    }
                    if (lib.config.layout == 'long') {
                        // map.fewplayer.show();
                        map.player_height.show();
                    }
                    else {
                        // map.fewplayer.hide();
                        if (lib.config.layout == 'long2') {
                            map.player_height.show();
                        }
                        else {
                            map.player_height.hide();
                        }
                    }
                    if (lib.config.layout == 'nova') {
                        map.player_height_nova.show();
                    }
                    else {
                        map.player_height_nova.hide();
                    }
                    if (lib.config.border_style == 'auto') {
                        map.autoborder_count.show();
                        map.autoborder_start.show();
                    }
                    else {
                        map.autoborder_count.hide();
                        map.autoborder_start.hide();
                    }
                },
            }
        },
        /**
         * 显示设置
         * @name configMenu.view
         * @type {!Object}
         */
        view: {
            name: '显示',
            config: {
                update: function (config, map) {
                    if (['versus', 'chess', 'tafang', 'boss', 'richer'].contains(lib.config.mode)) {
                        map.show_handcardbutton.show();
                    }
                    else {
                        map.show_handcardbutton.hide();
                    }
                    if (lib.config.touchscreen) {
                        map.pop_logv.hide();
                    }
                    else {
                        map.pop_logv.show();
                    }
                    if (lib.device) {
                        if (lib.device == 'android') {
                            map.show_statusbar_android.show();
                            map.show_statusbar_ios.hide();
                        }
                        else if (lib.device == 'ios') {
                            map.show_statusbar_ios.show();
                            map.show_statusbar_android.hide();
                        }
                        if (!game.download) {
                            setTimeout(function () {
                                if (!window.StatusBar) {
                                    map.show_statusbar.hide();
                                }
                            }, 5000);
                        }
                    }
                    else {
                        map.show_statusbar_ios.hide();
                        map.show_statusbar_android.hide();
                    }
                    if (get.is.phoneLayout()) {
                        map.remember_round_button.show();
                        map.popequip.show();
                        map.filternode_button.show();
                        map.show_pause.hide();
                        map.show_auto.hide();
                        map.show_replay.hide();
                        map.show_round_menu.show();
                    }
                    else {
                        map.show_pause.show();
                        map.show_auto.show();
                        map.show_replay.show();
                        map.show_round_menu.hide();
                        map.remember_round_button.hide();
                        map.popequip.hide();
                        map.filternode_button.hide();
                    }
                    if (lib.config.show_card_prompt) {
                        map.hide_card_prompt_basic.show();
                        map.hide_card_prompt_equip.show();
                    }
                    else {
                        map.hide_card_prompt_basic.hide();
                        map.hide_card_prompt_equip.hide();
                    }
                    if (lib.config.show_log != 'off') {
                        map.clear_log.show();
                    }
                    else {
                        map.clear_log.hide();
                    }
                    if (get.is.phoneLayout()) {
                        map.show_time2.show();
                        map.show_time.hide();
                        if (lib.config.show_time2) {
                            map.watchface.show();
                        }
                        else {
                            map.watchface.hide();
                        }
                    }
                    else {
                        map.show_time2.hide();
                        map.show_time.show();
                        map.watchface.hide();
                    }
                    // if (lib.config.show_extensionmaker) {
                    //     map.show_extensionshare.show();
                    // }
                    // else {
                    //     map.show_extensionshare.hide();
                    // }
                },
                show_history: {
                    name: '出牌记录栏',
                    init: 'off',
                    intro: '在屏幕左侧或右侧显示出牌记录',
                    unfrequent: true,
                    item: {
                        off: '关闭',
                        left: '靠左',
                        right: '靠右',
                    },
                    onclick: function (bool) {
                        if (lib.config.show_history == 'right') ui.window.animate('rightbar2');
                        game.saveConfig('show_history', bool);
                        if (_status.video || !_status.prepareArena) return;
                        if (bool == 'left') {
                            ui.window.classList.add('leftbar');
                            ui.window.classList.remove('rightbar');
                        }
                        else if (bool == 'right') {
                            ui.window.classList.remove('leftbar');
                            ui.window.classList.add('rightbar');
                        }
                        else {
                            ui.window.classList.remove('leftbar');
                            ui.window.classList.remove('rightbar');
                        }
                    }
                },
                pop_logv: {
                    name: '自动弹出记录',
                    init: false,
                    unfrequent: true
                },
                show_log: {
                    name: '历史记录栏',
                    init: 'off',
                    intro: '在屏幕中部显示出牌文字记录',
                    unfrequent: true,
                    item: {
                        off: '关闭',
                        left: '靠左',
                        center: '居中',
                        right: '靠右',
                    },
                    onclick: function (bool) {
                        game.saveConfig('show_log', bool);
                        if (lib.config.show_log != 'off') {
                            ui.arenalog.style.display = '';
                            ui.arenalog.dataset.position = bool;
                        }
                        else {
                            ui.arenalog.style.display = 'none';
                            ui.arenalog.innerHTML = '';
                        }
                    }
                },
                clear_log: {
                    name: '自动清除历史记录',
                    init: false,
                    unfrequent: true,
                    intro: '开启后将定时清除历史记录栏的条目（而不是等记录栏满后再清除）'
                },
                // log_highlight: {
                //     name: '历史记录高亮',
                //     init: true,
                //     unfrequent: true,
                //     intro: '开启后历史记录不同类别的信息将以不同颜色显示',
                // },
                show_time: {
                    name: '显示时间',
                    intro: '在屏幕顶部显示当前时间',
                    init: false,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('show_time', bool);
                        if (bool) {
                            ui.time.style.display = '';
                        }
                        else {
                            ui.time.style.display = 'none';
                        }
                    }
                },
                show_time2: {
                    name: '显示时间',
                    intro: '在触屏按钮处显示当前时间',
                    init: false,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('show_time2', bool);
                        if (bool) {
                            ui.roundmenu.classList.add('clock');
                        }
                        else {
                            ui.roundmenu.classList.remove('clock');
                        }
                    }
                },
                watchface: {
                    name: '表盘样式',
                    init: 'none',
                    unfrequent: true,
                    item: {
                        none: '默认',
                        simple: '简约',
                    },
                    onclick: function (item) {
                        game.saveConfig('watchface', item);
                        ui.roundmenu.dataset.watchface = item;
                    }
                },
                show_time3: {
                    name: '显示游戏时间',
                    init: false,
                    unfrequent: true
                },
                show_statusbar_android: {
                    name: '显示状态栏',
                    init: false,
                    unfrequent: true,
                    content: function (bool) {
                        game.saveConfig('show_statusbar', bool);
                        if (window.StatusBar && lib.device == 'android') {
                            if (bool) {
                                window.StatusBar.overlaysWebView(false);
                                window.StatusBar.backgroundColorByName('black');
                                window.StatusBar.show();
                            }
                            else {
                                window.StatusBar.hide();
                            }
                        }
                    }
                },
                show_statusbar_ios: {
                    name: '显示状态栏',
                    init: 'off',
                    unfrequent: true,
                    item: {
                        default: '默认',
                        overlay: '嵌入',
                        auto: '自动',
                        off: '关闭'
                    },
                    onclick: function (bool) {
                        game.saveConfig('show_statusbar_ios', bool);
                        if (window.StatusBar && lib.device == 'ios') {
                            if (bool != 'off' && bool != 'auto') {
                                if (lib.config.show_statusbar_ios == 'default') {
                                    window.StatusBar.overlaysWebView(false);
                                    document.body.classList.remove('statusbar');
                                }
                                else {
                                    window.StatusBar.overlaysWebView(true);
                                    document.body.classList.add('statusbar');
                                }
                                window.StatusBar.backgroundColorByName('black');
                                window.StatusBar.show();
                            }
                            else {
                                document.body.classList.remove('statusbar');
                                window.StatusBar.hide();
                            }
                        }
                    }
                },
                show_card_prompt: {
                    name: '显示出牌信息',
                    intro: '出牌时在使用者上显示卡牌名称',
                    init: true,
                    unfrequent: true,
                },
                hide_card_prompt_basic: {
                    name: '隐藏基本牌信息',
                    intro: '不显示基本牌名称',
                    init: false,
                    unfrequent: true,
                },
                hide_card_prompt_equip: {
                    name: '隐藏装备牌信息',
                    intro: '不显示装备牌名称',
                    init: false,
                    unfrequent: true,
                },
                show_phase_prompt: {
                    name: '显示阶段信息',
                    intro: '在当前回合不同阶段开始时显示阶段名称',
                    init: true,
                    unfrequent: true,
                },
                show_phaseuse_prompt: {
                    name: '出牌阶段提示',
                    intro: '在你出牌时显示提示文字',
                    init: true,
                    unfrequent: true,
                },
                auto_popped_config: {
                    name: '自动弹出选项',
                    intro: '鼠标移至选项按钮时弹出模式选择菜单',
                    init: true,
                    unfrequent: true,
                },
                auto_popped_history: {
                    name: '自动弹出历史',
                    intro: '鼠标移至暂停按钮时弹出历史记录菜单',
                    init: false,
                    unfrequent: true,
                },
                show_round_menu: {
                    name: '显示触屏按钮',
                    init: true,
                    unfrequent: true,
                    onclick: function (bool) {
                        if (get.is.nomenu('show_round_menu', bool)) return false;
                        game.saveConfig('show_round_menu', bool);
                        if (bool && ui.roundmenu) {
                            ui.roundmenu.style.display = '';
                        }
                        else {
                            ui.roundmenu.style.display = 'none';
                            alert('关闭触屏按钮后可通过手势打开菜单（默认为下划）')
                        }
                    }
                },
                remember_round_button: {
                    name: '记住按钮位置',
                    intro: '重新开始后触屏按钮将保存的上一局的位置',
                    init: false,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('remember_round_button', bool);
                        if (!bool) {
                            ui.click.resetround();
                        }
                    }
                },
                remember_dialog: {
                    name: '记住对话框位置',
                    intro: '移动对话框后新的对话框也将在移动后的位置显示',
                    init: false,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('remember_dialog', bool);
                        if (!bool) {
                            if (ui.dialog) {
                                var dialog = ui.dialog;
                                dialog.style.transform = '';
                                dialog._dragtransform = [0, 0];
                                dialog.style.transition = 'all 0.3s';
                                dialog._dragtouches;
                                dialog._dragorigin;
                                dialog._dragorigintransform;
                                setTimeout(function () {
                                    dialog.style.transition = '';
                                }, 500);
                            }
                            game.saveConfig('dialog_transform', [0, 0]);
                        }
                    }
                },
                transparent_dialog: {
                    name: '堆叠对话框虚化',
                    init: false,
                    intro: '当具有static属性的对话框堆叠（如五谷丰登对话框中提示无懈可击）时，将后方的对话框变为半透明',
                    onclick: function (bool) {
                        game.saveConfig('transparent_dialog', bool);
                        if (bool) {
                            for (var i = 0; i < ui.dialogs.length; i++) {
                                if (ui.dialogs[i] != ui.dialog && ui.dialogs[i].static) {
                                    ui.dialogs[i].unfocus();
                                }
                            }
                        }
                        else {
                            for (var i = 0; i < ui.dialogs.length; i++) {
                                if (ui.dialogs[i] != ui.dialog && ui.dialogs[i].static) {
                                    ui.dialogs[i].refocus();
                                }
                            }
                        }
                    }
                },
                show_rarity: {
                    name: '显示武将星级',
                    init: true,
                    intro: '仅供娱乐，重启后生效',
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('show_rarity', bool);
                    }
                },
                mark_identity_style: {
                    name: '标记身份操作',
                    intro: '设置单击身份按钮时的操作',
                    unfrequent: true,
                    init: 'menu',
                    item: {
                        menu: '菜单',
                        click: '单击',
                    },
                },
                character_dialog_tool: {
                    name: '自由选将显示',
                    intro: '点击自由选将时默认显示的条目',
                    init: '最近',
                    item: {
                        '收藏': '收藏',
                        '最近': '最近',
                        'all': '全部'
                    },
                    unfrequent: true,
                },
                recent_character_number: {
                    name: '最近使用武将',
                    intro: '自由选将对话框中最近使用武将的数量',
                    init: '12',
                    item: {
                        '6': '6',
                        '12': '12',
                        '20': '24',
                        '30': '36',
                    },
                    unfrequent: true
                },
                popequip: {
                    name: '触屏装备选择',
                    intro: '设置触屏布局中选择装备的方式',
                    init: true,
                    unfrequent: true,
                },
                filternode_button: {
                    name: '触屏筛选按钮',
                    intro: '设置自由选将对话框中筛选按钮的样式',
                    init: true,
                    unfrequent: true,
                },
                show_charactercard: {
                    name: '显示武将资料',
                    intro: '在武将界面单击时弹出武将资料卡',
                    init: true,
                    unfrequent: true
                },
                show_favourite: {
                    name: '显示添加收藏',
                    intro: '在角色的右键菜单中显示添加收藏',
                    init: false,
                    unfrequent: true
                },
                show_favmode: {
                    name: '显示模式收藏',
                    intro: '快捷菜单中显示收藏模式',
                    init: true,
                    unfrequent: true
                },
                show_favourite_menu: {
                    name: '显示收藏菜单',
                    intro: '在选项-武将中显示收藏一栏',
                    init: true,
                    unfrequent: true
                },
                show_ban_menu: {
                    name: '显示禁将菜单',
                    intro: '在选项-武将中显示禁将一栏',
                    init: true,
                    unfrequent: true
                },
                right_range: {
                    name: '显示距离信息',
                    intro: '在角色的右键菜单中显示距离等信息',
                    init: true,
                    unfrequent: true
                },
                replace_image: {
                    name: '替换为原始卡图',
                    intro: '所有V版卡图替换为三国杀原版卡图',
                    init: false,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('replace_image', bool);
                        if (bool) {
                            ui.arena.classList.remove('replace_image');
                        }
                        else {
                            ui.arena.classList.add('replace_image');
                        }
                    },
                },
                // hide_card_image: {
                //     name: '隐藏卡牌背景',
                //     intro: '所有卡牌将使用文字作为背景',
                //     init: false,
                //     unfrequent: true,
                //     restart: true,
                // },
                show_name: {
                    name: '显示角色名称',
                    init: false,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('show_name', bool);
                        if (bool) {
                            ui.arena.classList.remove('hide_name');
                        }
                        else {
                            ui.arena.classList.add('hide_name');
                        }
                    }
                },
                show_replay: {
                    name: '显示重来按钮',
                    init: false,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('show_replay', bool);
                        if (lib.config.show_replay) {
                            ui.replay.style.display = '';
                        }
                        else {
                            ui.replay.style.display = 'none';
                        }
                    }
                },
                show_playerids: {
                    name: '显示身份按钮',
                    init: true,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('show_playerids', bool);
                        if (lib.config.show_playerids) {
                            ui.playerids.style.display = '';
                        }
                        else {
                            ui.playerids.style.display = 'none';
                        }
                    }
                },
                show_sortcard: {
                    name: '显示整理手牌按钮',
                    init: true,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('show_sortcard', bool);
                        if (lib.config.show_sortcard) {
                            ui.sortCard.style.display = '';
                        }
                        else {
                            ui.sortCard.style.display = 'none';
                        }
                    }
                },
                show_pause: {
                    name: '显示暂停按钮',
                    init: true,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('show_pause', bool);
                        if (lib.config.show_pause) {
                            ui.pause.style.display = '';
                        }
                        else {
                            ui.pause.style.display = 'none';
                        }
                    }
                },
                show_auto: {
                    name: '显示托管按钮',
                    init: true,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('show_auto', bool);
                        if (lib.config.show_auto) {
                            ui.auto.style.display = '';
                        }
                        else {
                            ui.auto.style.display = 'none';
                        }
                    }
                },
                show_volumn: {
                    name: '显示音量按钮',
                    init: true,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('show_volumn', bool);
                        if (lib.config.show_volumn) {
                            ui.volumn.style.display = '';
                        }
                        else {
                            ui.volumn.style.display = 'none';
                        }
                    }
                },
                show_cardpile: {
                    name: '显示牌堆按钮',
                    init: true,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('show_cardpile', bool);
                        if (bool) {
                            ui.cardPileButton.style.display = '';
                        }
                        else {
                            ui.cardPileButton.style.display = 'none';
                        }
                    }
                },
                show_cardpile_number: {
                    name: '显示剩余牌数',
                    init: false,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('show_cardpile_number', bool);
                        if (bool) {
                            ui.cardPileNumber.style.display = '';
                        }
                        else {
                            ui.cardPileNumber.style.display = 'none';
                        }
                    }
                },
                show_handcardbutton: {
                    name: '显示手牌按钮',
                    init: true,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('show_handcardbutton', bool);
                    }
                },
                show_giveup: {
                    name: '显示投降按钮',
                    init: true,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('show_giveup', bool);
                    }
                },
                show_wuxie: {
                    name: '显示无懈按钮',
                    intro: '在右上角显示不询问无懈',
                    init: false,
                    unfrequent: true,
                    onclick: function (bool) {
                        game.saveConfig('show_wuxie', bool);
                        if (lib.config.show_wuxie) {
                            ui.wuxie.style.display = '';
                        }
                        else {
                            ui.wuxie.style.display = 'none';
                        }
                    }
                },
                wuxie_right: {
                    name: '无懈按钮靠左',
                    init: true,
                    unfrequent: true,
                },
                show_discardpile: {
                    name: '暂停时显示弃牌堆',
                    init: false,
                    unfrequent: true,
                }
            }
        },
        /**
         * 音效设置
         * @name configMenu.audio
         * @type {!Object}
         */
        audio: {
            name: '音效',
            config: {
                update: function (config, map) {
                    if (lib.config.background_music == 'music_custom' && (lib.device || lib.node)) {
                        map.import_music.show();
                    }
                    else {
                        map.import_music.hide();
                    }
                    map.clear_background_music[get.is.object(lib.config.customBackgroundMusic) ? 'show' : 'hide']();
                    ui.background_music_setting = map.background_music;
                    map.background_music._link.config.updatex.call(map.background_music, []);
                },
                background_music: {
                    updatex: function () {
                        this.lastChild.innerHTML = this._link.config.item[lib.config.background_music];
                        var menu = this._link.menu;
                        for (var i = 0; i < menu.childElementCount; i++) {
                            if (!['music_off', 'music_custom', 'music_random'].concat(lib.config.all.background_music).contains(menu.childNodes[i]._link)) menu.childNodes[i].delete();
                        }
                    },
                    name: '背景音乐',
                    init: true,
                    item: {
                        music_default: '默认',
                    },
                    onclick: function (item) {
                        game.saveConfig('background_music', item);
                        game.playBackgroundMusic();
                    }
                },
                import_music: {
                    name: '<div style="white-space:nowrap;width:calc(100% - 5px)">' +
                        '<input type="file" style="width:calc(100% - 40px)" accept="audio/*">' +
                        '<button style="width:40px">确定</button></div>',
                    clear: true,
                },
                background_audio: {
                    name: '游戏音效',
                    init: true,
                },
                background_speak: {
                    name: '人物配音',
                    init: true,
                },
                // equip_audio: {
                //     name: '装备配音',
                //     init: false,
                // },
                repeat_audio: {
                    name: '播放重复语音',
                    init: false,
                },
                volumn_audio: {
                    name: '音效音量',
                    init: 8,
                    item: {
                        '0': '〇',
                        '1': '一',
                        '2': '二',
                        '3': '三',
                        '4': '四',
                        '5': '五',
                        '6': '六',
                        '7': '七',
                        '8': '八',
                    },
                    onclick: function (volume) {
                        game.saveConfig('volumn_audio', parseInt(volume));
                    }
                },
                volumn_background: {
                    name: '音乐音量',
                    init: 8,
                    item: {
                        '0': '〇',
                        '1': '一',
                        '2': '二',
                        '3': '三',
                        '4': '四',
                        '5': '五',
                        '6': '六',
                        '7': '七',
                        '8': '八',
                    },
                    onclick: function (volume) {
                        game.saveConfig('volumn_background', parseInt(volume));
                        ui.backgroundMusic.volume = volume / 8;
                    }
                },
                clear_background_music: {
                    name: '清除自定义背景音乐',
                    clear: true,
                    onclick: function () {
                        if (confirm('是否清除已导入的所有自定义背景音乐？（该操作不可撤销！）')) {
                            for (var i in lib.config.customBackgroundMusic) {
                                lib.config.all.background_music.remove(i);
                                if (i.indexOf('cdv_') == 0) {
                                    game.removeFile('audio/background/' + i + '.mp3');
                                }
                                else {
                                    game.deleteDB('audio', i);
                                }
                            }
                            lib.config.customBackgroundMusic = null;
                            game.saveConfig('customBackgroundMusic', null);
                            game.saveConfig('background_music', 'music_off');
                            if (!_status._aozhan) game.playBackgroundMusic();
                        }
                    },
                },
            }
        },
        /**
         * (自动, 禁用)技能设置
         * @name configMenu.skill
         * @type {!Object}
         */
        skill: {
            name: '技能',
            config: {
                update: function (config, map) {
                    for (var i in map) {
                        if (map[i]._link.config.type == 'autoskill') {
                            if (!lib.config.autoskilllist.contains(i)) {
                                map[i].classList.add('on');
                            }
                            else {
                                map[i].classList.remove('on');
                            }
                        }
                        else if (map[i]._link.config.type == 'banskill') {
                            if (!lib.config.forbidlist.contains(i)) {
                                map[i].classList.add('on');
                            }
                            else {
                                map[i].classList.remove('on');
                            }
                        }
                    }
                }
            }
        },
        /**
         * 其他菜单项
         * @name configMenu.others
         * @type {!Object}
         */
        others: {
            name: '其它',
            config: {
                // reset_database:{
                //     name:'重置游戏',
                //     onclick:function(){
                //         var node=this;
                //         if(node._clearing){
                //             if(indexedDB) indexedDB.deleteDatabase(lib.configprefix+'data');
                //             game.reload();
                //             return;
                //         }
                //         node._clearing=true;
                //         node.innerHTML='单击以确认 (3)';
                //         setTimeout(function(){
                //             node.innerHTML='单击以确认 (2)';
                //             setTimeout(function(){
                //                 node.innerHTML='单击以确认 (1)';
                //                 setTimeout(function(){
                //                     node.innerHTML='重置游戏录像';
                //                     delete node._clearing;
                //                 },1000);
                //             },1000);
                //         },1000);
                //     },
                //     clear:true
                // },
                reset_game: {
                    name: '重置游戏设置',
                    onclick: function () {
                        var node = this;
                        if (node._clearing) {
                            var noname_inited = localStorage.getItem('noname_inited');
                            var onlineKey = localStorage.getItem(lib.configprefix + 'key');
                            localStorage.clear();
                            if (noname_inited) {
                                localStorage.setItem('noname_inited', noname_inited);
                            }
                            if (onlineKey) {
                                localStorage.setItem(lib.configprefix + 'key', onlineKey);
                            }
                            game.deleteDB('config');
                            game.deleteDB('data');
                            game.reload();
                            return;
                        }
                        node._clearing = true;
                        node.firstChild.innerHTML = '单击以确认 (3)';
                        setTimeout(() => {
                            node.firstChild.innerHTML = '单击以确认 (2)';
                            setTimeout(() => {
                                node.firstChild.innerHTML = '单击以确认 (1)';
                                setTimeout(() => {
                                    node.firstChild.innerHTML = '重置游戏设置';
                                    delete node._clearing;
                                }, 1000);
                            }, 1000);
                        }, 1000);
                    },
                    clear: true
                },
                reset_hiddenpack: {
                    name: '重置隐藏内容',
                    onclick: function () {
                        if (this.firstChild.innerHTML != '已重置') {
                            this.firstChild.innerHTML = '已重置'
                            game.saveConfig('hiddenModePack', []);
                            game.saveConfig('hiddenCharacterPack', []);
                            game.saveConfig('hiddenCardPack', []);
                            game.saveConfig('hiddenPlayPack', []);
                            game.saveConfig('hiddenBackgroundPack', []);
                            setTimeout(() => {
                                this.firstChild.innerHTML = '重置隐藏内容';
                                setTimeout(() => {
                                    if (confirm('是否重新启动使改变生效？')) {
                                        game.reload();
                                    }
                                });
                            }, 500);
                        }
                    },
                    clear: true
                },
                reset_tutorial: {
                    name: '重置身份模式的新手向导',
                    onclick: function () {
                        if (this.firstChild.innerHTML != '已重置') {
                            this.firstChild.innerHTML = '已重置'
                            game.saveConfig('new_tutorial', false);
                            game.saveConfig('prompt_hidebg');
                            game.saveConfig('prompt_hidepack');
                            setTimeout(() => {
                                this.firstChild.innerHTML = '重置新手向导';
                            }, 500);
                        }
                    },
                    clear: true
                },
                import_data: {
                    name: '导入游戏设置',
                    onclick: function () {
                        ui.import_data_button.classList.toggle('hidden');
                    },
                    clear: true
                },
                import_data_button: {
                    name: '<div style="white-space:nowrap;width:calc(100% - 10px)">' +
                        '<input type="file" style="width:calc(100% - 40px)">' +
                        '<button style="width:40px">确定</button></div>',
                    clear: true,
                },
                export_data: {
                    name: '导出游戏设置',
                    onclick: function () {
                        var data;
                        var export_data = function (data) {
                            game.export(lib.init.encode(JSON.stringify(data)), '无名杀 - 数据 - ' + (new Date()).toLocaleString());
                        }
                        if (!lib.db) {
                            data = {};
                            for (var i in localStorage) {
                                if (i.indexOf(lib.configprefix) == 0) {
                                    data[i] = localStorage[i];
                                }
                            }
                            export_data(data);
                        }
                        else {
                            game.getDB('config', null, function (data1) {
                                game.getDB('data', null, function (data2) {
                                    export_data({
                                        config: data1,
                                        data: data2
                                    });
                                });
                            });
                        }

                    },
                    clear: true
                },
                redownload_game: {
                    name: '重新下载游戏',
                    onclick: function () {
                        var node = this;
                        if (node._clearing) {
                            localStorage.removeItem('noname_inited');
                            game.reload();
                            return;
                        }
                        node._clearing = true;
                        node.firstChild.innerHTML = '单击以确认 (3)';
                        setTimeout(function () {
                            node.firstChild.innerHTML = '单击以确认 (2)';
                            setTimeout(function () {
                                node.firstChild.innerHTML = '单击以确认 (1)';
                                setTimeout(function () {
                                    node.firstChild.innerHTML = '重新下载游戏';
                                    delete node._clearing;
                                }, 1000);
                            }, 1000);
                        }, 1000);
                    },
                    clear: true
                },
                update: function (config, map) {
                    if (lib.device || lib.node) {
                        map.redownload_game.show();
                    }
                    else {
                        map.redownload_game.hide();
                    }
                }
            }
        }
    }
    /**
     * 拓展菜单
     * @name configMenu.extensionMenu
     */
    lib.extensionMenu = {
        cardpile: {
            enable: {
                name: '开启',
                init: false,
                restart: true,
            },
            intro: {
                name: '将杀闪等牌在牌堆中的比例维持在与军争牌堆相同，防止开启扩展包后被过多地稀释',
                clear: true,
                nopointer: true,
            },
            sha: {
                name: '杀',
                init: '1',
                item: {
                    '1': '补充全部',
                    '0.5': '补充一半',
                    '0': '不补充'
                }
            },
            huosha: {
                name: '火杀',
                init: '1',
                item: {
                    '1': '补充全部',
                    '0.5': '补充一半',
                    '0': '不补充'
                }
            },
            leisha: {
                name: '雷杀',
                init: '1',
                item: {
                    '1': '补充全部',
                    '0.5': '补充一半',
                    '0': '不补充'
                }
            },
            shan: {
                name: '闪',
                init: '1',
                item: {
                    '1': '补充全部',
                    '0.5': '补充一半',
                    '0': '不补充'
                }
            },
            tao: {
                name: '桃',
                init: '0',
                item: {
                    '1': '补充全部',
                    '0.5': '补充一半',
                    '0': '不补充'
                }
            },
            jiu: {
                name: '酒',
                init: '0',
                item: {
                    '1': '补充全部',
                    '0.5': '补充一半',
                    '0': '不补充'
                }
            },
            wuxie: {
                name: '无懈可击',
                init: '0.5',
                item: {
                    '1': '补充全部',
                    '0.5': '补充一半',
                    '0': '不补充'
                }
            },
            nanman: {
                name: '南蛮入侵',
                init: '0',
                item: {
                    '1': '补充全部',
                    '0.5': '补充一半',
                    '0': '不补充'
                }
            },
            wanjian: {
                name: '万箭齐发',
                init: '0',
                item: {
                    '1': '补充全部',
                    '0.5': '补充一半',
                    '0': '不补充'
                }
            },
            guohe: {
                name: '过河拆桥',
                init: '0',
                item: {
                    '1': '补充全部',
                    '0.5': '补充一半',
                    '0': '不补充'
                }
            },
            shunshou: {
                name: '顺手牵羊',
                init: '0',
                item: {
                    '1': '补充全部',
                    '0.5': '补充一半',
                    '0': '不补充'
                }
            },
            tiesuo: {
                name: '铁索连环',
                init: '0',
                item: {
                    '1': '补充全部',
                    '0.5': '补充一半',
                    '0': '不补充'
                }
            },
            hide: {
                name: '隐藏此扩展',
                clear: true,
                onclick: function () {
                    if (this.firstChild.innerHTML == '隐藏此扩展') {
                        this.firstChild.innerHTML = '此扩展将在重启后隐藏';
                        lib.config.hiddenPlayPack.add('cardpile');
                        if (!lib.config.prompt_hidepack) {
                            alert('隐藏的扩展包可通过选项-其它-重置隐藏内容恢复');
                            game.saveConfig('prompt_hidepack', true);
                        }
                    }
                    else {
                        this.firstChild.innerHTML = '隐藏此扩展';
                        lib.config.hiddenPlayPack.remove('cardpile');
                    }
                    game.saveConfig('hiddenPlayPack', lib.config.hiddenPlayPack);
                }
            },
        },
        // boss: {
        //     enable: {
        //         name: '开启',
        //         init: false,
        //         restart: true,
        //         onswitch: function (bool) {
        //             if (bool) {
        //                 var storage = { boss: {}, versus: {}, translate: {} };
        //                 var loadversus = function () {
        //                     game.loadModeAsync('versus', function (mode) {
        //                         for (var i in mode.translate) {
        //                             storage.translate[i] = mode.translate[i];
        //                         }
        //                         for (var i in mode.jiangeboss) {
        //                             if (mode.jiangeboss[i][4].contains('bossallowed')) {
        //                                 storage.versus[i] = mode.jiangeboss[i];
        //                             }
        //                         }
        //                         localStorage.setItem('boss_storage_playpackconfig', JSON.stringify(storage));
        //                     });
        //                 };
        //                 game.loadModeAsync('boss', function (mode) {
        //                     for (var i in mode.translate) {
        //                         storage.translate[i] = mode.translate[i];
        //                     }
        //                     for (var i in mode.characterPack.mode_boss) {
        //                         if (mode.characterPack.mode_boss[i][4].contains('bossallowed')) {
        //                             storage.boss[i] = mode.characterPack.mode_boss[i];
        //                         }
        //                     }
        //                     loadversus();
        //                 });
        //             }
        //             else {
        //                 localStorage.removeItem('boss_storage_playpackconfig');
        //             }
        //         }
        //     },
        //     intro: {
        //         name: '将剑阁和挑战模式的武将添加到其它模式',
        //         clear: true,
        //         nopointer: true,
        //     },
        //     enableai: {
        //         name: '随机选将可用',
        //         init: false
        //     },
        //     hide: {
        //         name: '隐藏此扩展',
        //         clear: true,
        //         onclick: function () {
        //             if (this.firstChild.innerHTML == '隐藏此扩展') {
        //                 this.firstChild.innerHTML = '此扩展将在重启后隐藏';
        //                 lib.config.hiddenPlayPack.add('boss');
        //                 if (!lib.config.prompt_hidepack) {
        //                     alert('隐藏的扩展包可通过选项-其它-重置隐藏内容恢复');
        //                     game.saveConfig('prompt_hidepack', true);
        //                 }
        //             }
        //             else {
        //                 this.firstChild.innerHTML = '隐藏此扩展';
        //                 lib.config.hiddenPlayPack.remove('boss');
        //             }
        //             game.saveConfig('hiddenPlayPack', lib.config.hiddenPlayPack);
        //         }
        //     },
        // },
        wuxing: {
            enable: {
                name: '开启',
                init: false,
                restart: true,
            },
            intro: {
                name: '每名角色和部分卡牌在游戏开始时随机获得一个属性',
                clear: true,
                nopointer: true,
            },
            num: {
                name: '带属性卡牌',
                init: '0.3',
                item: {
                    '0.1': '10%',
                    '0.2': '20%',
                    '0.3': '30%',
                    '0.5': '50%',
                }
            },
            hide: {
                name: '隐藏此扩展',
                clear: true,
                onclick: function () {
                    if (this.firstChild.innerHTML == '隐藏此扩展') {
                        this.firstChild.innerHTML = '此扩展将在重启后隐藏';
                        lib.config.hiddenPlayPack.add('wuxing');
                        if (!lib.config.prompt_hidepack) {
                            alert('隐藏的扩展包可通过选项-其它-重置隐藏内容恢复');
                            game.saveConfig('prompt_hidepack', true);
                        }
                    }
                    else {
                        this.firstChild.innerHTML = '隐藏此扩展';
                        lib.config.hiddenPlayPack.remove('wuxing');
                    }
                    game.saveConfig('hiddenPlayPack', lib.config.hiddenPlayPack);
                }
            },
        },
        coin: {
            enable: {
                name: '开启',
                init: false,
                restart: true,
                onclick: function (bool) {
                    if (bool) {
                        lib.config.plays.add('coin');
                    }
                    else {
                        lib.config.plays.remove('coin');
                    }
                    game.saveConfig('plays', lib.config.plays);
                }
            },
            intro: {
                name: '每完成一次对局，可获得一定数量的金币；金币可用于购买游戏特效',
                clear: true,
                nopointer: true,
            },
            display: {
                name: '金币显示',
                init: 'text',
                item: {
                    symbol: '符号',
                    text: '文字'
                },
                onclick: function (item) {
                    game.saveConfig('coin_display_playpackconfig', item);
                    if (game.changeCoin) game.changeCoin(0);
                }
            },
            canvas: {
                name: '特效置顶',
                init: false,
                onclick: function (bool) {
                    game.saveConfig('coin_canvas_playpackconfig', bool);
                    if (bool) {
                        ui.window.classList.add('canvas_top');
                    }
                    else {
                        ui.window.classList.remove('canvas_top');
                    }
                }
            },
            hide: {
                name: '隐藏此扩展',
                clear: true,
                onclick: function () {
                    if (this.firstChild.innerHTML == '隐藏此扩展') {
                        this.firstChild.innerHTML = '此扩展将在重启后隐藏';
                        lib.config.hiddenPlayPack.add('coin');
                        if (!lib.config.prompt_hidepack) {
                            alert('隐藏的扩展包可通过选项-其它-重置隐藏内容恢复');
                            game.saveConfig('prompt_hidepack', true);
                        }
                    }
                    else {
                        this.firstChild.innerHTML = '隐藏此扩展';
                        lib.config.hiddenPlayPack.remove('coin');
                    }
                    game.saveConfig('hiddenPlayPack', lib.config.hiddenPlayPack);
                }
            },
        },
    }
}

/***/ }),

/***/ 7876:
/***/ ((module) => {

module.exports={
	s:[
		'sp_Ava',
	],
	ap:[
		'sp_MinatoAqua',
	],
	a:[
		'sp_KaguraMea',
		'sp_UsadaPekora',
	],
	am:[
		'sp_Diana',
		'sp_MononobeAlice',
	],
	bp:[
		'sp_GawrGura',
		'Diana',
	],
	b:[
		'MinatoAqua',
	],
	bm:[
		'KaguraMea',
	],
	c:[
		'Ava',
	],
	d:[
		'junk_simayi',
	],
	rarity:{
		beginner:[
			're_MitoTsukino',
			're_UshimiIchigo',
			're_RobokoSan',
			're_HoshimatiSuisei',
			're_Omesis',
			're_Siro',
			're_KaguraMea',
			're_HisekiErio',
			'SakuraRitsuki',
			'Yousa',
			'bingtang',
		],
		legend:[
		],
		epic:[
		],
		rare:[
		],
		junk:[
		],
	}
};


/***/ }),

/***/ 8274:
/***/ ((module) => {

/*
* 鼠标点击特效，canvas点击效果，第二版
* 原文地址：https://www.iowen.cn/canvas-click-effect-second-edition
*/
/* Copyright (C) 2013 Justin Windle sketch.min.js, http://soulwire.co.uk */
var Sketch = function () { "use strict"; function e(e) { return "[object Array]" == Object.prototype.toString.call(e) } function t(e) { return "function" == typeof e } function n(e) { return "number" == typeof e } function o(e) { return "string" == typeof e } function r(e) { return E[e] || String.fromCharCode(e) } function i(e, t, n) { for (var o in t) (n || !e.hasOwnProperty(o)) && (e[o] = t[o]); return e } function u(e, t) { return function () { e.apply(t, arguments) } } function a(e) { var n = {}; for (var o in e) n[o] = t(e[o]) ? u(e[o], e) : e[o]; return n } function c(e) { function n(n) { t(n) && n.apply(e, [].splice.call(arguments, 1)) } function u(e) { for (_ = 0; _ < J.length; _++)G = J[_], o(G) ? O[(e ? "add" : "remove") + "EventListener"].call(O, G, k, !1) : t(G) ? k = G : O = G } function c() { L(T), T = I(c), U || (n(e.setup), U = t(e.setup), n(e.resize)), e.running && !j && (e.dt = (B = +new Date) - e.now, e.millis += e.dt, e.now = B, n(e.update), e.autoclear && K && e.clear(), n(e.draw)), j = ++j % e.interval } function l() { O = Y ? e.style : e.canvas, D = Y ? "px" : "", e.fullscreen && (e.height = w.innerHeight, e.width = w.innerWidth), O.height = e.height + D, O.width = e.width + D, e.retina && K && X && (O.height = e.height * X, O.width = e.width * X, O.style.height = e.height + "px", O.style.width = e.width + "px", e.scale(X, X)), U && n(e.resize) } function s(e, t) { return N = t.getBoundingClientRect(), e.x = e.pageX - N.left - w.scrollX, e.y = e.pageY - N.top - w.scrollY, e } function f(t, n) { return s(t, e.element), n = n || {}, n.ox = n.x || t.x, n.oy = n.y || t.y, n.x = t.x, n.y = t.y, n.dx = n.x - n.ox, n.dy = n.y - n.oy, n } function g(e) { if (e.preventDefault(), W = a(e), W.originalEvent = e, W.touches) for (M.length = W.touches.length, _ = 0; _ < W.touches.length; _++)M[_] = f(W.touches[_], M[_]); else M.length = 0, M[0] = f(W, V); return i(V, M[0], !0), W } function h(t) { for (t = g(t), q = (Q = J.indexOf(z = t.type)) - 1, e.dragging = /down|start/.test(z) ? !0 : /up|end/.test(z) ? !1 : e.dragging; q;)o(J[q]) ? n(e[J[q--]], t) : o(J[Q]) ? n(e[J[Q++]], t) : q = 0 } function p(t) { F = t.keyCode, H = "keyup" == t.type, Z[F] = Z[r(F)] = !H, n(e[t.type], t) } function v(t) { e.autopause && ("blur" == t.type ? b : C)(), n(e[t.type], t) } function C() { e.now = +new Date, e.running = !0 } function b() { e.running = !1 } function P() { (e.running ? b : C)() } function A() { K && e.clearRect(0, 0, e.width, e.height) } function S() { R = e.element.parentNode, _ = x.indexOf(e), R && R.removeChild(e.element), ~_ && x.splice(_, 1), u(!1), b() } var T, k, O, R, N, _, D, B, G, W, z, F, H, q, Q, j = 0, M = [], U = !1, X = w.devicePixelRatio, Y = e.type == m, K = e.type == d, V = { x: 0, y: 0, ox: 0, oy: 0, dx: 0, dy: 0 }, J = [e.element, h, "mousedown", "touchstart", h, "mousemove", "touchmove", h, "mouseup", "touchend", h, "click", y, p, "keydown", "keyup", w, v, "focus", "blur", l, "resize"], Z = {}; for (F in E) Z[E[F]] = !1; return i(e, { touches: M, mouse: V, keys: Z, dragging: !1, running: !1, millis: 0, now: 0 / 0, dt: 0 / 0, destroy: S, toggle: P, clear: A, start: C, stop: b }), x.push(e), e.autostart && C(), u(!0), l(), c(), e } for (var l, s, f = "E LN10 LN2 LOG2E LOG10E PI SQRT1_2 SQRT2 abs acos asin atan ceil cos exp floor log round sin sqrt tan atan2 pow max min".split(" "), g = "__hasSketch", h = Math, d = "canvas", p = "webgl", m = "dom", y = document, w = window, x = [], v = { fullscreen: !0, autostart: !0, autoclear: !0, autopause: !0, container: y.body, interval: 1, globals: !0, retina: !1, type: d }, E = { 8: "BACKSPACE", 9: "TAB", 13: "ENTER", 16: "SHIFT", 27: "ESCAPE", 32: "SPACE", 37: "LEFT", 38: "UP", 39: "RIGHT", 40: "DOWN" }, C = { CANVAS: d, WEB_GL: p, WEBGL: p, DOM: m, instances: x, install: function (t) { if (!t[g]) { for (var o = 0; o < f.length; o++)t[f[o]] = h[f[o]]; i(t, { TWO_PI: 2 * h.PI, HALF_PI: h.PI / 2, QUATER_PI: h.PI / 4, random: function (t, o) { return e(t) ? t[~~(h.random() * t.length)] : (n(o) || (o = t || 1, t = 0), t + h.random() * (o - t)) }, lerp: function (e, t, n) { return e + n * (t - e) }, map: function (e, t, n, o, r) { return (e - t) / (n - t) * (r - o) + o } }), t[g] = !0 } }, create: function (e) { return e = i(e || {}, v), e.globals && C.install(self), l = e.element = e.element || y.createElement(e.type === m ? "div" : "canvas"), s = e.context = e.context || function () { switch (e.type) { case d: return l.getContext("2d", e); case p: return l.getContext("webgl", e) || l.getContext("experimental-webgl", e); case m: return l.canvas = l } }(), e.container.appendChild(l), C.augment(s, e) }, augment: function (e, t) { return t = i(t || {}, v), t.element = e.canvas || e, t.element.className += " sketch", i(e, t, !0), c(e) } }, b = ["ms", "moz", "webkit", "o"], P = self, A = 0, S = "AnimationFrame", T = "request" + S, k = "cancel" + S, I = P[T], L = P[k], O = 0; O < b.length && !I; O++)I = P[b[O] + "Request" + S], L = P[b[O] + "Cancel" + T]; return P[T] = I = I || function (e) { var t = +new Date, n = h.max(0, 16 - (t - A)), o = setTimeout(function () { e(t + n) }, n); return A = t + n, o }, P[k] = L = L || function (e) { clearTimeout(e) }, C }();
//---
function Particle(x, y, radius) {
    this.init(x, y, radius);
}
Particle.prototype = {
    init: function (x, y, radius) {
        this.alive = true;
        this.radius = radius || 10;
        this.wander = 0.15;
        this.theta = random(TWO_PI);
        this.drag = 0.92;
        this.color = '#ffeb3b';
        this.x = x || 0.0;
        this.y = y || 0.0;
        this.vx = 0.0;
        this.vy = 0.0;
    },
    move: function () {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= this.drag;
        this.vy *= this.drag;
        this.theta += random(-0.5, 0.5) * this.wander;
        this.vx += sin(this.theta) * 0.1;
        this.vy += cos(this.theta) * 0.1;
        this.radius *= 0.96;
        this.alive = this.radius > 0.5;
    },
    draw: function (ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, TWO_PI);
        ctx.fillStyle = this.color;
        ctx.fill();
    }
};
module.exports = {
    init: function () {
        if ('ontouchstart' in document) return
        let div = document.createElement('div')
        div.setAttribute("id", "clickCanvas");
        div.setAttribute("style", " position:fixed;left:0;top:0;z-index:999999999;pointer-events:none;");
        document.body.insertBefore(div, document.body.firstChild)
        if (document.getElementById("clickCanvas")) {
            var MAX_PARTICLES = 50;//粒子数量？
            //圆点颜色库
            var COLOURS = ["#5ee4ff", "#f44033", "#ffeb3b", "#F38630", "#FA6900", "#f403e8", "#F9D423"];
            var particles = [];
            var pool = [];
            var clickparticle = Sketch.create({
                container: document.getElementById('clickCanvas')
            });
            clickparticle.spawn = function (x, y) {
                if (particles.length >= MAX_PARTICLES)
                    pool.push(particles.shift());
                particle = pool.length ? pool.pop() : new Particle();
                particle.init(x, y, random(5, 20));//圆点大小范围
                particle.wander = random(0.5, 2.0);
                particle.color = random(COLOURS);
                particle.drag = random(0.9, 0.99);
                theta = random(TWO_PI);
                force = random(1, 5);
                particle.vx = sin(theta) * force;
                particle.vy = cos(theta) * force;
                particles.push(particle);
            };
            clickparticle.update = function () {
                var i, particle;
                for (i = particles.length - 1; i >= 0; i--) {
                    particle = particles[i];
                    if (particle.alive)
                        particle.move();
                    else
                        pool.push(particles.splice(i, 1)[0]);
                }
            };
            clickparticle.draw = function () {
                clickparticle.globalCompositeOperation = 'lighter';
                for (var i = particles.length - 1; i >= 0; i--) {
                    particles[i].draw(clickparticle);
                }
            };
            let callback = (e) => {
                var max, j;
                //排除一些元素
                !["TEXTAREA", "INPUT", "A", "I", "IMG"].includes(e.target.nodeName)
                    && function () {
                        for (max = random(15, 20), j = 0; j < max; j++)
                        clickparticle.spawn(e.clientX, e.clientY);
                    }();
            }
            //按下时显示效果，mousedown 换成 click 为点击时显示效果（我用的 click）
            document.addEventListener("click", callback);
            // document.addEventListener("touchstart", callback);
            // document.addEventListener("mousedown", callback);
            this.clickparticle = clickparticle
        }
    },
    /**
     * 
     * @param {Object} config 
     * config.particles 圆点数量
     * config.colors 特效颜色库(数组)
     * config.size 圆点大小范围(数组)
     * config.trigger 按下时显示效果(可用click)
     */
    changeCanvas: function (config) {
        if (this.clickparticle) {
            var MAX_PARTICLES = config.particles | 50;

            //圆点颜色库
            var COLOURS = config.colors | ["#5ee4ff", "#f44033", "#ffeb3b", "#F38630", "#FA6900", "#f403e8", "#F9D423"];
            var particles = [];
            var pool = [];
            var clickparticle = this.clickparticle;
            clickparticle.spawn = function (x, y) {
                if (particles.length >= MAX_PARTICLES)
                    pool.push(particles.shift());
                particle = pool.length ? pool.pop() : new Particle();
                particle.init(x, y, config.size?random(config.size[0], config.size[1]):random(5, 20)); //圆点大小范围
                particle.wander = random(0.5, 2.0);
                particle.color = random(COLOURS);
                particle.drag = random(0.9, 0.99);
                theta = random(TWO_PI);
                force = random(1, 5);
                particle.vx = sin(theta) * force;
                particle.vy = cos(theta) * force;
                particles.push(particle);
            };
            clickparticle.update = function () {
                var i, particle;
                for (i = particles.length - 1; i >= 0; i--) {
                    particle = particles[i];
                    if (particle.alive)
                        particle.move();

                    else
                        pool.push(particles.splice(i, 1)[0]);
                }
            };
            clickparticle.draw = function () {
                clickparticle.globalCompositeOperation = 'lighter';
                for (var i = particles.length - 1; i >= 0; i--) {
                    particles[i].draw(clickparticle);
                }
            };
            this.clickparticle = clickparticle
        }
    }
}

/***/ }),

/***/ 6798:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//galgame相关功能
module.exports = function () {
    let { game, ui, get, ai, lib, _status } = vkCore
    var galgame = {
        text: {},
        game: game,
        sce(shijian) {
            var game = galgame.game;
            let next = game.createEvent('sce', false);
            next.shijian = shijian;
            next.setContent(galgame.sces);
            return next;
        },
        audio: document.createElement("audio"),
        backgroundMusic: document.createElement("audio"),
        end() {
            var game = galgame.game;
            galgame.audio.pause();
            galgame.backgroundMusic.pause();
            game.resume();
        },
        cg(src, callback) {
            var cg = document.createElement("video");
            cg.setAttribute("width", "100%");
            cg.setAttribute("height", "100%");
            cg.setAttribute("src", src);
            cg.setAttribute("autoplay", "autoplay");
            cg.addEventListener("ended", callback);
            cg.addEventListener("loadedmetadata", function () {
                (this).onclick = function () {
                    this.play();
                    this.currentTime = this.duration;
                }
            });
            return cg;
        },
        sces() {
            var game = galgame.game;
            var color = {};
            var beijing = ui.create.div('.scedi', ui.window);
            var booth = { node: ui.create.div(".scetu", beijing) };
            var node = ui.create.div('.sce', beijing);
            var drive = ui.create.div('.drive', beijing);
            var tou = ui.create.div('.tou', node);
            var txt = ui.create.div('.txt', node);
            var right = ui.create.div(node);
            var name = ui.create.div('.name', tou);
            var name2 = ui.create.div('.name', right);
            var num = 0,
                i = 0;
            var bofang = function () {
                if (!galgame.text[Evt.shijian]) return;
                var arr = galgame.text[Evt.shijian][num].split(':');
                if (arr[0] == "background") {
                    if (arr[1] == "none") {
                        beijing.style.backgroundImage = "";
                    } else {
                        beijing.setBackgroundImage('extension/' + arr[1]);
                    }
                    num++;
                    bofang();
                    return;
                } else if (arr[0] == "booth") {
                    if (arr[6] || (arr[1] == "none" && arr[2])) {
                        if (!booth[arr[6]]) {
                            booth[arr[6]] = ui.create.div(".scetu", beijing);
                        }
                        if (arr[1] == "none") {
                            booth[arr[2]].hide();
                        } else {
                            if (booth[arr[6]].classList.contains("hidden")) booth.node.show();
                            booth[arr[6]].style.width = parseInt(arr[2]) + "px";
                            booth[arr[6]].style.height = parseInt(arr[3]) + "px";
                            booth[arr[6]].style.left = parseInt(arr[4]) + "%";
                            booth[arr[6]].style.top = parseInt(arr[5]) + "%";
                            booth[arr[6]].setBackgroundImage('extension/' + arr[1]);
                        }
                    } else {
                        if (arr[1] == "none") {
                            booth.node.hide();
                        } else {
                            if (booth.node.classList.contains("hidden")) booth.node.show();
                            booth.node.style.width = parseInt(arr[2]) + "px";
                            booth.node.style.height = parseInt(arr[3]) + "px";
                            booth.node.style.left = parseInt(arr[4]) + "%";
                            booth.node.style.top = parseInt(arr[5]) + "%";
                            booth.node.setBackgroundImage('extension/' + arr[1]);
                        }
                    }
                    num++;
                    bofang();
                    return;
                } else if (arr[0] == "color") {
                    if (arr[1] == "text") {
                        node.style.backgroundColor = arr[2];
                    }
                    if (arr[1] == "choose") {
                        if (arr[3]) {
                            color[arr[3]] = arr[2];
                        } else {
                            color.every = arr[2];
                        }
                    }
                    num++;
                    bofang();
                    return;
                } else if (arr[0] == "music") {
                    ui.backgroundMusic.pause();
                    galgame.backgroundMusic.src = lib.assetURL + "galgame/" + arr[1];
                    galgame.backgroundMusic.play();
                    num++;
                    bofang();
                    return;
                } else if (arr[0] == "audio") {
                    galgame.audio.src = lib.assetURL + "galgame/" + arr[1];
                    galgame.audio.play();
                    num++;
                    bofang();
                    return;
                } else if (arr[0] == "cg") {
                    ui.backgroundMusic.pause();
                    galgame.backgroundMusic.pause();
                    var di = ui.create.div('.cg');
                    var cg = galgame.cg(lib.assetURL + "galgame/" + arr[1], function () {
                        beijing.removeChild(di);
                        ui.backgroundMusic.play();
                        bofang();
                    });
                    di.appendChild(cg);
                    beijing.appendChild(di);
                    num++;
                    return;
                } else if (arr[0] == "choose") {
                    var choose = ui.create.div('.choose', beijing);
                    for (var j = 1; j < arr.length; j++) {
                        var sele = ui.create.div('.sele', choose);
                        sele.onclick = function () {
                            _status.event.result = {
                                bool: this.innerText,
                            }
                            ui.window.removeChild(beijing);
                            ui.backgroundMusic.play();
                            galgame.end();
                        };
                        sele.innerHTML = arr[j];
                        if (color.every) sele.style.backgroundColor = color.every;
                        if (color[j]) sele.style.backgroundColor = color[j];
                    }
                    return;
                } else if (arr[0] == "right") {
                    if (arr[1] != "none") {
                        if (!right.classList.contains("galright")) {
                            right.classList.add("galright");
                        }
                        if (!txt.classList.contains("txt2")) {
                            txt.classList.add("txt2");
                        }
                        right.setBackgroundImage('extension/' + arr[1]);
                        if (arr[2] == "none") {
                            name2.innerHTML = "";
                        } else {
                            name2.innerHTML = arr[2];
                        }
                        if (arr[3]) {
                            if (arr[3] == "left") {
                                if (!tou.classList.contains("yingyin")) {
                                    tou.classList.add("yingyin");
                                }
                                if (right.classList.contains("yingyin")) {
                                    right.classList.remove("yingyin");
                                }
                            }
                            if (arr[3] == "right") {
                                if (tou.classList.contains("yingyin")) {
                                    tou.classList.remove("yingyin");
                                }
                                if (!right.classList.contains("yingyin")) {
                                    right.classList.add("yingyin");
                                }
                            }
                        } else {
                            if (tou.classList.contains("yingyin")) {
                                tou.classList.remove("yingyin");
                            }
                            if (right.classList.contains("yingyin")) {
                                right.classList.remove("yingyin");
                            }
                        }
                    } else {
                        right.classList.remove("galright");
                        txt.classList.remove("txt2");
                        if (tou.classList.contains("yingyin")) {
                            tou.remove("yingyin");
                        }
                        if (right.classList.contains("yingyin")) {
                            right.remove("yingyin");
                        }
                        name2.innerHTML = "";
                    }
                    num++;
                    bofang();
                    return;
                }
                tou.show();
                if (arr[0] == "none") {
                    tou.hide();
                } else if (arr[0] == "sp") {
                    tou.setBackgroundImage("galgame/" + arr[3]);
                    name.innerHTML = arr[2];
                } else {
                    tou.setBackground(arr[0], "character");
                    name.innerHTML = get.rawName([arr[0]]);
                }
                function skip0(e) {
                    if (e.ctrlKey) {
                        window.status = 'skip';
                    }
                }
                function skip1(e) {
                    if (e.keyCode == '17') {
                        window.status = '';
                    }
                }
                var skipfun0 = function (e) {
                    skip0(e);
                }
                var skipfun1 = function (e) {
                    skip1(e);
                }
                var link = arr[1].replace(/@/g, lib.config.connect_nickname);
                var show = function () {
                    delete drive.onclick
                    if (link[i] == "<") {
                        for (var j = i; j < link.length; j++) {
                            if (link[j] == ">") {
                                if (link[j + 1] && link[j + 1] == "<") {
                                    continue;
                                }
                                i = j + 1;
                                break;
                            }
                        }
                    }
                    var str = link.substr(0, i);
                    txt.innerHTML = str;
                    i++;
                    if (i <= link.length) {
                        window.addEventListener('keydown', skipfun0);
                        window.addEventListener('keyup', skipfun1);
                        let dis = (link.length - i)
                        if (window.status == 'skip') {
                            let t = setTimeout(show, (dis > 5 ? 20 + (80 / (dis-3)) : 100));
                            drive.onclick = function () {
                                clearTimeout(t);
                                show();
                            }
                        }
                        else {
                            let t = setTimeout(show, (dis > 5 ? 200 + (300 / (dis-4)) : 500));
                            drive.onclick = function () {
                                clearTimeout(t);
                                show();
                            }
                        }
                    } else {
                        if (num < galgame.text[Evt.shijian].length) {
                            if (window.status == 'skip') {
                                i = 0;
                                galgame.audio.pause();
                                bofang();
                                window.status = '';
                                delete drive.onclick
                            }
                            else {
                                drive.onclick = function () {
                                    this.onclick = false;
                                    i = 0;
                                    galgame.audio.pause();
                                    bofang();
                                }
                            }
                        } else {
                            window.removeEventListener('keydown', skipfun0);
                            window.removeEventListener('keyup', skipfun1);
                            if (window.status == 'skip') {
                                ui.backgroundMusic.play();
                                ui.window.removeChild(beijing);
                                galgame.end();
                                window.status = '';
                                delete drive.onclick
                            }
                            else {
                                drive.onclick = function () {
                                    this.onclick = false;
                                    ui.backgroundMusic.play();
                                    ui.window.removeChild(beijing);
                                    galgame.end();
                                }
                            }
                        }
                    }
                }
                show();
                console.log('++')
                num++;
            }
            bofang();
            game.pause();
        }
    };
    let text = __webpack_require__(8478)
    for (var i in text) {
        galgame.text[i] = text[i];
    }
    __webpack_require__(9723)
    game.galgame = galgame;
}

/***/ }),

/***/ 476:
/***/ ((module) => {

module.exports = {
    bannedKeyWords: [
        'http',
    ]
}

/***/ }),

/***/ 3207:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
    gameFun: (vkCore) => {
        let { game, ui, get, ai, lib, _status } = vkCore
        /**
         * dist 路径
         */
        const dist = () => lib.assetURL + 'dist'
        return {
            /**
             * 资源封装_事件相关_向弹窗中添加一名角色区域内满足要求的牌
             * @param {!object} Evt 弹窗所在的事件对象，必须要有dialog属性
             * @param {!Player} target 获取牌的目标角色
             * @param {boolean} [directh] 当添加的牌均为不可见（'blank'）的手牌时，directh为true
             * @param {?string} [type] 获取牌的条件，可能为'canBeDiscarded' | 'canBeGained'
             * @param {?function} [callback] 添加动作完成后执行的回调函数
             */
            showPlayerCard: function (Evt, target, directh, type, callback) {
                if (!Evt.dialog) return;
                let player = Evt.player || _status.event.player, position = Evt.position || 'h';
                for (let i = 0; i < Evt.position.length; i++) {
                    if (Evt.position[i] == 'h') {
                        let ms = target.getCards('h', function (card) {
                            if (type && !lib.filter[type](card, player, target)) return false;
                            if (target.isUnderControl(true)) return true;
                            if (card.hasGaintag('an_')) return false;
                            if (Evt.visible || player.hasSkillTag('viewHandcard', null, target, true)) {
                                return true;
                            }
                            return card.hasGaintag('ming_');
                        });
                        if (ms.length > 0) {
                            Evt.dialog.addText('明置区');
                            ms.randomSort();
                            Evt.dialog.add(ms);
                            directh = false;
                        }
                        let ans = target.getCards('h', function (card) {
                            if (type && !lib.filter[type](card, player, target)) return false;
                            if (ms.contains(card)) return false;
                            return true;
                        });
                        if (ans.length > 0) {
                            Evt.dialog.addText((ms.length ? '暗置区' : '手牌区'));
                            ans.randomSort();
                            Evt.dialog.add([ans, 'blank']);
                        }
                    }
                    else if (Evt.position[i] == 'e') {
                        let es = target.getCards('e', function (card) {
                            if (type && !lib.filter[type](card, player, target)) return false;
                            return true;
                        });
                        if (es.length) {
                            Evt.dialog.addText('装备区');
                            Evt.dialog.add(es);
                            directh = false;
                        }
                    }
                    else if (Evt.position[i] == 'j') {
                        let js = target.getCards('j', function (card) {
                            if (type && !lib.filter[type](card, player, target)) return false;
                            return true;
                        });
                        if (js.length) {
                            Evt.dialog.addText('判定区');
                            Evt.dialog.add(js);
                            directh = false;
                        }
                    }
                }
                callback && callback(Evt);
                return directh;
            },
            loseAsync: function (arg) {
                let next = game.createEvent('loseAsync');
                next.getl = function (player) {
                    var that = this;
                    var map = {
                        player: player,
                        hs: [],
                        es: [],
                        js: [],
                        ss: [],
                        cards: [],
                        cards2: [],
                    };
                    player.getHistory('lose', function (evt) {
                        if (evt.parent == that) {
                            map.hs.addArray(evt.hs);
                            map.es.addArray(evt.es);
                            map.js.addArray(evt.js);
                            map.ss.addArray(evt.ss);
                            map.cards.addArray(evt.cards);
                            map.cards2.addArray(evt.cards2);
                        }
                    });
                    if (map.cards.length > 0 || map.ss.length > 0) return map;
                };
                if (arg && get.is.object(arg)) {
                    for (var i in arg) next[i] = arg[i];
                }
                return next;
            },
            //获取（角色名）的评级
            getRarity: function (name) {
                var rank = lib.rank.rarity;
                if (rank.beginner.contains(name)) return 'beginner';
                if (rank.legend.contains(name)) return 'legend';
                if (rank.epic.contains(name)) return 'epic';
                if (rank.rare.contains(name)) return 'rare';
                if (get.mode() != 'chess' && rank.junk.contains(name)) return 'junk';
                return 'common';
            },
            getGlobalHistory: function (key, filter) {
                if (!key) return _status.globalHistory[_status.globalHistory.length - 1];
                if (!filter) return _status.globalHistory[_status.globalHistory.length - 1][key];
                else {
                    var history = game.getGlobalHistory(key).slice(0);
                    for (var i = 0; i < history.length; i++) {
                        if (!filter(history[i])) history.splice(i--, 1);
                    }
                    return history;
                }
            },
            cardsDiscard: function (cards) {
                var type = get.itemtype(cards);
                if (type != 'cards' && type != 'card') return;
                let next = game.createEvent('cardsDiscard');
                next.cards = type == 'cards' ? cards.slice(0) : [cards];
                next.setContent('cardsDiscard');
                return next;
            },
            cardsGotoOrdering: function (cards) {
                var type = get.itemtype(cards);
                if (type != 'cards' && type != 'card') return;
                let next = game.createEvent('cardsGotoOrdering');
                next.cards = type == 'cards' ? cards.slice(0) : [cards];
                next.setContent('cardsGotoOrdering');
                return next;
            },
            cardsGotoSpecial: function (cards, bool) {
                var type = get.itemtype(cards);
                if (type != 'cards' && type != 'card') return;
                let next = game.createEvent('cardsGotoSpecial');
                next.cards = type == 'cards' ? cards.slice(0) : [cards];
                if (bool === false) next.notrigger = true;
                next.setContent('cardsGotoSpecial');
                return next;
            },
            online: false,
            onlineID: null,
            onlineKey: null,
            showHistory: function (pause) {
                if (lib.config.show_history == 'left') {
                    ui.window.classList.add('leftbar');
                }
                else if (lib.config.show_history == 'right') {
                    ui.window.classList.add('rightbar');
                }
                if (pause != false && ui.pause) {
                    ui.pause.show();
                }
            },
            createBackground: function (src, blur) {
                var current = document.body.querySelector('.background.upper');
                if (current) {
                    current.delete();
                }
                var node = ui.create.div('.background.blurbg', document.body);
                node.setBackgroundImage(src);
                node.style.backgroundSize = 'cover';
                if (blur) {
                    node.classList.add('paused')
                }
                return node;
            },
            changeLand: function (url, player) {
                game.addVideo('changeLand', player, url);
                if (url.indexOf('/') === -1) {
                    url = 'image/card/' + url;
                }
                if (url.indexOf('.png') == -1 && url.indexOf('.jpg') == -1) {
                    url += '.jpg';
                }
                var name = url.slice(url.lastIndexOf('/') + 1, url.lastIndexOf('.'));
                var skill = name + '_skill';
                var node = ui.create.div('.background.upper.land');
                node.setBackgroundImage(url);
                node.destroy = function () {
                    if (this.skill) {
                        game.removeGlobalSkill(this.skill);
                        if (this.system) {
                            this.system.remove();
                        }
                    }
                    this.classList.add('hidden');
                    var node = this;
                    setTimeout(function () {
                        node.remove();
                    }, 3000);
                    if (ui.land == this) {
                        ui.land = null;
                    }
                }
                if (ui.land) {
                    document.body.insertBefore(node, ui.land);
                    ui.land.destroy();
                }
                else {
                    node.classList.add('hidden');
                    document.body.insertBefore(node, ui.window);
                    ui.refresh(node);
                    node.classList.remove('hidden');
                }
                ui.land = node;
                if (name) {
                    node.name = name;
                    node.skill = skill;
                    if (player) {
                        node.player = player;
                        player.addTempSkill('land_used');
                    }
                    node.system = ui.create.system(lib.translate[skill], null, true, true);
                    lib.setPopped(node.system, function () {
                        var uiintro = ui.create.dialog('hidden');
                        var str = '地图';
                        if (player) {
                            str = '来源：' + get.translation(player);
                        }
                        var caption = uiintro.addText(str);
                        caption.style.margin = '0';
                        uiintro._place_text = uiintro.add('<div class="text">' + lib.translate[skill + '_info'] + '</div>');
                        uiintro.add(ui.create.div('.placeholder.slim'));
                        return uiintro;
                    }, 200);
                    game.addGlobalSkill(skill);
                }
            },
            checkFileList: function (updates, proceed) {
                var n = updates.length;
                if (!n) {
                    proceed(n);
                }
                for (var i = 0; i < updates.length; i++) {
                    if (lib.node && lib.node.fs) {
                        lib.node.fs.access(__dirname + '/' + updates[i], (function (entry) {
                            return function (err) {
                                if (!err) {
                                    var stat = lib.node.fs.statSync(__dirname + '/' + entry);
                                    if (stat.size == 0) {
                                        err = true;
                                    }
                                }
                                if (err) {
                                    n--;
                                    if (n == 0) {
                                        proceed();
                                    }
                                }
                                else {
                                    n--;
                                    updates.remove(entry);
                                    if (n == 0) {
                                        proceed();
                                    }
                                }
                            }
                        }(updates[i])));
                    }
                    else {
                        resolveLocalFileSystemURL(lib.assetURL + updates[i], (function (name) {
                            return function (entry) {
                                n--;
                                updates.remove(name);
                                if (n == 0) {
                                    proceed();
                                }
                            }
                        }(updates[i])), function () {
                            n--;
                            if (n == 0) {
                                proceed();
                            }
                        });
                    }
                }
            },
            replaceHandcards: function () {
                let next = game.createEvent('replaceHandcards');
                if (Array.isArray(arguments[0])) {
                    next.players = arguments[0];
                }
                else {
                    next.players = [];
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'player') {
                            next.players.push(arguments[i]);
                        }
                    }
                }
                if (_status.connectMode) {
                    next.setContent('replaceHandcardsOL');
                }
                else {
                    next.setContent('replaceHandcards');
                }
            },
            removeCard: function (name) {
                for (var i = 0; i < lib.card.list.length; i++) {
                    if (lib.card.list[i][2] == name) {
                        lib.card.list.splice(i--, 1);
                    }
                }
                var list = [];
                for (var i = 0; i < ui.cardPile.childElementCount; i++) {
                    if (ui.cardPile.childNodes[i].name == name) {
                        list.push(ui.cardPile.childNodes[i]);
                    }
                }
                for (var i = 0; i < list.length; i++) {
                    list[i].remove();
                }
            },
            randomMapOL: function (type) {
                if (type == 'hidden') {
                    ui.arena.classList.add('playerhidden');
                }
                game.prepareArena();
                if (window.isNonameServer) {
                    game.me = ui.create.player();
                }
                var list = [];
                for (var i = 0; i < game.players.length; i++) {
                    if (game.players[i] != game.me) {
                        list.push(game.players[i]);
                    }
                }
                var map = [];
                for (var i = 0; i < lib.node.clients.length; i++) {
                    if (!list.length) break;
                    if (lib.configOL.observe_race) var current = list.shift();
                    else var current = list.randomRemove();
                    current.ws = lib.node.clients[i];
                    current.playerid = current.ws.id;
                    current.nickname = current.ws.nickname;
                    current.setNickname();
                }
                if (!window.isNonameServer) {
                    game.me.playerid = get.id();
                    game.me.nickname = get.connectNickname();
                    game.me.setNickname();
                }
                for (var i = 0; i < game.players.length; i++) {
                    if (!game.players[i].playerid) {
                        game.players[i].playerid = get.id();
                    }
                    map.push([game.players[i].playerid, game.players[i].nickname]);
                    lib.playerOL[game.players[i].playerid] = game.players[i];
                }
                game.broadcast(function (map, config, hidden) {
                    if (hidden) {
                        ui.arena.classList.add('playerhidden');
                    }
                    lib.configOL = config;
                    ui.create.players();
                    ui.create.me();
                    game.me.playerid = game.onlineID;
                    game.me.nickname = get.connectNickname();
                    for (var i = 0; i < map.length; i++) {
                        if (map[i][0] == game.me.playerid) {
                            map = map.concat(map.splice(0, i));
                            break;
                        }
                    }
                    for (var i = 0; i < game.players.length; i++) {
                        game.players[i].playerid = map[i][0];
                        game.players[i].nickname = map[i][1];
                        game.players[i].setNickname();
                        lib.playerOL[game.players[i].playerid] = game.players[i];
                    }
                    _status.mode = lib.configOL[lib.configOL.mode + '_mode'];
                }, map, lib.configOL, type == 'hidden');
                _status.mode = lib.configOL[lib.configOL.mode + '_mode'];
                game.chooseCharacterOL();
            },
            closeMenu: function () {
                if (ui.menuContainer && !ui.menuContainer.classList.contains('hidden')) {
                    ui.click.configMenu();
                }
            },
            closeConnectMenu: function () {
                if (ui.connectMenuContainer && !ui.connectMenuContainer.classList.contains('hidden')) {
                    ui.click.connectMenu();
                }
            },
            closePopped: function () {
                if (ui.currentpopped) {
                    if (ui.currentpopped._uiintro) {
                        ui.currentpopped._uiintro.delete();
                        delete ui.currentpopped._uiintro;
                    }
                    delete ui.currentpopped;
                }
            },
            broadcast: function () {
                if (!lib.node || !lib.node.clients || game.online) return;
                for (var i = 0; i < lib.node.clients.length; i++) {
                    if (lib.node.clients[i].inited) {
                        lib.node.clients[i].send.apply(lib.node.clients[i], arguments);
                    }
                }
            },
            broadcastAll: function () {
                if (game.online) return;
                var argc = arguments.length;
                var args = new Array(argc);
                for (var i = 0; i < argc; i++) {
                    args[i] = arguments[i];
                }
                game.broadcast.apply(this, args);
                var func = args.shift();
                if (typeof func == 'string') {
                    func = lib.message.client[func];
                }
                if (typeof func == 'function') {
                    func.apply(this, args);
                }
            },
            syncState: function () {
                var state = null;
                if (game.getState) {
                    state = game.getState();
                }
                game.broadcast(function (state, current, number) {
                    if (game.updateState && state) game.updateState(state);
                    _status.currentPhase = current;
                    game.phaseNumber = number;
                }, state, _status.currentPhase, game.phaseNumber);
            },
            updateWaiting: function () {
                var map = [];
                for (var i = 0; i < game.connectPlayers.length; i++) {
                    var player = game.connectPlayers[i];
                    if (player.playerid) {
                        if (!game.onlinezhu) {
                            game.onlinezhu = player.playerid;
                            game.send('server', 'changeAvatar', player.nickname, player.avatar);
                            _status.onlinenickname = player.nickname;
                            _status.onlineavatar = player.avatar;
                        }
                        map[i] = [player.nickname, player.avatar, player.playerid];
                        if (player.playerid == game.onlinezhu) {
                            map[i].push('zhu');
                        }
                    }
                    else if (player.classList.contains('unselectable2')) {
                        map[i] = 'disabled';
                    }
                    else {
                        map[i] = null;
                    }
                }
                game.broadcast('updateWaiting', map);
            },
            createServer: function () {
                lib.node.clients = [];
                lib.node.banned = [];
                lib.node.observing = [];
                lib.node.torespond = {};
                lib.node.torespondtimeout = {};
                lib.playerOL = {};
                lib.cardOL = {};
                lib.wsOL = {};
                ui.create.roomInfo();
                ui.create.chat();

                if (game.onlineroom) {

                }
                else {
                    var WebSocketServer = (__webpack_require__(9398).Server);
                    var wss = new WebSocketServer({ port: 8080 });

                    game.ip = get.ip();

                    wss.on('connection', lib.init.connection);
                }
            },
            playAudio: function () {
                if (_status.video && arguments[1] != 'video') return;
                var str = '';
                var onerror = null;
                for (var i = 0; i < arguments.length; i++) {
                    if (typeof arguments[i] === 'string' || typeof arguments[i] == 'number') {
                        str += '/' + arguments[i];
                    }
                    else if (typeof arguments[i] == 'function') {
                        onerror = arguments[i]
                    }
                    if (_status.video) break;
                }
                if (!lib.config.repeat_audio && _status.skillaudio.contains(str)) return;
                _status.skillaudio.add(str);
                game.addVideo('playAudio', null, str);
                setTimeout(function () {
                    _status.skillaudio.remove(str);
                }, 1000);
                var audio = document.createElement('audio');
                audio.autoplay = true;
                audio.volume = lib.config.volumn_audio / 8;
                if (str.indexOf('.mp3') != -1 || str.indexOf('.ogg') != -1) {
                    audio.src = lib.assetURL + 'audio' + str;
                }
                else {
                    audio.src = lib.assetURL + 'audio' + str + '.mp3';
                }
                audio.addEventListener('ended', function () {
                    this.remove();
                });
                audio.onerror = function () {
                    if (this._changed) {
                        this.remove();
                        if (onerror) {
                            onerror();
                        }
                    }
                    else {
                        this.src = lib.assetURL + 'audio' + str + '.ogg';
                        this._changed = true;
                    }
                };
                ui.window.appendChild(audio);
                return audio;
            },
            trySkillAudio: function (skill, player, directaudio) {
                game.broadcast(game.trySkillAudio, skill, player, directaudio);
                var info = get.info(skill);
                if (!info) return;
                if ((!info.direct || directaudio) && lib.config.background_speak &&
                    (!lib.skill.global.contains(skill) || lib.skill[skill].forceaudio)) {
                    var audioname = skill;
                    if (info.audioname2 && info.audioname2[player.name]) {
                        audioname = info.audioname2[player.name];
                        info = lib.skill[audioname];
                    }
                    var audioinfo = info.audio;
                    if (typeof audioinfo == 'string' && lib.skill[audioinfo]) {
                        audioname = audioinfo;
                        audioinfo = lib.skill[audioname].audio;
                    }
                    if (typeof audioinfo == 'string') {
                        if (audioinfo.indexOf('ext:') == 0) {
                            audioinfo = audioinfo.split(':');
                            if (audioinfo.length == 3) {
                                if (audioinfo[2] == 'true') {
                                    game.playAudio('..', 'extension', audioinfo[1], audioname);
                                }
                                else {
                                    audioinfo[2] = parseInt(audioinfo[2]);
                                    if (audioinfo[2]) {
                                        game.playAudio('..', 'extension', audioinfo[1], audioname + Math.ceil(audioinfo[2] * Math.random()));
                                    }
                                }
                            }
                            return;
                        }
                    }
                    else if (Array.isArray(audioinfo)) {
                        audioname = audioinfo[0];
                        audioinfo = audioinfo[1];
                    }
                    if (Array.isArray(info.audioname) && player) {
                        if (info.audioname.contains(player.name)) {
                            audioname += '_' + player.name;
                        }
                        else if (info.audioname.contains(player.name1)) {
                            audioname += '_' + player.name1;
                        }
                        else if (info.audioname.contains(player.name2)) {
                            audioname += '_' + player.name2;
                        }
                    }
                    if (typeof audioinfo == 'number') {
                        console.log(audioname)
                        game.playAudio('skill', audioname + Math.ceil(audioinfo * Math.random()));
                    }
                    else if (audioinfo) {
                        game.playAudio('skill', audioname);
                    }
                    else if ( true && info.audio !== false) {
                        game.playSkillAudio(audioname);
                    }
                }
            },
            playSkillAudio: function (name, index) {
                if (_status.video && arguments[1] != 'video') return;
                if (!lib.config.repeat_audio && _status.skillaudio.contains(name)) return;
                game.addVideo('playSkillAudio', null, name);
                if (name.indexOf('|') < name.lastIndexOf('|')) {
                    name = name.slice(name.lastIndexOf('|') + 1);
                }
                _status.skillaudio.add(name);
                setTimeout(function () {
                    _status.skillaudio.remove(name);
                }, 1000);
                var str = 'audio/skill/';
                var audio = document.createElement('audio');
                audio.autoplay = true;
                audio.volume = lib.config.volumn_audio / 8;
                audio.src = lib.assetURL + str + name + '.mp3';
                audio.addEventListener('ended', function () {
                    this.remove();
                });
                if (typeof index != 'number') {
                    index = Math.ceil(Math.random() * 2);
                }
                audio._changed = 1;
                audio.onerror = function () {
                    switch (this._changed) {
                        case 1: {
                            audio.src = lib.assetURL + str + name + '.ogg';
                            this._changed = 2;
                            break;
                        }
                        case 2: {
                            audio.src = lib.assetURL + str + name + index + '.mp3';
                            this._changed = 3;
                            break;
                        }
                        case 3: {
                            audio.src = lib.assetURL + str + name + index + '.ogg';
                            this._changed = 4;
                            break;
                        }
                        default: {
                            this.remove();
                        }
                    }
                };
                ui.window.appendChild(audio);
            },
            playBackgroundMusic: function () {
                if (lib.config.background_music == 'music_off') {
                    ui.backgroundMusic.src = '';
                }
                else if (_status._aozhan == true && lib.config.mode_config.guozhan.aozhan_bgm != 'disabled') {
                    var aozhan = lib.config.mode_config.guozhan.aozhan_bgm;
                    ui.backgroundMusic.src = lib.assetURL + 'audio/background/aozhan_' + aozhan + '.mp3';
                }
                else {
                    var music = lib.config.background_music;
                    if (music == 'music_random') {
                        music = lib.config.all.background_music.randomGet('music_off', 'music_random', _status.currentMusic);
                    }
                    _status.currentMusic = music;
                    if (music == 'music_custom') {
                        if (lib.config.background_music_src) {
                            ui.backgroundMusic.src = lib.config.background_music_src;
                        }
                    }
                    else {
                        ui.backgroundMusic.src = lib.assetURL + 'audio/background/' + music + '.mp3';
                    }
                }
            },
            /**
             * 导入包(卡牌|角色|拓展)
             * @param {!string} type 类型
             * @param {!function} content 载入内容的回调函数
             */
            import: function (type, content) {
                if (type == 'extension') {
                    game.loadExtension(content);
                }
                else {
                    if (!lib.imported[type]) {
                        lib.imported[type] = {};
                    }
                    var content2 = content(lib, game, ui, get, ai, _status);
                    if (content2.name) {
                        lib.imported[type][content2.name] = content2;
                        delete content2.name;
                    }
                }
            },
            loadExtension: function (obj) {
                var noeval = false;
                if (typeof obj == 'function') {
                    obj = obj(lib, game, ui, get, ai, _status);
                    noeval = true;
                }
                {
                    // function changeStep(content) {
                    //     if (content instanceof Function) {
                    //         let v = new Function('return ' + content.toString())()
                    //         content = [];
                    //         let str = v.toString();
                    //         str = str.slice(str.indexOf('{') + 1);
                    //         if (str.indexOf('step 0') == -1) {
                    //             content[0] = new Function(str)
                    //         }
                    //         else {
                    //             let keys = str.split('step ')
                    //             for (let k = 0; k < keys.length; k++) {
                    //                 content[k] = new Function(keys[k].slice(1))
                    //             }
                    //         }
                    //     }
                    // }
                    // for (let i in obj.skill) {
                    //     changeStep(obj.skill[i].content)
                    //     changeStep(obj.skill[i].callback)
                    //     changeStep(obj.skill[i].precontent)
                    // }
                    // for (let i in obj.card) {
                    //     changeStep(obj.skill[i].content)
                    // }
                }
                lib.extensionMenu['extension_' + obj.name] = {
                    enable: {
                        name: '开启',
                        init: true
                    }
                };
                if (obj.package && obj.package.author) {
                    lib.extensionMenu['extension_' + obj.name].author = {
                        name: '作者：' + obj.package.author,
                        clear: true,
                        nopointer: true,
                    }
                }
                if (obj.package && obj.package.intro) {
                    lib.extensionMenu['extension_' + obj.name].intro = {
                        name: obj.package.intro,
                        clear: true,
                        nopointer: true,
                    }
                }
                for (var i in obj.config) {
                    lib.extensionMenu['extension_' + obj.name][i] = obj.config[i];
                }
                for (var i in obj.help) {
                    lib.help[i] = obj.help[i];
                }
                if (obj.editable !== false) {
                    lib.extensionMenu['extension_' + obj.name].edit = {
                        name: '编辑此扩展',
                        clear: true,
                        onclick: function () {
                            if (game.editExtension && lib.extensionPack && lib.extensionPack[obj.name]) {
                                game.editExtension(obj.name);
                            }
                            else {
                                alert('无法编辑未启用的扩展，请启用此扩展并重启后重试')
                            }
                        }
                    }
                }
                lib.extensionMenu['extension_' + obj.name].delete = {
                    name: '删除此扩展',
                    clear: true,
                    onclick: function () {
                        if (this.innerHTML == '<span>确认删除</span>') {
                            var prefix = 'extension_' + obj.name;
                            var page = this.parentNode;
                            var start = page.parentNode.previousSibling;
                            page.remove();
                            if (start) {
                                for (var i = 0; i < start.childElementCount; i++) {
                                    if (start.childNodes[i].link == page) {
                                        var active = false;
                                        if (start.childNodes[i].classList.contains('active')) {
                                            active = true;
                                        }
                                        start.childNodes[i].remove();
                                        if (active) {
                                            start.firstChild.classList.add('active');
                                            start.nextSibling.appendChild(start.firstChild.link);
                                        }
                                        break;
                                    }
                                }
                            }
                            game.removeExtension(obj.name);
                            if (obj.onremove) {
                                obj.onremove();
                            }
                        }
                        else {
                            this.innerHTML = '<span>确认删除</span>';
                            var that = this;
                            setTimeout(function () {
                                that.innerHTML = '<span>删除此扩展</span>';
                            }, 1000);
                        }
                    }
                }

                if (!_status.importingExtension) {
                    if (obj && lib.config['extension_' + obj.name + '_enable']) {
                        if (!noeval) lib.init.eval(obj);
                        var cfg = {};
                        for (var j in lib.config) {
                            if (j.indexOf('extension_' + obj.name) == 0 &&
                                j != 'extension_' + obj.name) {
                                cfg[j.slice(11 + obj.name.length)] = lib.config[j];
                            }
                        }
                        try {
                            if (obj.package) {
                                lib.extensionPack[obj.name] = obj.package;
                                lib.extensionPack[obj.name].files = obj.files || {};
                                if (!lib.extensionPack[obj.name].files.character) {
                                    lib.extensionPack[obj.name].files.character = [];
                                }
                                if (!lib.extensionPack[obj.name].files.card) {
                                    lib.extensionPack[obj.name].files.card = [];
                                }
                                if (!lib.extensionPack[obj.name].files.skill) {
                                    lib.extensionPack[obj.name].files.skill = [];
                                }
                            }
                            else {
                                lib.extensionPack[obj.name] = {};
                            }
                            lib.extensionPack[obj.name].code = {
                                content: obj.content,
                                precontent: obj.precontent,
                                help: obj.help,
                                config: obj.config
                            }
                            if (obj.precontent) {
                                _status.extension = obj.name;
                                obj.precontent(cfg);
                                delete _status.extension;
                            }
                            if (obj.content) {
                                lib.extensions.push([obj.name, obj.content, cfg, _status.evaluatingExtension, obj.package || {}]);
                            }
                        }
                        catch (e) {
                            console.log(e);
                        }
                    }
                }
                else {
                    game.importedPack = obj;
                }
            },
            createDir: function (dir, success, error) {
                var nullFC = function () { };
                success = success || nullFC;
                error = error || nullFC;
                dir = dir.split("/");
                if (window.resolveLocalFileSystemURL) {
                    window.resolveLocalFileSystemURL(lib.assetURL, function (entry) {
                        (function redo(entry) {
                            var i = dir.shift();
                            entry.getDirectory(i, { create: true }, function (dirEntry) {
                                if (dir.length) redo(dirEntry);
                                else success();
                            });
                        })(entry);
                    }, error);
                }
                else {
                    var fs = __webpack_require__(7147);
                    var str = __dirname;
                    (function redo() {
                        str += "/";
                        str += dir.shift();
                        fs.access(str, function (err) {
                            if (!err) {
                                //已存在此目录
                                if (dir.length) redo();
                                else success();
                            }
                            else {
                                fs.mkdir(str, function () {
                                    if (dir.length) redo();
                                    else success();
                                });
                            }
                        });
                    })();
                }
            },
            importExtension: function (data, finishLoad, exportext, pkg) {
                if (!window.JSZip) {
                    lib.init.js(lib.assetURL + 'game', 'jszip', function () {
                        game.importExtension(data, finishLoad, exportext, pkg);
                    });
                }
                else if (get.objtype(data) == 'object') {
                    //导出
                    var zip = new JSZip();
                    var filelist = [];
                    var filelist2 = [];
                    if (data._filelist) {
                        filelist2 = data._filelist;
                        delete data._filelist;
                    }
                    for (var i in data) {
                        zip.file(i, data[i]);
                        filelist.push(i);
                    }
                    if (exportext) {
                        if (pkg) {
                            filelist.remove('extension.js');
                            pkg.files = filelist.slice(0);
                            pkg.files.addArray(filelist2);
                            pkg.size = zip.generate({ type: "arraybuffer" }).byteLength;
                            if (pkg.size < 1000) {
                                pkg.size = pkg.size + 'B';
                            }
                            else if (pkg.size < 1000000) {
                                pkg.size = Math.round(pkg.size / 1000) + 'KB';
                            }
                            else {
                                pkg.size = Math.round(pkg.size / 100000) / 10 + 'MB';
                            }
                            var pkgstr = 'extension["' + exportext + '"]={\n';
                            for (var i in pkg) {
                                var pkgfrag;
                                if (i == 'files') {
                                    var pkgjs = JSON.stringify(pkg[i]);
                                    var pkgfrag = '';
                                    var pkgbuffer = 0;
                                    for (var j = 0; j < pkgjs.length; j++) {
                                        pkgfrag += pkgjs[j];
                                        pkgbuffer++;
                                        if (pkgbuffer >= 80 && pkgjs[j] == ',' && pkgjs[j - 1] == '"') {
                                            pkgfrag += '\n\t\t';
                                            pkgbuffer = 0;
                                        }
                                    }
                                }
                                else {
                                    pkgfrag = JSON.stringify(pkg[i]);
                                }
                                pkgstr += '\t' + i + ':' + pkgfrag + ',\n'
                            }
                            pkgstr = pkgstr.slice(0, pkgstr.length - 2);
                            pkgstr += '\n};';
                            zip.file('package.js', pkgstr);
                        }
                        var blob = zip.generate({ type: "blob" });
                        var fileNameToSaveAs = exportext;
                        fileNameToSaveAs = fileNameToSaveAs.replace(/\\|\/|\:|\?|\"|\*|<|>|\|/g, '.');
                        fileNameToSaveAs += '.zip';

                        if (lib.device) {
                            var directory;
                            if (lib.device == 'android') {
                                directory = cordova.file.externalDataDirectory;
                            }
                            else {
                                directory = cordova.file.documentsDirectory;
                            }
                            window.resolveLocalFileSystemURL(directory, function (entry) {
                                entry.getFile(fileNameToSaveAs, { create: true }, function (fileEntry) {
                                    fileEntry.createWriter(function (fileWriter) {
                                        fileWriter.onwriteend = function () {
                                            alert('文件已导出至' + directory + fileNameToSaveAs);
                                        }
                                        fileWriter.write(blob)
                                    });
                                });
                            });
                        }
                        else {
                            var downloadLink = document.createElement("a");
                            downloadLink.download = fileNameToSaveAs;
                            downloadLink.innerHTML = "Download File";
                            downloadLink.href = window.URL.createObjectURL(blob);
                            downloadLink.click();
                        }

                        if (typeof finishLoad == 'function') {
                            finishLoad();
                        }
                    }
                    else {
                        game.importExtension.apply(this, [zip.generate({ type: 'arraybuffer' }), finishLoad]);
                    }
                }
                else {
                    //导入
                    function UHP() {
                        alert("导入失败");
                    };
                    var zip = new JSZip();
                    try {
                        zip.loadAsync(data).then(zip => {
                            zip.file('extension.js').async("string").then(str => {
                                _status.importingExtension = true;
                                eval(str)
                                _status.importingExtension = false;
                                if (!game.importedPack) throw ('err');
                                let extname = game.importedPack.name;
                                if (lib.config.all.plays.contains(extname)) {
                                    throw ('禁止安装游戏原生扩展');
                                }
                                if (lib.config.extensions.contains(extname)) {
                                    game.removeExtension(extname, true);
                                }
                                lib.config.extensions.add(extname);
                                game.saveConfig('extensions', lib.config.extensions);
                                game.saveConfig('extension_' + extname + '_enable', true);
                                for (let i in game.importedPack.config) {
                                    if (game.importedPack.config[i] && game.importedPack.config[i].hasOwnProperty('init')) {
                                        game.saveConfig('extension_' + extname + '_' + i, game.importedPack.config[i].init);
                                    }
                                }
                                if (game.download) {
                                    let filelist = [];
                                    for (let i in zip.files) {
                                        //alert(zip.files[i].dir+i)
                                        if (!zip.files[i].dir && i[0] != '.' && i[0] != '_') {
                                            filelist.push(i);
                                        }
                                    }
                                    //alert(filelist)
                                    if (lib.node && lib.node.fs) {
                                        //电脑端
                                        //具备nodeJS环境
                                        game.ensureDirectory('extension/' + extname, function () {
                                            let writeFile = function (e) {
                                                if (e) {
                                                    finishLoad();
                                                    UHP();
                                                    return;
                                                }
                                                if (filelist.length) {
                                                    let filename = filelist.shift();
                                                    //filename 数组 ...dir+/+file
                                                    let zipdir = filename;
                                                    filename = filename.split("/");
                                                    let name = filename.pop();
                                                    if (filename.length) game.createDir(`extension/${extname}/${filename.join("/")}`, function () {
                                                        //这里需要个创文件夹的函数
                                                        Letgo(`${filename.join("/")}/${name}`);
                                                    }, UHP);
                                                    else Letgo(name);
                                                    function Letgo(name) {
                                                        zip.file(zipdir).async('nodebuffer').then(str => {
                                                            lib.node.fs.writeFile(`${__dirname}/extension/${extname}/${name}`, str, null, writeFile);
                                                        })
                                                    }
                                                }
                                                else {
                                                    finishLoad();
                                                }
                                            }
                                            writeFile();
                                        });
                                    }
                                    else {
                                        window.resolveLocalFileSystemURL(lib.assetURL, function (entry) {
                                            entry.getDirectory('extension/' + extname, { create: true }, function (dirEntry) {
                                                //扩展文件夹
                                                writeFile();
                                                function writeFile() {
                                                    if (filelist.length) {
                                                        let filename = filelist.shift();
                                                        //filename 数组 ...dir+/+file
                                                        let zipdir = filename;
                                                        filename = filename.split("/");
                                                        let name = filename.pop();
                                                        if (filename.length) game.createDir(`extension/${extname}/${filename.join("/")}`, function () {
                                                            Letgo(`${filename.join("/")}/${name}`);
                                                        }, UHP);
                                                        else Letgo(name);
                                                        function Letgo(name) {
                                                            dirEntry.getFile(name, { create: true }, function (fileEntry) {
                                                                fileEntry.createWriter(function (fileWriter) {
                                                                    fileWriter.onwriteend = writeFile;
                                                                    zip.file(zipdir).async("arraybuffer").then(str => {
                                                                        fileWriter.write(str);
                                                                    })
                                                                });
                                                            }, UHP);
                                                        }
                                                    }
                                                    else {
                                                        finishLoad();
                                                    }
                                                };

                                            });
                                        });
                                    }
                                }
                                else {
                                    localStorage.setItem(`${lib.configprefix}extension_${extname}`, str);
                                    let imglist = [];
                                    for (let i in zip.files) {
                                        if (i[0] != '.' && i[0] != '_') {
                                            if (i.indexOf('.jpg') != -1 || i.indexOf('.png') != -1) {
                                                imglist.push(i);
                                            }
                                        }
                                    }
                                    if (imglist.length && lib.db) {
                                        lib.config.extensionInfo[extname] = {
                                            image: imglist
                                        }
                                        game.saveConfig('extensionInfo', lib.config.extensionInfo);
                                        for (let i = 0; i < imglist.length; i++) {
                                            let imgname = imglist[i];
                                            zip.file(imgname).async("arraybuffer").then(str => {
                                                let blob = new Blob([str]);
                                                let fileReader = new FileReader();
                                                console.log(imgname, str, blob)
                                                fileReader.onload = (function (imgname) {
                                                    return function (fileLoadedEvent) {
                                                        let data = fileLoadedEvent.target.result;
                                                        game.putDB('image', `extension-${extname}:${imgname}`, data);
                                                    };
                                                }(imgname))
                                                fileReader.readAsDataURL(blob);
                                            });
                                        }
                                    }
                                    finishLoad();
                                }
                                delete game.importedPack;
                            }).catch(reason => {
                                if (!str) throw (`你导入的不是扩展！请选择正确的文件:\n ${reason}`);
                            })
                        })
                    }
                    catch (e) {
                        console.log(e);
                        alert('导入失败');
                        return false;
                    }
                }
            },
            export: function (textToWrite, name) {
                let textFileAsBlob = new Blob([textToWrite], { type: 'text/plain' });
                let fileNameToSaveAs = name || 'noname';
                fileNameToSaveAs = fileNameToSaveAs.replace(/\\|\/|\:|\?|\"|\*|<|>|\|/g, '.');

                if (lib.device) {
                    let directory;
                    if (lib.device == 'android') {
                        directory = cordova.file.externalDataDirectory;
                    }
                    else {
                        directory = cordova.file.documentsDirectory;
                    }
                    window.resolveLocalFileSystemURL(directory, function (entry) {
                        entry.getFile(fileNameToSaveAs, { create: true }, function (fileEntry) {
                            fileEntry.createWriter(function (fileWriter) {
                                fileWriter.onwriteend = function () {
                                    alert('文件已导出至' + directory + fileNameToSaveAs);
                                }
                                fileWriter.write(textFileAsBlob)
                            });
                        });
                    });
                }
                else {
                    let downloadLink = document.createElement("a");
                    downloadLink.download = fileNameToSaveAs;
                    downloadLink.innerHTML = "Download File";
                    downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
                    downloadLink.click();
                }
            },
            multiDownload2: function (list, onsuccess, onerror, onfinish, process, dev) {
                list = list.slice(0);
                let download = function () {
                    if (list.length) {
                        let current = list.shift();
                        let current2;
                        if (typeof process == 'function') {
                            current2 = process(current);
                        }
                        else {
                            current2 = current;
                        }
                        if (current.indexOf('theme') == 0) {
                            game.print(current.slice(6));
                        }
                        else if (current.indexOf('image/skin') == 0) {
                            game.print(current.slice(11));
                        }
                        else {
                            game.print(current.slice(current.lastIndexOf('/') + 1));
                        }
                        game.download(current, current2, function () {
                            if (onsuccess) onsuccess(list.length);
                            download();
                        }, function () {
                            if (onerror) onerror(list.length);
                            download();
                        }, dev);
                    }
                    else {
                        if (onfinish) onfinish();
                    }
                }
                download();
            },
            multiDownload: function (list, onsuccess, onerror, onfinish, process, dev) {
                if (lib.config.dev) game.print(get.url());
                var args = Array.from(arguments);
                if (list.length <= 3) {
                    game.multiDownload2.apply(this, args);
                }
                else {
                    var num = Math.round(list.length / 3);
                    var left = 3;
                    args[3] = function () {
                        left--;
                        if (left == 0) {
                            onfinish();
                        }
                    };
                    setTimeout(function () {
                        args[0] = list.slice(0, num); game.multiDownload2.apply(game, args);
                    });
                    setTimeout(function () {
                        args[0] = list.slice(num, 2 * num); game.multiDownload2.apply(this, args);
                    }, 200);
                    setTimeout(function () {
                        args[0] = list.slice(2 * num); game.multiDownload2.apply(this, args);
                    }, 400);
                }
            },
            fetch: function (url, onload, onerror, onprogress) {
                var tmpName = '~tmp' + get.id();
                game.download(encodeURI(url), tmpName, function () {
                    game.readFile(tmpName, function (data) {
                        onload(data);
                        game.removeFile(tmpName);
                    }, onerror);
                }, onerror, null, onprogress);
            },
            playVideo: function (time, mode) {
                if (!_status.replayvideo) {
                    localStorage.setItem(lib.configprefix + 'playbackmode', lib.config.mode);
                }
                game.saveConfig('mode', mode);
                localStorage.setItem(lib.configprefix + 'playback', time);
                game.reload();
            },
            playVideoContent: function (video) {
                let next = game.createEvent('video', false);
                next.video = video;
                ui.system.style.display = 'none';
                ui.system.hide();
                ui.arena.style.display = 'none';
                ui.arena.hide();
                ui.window.classList.remove('leftbar');
                ui.window.classList.remove('rightbar');
                ui.historybar.style.display = 'none';
                _status.event = next;
                _status.paused = false;
                _status.paused2 = false;
                _status.over = false;
                _status.video = true;
                clearTimeout(_status.timeout);

                for (var i in lib.characterPack) {
                    for (var j in lib.characterPack[i]) {
                        lib.character[j] = lib.character[j] || lib.characterPack[i][j];
                    }
                }
                next.setContent('playVideoContent');
                game.loop();
            },
            /**
             * 一些函数的回放实现(录像功能)
             * @type {!Object}
             */
            videoContent: {
                arrangeLib: function (content) {
                    for (var i in content) {
                        for (var j in content[i]) {
                            lib[i][j] = content[i][j];
                        }
                    }
                },
                jiuNode: function (player, bool) {
                    //Powered by 升麻
                    if (bool) {
                        if (!player.node.jiu && lib.config.jiu_effect) {
                            player.node.jiu = ui.create.div('.playerjiu', player.node.avatar);
                            player.node.jiu2 = ui.create.div('.playerjiu', player.node.avatar2);
                        }
                    }
                    else {
                        if (player.node.jiu) {
                            player.node.jiu.delete();
                            player.node.jiu2.delete();
                            delete player.node.jiu;
                            delete player.node.jiu2;
                        }
                    }
                },
                init: function (players) {
                    if (game.chess) return;
                    if (lib.config.mode == 'versus') {
                        players.bool = players.pop();
                    }
                    ui.arena.setNumber(players.length);
                    ui.arena.classList.add('video');
                    game.players.length = 0;
                    game.dead.length = 0;
                    ui.create.players(players.length);
                    game.me = game.players[0];
                    ui.handcards1 = game.me.node.handcards1;
                    ui.handcards2 = game.me.node.handcards2;
                    ui.handcards1Container.appendChild(ui.handcards1);
                    ui.handcards2Container.appendChild(ui.handcards2);
                    if (lib.config.mode == 'versus') {
                        if (players.bool) {
                            ui.arena.setNumber(parseInt(ui.arena.dataset.number) + 1);
                            for (var i = 0; i < game.players.length; i++) {
                                game.players[i].dataset.position = parseInt(game.players[i].dataset.position) + 1;
                            }
                            game.singleHandcard = true;
                            ui.arena.classList.add('single-handcard');
                            ui.window.classList.add('single-handcard');
                            ui.fakeme = ui.create.div('.fakeme.avatar', ui.me);
                        }
                        ui.arena.style.display = '';
                        ui.refresh(ui.arena);
                        ui.arena.show();
                    }
                    else if (lib.config.mode == 'boss') {
                        if (!players.boss) {
                            game.singleHandcard = true;
                            ui.arena.classList.add('single-handcard');
                            ui.window.classList.add('single-handcard');
                            ui.fakeme = ui.create.div('.fakeme.avatar', ui.me);
                        }
                        ui.arena.setNumber(8);
                    }
                    ui.updatehl();
                    for (var i = 0; i < players.length; i++) {
                        if (lib.config.mode == 'identity') {
                            game.players[i].init(players[i].name, players[i].name2);
                            game.players[i].setIdentity(players[i].identity);
                        }
                        else if (lib.config.mode == 'doudizhu' || lib.config.mode == 'longlaoguan' || lib.config.mode == 'single') {
                            game.players[i].init(players[i].name, players[i].name2);
                            game.players[i].setIdentity(players[i].identity);
                        }
                        else if (lib.config.mode == 'stone') {
                            game.players[i].init(players[i].name, players[i].name2);
                            game.players[i].classList.add('noidentity');
                            game.players[i].updateActCount(null, players[i].count, 0);
                        }
                        else if (lib.config.mode == 'boss') {
                            game.players[i].init(players[i].name, players[i].name2);
                            game.players[i].setIdentity(players[i].identity);
                            game.players[i].dataset.position = players[i].position;
                            game.players[i].node.action.innerHTML = '行动';
                        }
                        else if (lib.config.mode == 'versus') {
                            game.players[i].init(players[i].name, players[i].name2);
                            game.players[i].node.identity.firstChild.innerHTML = players[i].identity;
                            game.players[i].node.identity.dataset.color = players[i].color;
                            game.players[i].node.action.innerHTML = '行动';
                        }
                        else if (lib.config.mode == 'guozhan') {
                            game.players[i].name = players[i].name;
                            game.players[i].name1 = players[i].name1;
                            game.players[i].name2 = players[i].name2;

                            game.players[i].sex = 'unknown';
                            game.players[i].identity = 'unknown';

                            lib.translate[game.players[i].name] = players[i].translate;
                            game.players[i].init(players[i].name1, players[i].name2);

                            game.players[i].classList.add('unseen_v');
                            game.players[i].classList.add('unseen2_v');
                            if (game.players[i] != game.me) {
                                game.players[i].node.identity.firstChild.innerHTML = '猜';
                                game.players[i].node.identity.dataset.color = 'unknown';
                            }
                            else {
                                game.players[i].setIdentity(game.players[i].group);
                            }
                        }
                    }
                    for (var i = 0; i < game.players.length; i++) {
                        game.playerMap[game.players[i].dataset.position] = game.players[i];
                    }

                    if (lib.config.mode == 'versus') {
                        if (players.bool) {
                            game.onSwapControl();
                        }
                    }
                    else if (lib.config.mode == 'boss') {
                        if (!players.boss) {
                            game.onSwapControl();
                        }
                        ui.arena.style.display = '';
                        ui.refresh(ui.arena);
                        ui.arena.show();
                        ui.updatehl();
                    }
                },
                newcard: function (content) {
                    if (content) {
                        lib.translate[content.name] = content.translate;
                        lib.translate[content.name + '_info'] = content.info;
                        lib.card[content.name] = {};
                        lib.card[content.name].cardimage = content.card
                        for (var i in lib.card[content.card]) {
                            lib.card[content.name][i] = lib.card[content.card][i];
                        }
                        if (content.legend) {
                            lib.card[content.name].legend = true;
                        }
                        else if (content.epic) {
                            lib.card[content.name].epic = true;
                        }
                        else if (content.unique) {
                            lib.card[content.name].unique = true;
                        }
                    }
                },
                changeLand: function (player, url) {
                    game.changeLand(url, player);
                },
                destroyLand: function () {
                    if (ui.land) {
                        ui.land.destroy();
                    }
                },
                playAudio: function (str) {
                    game.playAudio(str, 'video');
                },
                playSkillAudio: function (name) {
                    game.playSkillAudio(name, 'video');
                },
                phaseChange: function (player) {
                    if (player) {
                        var glowing = document.querySelector('.glow_phase');
                        if (glowing) {
                            glowing.classList.remove('glow_phase');
                        }
                        if (lib.config.glow_phase) {
                            player.classList.add('glow_phase');
                            // player.dataset.glow_phase=lib.config.glow_phase;
                        }
                    }
                    else {
                        console.log(player);
                    }
                },
                playerfocus: function (player, time) {
                    if (player && player.playerfocus) {
                        player.playerfocus(time);
                    }
                    else {
                        console.log(player);
                    }
                },
                playerfocus2: function () {
                    ui.arena.classList.add('playerfocus');
                    setTimeout(function () {
                        ui.arena.classList.remove('playerfocus');
                    }, 1500)
                },
                identityText: function (player, str) {
                    if (player && str) {
                        player.node.identity.firstChild.innerHTML = str;
                    }
                    else {
                        console.log(player);
                    }
                },
                identityColor: function (player, str) {
                    if (player && str) {
                        player.node.identity.dataset.color = str;
                    }
                    else {
                        console.log(player);
                    }
                },
                chessSwap: function (content) {
                    var me = game.playerMap[content[0]];
                    var player = game.playerMap[content[1]];
                    if (me) {
                        me.classList.remove('current_action');
                    }
                    if (player) {
                        player.classList.add('current_action');
                    }
                },
                chessgainmod: function (player, num) {
                    if (Array.isArray(num)) {
                        num = get.infoCards(num);
                    }
                    if (player && player.$gainmod) {
                        player.$gainmod(num);
                    }
                    else {
                        console.log(player);
                    }
                },
                moveTo: function (player, pos) {
                    if (player && player.moveTo && pos) {
                        player.moveTo(pos[0], pos[1]);
                    }
                    else {
                        console.log(player)
                    }
                },
                addObstacle: function (pos) {
                    if (pos) {
                        game.addObstacle(pos[0], pos[1]);
                    }
                },
                removeObstacle: function (pos) {
                    game.removeObstacle(pos);
                },
                moveObstacle: function (pos) {
                    if (pos) {
                        game.moveObstacle(pos[0], pos[1], pos[2]);
                    }
                },
                colorObstacle: function (pos) {
                    if (pos) {
                        game.colorObstacle(pos[0], pos[1]);
                    }
                },
                thrownhighlight1: function () {
                    ui.arena.classList.add('thrownhighlight');
                },
                thrownhighlight2: function () {
                    ui.arena.classList.remove('thrownhighlight');
                },
                chessFocus: function (player) {
                    if (player) {
                        player.chessFocus();
                    }
                    else {
                        console.log('chessFocus');
                    }
                },
                removeTreasure: function (pos) {
                    if (game.playerMap[pos]) {
                        game.playerMap[pos].delete();
                        delete game.playerMap[pos];
                    }
                    else {
                        console.log(pos);
                    }
                },
                initobs: function (obs) {
                    if (obs) {
                        for (var i = 0; i < obs.length; i++) {
                            game.addObstacle(obs[i]);
                        }
                    }
                    else {
                        console.log(obs);
                    }
                },
                stonePosition: function (content) {
                    var player = game.playerMap[content[0]];
                    if (player) {
                        delete game.playerMap[content[0]];
                        player.dataset.position = content[1];
                        game.playerMap[content[1]] = player;
                    }
                    else {
                        console.log(content);
                    }
                },
                bossSwap: function (player, name) {
                    if (player && name) {
                        player.delete();
                        var noboss = false;
                        if (name[0] == '_') {
                            name = name.slice(1);
                            noboss = true;
                        }
                        var boss = ui.create.player().init(name);
                        boss.dataset.position = player.dataset.position;
                        game.playerMap[player.dataset.position] = boss;
                        if (game.me == player) {
                            game.me = boss;
                        }
                        game.players.push(boss);
                        game.arrangePlayers();
                        if (!noboss) {
                            game.boss = boss;
                            boss.setIdentity('zhu');
                            boss.identity = 'zhu';
                        }
                        else {
                            boss.setIdentity('zhong');
                            boss.identity = 'zhong';
                        }
                        ui.arena.appendChild(boss.animate('zoominanim'));
                    }
                },
                stoneSwap: function (info) {
                    var player = ui.create.player();
                    player.classList.add('noidentity');
                    player.dataset.position = info.position;
                    player.animate(info.me ? 'replaceme' : 'replaceenemy');
                    player.actcount = info.actcount;
                    player.init(info.name, info.name2);
                    game.players.push(player);
                    player.updateActCount(null, info.actcount, 0);
                    ui.arena.appendChild(player);
                    game.playerMap[player.dataset.position] = player;
                    game.arrangePlayers();
                },
                chess_tongshuai: function (player, content) {
                    if (player && player.storage) {
                        player.$.tongshuai.owned = content;
                    }
                    else {
                        console.log(player);
                    }
                },
                chess_tongshuai_skill: function (player, content) {
                    if (player && content) {
                        if (player.marks.tongshuai.firstChild) {
                            player.marks.tongshuai.firstChild.remove();
                        }
                        player.marks.tongshuai.setBackground(content[0], 'character');
                        player.additionalSkills.tongshuai = content[1];
                    }
                    else {
                        console.log(player);
                    }
                },
                smoothAvatar: function (player, vice) {
                    if (player && player.node) {
                        if (vice) {
                            if (player.node.avatar2) {
                                player.smoothAvatar(vice);
                            }
                        }
                        else {
                            if (player.node.avatar) {
                                player.smoothAvatar(vice);
                            }
                        }
                    }
                },
                setAvatar: function (player, content) {
                    if (player && content && content.length == 2) {
                        player.setAvatar(content[0], content[1])
                    }
                },
                setAvatarQueue: function (player, content) {
                    if (player && content && content.length == 2) {
                        player.setAvatarQueue(content[0], content[1])
                    }
                },
                addSubPlayer: function (player, content) {
                    if (player && content && content[0] && content[1] &&
                        content[2] && content[3] && content[4]) {
                        var skill = content[0];
                        lib.skill[skill] = content[1];
                        lib.character[skill] = content[2];
                        lib.translate[skill] = content[3];
                        player.storage[skill] = content[4];
                    }
                },
                arenaNumber: function (content) {
                    ui.arena.dataset.number = content;
                },
                reinit: function (source, content) {
                    if (source && content) {
                        source.uninit();
                        source.init(content[0]);
                        source.node.identity.dataset.color = content[1];
                    }
                    else {
                        console.log(source);
                    }
                },
                reinit2: function (source, name) {
                    if (source && name) {
                        source.init(name);
                    }
                    else {
                        console.log(source);
                    }
                },
                reinit3: function (source, content) {
                    if (source && content) {
                        var info1 = lib.character[content.from];
                        var info2 = lib.character[content.to];
                        if (content.avatar2) {
                            source.name2 = content.to;
                            if (source.isUnseen(0)) {
                                source.sex = info2[0];
                            }
                            source.node.avatar2.setBackground(content.to, 'character');
                            source.node.name2.innerHTML = get.slimName(content.to);
                        }
                        else {
                            source.name = content.to;
                            source.sex = info2[0];
                            source.node.avatar.setBackground(content.to, 'character');
                            source.node.name.innerHTML = get.slimName(content.to);
                        }
                        source.maxHp = content.hp;
                        this.update();
                        for (var i = 0; i < info1[3].length; i++) {
                            source.removeSkill(info1[3][i]);
                        }
                        for (var i = 0; i < info2[3].length; i++) {
                            source.addSkill(info2[3][i]);
                        }
                    }
                },
                skill: function (player, content) {
                    if (typeof content == 'string') {
                        lib.skill[content].video(player);
                    }
                    else if (Array.isArray(content)) {
                        lib.skill[content[0]].video(player, content[1]);
                    }
                    else {
                        console.log(player, content)
                    }
                },
                addFellow: function (content) {
                    var player = game.addFellow(content[0], content[1], content[2]);
                    game.playerMap[player.dataset.position] = player;
                },
                windowzoom1: function () {
                    ui.window.style.transition = 'all 0.5s';
                    ui.window.classList.add('zoomout3');
                    ui.window.hide();
                },
                windowzoom2: function () {
                    ui.window.style.transition = 'all 0s';
                    ui.refresh(ui.window);
                },
                windowzoom3: function () {
                    ui.window.classList.remove('zoomout3');
                    ui.window.classList.add('zoomin3');
                },
                windowzoom4: function () {
                    ui.window.style.transition = 'all 0.5s';
                    ui.refresh(ui.window);
                    ui.window.show();
                    ui.window.classList.remove('zoomin3');
                },
                windowzoom5: function () {
                    ui.window.style.transition = '';
                },
                updateActCount: function (player, content) {
                    if (player && content) {
                        player.updateActCount(content[0], content[1], content[2]);
                    }
                    else {
                        console.log(player);
                    }
                },
                setIdentity: function (player, identity) {
                    if (player && identity) {
                        player.setIdentity(identity);
                    }
                    else {
                        console.log(num);
                    }
                },
                showCharacter: function (player, num) {
                    if (player && player.classList) {
                        switch (num) {
                            case 0:
                                player.classList.remove('unseen_v');
                                break;
                            case 1:
                                player.classList.remove('unseen2_v');
                                break;
                            case 2:
                                player.classList.remove('unseen_v');
                                player.classList.remove('unseen2_v');
                                break;
                        }
                        if (!player.classList.contains('unseen_v') && (!player.name2 || !player.classList.contains('unseen2_v')) && player.$.nohp) {
                            delete player.$.nohp;
                            player.node.hp.show();
                            player.update();
                        }
                    }
                    else {
                        console.log(num);
                    }
                },
                hidePlayer: function (player) {
                    if (player) {
                        player.hide();
                    }
                },
                deleteHandcards: function (player) {
                    if (player) {
                        player.node.handcards1.delete();
                        player.node.handcards2.delete();
                    }
                },
                hideCharacter: function (player, num) {
                    if (player && player.classList) {
                        switch (num) {
                            case 0:
                                player.classList.add('unseen_v');
                                break;
                            case 1:
                                player.classList.add('unseen2_v');
                                break;
                            case 2:
                                player.classList.add('unseen_v');
                                player.classList.add('unseen2_v');
                                break;
                        }
                    }
                    else {
                        console.log(num);
                    }
                },
                popup: function (player, info) {
                    if (player && info) {
                        player.popup(info[0], info[1]);
                    }
                    else {
                        console.log(player);
                    }
                },
                log: function (str) {
                    game.log(str);
                },
                draw: function (player, info) {
                    if (player && player.$draw) {
                        player.$draw(info);
                    }
                    else {
                        console.log(player);
                    }
                },
                drawCard: function (player, info) {
                    if (player && info) {
                        player.$draw(get.infoCards(info));
                    }
                    else {
                        console.log(player);
                    }
                },
                throw: function (player, info) {
                    if (player && info) {
                        player.$throw(get.infoCards(info[0]), info[1], null, info[2]);
                    }
                    else {
                        console.log(player);
                    }
                },
                compare: function (player, info) {
                    if (player && info) {
                        player.$compare(get.infoCard(info[0]), game.playerMap[info[1]], get.infoCard(info[2]));
                    }
                    else {
                        console.log(player);
                    }
                },
                compareMultiple: function (player, info) {
                    if (player && info) {
                        player.$compareMultiple(get.infoCard(info[0]), get.infoTargets(info[1]), get.infoCards(info[2]));
                    }
                    else {
                        console.log(player);
                    }
                },
                give: function (player, info) {
                    if (player && info) {
                        player.$give(info[0], game.playerMap[info[1]]);
                    }
                    else {
                        console.log(player);
                    }
                },
                giveCard: function (player, info) {
                    if (player && info) {
                        player.$give(get.infoCards(info[0]), game.playerMap[info[1]]);
                    }
                    else {
                        console.log(player);
                    }
                },
                gain: function (player, info) {
                    if (player && player.$gain) {
                        player.$gain(info);
                    }
                    else {
                        console.log(player);
                    }
                },
                gainCard: function (player, info) {
                    if (player && info) {
                        player.$gain(get.infoCards(info));
                    }
                    else {
                        console.log(player);
                    }
                },
                gain2: function (player, cards) {
                    if (player && player.$draw) {
                        var nodeList = document.querySelectorAll('#arena>.card,#chess>.card');
                        var nodes = [];
                        for (var i = 0; i < nodeList.length; i++) {
                            nodes.push(nodeList[i]);
                        }
                        for (var i = 0; i < cards.length; i++) {
                            for (var j = 0; j < nodes.length; j++) {
                                if (cards[i][2] == nodes[j].name && cards[i][0] == nodes[j].suit && cards[i][1] == nodes[j].number) {
                                    nodes[j].moveDelete(player);
                                    cards.splice(i--, 1);
                                    nodes.splice(j--, 1);
                                    break;
                                }
                            }
                        }
                        if (cards.length) {
                            player.$draw(get.infoCards(cards));
                        }
                    }
                    else {
                        console.log(player);
                    }
                },
                deletenode: function (player, cards, method) {
                    if (cards) {
                        var nodeList = document.querySelectorAll('#arena>.card,#chess>.card');
                        var nodes = [];
                        for (var i = 0; i < nodeList.length; i++) {
                            nodes.push(nodeList[i]);
                        }
                        for (var i = 0; i < cards.length; i++) {
                            for (var j = 0; j < nodes.length; j++) {
                                if (cards[i][2] == nodes[j].name && cards[i][0] == nodes[j].suit && cards[i][1] == nodes[j].number) {
                                    nodes[j].delete();
                                    if (method == 'zoom') {
                                        nodes[j].style.transform = 'scale(0)';
                                    }
                                    cards.splice(i--, 1);
                                    nodes.splice(j--, 1);
                                    break;
                                }
                            }
                        }
                    }
                    else {
                        console.log(player, cards);
                    }
                },
                highlightnode: function (player, card) {
                    if (card) {
                        var nodeList = document.querySelectorAll('#arena>.card,#chess>.card');
                        var nodes = [];
                        for (var i = 0; i < nodeList.length; i++) {
                            nodes.push(nodeList[i]);
                        }
                        for (var j = nodes.length - 1; j >= 0; j--) {
                            if (card[2] == nodes[j].name && card[0] == nodes[j].suit && card[1] == nodes[j].number) {
                                nodes[j].classList.add('thrownhighlight');
                                break;
                            }
                        }
                    }
                    else {
                        console.log(player, cards);
                    }
                },
                uiClear: function () {
                    ui.clear();
                },
                judge1: function (player, content) {
                    if (player && content) {
                        var judging = get.infoCard(content[0]);
                        if (game.chess) {
                            judging.copy('thrown', 'center', 'thrownhighlight', ui.arena).animate('start');
                        }
                        else {
                            player.$throwordered(judging.copy('thrownhighlight'), true);
                        }

                        ui.create.dialog(content[1]).videoId = content[2];
                        ui.arena.classList.add('thrownhighlight');
                    }
                    else {
                        console.log(player);
                    }
                },
                centernode: function (content) {
                    get.infoCard(content).copy('thrown', 'center', 'thrownhighlight', ui.arena).animate('start');
                },
                judge2: function (videoId) {
                    for (var i = 0; i < ui.dialogs.length; i++) {
                        if (ui.dialogs[i].videoId == videoId) {
                            ui.dialogs[i].close();
                        }
                    }
                    ui.arena.classList.remove('thrownhighlight');
                },
                unmarkname: function (player, name) {
                    if (player && player.unmark) {
                        player.unmark(name);
                    }
                    else {
                        console.log(player);
                    }
                },
                unmark: function (player, name) {
                    if (player && player.marks && player.marks[name]) {
                        player.marks[name].delete();
                        player.marks[name].style.transform += ' scale(0.2)';
                        delete player.marks[name];
                        ui.updatem(this);
                    }
                },
                flame: function (player, type) {
                    if (player && type) {
                        player['$' + type]();
                    }
                    else {
                        console.log(player);
                    }
                },
                throwEmotion: function (player, content) {
                    if (player && content) {
                        player.$throwEmotion(game.playerMap[content[0]], content[1]);
                    }
                    else {
                        console.log(player);
                    }
                },
                addGaintag: function (player, content) {
                    if (player && content) {
                        var checkMatch = function (l1, l2) {
                            for (var i = 0; i < l1.length; i++) {
                                for (var j = 0; j < l2.length; j++) {
                                    if (l2[j].suit == l1[i][0] && l2[j].number == l1[i][1] && l2[j].name == l1[i][2]) {
                                        l2[j].addGaintag(content[1]);
                                        l2.splice(j--, 1);
                                        break;
                                    }
                                }
                            }
                        }
                        checkMatch(content[0], player.getCards('h'));
                    }
                    else {
                        console.log(player);
                    }
                },
                removeGaintag: function (player, content) {
                    if (player && content) {
                        player.removeGaintag(content);
                    }
                    else {
                        console.log(player);
                    }
                },
                line: function (player, content) {
                    if (player && content) {
                        player.line(game.playerMap[content[0]], content[1]);
                    }
                    else {
                        console.log(player);
                    }
                },
                fullscreenpop: function (player, content) {
                    if (player && content) {
                        player.$fullscreenpop(content[0], content[1], content[2]);
                    }
                    else {
                        console.log(player);
                    }
                },
                damagepop: function (player, content) {
                    if (player && content) {
                        player.$damagepop(content[0], content[1], content[2]);
                    }
                    else {
                        console.log(player);
                    }
                },
                damage: function (player, source) {
                    if (player && player.$damage) {
                        player.$damage(game.playerMap[source]);
                    }
                    else {
                        console.log(player);
                    }
                },
                diex: function (player) {
                    if (!player) {
                        console.log('diex');
                        return;
                    }
                    var cards = player.getCards('hej');
                    for (var i = 0; i < cards.length; i++) {
                        cards[i].discard();
                    }
                    while (player.node.marks.childNodes.length > 1) {
                        player.node.marks.lastChild.remove();
                    }
                    player.classList.add('dead');
                    player.classList.remove('turnedover');
                    player.classList.remove('out');
                    player.node.count.innerHTML = '0';
                    player.node.hp.hide();
                    player.node.equips.hide();
                    player.node.count.hide();
                    player.previous.next = player.next;
                    player.next.previous = player.previous;
                    game.players.remove(player);
                    game.dead.push(player);
                    if (lib.config.mode == 'stone') {
                        setTimeout(function () {
                            player.delete();
                        }, 500);
                    }
                },
                tafangMe: function (player) {
                    if (player) {
                        game.me = player;
                        ui.me.lastChild.show();
                        ui.create.fakeme();
                        ui.handcards1 = player.node.handcards1.animate('start').fix();
                        ui.handcards2 = player.node.handcards2.animate('start').fix();
                        ui.handcards1Container.appendChild(ui.handcards1);
                        ui.handcards2Container.appendChild(ui.handcards2);
                        ui.updatehl();
                        game.setChessInfo();
                    }
                },
                deleteChessPlayer: function (player) {
                    if (player) {
                        player.delete();
                        delete game.playerMap[player.dataset.position];
                        game.players.remove(player);
                        for (var i = 0; i < ui.phasequeue.length; i++) {
                            if (ui.phasequeue[i].link == player) {
                                ui.phasequeue[i].remove();
                                ui.phasequeue.splice(i, 1);
                                break;
                            }
                        }
                    }
                },
                addChessPlayer: function (content) {
                    game.addChessPlayer.apply(this, content);
                },
                die: function (player) {
                    if (!player) {
                        console.log('die');
                        return;
                    }
                    player.$die();
                    if (game.chess) {
                        delete lib.posmap[player.dataset.position];
                        setTimeout(function () {
                            player.delete();
                        }, 500);
                        for (var i = 0; i < ui.phasequeue.length; i++) {
                            if (ui.phasequeue[i].link == player) {
                                ui.phasequeue[i].remove();
                                ui.phasequeue.splice(i, 1);
                                break;
                            }
                        }
                    }
                },
                revive: function (player) {
                    if (!player) {
                        console.log('revive');
                        return;
                    }
                    player.classList.remove('dead');
                    player.node.hp.show();
                    player.node.equips.show();
                    player.node.count.show();
                    player.node.avatar.style.transform = '';
                    player.node.avatar2.style.transform = '';
                    player.removeAttribute('style');
                },
                update: function (player, info) {
                    if (player && info) {
                        player.hp = info[1];
                        player.maxHp = info[2];
                        player.hujia = info[3];
                        player.update(info[0]);
                    }
                    else {
                        console.log(player);
                    }
                },
                phaseJudge: function (player, card) {
                    if (player && card) {
                        // player.$phaseJudge(get.infoCard(card));
                    }
                    else {
                        console.log(player);
                    }
                },
                directgain: function (player, cards) {
                    if (player && cards) {
                        player.directgain(get.infoCards(cards));
                    }
                    else {
                        console.log(player);
                    }
                },
                directgains: function (player, cards) {
                    if (player && cards) {
                        player.directgains(get.infoCards(cards));
                    }
                    else {
                        console.log(player);
                    }
                },
                directequip: function (player, cards) {
                    if (player && cards) {
                        player.directequip(get.infoCards(cards));
                    }
                    else {
                        console.log(player);
                    }
                },
                gain12: function (player, cards12) {
                    if (player && cards12) {
                        var cards1 = get.infoCards(cards12[0]);
                        var cards2 = get.infoCards(cards12[1]);
                        for (var i = 0; i < cards1.length; i++) {
                            cards1[i].classList.add('drawinghidden');
                            cards1[i].addGaintag(cards12[2]);
                            player.node.handcards1.insertBefore(cards1[i], player.node.handcards1.firstChild);
                        }
                        for (var i = 0; i < cards2.length; i++) {
                            cards2[i].classList.add('drawinghidden');
                            cards2[i].addGaintag(cards12[2]);
                            player.node.handcards2.insertBefore(cards2[i], player.node.handcards2.firstChild);
                        }
                        ui.updatehl();
                    }
                    else {
                        console.log(player);
                    }
                },
                equip: function (player, card) {
                    if (player && card) {
                        player.$equip(get.infoCard(card));
                    }
                    else {
                        console.log(player);
                    }
                },
                addJudge: function (player, content) {
                    if (player && content) {
                        var card = get.infoCard(content[0]);
                        card.viewAs = content[1];
                        if (card.viewAs && card.viewAs != card.name && (card.classList.contains('fullskin') || card.classList.contains('fullborder'))) {
                            card.classList.add('fakejudge');
                            card.node.background.innerHTML = lib.translate[card.viewAs + '_bg'] || get.translation(card.viewAs)[0]
                        }
                        card.classList.add('drawinghidden');
                        player.node.judges.insertBefore(card, player.node.judges.firstChild);
                        ui.updatej(player);
                    }
                    else {
                        console.log(player);
                    }
                },
                markCharacter: function (player, content) {
                    if (player && content) {
                        if (game.playerMap[content.target]) {
                            content.target = game.playerMap[content.target];
                        }
                        var mark = player.markCharacter(content.target, content);
                        if (content.id) {
                            player.marks[content.id] = mark;
                        }
                    }
                    else {
                        console.log(player);
                    }
                },
                changeMarkCharacter: function (player, content) {
                    if (player && content && player.marks[content.id]) {
                        player.marks[content.id].info = {
                            name: content.name,
                            content: content.content
                        };
                        player.marks[content.id].setBackground(content.target, 'character');
                    }
                },
                mark: function (player, content) {
                    if (player && content) {
                        var mark = player.mark(content.id, content);
                    }
                    else {
                        console.log(player);
                    }
                },
                markSkill: function (player, content) {
                    if (player && content) {
                        if (content[1]) {
                            player.markSkill(content[0], null, get.infoCard(content[1]));
                        }
                        else {
                            player.markSkill(content[0]);
                        }
                    }
                    else {
                        console.log(player);
                    }
                },
                unmarkSkill: function (player, name) {
                    if (player && player.unmarkSkill) {
                        player.unmarkSkill(name);
                    }
                    else {
                        console.log(player);
                    }
                },
                storage: function (player, content) {
                    if (player && content) {
                        if (content[2]) {
                            switch (content[2]) {
                                case 'cards': content[1] = get.infoCards(content[1]); break;
                                case 'card': content[1] = get.infoCard(content[1]); break;
                            }
                        }
                        player.storage[content[0]] = content[1];
                    }
                    else {
                        console.log(player);
                    }
                },
                markId: function (player, content) {
                    if (player && content) {
                        player.mark(get.infoCard(content[0]), content[1]);
                    }
                    else {
                        console.log(player);
                    }
                },
                unmarkId: function (player, content) {
                    if (player && content) {
                        player.unmark(get.infoCard(content[0]), content[1]);
                    }
                    else {
                        console.log(player);
                    }
                },
                lose: function (player, info) {
                    if (player && info) {
                        var hs = info[0] || [], es = info[1] || [], js = info[2] || [], ss = info[3] || [];
                        var phs = player.getCards('h'), pes = player.getCards('e'), pjs = player.getCards('j'), pss = player.getCards('s');
                        var checkMatch = function (l1, l2) {
                            for (var i = 0; i < l1.length; i++) {
                                for (var j = 0; j < l2.length; j++) {
                                    if (l2[j].suit == l1[i][0] && l2[j].number == l1[i][1] && l2[j].name == l1[i][2]) {
                                        l2[j].remove();
                                        l2.splice(j--, 1);
                                        break;
                                    }
                                }
                            }
                        }
                        checkMatch(hs, phs);
                        checkMatch(es, pes);
                        checkMatch(js, pjs);
                        checkMatch(ss, pss);
                        ui.updatehl();
                    }
                    else {
                        console.log(player);
                    }
                },
                loseAfter: function (player) {
                    if (!player) {
                        console.log('loseAfter');
                        return;
                    }
                },
                link: function (player, bool) {
                    if (player && player.classList) {
                        if (bool) {
                            player.addLink();
                        }
                        else {
                            player.removeLink();
                        }
                    }
                    else {
                        console.log(player);
                    }
                },
                turnOver: function (player, bool) {
                    if (player && player.classList) {
                        if (bool) {
                            player.classList.add('turnedover');
                        }
                        else {
                            player.classList.remove('turnedover');
                        }
                    }
                    else {
                        console.log(player);
                    }
                },
                showCards: function (player, info) {
                    if (info) {
                        var dialog = ui.create.dialog(info[0], get.infoCards(info[1]));
                        setTimeout(function () {
                            dialog.close();
                        }, 1000);
                    }
                    else {
                        console.log(player);
                    }
                },
                cardDialog: function (content) {
                    if (Array.isArray(content)) {
                        ui.create.dialog(content[0], get.infoCards(content[1])).videoId = content[2];
                    }
                    else if (typeof content == 'number') {
                        for (var i = 0; i < ui.dialogs.length; i++) {
                            if (ui.dialogs[i].videoId == content) {
                                ui.dialogs[i].close();
                                return;
                            }
                        }
                    }
                },
                changeSeat: function (player, info) {
                    if (player && player.getBoundingClientRect && player.changeSeat) {
                        player.changeSeat(info);
                        game.playerMap = {};
                        var players = game.players.concat(game.dead);
                        for (var i = 0; i < players.length; i++) {
                            game.playerMap[players[i].dataset.position] = players[i];
                        }
                    }
                },
                dialogCapt: function (content) {
                    for (var i = 0; i < ui.dialogs.length; i++) {
                        if (ui.dialogs[i].videoId == content[0]) {
                            ui.dialogs[i].content.firstChild.innerHTML = content[1];
                            return;
                        }
                    }
                },
                swapSeat: function (content) {
                    var player1 = game.playerMap[content[0]];
                    var player2 = game.playerMap[content[1]];
                    if (!player1 || !player2) {
                        console.log(content);
                        return;
                    }
                    var temp1, pos, i, num;
                    temp1 = player1.dataset.position;
                    player1.dataset.position = player2.dataset.position;
                    player2.dataset.position = temp1;
                    game.arrangePlayers();
                    if (player1.dataset.position == '0' || player2.dataset.position == '0') {
                        pos = parseInt(player1.dataset.position);
                        if (pos == 0) pos = parseInt(player2.dataset.position);
                        num = game.players.length + game.dead.length;
                        for (i = 0; i < game.players.length; i++) {
                            temp1 = parseInt(game.players[i].dataset.position) - pos;
                            if (temp1 < 0) temp1 += num;
                            game.players[i].dataset.position = temp1;
                        }
                        for (i = 0; i < game.dead.length; i++) {
                            temp1 = parseInt(game.dead[i].dataset.position) - pos;
                            if (temp1 < 0) temp1 += num;
                            game.dead[i].dataset.position = temp1;
                        }
                    }
                    game.playerMap = {};
                    var players = game.players.concat(game.dead);
                    for (var i = 0; i < players.length; i++) {
                        game.playerMap[players[i].dataset.position] = players[i];
                    }
                },
                removeTafangPlayer: function () {
                    ui.fakeme.hide();
                    ui.handcards1Container.innerHTML = '';
                    ui.handcards2Container.innerHTML = '';
                    game.me = ui.create.player();
                },
                swapControl: function (player, hs) {
                    if (player && player.node) {
                        var cards = get.infoCards(hs);
                        player.node.handcards1.innerHTML = '';
                        player.node.handcards2.innerHTML = '';
                        player.directgain(cards, false);

                        game.me.node.handcards1.remove();
                        game.me.node.handcards2.remove();

                        ui.handcards1 = player.node.handcards1.animate('start').fix();
                        ui.handcards2 = player.node.handcards2.animate('start').fix();
                        ui.handcards1Container.insertBefore(ui.handcards1, ui.handcards1Container.firstChild);
                        ui.handcards2Container.insertBefore(ui.handcards2, ui.handcards2Container.firstChild);

                        game.me = player;
                        ui.updatehl();
                        if (game.chess) {
                            ui.create.fakeme();
                        }
                    }
                    else {
                        console.log(player);
                    }
                },
                onSwapControl: function () {
                    game.onSwapControl();
                },
                swapPlayer: function (player, hs) {
                    if (player && player.node) {
                        var cards = get.infoCards(hs);
                        player.node.handcards1.innerHTML = '';
                        player.node.handcards2.innerHTML = '';
                        player.directgain(cards, false);

                        var pos = parseInt(player.dataset.position);
                        var num = game.players.length + game.dead.length;
                        var players = game.players.concat(game.dead);
                        var temp;
                        for (var i = 0; i < players.length; i++) {
                            temp = parseInt(players[i].dataset.position) - pos;
                            if (temp < 0) temp += num;
                            players[i].dataset.position = temp;
                        }
                        game.me.node.handcards1.remove();
                        game.me.node.handcards2.remove();
                        game.me = player;
                        ui.handcards1 = player.node.handcards1.animate('start').fix();
                        ui.handcards2 = player.node.handcards2.animate('start').fix();
                        ui.handcards1Container.appendChild(ui.handcards1);
                        ui.handcards2Container.appendChild(ui.handcards2);

                        ui.updatehl();

                        game.playerMap = {};
                        var players = game.players.concat(game.dead);
                        for (var i = 0; i < players.length; i++) {
                            game.playerMap[players[i].dataset.position] = players[i];
                        }
                    }
                    else {
                        console.log(player);
                    }
                },
                over: function (str) {
                    var dialog = ui.create.dialog('hidden');
                    dialog.noforcebutton = true;
                    dialog.content.innerHTML = str;
                    dialog.forcebutton = true;
                    dialog.open();
                    if (game.chess) {
                        dialog.classList.add('center');
                    }
                    if ((game.layout == 'long2' || game.layout == 'nova') && !game.chess) {
                        ui.arena.classList.add('choose-character');
                        if (ui.me) ui.me.hide();
                        if (ui.mebg) ui.mebg.hide()
                        if (ui.autonode) ui.autonode.hide();
                        if (lib.config.radius_size != 'off') {
                            if (ui.historybar) ui.historybar.style.borderRadius = '0 0 0 4px';
                        }
                    }
                }
            },
            reload: function () {
                if (_status) {
                    if (_status.reloading) return;
                    _status.reloading = true;
                }
                if (_status.video && !_status.replayvideo) {
                    localStorage.removeItem(lib.configprefix + 'playbackmode');
                }
                localStorage.setItem('show_splash_off', true);
                if (lib.status.reload) {
                    _status.waitingToReload = true;
                }
                else {
                    window.location.reload();
                }
            },
            reload2: function () {
                lib.status.reload--;
                if (lib.status.reload == 0 && lib.ondb2.length) {
                    var command = lib.ondb2.shift();
                    game[command[0]].apply(game, command[1]);
                }
                if (lib.status.reload == 0 && lib.ondb.length) {
                    var command = lib.ondb.shift();
                    game[command[0]].apply(game, command[1]);
                }
                if (lib.status.reload == 0) {
                    if (_status.waitingToReload) {
                        window.location.reload();
                        delete _status.waitingToReload;
                    }
                }
            },
            exit: function () {
                if (lib.device == 'ios') {
                    game.saveConfig('mode');
                    if (_status) {
                        if (_status.reloading) return;
                        _status.reloading = true;
                    }
                    if (_status.video && !_status.replayvideo) {
                        localStorage.removeItem(lib.configprefix + 'playbackmode');
                    }
                    window.location.reload();
                }
                else {
                    if (navigator.app && navigator.app.exitApp) {
                        navigator.app.exitApp();
                    }
                }
            },
            open: function (url) {
                if (lib.device) {
                    if (cordova.InAppBrowser) {
                        cordova.InAppBrowser.open(url, '_system');
                    }
                    else {
                        ui.create.iframe(url);
                    }
                }
                else {
                    window.open(url);
                }
            },
            reloadCurrent: function () {
                game.saveConfig('continue_name', [game.me.name1 || game.me.name, game.me.name2]);
                game.saveConfig('mode', lib.config.mode);
                localStorage.setItem(lib.configprefix + 'directstart', true);
                game.reload();
            },
            update: function (func) {
                lib.updates.push(func);
                if (lib.updates.length === 1) {
                    game.run();
                }
                return func;
            },
            unupdate: function (func) {
                lib.updates.remove(func);
            },
            stop: function () {
                cancelAnimationFrame(lib.status.frameId);
            },
            run: function () {
                if (lib.updates.length) {
                    cancelAnimationFrame(lib.status.frameId);
                    lib.status.frameId = requestAnimationFrame(function (time) {
                        if (lib.status.time !== 0) {
                            lib.status.delayed += time - lib.status.time;
                        }
                        lib.status.frameId = requestAnimationFrame(lib.run);
                    });
                }
            },
            addVideo: function (type, player, content) {
                if (_status.video || game.online) return;
                if (!_status.videoInited) {
                    if (type == 'arrangeLib') {
                        lib.video.push({
                            type: type,
                            player: player,
                            content: content,
                            delay: 0
                        });
                    }
                    return;
                }
                if (type == 'storage' && player && player.updateMarks) {
                    player.updateMarks();
                }
                if (game.getVideoName) {
                    var time = get.time();
                    if (!_status.lastVideoLog) {
                        _status.lastVideoLog = time;
                    }
                    if (get.itemtype(player) == 'player') {
                        player = player.dataset.position;
                    }
                    lib.video.push({
                        type: type,
                        player: player,
                        content: content,
                        delay: time - _status.lastVideoLog
                    });
                    _status.lastVideoLog = time;
                }
            },
            draw: function (func) {
                lib.canvasUpdates.push(func);
                if (!lib.status.canvas) {
                    lib.status.canvas = true;
                    game.update(lib.updateCanvas);
                }
            },
            vibrate: function (time) {
                if (typeof navigator.vibrate == 'function') {
                    navigator.vibrate(time || 500);
                }
            },
            prompt: function () {
                var str, forced, callback, noinput = false, str2 = '';
                for (var i = 0; i < arguments.length; i++) {
                    if (arguments[i] == 'alert') {
                        forced = true;
                        callback = function () { };
                        noinput = true;
                    }
                    else if (typeof arguments[i] == 'string') {
                        if (arguments[i].indexOf('###') == 0) {
                            var list = arguments[i].slice(3).split('###');
                            str = list[0];
                            str2 = list[1];
                        }
                        else str = arguments[i];
                    }
                    else if (typeof arguments[i] == 'boolean') {
                        forced = arguments[i];
                    }
                    else if (typeof arguments[i] == 'function') {
                        callback = arguments[i];
                    }
                }
                if (!callback) {
                    return;
                }
                //try{
                //    if(noinput){
                //        throw('e');
                //    }
                //    var result=prompt(str);
                //    callback(result);
                //}
                //catch(e){
                var promptContainer = ui.create.div('.popup-container', ui.window, function () {
                    if (this.clicked) {
                        this.clicked = false;
                    }
                    else {
                        clickCancel();
                    }
                });
                var dialogContainer = ui.create.div('.prompt-container', promptContainer);
                var dialog = ui.create.div('.menubg', ui.create.div(dialogContainer), function () {
                    promptContainer.clicked = true;
                });
                var strnode = ui.create.div('', str || '', dialog);
                var input = ui.create.node('input', ui.create.div(dialog));
                input.value = str2;
                if (noinput) {
                    input.style.display = 'none';
                }
                var controls = ui.create.div(dialog);
                var clickConfirm = function () {
                    if (noinput) {
                        promptContainer.remove();
                    }
                    else if (input.value) {
                        callback(input.value);
                        promptContainer.remove();
                    }
                }
                var clickCancel = function () {
                    if (!forced) {
                        callback(false);
                        promptContainer.remove();
                    }
                }
                var confirmNode = ui.create.div('.menubutton.large.disabled', '确定', controls, clickConfirm);
                if (!forced) {
                    ui.create.div('.menubutton.large', '取消', controls, clickCancel);
                }
                if (noinput) {
                    confirmNode.classList.remove('disabled');
                }
                else {
                    input.onkeydown = function (e) {
                        if (e.keyCode == 13) {
                            clickConfirm();
                        }
                        else if (e.keyCode == 27) {
                            clickCancel();
                        }
                    }
                    input.onkeyup = function () {
                        if (input.value) {
                            confirmNode.classList.remove('disabled');
                        }
                        else {
                            confirmNode.classList.remove('disabled');
                        }
                    }
                    input.focus();
                }
                //}
            },
            alert: function (str) {
                game.prompt(str, 'alert');
            },
            print: function () {
                if (!_status.toprint) {
                    _status.toprint = [];
                }
                _status.toprint.push(Array.from(arguments));
            },
            animate: {
                window: function (num) {
                    switch (num) {
                        case 1: {
                            ui.window.style.transition = 'all 0.5s';
                            ui.window.classList.add('zoomout3');
                            ui.window.hide();
                            game.addVideo('windowzoom1');
                            game.delay(0, 500);
                            break;
                        }
                        case 2: {
                            ui.window.style.transition = 'all 0s';
                            ui.refresh(ui.window);
                            game.addVideo('windowzoom2');
                            game.pause();
                            setTimeout(function () {
                                ui.window.classList.remove('zoomout3');
                                ui.window.classList.add('zoomin3');
                                game.addVideo('windowzoom3');
                                setTimeout(function () {
                                    ui.window.style.transition = 'all 0.5s';
                                    ui.refresh(ui.window);
                                    ui.window.show();
                                    ui.window.classList.remove('zoomin3');
                                    game.addVideo('windowzoom4');
                                    setTimeout(function () {
                                        ui.window.style.transition = '';
                                        game.addVideo('windowzoom5');
                                        game.resume();
                                    }, 500);
                                }, 100);
                            }, 100);
                            break;
                        }
                    }
                },
                flame: function (x, y, duration, type) {
                    var particles = [];
                    var particle_count = 50;
                    if (type == 'thunder' || type == 'recover') {
                        particle_count = 30;
                    }
                    else if (type == 'coin' || type == 'dust') {
                        particle_count = 50;
                    }
                    else if (type == 'legend') {
                        particle_count = 120;
                    }
                    else if (type == 'epic') {
                        particle_count = 80;
                    }
                    else if (type == 'rare') {
                        particle_count = 50;
                    }
                    for (var i = 0; i < particle_count; i++) {
                        particles.push(new particle());
                    }
                    function particle() {
                        this.speed = { x: -1 + Math.random() * 2, y: -5 + Math.random() * 5 };
                        if (type == 'thunder' || type == 'coin' || type == 'dust') {
                            this.speed.y = -3 + Math.random() * 5;
                            this.speed.x = -2 + Math.random() * 4;
                        }
                        if (type == 'legend' || type == 'rare' || type == 'epic') {
                            this.speed.x *= 3;
                            this.speed.y *= 1.5;
                        }
                        this.location = { x: x, y: y };

                        this.radius = 0.5 + Math.random() * 1;

                        this.life = 10 + Math.random() * 10;
                        this.death = this.life;

                        switch (type) {
                            case 'thunder': {
                                this.b = 255;
                                this.r = Math.round(Math.random() * 255);
                                this.g = Math.round(Math.random() * 255);
                                this.x += Math.random() * 20 - 10;
                                this.y += Math.random() * 20 - 10;

                                break;
                            }
                            case 'fire': {
                                this.r = 255;
                                this.g = Math.round(Math.random() * 155);
                                this.b = 0;
                                break;
                            }
                            case 'coin': {
                                this.r = 255;
                                this.g = Math.round(Math.random() * 25 + 230);
                                this.b = Math.round(Math.random() * 100 + 50);
                                this.location.x += Math.round(Math.random() * 60) - 30;
                                this.location.y += Math.round(Math.random() * 40) - 20;
                                if (this.location.x < x) {
                                    this.speed.x = -Math.abs(this.speed.x);
                                }
                                else if (this.location.x > x) {
                                    this.speed.x = Math.abs(this.speed.x);
                                }
                                this.life *= 1.3;
                                this.death *= 1.3;
                                break;
                            }
                            case 'dust': {
                                this.r = Math.round(Math.random() * 55) + 105;
                                this.g = Math.round(Math.random() * 55) + 150;
                                this.b = 255;
                                this.location.x += Math.round(Math.random() * 60) - 30;
                                this.location.y += Math.round(Math.random() * 40) - 20;
                                if (this.location.x < x) {
                                    this.speed.x = -Math.abs(this.speed.x);
                                }
                                else if (this.location.x > x) {
                                    this.speed.x = Math.abs(this.speed.x);
                                }
                                this.life *= 1.3;
                                this.death *= 1.3;
                                break;
                            }
                            case 'legend': {
                                this.r = 255;
                                this.g = Math.round(Math.random() * 100 + 155);
                                this.b = Math.round(Math.random() * 100 + 50);
                                this.location.x += Math.round(Math.random() * 60) - 30;
                                this.location.y += Math.round(Math.random() * 40) - 20;
                                if (this.location.x < x) {
                                    this.speed.x = -Math.abs(this.speed.x);
                                }
                                else if (this.location.x > x) {
                                    this.speed.x = Math.abs(this.speed.x);
                                }
                                this.speed.x /= 2;
                                this.speed.y /= 2;
                                this.life *= 2;
                                this.death *= 2;
                                break;
                            }
                            case 'epic': {
                                this.r = Math.round(Math.random() * 55) + 200;
                                this.g = Math.round(Math.random() * 100) + 55;
                                this.b = 255;
                                this.location.x += Math.round(Math.random() * 60) - 30;
                                this.location.y += Math.round(Math.random() * 40) - 20;
                                if (this.location.x < x) {
                                    this.speed.x = -Math.abs(this.speed.x);
                                }
                                else if (this.location.x > x) {
                                    this.speed.x = Math.abs(this.speed.x);
                                }
                                this.speed.x /= 2;
                                this.speed.y /= 2;
                                this.life *= 2;
                                this.death *= 2;
                                break;
                            }
                            case 'rare': {
                                this.r = Math.round(Math.random() * 55) + 105;
                                this.g = Math.round(Math.random() * 55) + 150;
                                this.b = 255;
                                this.location.x += Math.round(Math.random() * 60) - 30;
                                this.location.y += Math.round(Math.random() * 40) - 20;
                                if (this.location.x < x) {
                                    this.speed.x = -Math.abs(this.speed.x);
                                }
                                else if (this.location.x > x) {
                                    this.speed.x = Math.abs(this.speed.x);
                                }
                                this.speed.x /= 2;
                                this.speed.y /= 2;
                                this.life *= 2;
                                this.death *= 2;
                                break;
                            }
                            case 'recover': {
                                this.g = 255;
                                this.r = Math.round(Math.random() * 200 + 55);
                                this.b = Math.round(Math.random() * 155 + 55);
                                this.location.x += Math.round(Math.random() * 60) - 30;
                                this.location.y += Math.round(Math.random() * 40) - 20;
                                if (this.location.x < x) {
                                    this.speed.x = -Math.abs(this.speed.x);
                                }
                                else if (this.location.x > x) {
                                    this.speed.x = Math.abs(this.speed.x);
                                }
                                this.speed.x /= 2;
                                this.speed.y /= 2;
                                this.life *= 2;
                                this.death *= 2;
                                break;
                            }
                            default: {
                                this.r = 255;
                                this.g = Math.round(Math.random() * 155);
                                this.b = 0;
                            }
                        }
                    }

                    game.draw(function (time, surface) {
                        surface.globalCompositeOperation = "source-over";
                        surface.globalCompositeOperation = "lighter";

                        for (var i = 0; i < particles.length; i++) {
                            var p = particles[i];

                            surface.beginPath();
                            var middle = 0.5;
                            var radius = p.radius;
                            if (type == 'recover' || type == 'legend' || type == 'rare' ||
                                type == 'epic' || type == 'coin' || type == 'dust') {
                                middle = 0.7;
                                radius /= 3;
                            }

                            p.opacity = Math.round(p.death / p.life * 100) / 100
                            var gradient = surface.createRadialGradient(p.location.x, p.location.y, 0, p.location.x, p.location.y, p.radius);
                            gradient.addColorStop(0, "rgba(" + p.r + ", " + p.g + ", " + p.b + ", " + p.opacity + ")");
                            gradient.addColorStop(middle, "rgba(" + p.r + ", " + p.g + ", " + p.b + ", " + p.opacity + ")");
                            gradient.addColorStop(1, "rgba(" + p.r + ", " + p.g + ", " + p.b + ", 0)");
                            surface.fillStyle = gradient;
                            surface.arc(p.location.x, p.location.y, radius, Math.PI * 2, false);
                            surface.fill();
                            p.death--;
                            if (type == 'recover') {
                                p.radius += 0.5;
                            }
                            else if (type == 'coin' || type == 'dust') {
                                p.radius += 0.7;
                            }
                            else if (type == 'legend' || type == 'rare' || type == 'epic') {
                                p.radius += 0.5;
                            }
                            else {
                                p.radius++;
                            }
                            p.location.x += (p.speed.x);
                            p.location.y += (p.speed.y);

                            if (p.death < 0 || p.radius < 0) {
                                if (typeof duration == 'number' && time + 500 >= duration) {
                                    particles.splice(i--, 1);
                                }
                                else {
                                    particles[i] = new particle();
                                }
                            }
                        }
                        if (particles.length == 0) {
                            return false;
                        }
                    });
                }
            },
            linexy: function (path) {
                var from = [path[0], path[1]];
                var to = [path[2], path[3]];
                var total = typeof arguments[1] === 'number' ? arguments[1] : lib.config.duration * 2;
                var opacity = 1;
                var color = [255, 255, 255];
                var dashed = false;
                var drag = false;
                if (typeof arguments[1] == 'object') {
                    for (var i in arguments[1]) {
                        switch (i) {
                            case 'opacity': opacity = arguments[1][i]; break;
                            case 'color': color = arguments[1][i]; break;
                            case 'dashed': dashed = arguments[1][i]; break;
                            case 'duration': total = arguments[1][i]; break;
                        }
                    }
                }
                else if (arguments[1] == 'fire' || arguments[1] == 'thunder' || arguments[1] == 'ocean' || arguments[1] == 'green') {
                    color = arguments[1];
                }
                if (color == 'fire') {
                    color = [255, 146, 68];
                }
                else if (color == 'thunder') {
                    color = [141, 216, 255];
                }
                else if (color == 'ocean') {
                    color = [98, 146, 240];
                }
                else if (color == 'green') {
                    color = [141, 255, 216];
                }
                var node;
                if (arguments[1] == 'drag') {
                    color = [236, 201, 71];
                    drag = true;
                    if (arguments[2]) {
                        node = arguments[2]
                    }
                    else {
                        node = ui.create.div('.linexy.drag');
                        node.style.left = from[0] + 'px';
                        node.style.top = from[1] + 'px';
                        node.style.background = 'linear-gradient(transparent,rgba(' + color.toString() + ',' + opacity + '),rgba(' + color.toString() + ',' + opacity + '))';
                        if (game.chess) {
                            ui.chess.appendChild(node);
                        }
                        else {
                            ui.arena.appendChild(node);
                        }
                    }
                }
                else {
                    node = ui.create.div('.linexy.hidden');
                    node.style.left = from[0] + 'px';
                    node.style.top = from[1] + 'px';
                    node.style.background = 'linear-gradient(transparent,rgba(' + color.toString() + ',' + opacity + '),rgba(' + color.toString() + ',' + opacity + '))';
                    node.style.transitionDuration = (total / 3000) + 's';
                }
                var dy = to[1] - from[1];
                var dx = to[0] - from[0];
                var deg = Math.atan(Math.abs(dy) / Math.abs(dx)) / Math.PI * 180;
                if (dx >= 0) {
                    if (dy <= 0) {
                        deg += 90;
                    }
                    else {
                        deg = 90 - deg;
                    }
                }
                else {
                    if (dy <= 0) {
                        deg = 270 - deg;
                    }
                    else {
                        deg += 270;
                    }
                }
                if (drag) {
                    node.style.transform = 'rotate(' + (-deg) + 'deg)';
                    node.style.height = get.xyDistance(from, to) + 'px';
                }
                else {
                    node.style.transform = 'rotate(' + (-deg) + 'deg) scaleY(0)';
                    node.style.height = get.xyDistance(from, to) + 'px';
                    if (game.chess) {
                        ui.chess.appendChild(node);
                    }
                    else {
                        ui.arena.appendChild(node);
                    }
                    ui.refresh(node);
                    node.show();
                    node.style.transform = 'rotate(' + (-deg) + 'deg) scaleY(1)';
                    node.listenTransition(function () {
                        setTimeout(function () {
                            if (node.classList.contains('removing')) return;
                            node.delete();
                        }, total / 3);
                    });
                }
                return node;
            },
            _linexy: function (path) {
                var from = [path[0], path[1]];
                var to = [path[2], path[3]];
                var total = typeof arguments[1] === 'number' ? arguments[1] : lib.config.duration * 2;
                var opacity = 1;
                var color = [255, 255, 255];
                var dashed = false;
                if (typeof arguments[1] == 'object') {
                    for (var i in arguments[1]) {
                        switch (i) {
                            case 'opacity': opacity = arguments[1][i]; break;
                            case 'color': color = arguments[1][i]; break;
                            case 'dashed': dashed = arguments[1][i]; break;
                            case 'duration': total = arguments[1][i]; break;
                        }
                    }
                }
                else if (arguments[1] == 'fire' || arguments[1] == 'thunder' || arguments[1] == 'ocean' || arguments[1] == 'green') {
                    color = arguments[1];
                }
                if (color == 'fire') {
                    color = [255, 146, 68];
                }
                else if (color == 'thunder') {
                    color = [141, 216, 255];
                }
                else if (color == 'ocean') {
                    color = [98, 146, 250];
                }
                else if (color == 'green') {
                    color = [141, 255, 216];
                }
                var drawfunc = function (time, ctx) {
                    var current;
                    if (time < total / 3) {
                        ctx.strokeStyle = 'rgba(' + color.toString() + ',' + opacity * (time / (total / 3)) + ')';
                        current = [from[0] + (to[0] - from[0]) * time / (total / 3),
                        from[1] + (to[1] - from[1]) * time / (total / 3)];
                    }
                    else if (time <= total) {
                        current = to;
                        if (time > total / 1.5) {
                            ctx.strokeStyle = 'rgba(' + color.toString() + ',' + opacity * (1 - (time - total / 1.5) / (total - total / 1.5)) + ')';
                        }
                        else {
                            ctx.strokeStyle = 'rgba(' + color.toString() + ',' + opacity + ')';
                        }
                    }
                    else {
                        return false;
                    }
                    ctx.beginPath();
                    if (dashed) {
                        ctx.lineCap = 'butt';
                        ctx.setLineDash([8, 2]);
                    }
                    else {
                        ctx.lineCap = 'round';
                    }
                    ctx.moveTo(from[0], from[1]);
                    ctx.lineTo(current[0], current[1]);
                    ctx.stroke();
                };
                if (arguments[2] && game.chess) {
                    game.draw2(drawfunc);
                }
                else {
                    game.draw(drawfunc);
                }
            },
            /**
             * 创建trigger事件；`trigger`本身也是事件，但是`trigger`事件不可触发
             * @param {string} name trigger name
             * @param {*} skill 技能ID
             * @param {GameCores.GameObjects.Player} player 事件所属的角色
             * @param {GameCores.Bases.Event} Evt trigger事件的触发事件
             */
            createTrigger: function (name, skill, player, Evt) {
                if (player.isOut() || player.removed) return;
                if (player.isDead() && !lib.skill[skill].forceDie) return;
                let next = game.createEvent('trigger', false);
                next.skill = skill;
                next.player = player;
                next.triggername = name;
                next.forceDie = true;
                next._trigger = Evt;
                next.setContent('createTrigger');
            },
            /**
             * 创建事件
             * @function
             * @param {string} name 事件名称
             * @param {?boolean} [canTriggered] 是否可以触发，如果是true或未指定，可以触发；如果是false，不会触发
             * @param {?GameCores.Bases.Event} [triggerevent] 前置事件，如果未指定，使用当前事件{@link _status.event}
             */
            createEvent: function (name, trigger, triggerevent) {
                /**
                 * 事件对象
                 * 创建事件，见{@link game.createEvent}
                 * @namespace GameCores.Bases.Event
                 */
                let next =
                /**@lends GameCores.Bases.Event */
                {
                    /**
                     * 事件名称
                     * @type {string}
                     */
                    name: name,
                    /**
                     * 事件状态，用于记录状态机状态
                     * @type {string}
                     * @default 0
                     */
                    step: 0,
                    /**
                     * 事件是否结束，如果结束则为true；默认为false
                     * @type {boolean}
                     * @default false
                     */
                    finished: false,
                    /**
                     * 事件的子事件数组
                     * @type {!GameCores.Bases.Event[]}
                     */
                    next: [],
                    /**
                     * 事件的追加事件数组，在After后如果有事件就执行
                     * 受`skipList`影响
                     * @type {GameCores.Bases.Event[]}
                     */
                    after: [],
                    custom: {//??
                        add: {},
                        replace: {}
                    },
                    _aiexclude: [],
                    /**
                     * 禁止触发对象数组，该事件无法被其中的角色对象触发
                     * @type {GameCores.GameObjects.Player[]}
                     */
                    _notrigger: [],
                    /**
                     * 子事件返回值
                     * @type {?Object}
                     */
                    _result: {},
                    _set: [],
                }
                if (trigger !== false && !game.online) next._triggered = 0;
                for (var i in lib.element.event) {
                    next[i] = lib.element.event[i];
                }
                (triggerevent || _status.event).next.push(next);
                return next;
            },
            /**
             * 添加角色
             * @param {*} name 
             * @param {*} info 
             */
            //TODO
            addCharacter: function (name, info) {
                var extname = (_status.extension || info.extension);
                var imgsrc;
                if (_status.evaluatingExtension) {
                    imgsrc = 'db:extension-' + extname + ':' + name + '.jpg';
                }
                else {
                    imgsrc = 'ext:' + extname + '/' + name + '.jpg';
                }
                var character = [info.sex, info.group, info.hp, info.skills || [], [imgsrc]];
                if (info.tags) {
                    character[4] = character[4].concat(info.tags);
                }
                lib.character[name] = character;
                var packname = 'mode_extension_' + extname;
                if (!lib.characterPack[packname]) {
                    lib.characterPack[packname] = {};
                }
                lib.translate[name] = info.translate;
                lib.characterPack[packname][name] = character;
                lib.translate[packname + '_character_config'] = extname;
            },
            /**
             * 添加角色包
             * @param {*} pack 
             * @param {*} packagename 
             */
            //TODO
            addCharacterPack: function (pack, packagename) {
                var extname = _status.extension || '扩展';
                packagename = packagename || extname;
                for (var i in pack) {
                    if (i == 'mode' || i == 'forbid') continue;
                    for (var j in pack[i]) {
                        if (i == 'character') {
                            if (!pack[i][j][4]) {
                                pack[i][j][4] = [];
                            }
                            var imgsrc;
                            if (_status.evaluatingExtension) {
                                imgsrc = 'db:extension-' + extname + ':' + j + '.jpg';
                            }
                            else {
                                imgsrc = 'ext:' + extname + '/' + j + '.jpg';
                            }
                            pack[i][j][4].push(imgsrc);
                            if (pack[i][j][4].contains('boss') ||
                                pack[i][j][4].contains('hiddenboss')) {
                                lib.config.forbidai.add(j);
                            }
                            if (lib.config.forbidai_user && lib.config.forbidai_user.contains(j)) {
                                lib.config.forbidai.add(j);
                            }
                            for (var l = 0; l < pack[i][j][3].length; l++) {
                                lib.skilllist.add(pack[i][j][3][l]);
                            }
                        }
                        else if (i == 'skill') {
                            if (typeof pack[i][j].audio == 'number' || typeof pack[i][j].audio == 'boolean') {
                                pack[i][j].audio = 'ext:' + extname + ':' + pack[i][j].audio;
                            }
                        }
                        if (lib[i][j] == undefined) {
                            lib[i][j] = pack[i][j];
                        }
                    }
                }
                var packname = 'mode_extension_' + packagename;
                lib.characterPack[packname] = pack.character;
                lib.translate[packname + '_character_config'] = packagename;
            },
            /**
             * 添加卡牌
             */
            //TODO
            addCard: function (name, info, info2) {
                var extname = (_status.extension || info2.extension);
                if (info.audio == true) {
                    info.audio = 'ext:' + extname;
                }
                if (info.fullskin) {
                    if (_status.evaluatingExtension) {
                        info.image = 'db:extension-' + extname + ':' + name + '.png';
                    }
                    else {
                        info.image = 'ext:' + extname + '/' + name + '.png';
                    }
                }
                else if (info.fullimage) {
                    if (_status.evaluatingExtension) {
                        info.image = 'db:extension-' + extname + ':' + name + '.jpg';
                    }
                    else {
                        info.image = 'ext:' + extname + '/' + name + '.jpg';
                    }
                }
                lib.card[name] = info;
                lib.translate[name] = info2.translate;
                lib.translate[name + '_info'] = info2.description;
                if (typeof info2.number == 'number') {
                    var suits = ['heart', 'spade', 'diamond', 'club'];
                    if (info2.color == 'red') {
                        suits = ['heart', 'diamond'];
                    }
                    else if (info2.color == 'black') {
                        suits = ['club', 'spade'];
                    }
                    for (var i = 0; i < info2.number; i++) {
                        lib.card.list.push([suits[Math.floor(Math.random() * suits.length)], Math.ceil(Math.random() * 13), name]);
                    }
                }
                var packname = 'mode_extension_' + extname;
                if (!lib.cardPack[packname]) {
                    lib.cardPack[packname] = [];
                    lib.translate[packname + '_card_config'] = extname;
                }
                lib.cardPack[packname].push(name);
            },
            /**
             * 添加卡包
             * @param {Object} pack 包
             * @param {string} packagename 包名
             */
            //TODO
            addCardPack: function (pack, packagename) {
                var extname = _status.extension || '扩展';
                packagename = packagename || extname;
                var packname = 'mode_extension_' + packagename;
                lib.cardPack[packname] = [];
                lib.translate[packname + '_card_config'] = packagename;
                for (var i in pack) {
                    if (i == 'mode' || i == 'forbid') continue;
                    if (i == 'list') {
                        for (var j = 0; j < pack[i].length; j++) {
                            lib.card.list.push(pack[i][j]);
                        }
                        continue;
                    }
                    for (var j in pack[i]) {
                        if (i == 'card') {
                            if (pack[i][j].audio == true) {
                                pack[i][j].audio = 'ext:' + extname;
                            }
                            if (pack[i][j].fullskin) {
                                if (_status.evaluatingExtension) {
                                    pack[i][j].image = 'db:extension-' + extname + ':' + j + '.png';
                                }
                                else {
                                    pack[i][j].image = 'ext:' + extname + '/' + j + '.png';
                                }
                            }
                            else if (pack[i][j].fullimage) {
                                if (_status.evaluatingExtension) {
                                    pack[i][j].image = 'db:extension-' + extname + ':' + j + '.jpg';
                                }
                                else {
                                    pack[i][j].image = 'ext:' + extname + '/' + j + '.jpg';
                                }
                            }
                            lib.cardPack[packname].push(j);
                        }
                        else if (i == 'skill') {
                            if (typeof pack[i][j].audio == 'number' || typeof pack[i][j].audio == 'boolean') {
                                pack[i][j].audio = 'ext:' + extname + ':' + pack[i][j].audio;
                            }
                        }
                        if (lib[i][j] == undefined) lib[i][j] = pack[i][j];
                    }
                }
            },
            /**
             * 添加技能
             */
            //TODO
            addSkill: function (name, info, translate, description) {
                if (lib.skill[name]) {
                    return false;
                }
                if (typeof info.audio == 'number' || typeof info.audio == 'boolean') {
                    info.audio = 'ext:' + _status.extension + ':' + info.audio;
                }
                lib.skill[name] = info;
                lib.translate[name] = translate;
                lib.translate[name + '_info'] = description;
                return true;
            },
            /**
             * 添加游戏模式（Mode）
             * @param {string} name 
             * @param {string} info 
             * @param {string} info2
             * @deprecated [never used] 
             */
            addMode: function (name, info, info2) {
                lib.config.all.mode.push(name);
                lib.translate[name] = info2.translate;
                var imgsrc;
                var extname = _status.extension || info2.extension;
                if (_status.evaluatingExtension) {
                    imgsrc = 'extension-' + extname + ':' + name + '.jpg';
                }
                else {
                    imgsrc = 'ext:' + extname + '/' + name + '.jpg';
                }
                lib.mode[name] = {
                    name: info2.translate,
                    config: info2.config,
                    splash: imgsrc,
                    fromextension: true
                }
                lib.init['setMode_' + name] = function () {
                    game.import('mode', function (lib, game, ui, get, ai, _status) {
                        info.name = name;
                        return info;
                    });
                }
                if (!lib.config.extensionInfo[extname]) {
                    lib.config.extensionInfo[extname] = {};
                }
                if (!lib.config.extensionInfo[extname].mode) {
                    lib.config.extensionInfo[extname].mode = [];
                }
                if (lib.config.extensionInfo[extname].mode.indexOf(name) == -1) {
                    lib.config.extensionInfo[extname].mode.push(name);
                }
                game.saveConfig('extensionMode', lib.config.extensionInfo);
            },
            /**
             * 添加全局技能
             * @param {string} skill 技能名
             * @param {?string} player 可以为该技能绑定一名角色
             * @deprecated [never used] 
             */
            addGlobalSkill: function (skill, player) {
                var info = lib.skill[skill];
                if (!info) return false;
                lib.skill.global.add(skill);
                if (player) {
                    if (!lib.skill.globalmap[skill]) {
                        lib.skill.globalmap[skill] = [];
                    }
                    lib.skill.globalmap[skill].add(player);
                }
                if (info.trigger) {
                    var setTrigger = function (i, evt) {
                        var name = i + '_' + evt;
                        if (!lib.hook.globalskill[name]) {
                            lib.hook.globalskill[name] = [];
                        }
                        lib.hook.globalskill[name].add(skill);
                        lib.hookmap[evt] = true;
                    }
                    for (var i in info.trigger) {
                        if (typeof info.trigger[i] == 'string') {
                            setTrigger(i, info.trigger[i]);
                        }
                        else if (Array.isArray(info.trigger[i])) {
                            for (var j = 0; j < info.trigger[i].length; j++) {
                                setTrigger(i, info.trigger[i][j]);
                            }
                        }
                    }
                }
                return true;
            },
            removeGlobalSkill: function (skill) {
                lib.skill.global.remove(skill);
                delete lib.skill.globalmap[skill];
                for (var i in lib.hook.globalskill) {
                    lib.hook.globalskill[i].remove(skill);
                }
            },
            //将清除武将牌上的临时技能
            resetSkills: function () {
                for (var i = 0; i < game.players.length; i++) {
                    for (var j in game.players[i].tempSkills) {
                        game.players[i].removeSkill(j);
                    }
                    var skills = game.players[i].getSkills();
                    for (var j = 0; j < skills.length; j++) {
                        if (lib.skill[skills[j]].vanish) {
                            game.players[i].removeSkill(skills[j]);
                        }
                    }
                    game.players[i].in(true);
                }
                ui.clear();
            },
            removeExtension: function (extname, keepfile) {
                var prefix = 'extension_' + extname;
                for (var i in lib.config) {
                    if (i.indexOf(prefix) == 0) {
                        game.saveConfig(i);
                    }
                }
                localStorage.removeItem(lib.configprefix + prefix);
                game.deleteDB('data', prefix);
                lib.config.extensions.remove(extname);
                game.saveConfig('extensions', lib.config.extensions);
                var modelist = lib.config.extensionInfo[extname];
                if (modelist) {
                    if (modelist.image) {
                        for (var i = 0; i < modelist.image.length; i++) {
                            game.deleteDB('image', 'extension-' + extname + ':' + modelist.image[i]);
                        }
                    }
                    if (modelist.mode) {
                        for (var i = 0; i < modelist.mode.length; i++) {
                            game.clearModeConfig(modelist.mode[i]);
                        }
                    }
                    delete lib.config.extensionInfo[extname];
                    game.saveConfig('extensionInfo', lib.config.extensionInfo);
                }
                if (game.download && !keepfile) {
                    if (lib.node && lib.node.fs) {
                        try {
                            lib.node.fs.readdir(__dirname + '/extension/' + extname, function (err, list) {
                                if (err) {
                                    return;
                                }
                                var removeFile = function () {
                                    if (list.length) {
                                        var filename = list.shift();
                                        lib.node.fs.unlink(__dirname + '/extension/' + extname + '/' + filename, removeFile);
                                    }
                                    else {
                                        try {
                                            lib.node.fs.rmdir(__dirname + '/extension/' + extname, function () { });
                                        }
                                        catch (e) { }
                                    }
                                }
                                removeFile();
                            });
                        }
                        catch (e) { }
                    }
                    else {
                        window.resolveLocalFileSystemURL(lib.assetURL + 'extension/' + extname, function (entry) {
                            entry.removeRecursively();
                        });
                    }
                }
            },
            addRecentCharacter: function () {
                var list = get.config('recentCharacter') || [];
                for (var i = 0; i < arguments.length; i++) {
                    if (lib.character[arguments[i]]) {
                        list.remove(arguments[i]);
                        list.unshift(arguments[i]);
                    }
                }
                var num = parseInt(lib.config.recent_character_number);
                if (list.length > num) {
                    list.splice(num);
                }
                game.saveConfig('recentCharacter', list, true);
            },
            createCard: function (name, suit, number, nature, tags, specialEffects) {
                if (typeof name == 'object') {
                    nature = name.nature;
                    number = name.number;
                    suit = name.suit;
                    name = name.name;
                    if (tags) tags = name.tags;
                    if (specialEffects) specialEffects = name.specialEffects;
                }
                if (typeof name != 'string') {
                    name = 'sha';
                }
                var noclick = false;
                if (suit == 'noclick') {
                    noclick = true;
                    suit = null;
                }
                if (!lib.card[name]) console.log(name);
                if (!suit && lib.card[name] && lib.card[name].cardcolor) {
                    suit = lib.card[name].cardcolor;
                }
                if (!nature && lib.card[name] && lib.card[name].cardnature) {
                    nature = lib.card[name].cardnature;
                }
                if (typeof suit != 'string') {
                    suit = ['heart', 'diamond', 'club', 'spade'].randomGet();
                }
                else if (suit == 'black') {
                    suit = Math.random() < 0.5 ? 'club' : 'spade';
                }
                else if (suit == 'red') {
                    suit = Math.random() < 0.5 ? 'diamond' : 'heart';
                }
                if (typeof number != 'number' && typeof number != 'string') {
                    number = Math.ceil(Math.random() * 13);
                }
                var card;
                if (noclick) {
                    card = ui.create.card(ui.special, 'noclick', true);
                }
                else {
                    card = ui.create.card(ui.special);
                }
                card.storage.vanish = true;
                return card.init([suit, number, name, nature, tags, specialEffects]);
            },
            createCard2: function () {
                var card = game.createCard.apply(this, arguments);
                delete card.storage.vanish;
                return card;
            },
            forceOver: function (bool, callback) {
                _status.event.next.length = 0;
                let next = game.createEvent('finish_game');
                next.bool = bool;
                next.callback = callback;
                next.setContent('forceOver');
                if (_status.paused) {
                    game.uncheck();
                    game.resume();
                }
            },
            over: function (result) {
                if (_status.over) return;
                if (game.me._trueMe) game.swapPlayer(game.me._trueMe);
                var i, j, k, num, table, tr, td, dialog;
                _status.over = true;
                ui.control.show();
                ui.clear();
                game.stopCountChoose();
                if (ui.time3) {
                    clearInterval(ui.time3.interval);
                }
                if ((game.layout == 'long2' || game.layout == 'nova') && !game.chess) {
                    ui.arena.classList.add('choose-character');
                    ui.me.hide();
                    ui.mebg.hide()
                    ui.autonode.hide();
                    if (lib.config.radius_size != 'off') {
                        ui.historybar.style.borderRadius = '0 0 0 4px';
                    }
                }
                if (game.online) {
                    var dialog = ui.create.dialog();
                    dialog.noforcebutton = true;
                    dialog.content.innerHTML = result;
                    dialog.forcebutton = true;
                    var result2 = arguments[1];
                    if (result2 == true) {
                        dialog.content.firstChild.innerHTML = '战斗胜利';
                    }
                    else if (result2 == false) {
                        dialog.content.firstChild.innerHTML = '战斗失败';
                    }
                    ui.update();
                    dialog.add(ui.create.div('.placeholder'));
                    for (var i = 0; i < game.players.length; i++) {
                        var hs = game.players[i].getCards('h');
                        if (hs.length) {
                            dialog.add('<div class="text center">' + get.translation(game.players[i]) + '</div>');
                            dialog.addSmall(hs);
                        }
                    }

                    for (var j = 0; j < game.dead.length; j++) {
                        var hs = game.dead[j].getCards('h');
                        if (hs.length) {
                            dialog.add('<div class="text center">' + get.translation(game.dead[j]) + '</div>');
                            dialog.addSmall(hs);
                        }
                    }

                    dialog.add(ui.create.div('.placeholder.slim'));
                    if (lib.config.background_audio) {
                        if (result2 === true) {
                            game.playAudio('effect', 'win');
                        }
                        else if (result2 === false) {
                            game.playAudio('effect', 'lose');
                        }
                        else {
                            game.playAudio('effect', 'tie');
                        }
                    }
                    if (!ui.exit) {
                        ui.create.exit();
                    }
                    if (ui.giveup) {
                        ui.giveup.remove();
                        delete ui.giveup;
                    }
                    if (game.servermode) {
                        ui.exit.firstChild.innerHTML = '返回房间';
                        setTimeout(function () {
                            ui.exit.firstChild.innerHTML = '退出房间';
                            _status.roomtimeout = true;
                            lib.config.reconnect_info[2] = null;
                            game.saveConfig('reconnect_info', lib.config.reconnect_info);
                        }, 10000);
                    }
                    if (ui.tempnowuxie) {
                        ui.tempnowuxie.close();
                        delete ui.tempnowuxie;
                    }
                    if (ui.auto) ui.auto.hide();
                    if (ui.wuxie) ui.wuxie.hide();
                    if (game.getIdentityList) {
                        for (var i = 0; i < game.players.length; i++) {
                            game.players[i].setIdentity();
                        }
                    }
                    return;
                }
                if (lib.config.background_audio) {
                    if (result === true) {
                        game.playAudio('effect', 'win');
                    }
                    else if (result === false) {
                        game.playAudio('effect', 'lose');
                    }
                    else {
                        game.playAudio('effect', 'tie');
                    }
                }
                var resultbool = result;
                if (typeof resultbool !== 'boolean') {
                    resultbool = null;
                }
                if (result === true) result = '战斗胜利';
                if (result === false) result = '战斗失败';
                if (result == undefined) result = '战斗结束';
                dialog = ui.create.dialog(result);
                dialog.noforcebutton = true;
                dialog.forcebutton = true;
                if (game.addOverDialog) {
                    game.addOverDialog(dialog, result);
                }
                if (typeof _status.coin == 'number' && !_status.connectMode) {
                    var coeff = Math.random() * 0.4 + 0.8;
                    var added = 0;
                    var betWin = false;
                    if (result == '战斗胜利') {
                        if (_status.betWin) {
                            betWin = true;
                            _status.coin += 10;
                        }
                        _status.coin += 20;
                        if (_status.additionalReward) {
                            _status.coin += _status.additionalReward();
                        }
                        switch (lib.config.mode) {
                            case 'identity': {
                                switch (game.me.identity) {
                                    case 'zhu': case 'zhong': case 'mingzhong':
                                        if (get.config('enhance_zhu')) {
                                            added = 10;
                                        }
                                        else {
                                            added = 20;
                                        }
                                        break;
                                    case 'fan':
                                        if (get.config('enhance_zhu')) {
                                            added = 16;
                                        }
                                        else {
                                            added = 8;
                                        }
                                        break;
                                    case 'nei':
                                        added = 40;
                                        break;
                                }
                                added = added * (game.players.length + game.dead.length) / 8;
                                break;
                            }
                            case 'guozhan':
                                if (game.me.identity == 'ye') {
                                    added = 8;
                                }
                                else {
                                    added = 5 / get.totalPopulation(game.me.identity);
                                }
                                added = added * (game.players.length + game.dead.length);
                                break;
                            case 'versus':
                                if (_status.friend) {
                                    added = 5 * (game.players.length + _status.friend.length);
                                }
                                break;
                            default:
                                added = 10;
                        }
                    }
                    else {
                        added = 10;
                    }
                    if (lib.config.mode == 'chess' && _status.mode == 'combat' && get.config('additional_player')) {
                        added = 2;
                    }
                    _status.coin += added * coeff;
                    if (_status.coinCoeff) {
                        _status.coin *= _status.coinCoeff;
                    }
                    _status.coin = Math.ceil(_status.coin);
                    dialog.add(ui.create.div('', '获得' + _status.coin + '金'));
                    if (betWin) {
                        game.changeCoin(20);
                        dialog.content.appendChild(document.createElement('br'));
                        dialog.add(ui.create.div('', '（下注赢得10金）'));
                    }
                    game.changeCoin(_status.coin);
                }
                if (get.mode() == 'versus' && _status.ladder) {
                    var mmr = _status.ladder_mmr;
                    mmr += 10 - get.rank(game.me.name, true) * 2;
                    if (result == '战斗胜利') {
                        mmr = 20 + Math.round(mmr);
                        if (mmr > 40) {
                            mmr = 40;
                        }
                        else if (mmr < 10) {
                            mmr = 10;
                        }
                        dialog.add(ui.create.div('', '获得 ' + mmr + ' 积分'));
                    }
                    else {
                        mmr = -30 + Math.round(mmr / 2);
                        if (mmr > -20) {
                            mmr = -20;
                        }
                        else if (mmr < -35) {
                            mmr = -35;
                        }
                        if (lib.storage.ladder.current < 900) {
                            mmr = Math.round(mmr / 4);
                        }
                        else if (lib.storage.ladder.current < 1400) {
                            mmr = Math.round(mmr / 2);
                        }
                        else if (lib.storage.ladder.current < 2000) {
                            mmr = Math.round(mmr / 1.5);
                        }
                        else if (lib.storage.ladder.current > 2500) {
                            mmr = Math.round(mmr * 1.5);
                        }
                        dialog.add(ui.create.div('', '失去 ' + (-mmr) + ' 积分'));
                    }
                    if (_status.ladder_tmp) {
                        lib.storage.ladder.current += 40;
                        delete _status.ladder_tmp;
                    }
                    lib.storage.ladder.current += mmr;
                    if (lib.storage.ladder.top < lib.storage.ladder.current) {
                        lib.storage.ladder.top = lib.storage.ladder.current;
                    }
                    game.save('ladder', lib.storage.ladder);
                    if (ui.ladder && game.getLadderName) {
                        ui.ladder.innerHTML = game.getLadderName(lib.storage.ladder.current);
                    }
                }
                // if(true){
                var tableData = [];
                if (game.players.length) {
                    table = document.createElement('table');
                    tr = document.createElement('tr');
                    tr.appendChild(document.createElement('td'));
                    td = document.createElement('td');
                    td.innerHTML = '伤害';
                    tr.appendChild(td);
                    td = document.createElement('td');
                    td.innerHTML = '受伤';
                    tr.appendChild(td);
                    td = document.createElement('td');
                    td.innerHTML = '摸牌';
                    tr.appendChild(td);
                    td = document.createElement('td');
                    td.innerHTML = '出牌';
                    tr.appendChild(td);
                    td = document.createElement('td');
                    td.innerHTML = '杀敌';
                    tr.appendChild(td);
                    table.appendChild(tr);
                    for (i = 0; i < game.players.length; i++) {
                        var uploadDataRow = {}
                        tr = document.createElement('tr');
                        td = document.createElement('td');
                        td.innerHTML = get.translation(game.players[i]);
                        uploadDataRow.name = game.players[i].name; //名字拼音
                        uploadDataRow.transName = td.innerHTML; //名字
                        uploadDataRow.nickname = game.players[i].nickname;//昵称
                        tr.appendChild(td);
                        td = document.createElement('td');
                        num = 0;
                        for (j = 0; j < game.players[i].stat.length; j++) {
                            if (game.players[i].stat[j].damage != undefined) num += game.players[i].stat[j].damage;
                        }
                        td.innerHTML = num;
                        uploadDataRow.damage = num; //伤害
                        tr.appendChild(td);
                        td = document.createElement('td');
                        num = 0;
                        for (j = 0; j < game.players[i].stat.length; j++) {
                            if (game.players[i].stat[j].damaged != undefined) num += game.players[i].stat[j].damaged;
                        }
                        td.innerHTML = num;
                        uploadDataRow.damaged = num; //受伤
                        tr.appendChild(td);
                        td = document.createElement('td');
                        num = 0;
                        for (j = 0; j < game.players[i].stat.length; j++) {
                            if (game.players[i].stat[j].gain != undefined) num += game.players[i].stat[j].gain;
                        }
                        td.innerHTML = num;
                        uploadDataRow.gain = num; //摸牌
                        tr.appendChild(td);
                        td = document.createElement('td');
                        num = 0;
                        for (j = 0; j < game.players[i].stat.length; j++) {
                            for (k in game.players[i].stat[j].card) {
                                num += game.players[i].stat[j].card[k];
                            }
                        }
                        td.innerHTML = num;
                        uploadDataRow.card = num; //出牌
                        tr.appendChild(td);
                        td = document.createElement('td');
                        num = 0;
                        for (j = 0; j < game.players[i].stat.length; j++) {
                            if (game.players[i].stat[j].kill != undefined) num += game.players[i].stat[j].kill;
                        }
                        td.innerHTML = num;
                        uploadDataRow.kill = num; //杀敌
                        tr.appendChild(td);
                        table.appendChild(tr);
                        uploadDataRow.identity = get.translation(game.players[i].identity) //身份
                        uploadDataRow.alive = true; //存活
                        if (get.mode() == 'identity') {	//胜利或失败
                            if (game.zhu.isAlive()) {
                                if (game.players[i].identity == 'fan' || game.players[i].identity == 'nei') {
                                    uploadDataRow.winner = false;
                                }
                                else {
                                    uploadDataRow.winner = true;
                                }
                            }
                            else {
                                if (game.players.length == 1) {
                                    if (game.players[i].identity == 'zhong')
                                        uploadDataRow.winner = false;
                                    else
                                        uploadDataRow.winner = true;
                                }
                                else {
                                    if (game.players[i].identity == 'fan') {
                                        uploadDataRow.winner = true;
                                    }
                                    else
                                        uploadDataRow.winner = false;
                                }
                            }
                        }
                        else if (get.mode() == 'guozhan') {
                            uploadDataRow.winner = true;
                        }
                        else {
                            uploadDataRow.winner = true;
                        }
                        tableData.push(uploadDataRow)
                    }
                    dialog.add(ui.create.div('.placeholder'));
                    dialog.content.appendChild(table);
                }
                if (game.dead.length) {
                    table = document.createElement('table');
                    table.style.opacity = '0.5';
                    if (game.players.length == 0) {
                        tr = document.createElement('tr');
                        tr.appendChild(document.createElement('td'));
                        td = document.createElement('td');
                        td.innerHTML = '伤害';
                        tr.appendChild(td);
                        td = document.createElement('td');
                        td.innerHTML = '受伤';
                        tr.appendChild(td);
                        td = document.createElement('td');
                        td.innerHTML = '摸牌';
                        tr.appendChild(td);
                        td = document.createElement('td');
                        td.innerHTML = '出牌';
                        tr.appendChild(td);
                        td = document.createElement('td');
                        td.innerHTML = '杀敌';
                        tr.appendChild(td);
                        table.appendChild(tr);
                    }
                    for (i = 0; i < game.dead.length; i++) {
                        var uploadDataRow = {}
                        tr = document.createElement('tr');
                        td = document.createElement('td');
                        td.innerHTML = get.translation(game.dead[i]);
                        uploadDataRow.name = game.dead[i].name;//名字拼音
                        uploadDataRow.transName = td.innerHTML; //名字
                        uploadDataRow.nickname = game.dead[i].nickname;//昵称
                        tr.appendChild(td);
                        td = document.createElement('td');
                        num = 0;
                        for (j = 0; j < game.dead[i].stat.length; j++) {
                            if (game.dead[i].stat[j].damage != undefined) num += game.dead[i].stat[j].damage;
                        }
                        td.innerHTML = num;
                        uploadDataRow.damage = num; //伤害
                        tr.appendChild(td);
                        td = document.createElement('td');
                        num = 0;
                        for (j = 0; j < game.dead[i].stat.length; j++) {
                            if (game.dead[i].stat[j].damaged != undefined) num += game.dead[i].stat[j].damaged;
                        }
                        td.innerHTML = num;
                        uploadDataRow.damaged = num; //受伤
                        tr.appendChild(td);
                        td = document.createElement('td');
                        num = 0;
                        for (j = 0; j < game.dead[i].stat.length; j++) {
                            if (game.dead[i].stat[j].gain != undefined) num += game.dead[i].stat[j].gain;
                        }
                        td.innerHTML = num;
                        uploadDataRow.gain = num; //摸牌
                        tr.appendChild(td);
                        td = document.createElement('td');
                        num = 0;
                        for (j = 0; j < game.dead[i].stat.length; j++) {
                            for (k in game.dead[i].stat[j].card) {
                                num += game.dead[i].stat[j].card[k];
                            }
                        }
                        td.innerHTML = num;
                        uploadDataRow.card = num; //出牌
                        tr.appendChild(td);
                        td = document.createElement('td');
                        num = 0;
                        for (j = 0; j < game.dead[i].stat.length; j++) {
                            if (game.dead[i].stat[j].kill != undefined) num += game.dead[i].stat[j].kill;
                        }
                        td.innerHTML = num;
                        uploadDataRow.kill = num; //杀敌
                        tr.appendChild(td);
                        table.appendChild(tr);
                        uploadDataRow.identity = get.translation(game.dead[i].identity); //身份
                        uploadDataRow.alive = false; //存活
                        if (get.mode() == 'identity') {	//胜利或失败
                            if (game.zhu.isAlive()) {
                                if (game.dead[i].identity == 'fan' || game.dead[i].identity == 'nei') {
                                    uploadDataRow.winner = false;
                                }
                                else {
                                    uploadDataRow.winner = true;
                                }
                            }
                            else {
                                if (game.players.length == 1) {
                                    if (game.players[0].identity == 'nei') {
                                        uploadDataRow.winner = false;
                                    }
                                    else if (game.players[0].identity == 'fan') {
                                        if (game.dead[i].identity == 'fan')
                                            uploadDataRow.winner = true;
                                        else
                                            uploadDataRow.winner = false;
                                    }
                                }
                                else {
                                    if (game.dead[i].identity == 'fan') {
                                        uploadDataRow.winner = true;
                                    }
                                    else
                                        uploadDataRow.winner = false;
                                }
                            }
                        }
                        else if (get.mode() == 'guozhan') {
                            if (game.players[0] && (game.dead[i].identity == game.players[0])) {
                                if (game.dead[i].identity != 'ye') {
                                    uploadDataRow.winner = true;
                                }
                                else {
                                    uploadDataRow.winner = false;
                                }
                            }
                            else
                                uploadDataRow.winner = false;
                        }
                        else {
                            if (game.players[0] && (game.dead[i].identity == game.players[0])) {
                                if (game.dead[i].identity != 'ye') {
                                    uploadDataRow.winner = true;
                                }
                                else {
                                    uploadDataRow.winner = false;
                                }
                            }
                        }
                        tableData.push(uploadDataRow)
                    }
                    dialog.add(ui.create.div('.placeholder'));
                    dialog.content.appendChild(table);
                }
                var nowType = 'other'
                if (get.mode() == 'identity') nowType = 'identity'
                else if (get.mode() == 'guozhan') nowType = 'guozhan'
                var uploadData = { type: nowType, playerRecords: tableData }
                if (game.onlinezhu) {
                    try {
                        var xhr = new XMLHttpRequest();
                        var sendForm = new FormData();
                        sendForm.append('data', JSON.stringify(uploadData))
                        xhr.open('post', 'https://data.vtuberkill.com/game-records/', (e) => { console.log(e) })
                        xhr.send(sendForm);
                    }
                    catch (e) {
                        console.log(e);
                    }
                }
                if (game.additionaldead && game.additionaldead.length) {
                    table = document.createElement('table');
                    table.style.opacity = '0.5';
                    for (i = 0; i < game.additionaldead.length; i++) {
                        tr = document.createElement('tr');
                        td = document.createElement('td');
                        td.innerHTML = get.translation(game.additionaldead[i]);
                        tr.appendChild(td);
                        td = document.createElement('td');
                        num = 0;
                        for (j = 0; j < game.additionaldead[i].stat.length; j++) {
                            if (game.additionaldead[i].stat[j].damage != undefined) num += game.additionaldead[i].stat[j].damage;
                        }
                        td.innerHTML = num;
                        tr.appendChild(td);
                        td = document.createElement('td');
                        num = 0;
                        for (j = 0; j < game.additionaldead[i].stat.length; j++) {
                            if (game.additionaldead[i].stat[j].damaged != undefined) num += game.additionaldead[i].stat[j].damaged;
                        }
                        td.innerHTML = num;
                        tr.appendChild(td);
                        td = document.createElement('td');
                        num = 0;
                        for (j = 0; j < game.additionaldead[i].stat.length; j++) {
                            if (game.additionaldead[i].stat[j].gain != undefined) num += game.additionaldead[i].stat[j].gain;
                        }
                        td.innerHTML = num;
                        tr.appendChild(td);
                        td = document.createElement('td');
                        num = 0;
                        for (j = 0; j < game.additionaldead[i].stat.length; j++) {
                            for (k in game.additionaldead[i].stat[j].card) {
                                num += game.additionaldead[i].stat[j].card[k];
                            }
                        }
                        td.innerHTML = num;
                        tr.appendChild(td);
                        td = document.createElement('td');
                        num = 0;
                        for (j = 0; j < game.additionaldead[i].stat.length; j++) {
                            if (game.additionaldead[i].stat[j].kill != undefined) num += game.additionaldead[i].stat[j].kill;
                        }
                        td.innerHTML = num;
                        tr.appendChild(td);
                        table.appendChild(tr);
                    }
                    dialog.add(ui.create.div('.placeholder'));
                    dialog.content.appendChild(table);
                }
                // }
                dialog.add(ui.create.div('.placeholder'));

                var clients = game.players.concat(game.dead);
                for (var i = 0; i < clients.length; i++) {
                    if (clients[i].isOnline2()) {
                        clients[i].send(game.over, dialog.content.innerHTML, game.checkOnlineResult(clients[i]));
                    }
                }

                dialog.add(ui.create.div('.placeholder'));

                for (var i = 0; i < game.players.length; i++) {
                    if (!_status.connectMode && game.players[i].isUnderControl(true) && game.layout != 'long2') continue;
                    var hs = game.players[i].getCards('h');
                    if (hs.length) {
                        dialog.add('<div class="text center">' + get.translation(game.players[i]) + '</div>');
                        dialog.addSmall(hs);
                    }
                }
                for (var i = 0; i < game.dead.length; i++) {
                    if (!_status.connectMode && game.dead[i].isUnderControl(true) && game.layout != 'long2') continue;
                    var hs = game.dead[i].getCards('h');
                    if (hs.length) {
                        dialog.add('<div class="text center">' + get.translation(game.dead[i]) + '</div>');
                        dialog.addSmall(hs);
                    }
                }
                dialog.add(ui.create.div('.placeholder.slim'));
                game.addVideo('over', null, dialog.content.innerHTML);
                var vinum = parseInt(lib.config.video);
                if (!_status.video && vinum && game.getVideoName && window.indexedDB && _status.videoInited) {
                    var store = lib.db.transaction(['video'], 'readwrite').objectStore('video');
                    var videos = lib.videos.slice(0);
                    for (var i = 0; i < videos.length; i++) {
                        if (videos[i].starred) {
                            videos.splice(i--, 1);
                        }
                    }
                    for (var deletei = 0; deletei < 5; deletei++) {
                        if (videos.length >= vinum) {
                            var toremove = videos.pop();
                            lib.videos.remove(toremove);
                            store.delete(toremove.time);
                        }
                        else {
                            break;
                        }
                    }
                    var me = game.me || game.players[0];
                    if (!me) return;
                    var newvid = {
                        name: game.getVideoName(),
                        mode: lib.config.mode,
                        video: lib.video,
                        win: result == '战斗胜利',
                        name1: me.name1 || me.name,
                        name2: me.name2,
                        time: lib.getUTC(new Date())
                    };
                    var modecharacters = lib.characterPack['mode_' + get.mode()];
                    if (modecharacters) {
                        if (get.mode() == 'guozhan') {
                            if (modecharacters[newvid.name1]) {
                                if (newvid.name1.indexOf('gz_shibing') == 0) {
                                    newvid.name1 = newvid.name1.slice(3, 11);
                                }
                                else {
                                    newvid.name1 = newvid.name1.slice(3);
                                }
                            }
                            if (modecharacters[newvid.name2]) {
                                if (newvid.name2.indexOf('gz_shibing') == 0) {
                                    newvid.name2 = newvid.name2.slice(3, 11);
                                }
                                else {
                                    newvid.name2 = newvid.name2.slice(3);
                                }
                            }
                        }
                        else {
                            if (modecharacters[newvid.name1]) {
                                newvid.name1 = get.mode() + '::' + newvid.name1;
                            }
                            if (modecharacters[newvid.name2]) {
                                newvid.name2 = get.mode() + '::' + newvid.name2;
                            }
                        }
                    }
                    if (newvid.name1 && newvid.name1.indexOf('subplayer_') == 0) {
                        newvid.name1 = newvid.name1.slice(10, newvid.name1.lastIndexOf('_'));
                    }
                    if (newvid.name2 && newvid.name2.indexOf('subplayer_') == 0) {
                        newvid.name1 = newvid.name2.slice(10, newvid.name1.lastIndexOf('_'));
                    }
                    lib.videos.unshift(newvid);
                    store.put(newvid);
                    ui.create.videoNode(newvid, true);
                }
                // _status.auto=false;
                if (ui.auto) {
                    // ui.auto.classList.remove('glow');
                    ui.auto.hide();
                }
                if (ui.wuxie) ui.wuxie.hide();
                if (ui.giveup) {
                    ui.giveup.remove();
                    delete ui.giveup;
                }

                if (lib.config.test_game && !_status.connectMode) {
                    if (typeof lib.config.test_game !== 'string') {
                        switch (lib.config.mode) {
                            case 'identity': game.saveConfig('mode', 'guozhan'); break;
                            case 'guozhan': game.saveConfig('mode', 'versus'); break;
                            case 'versus': game.saveConfig('mode', 'boss'); break;
                            case 'boss': game.saveConfig('mode', 'chess'); break;
                            case 'chess': game.saveConfig('mode', 'stone'); break;
                            case 'stone': game.saveConfig('mode', 'identity'); break;
                        }
                    }
                    setTimeout(game.reload, 500);
                }
                if (game.controlOver) {
                    game.controlOver(); return;
                }
                if (!_status.brawl) {
                    if (lib.config.mode == 'boss') {
                        ui.create.control('再战', function () {
                            var pointer = game.boss;
                            var map = { boss: game.me == game.boss, links: [] };
                            for (var iwhile = 0; iwhile < 10; iwhile++) {
                                pointer = pointer.nextSeat;
                                if (pointer == game.boss) {
                                    break;
                                }
                                if (!pointer.side) {
                                    map.links.push(pointer.name);
                                }
                            }
                            game.saveConfig('continue_name_boss', map);
                            game.saveConfig('mode', lib.config.mode);
                            localStorage.setItem(lib.configprefix + 'directstart', true);
                            game.reload();
                        });
                    }
                    else if (lib.config.mode == 'versus') {
                        if (_status.mode == 'standard' || _status.mode == 'three') {
                            ui.create.control('再战', function () {
                                game.saveConfig('continue_name_versus' + (_status.mode == 'three' ? '_three' : ''), {
                                    friend: _status.friendBackup,
                                    enemy: _status.enemyBackup,
                                    color: _status.color
                                });
                                game.saveConfig('mode', lib.config.mode);
                                localStorage.setItem(lib.configprefix + 'directstart', true);
                                game.reload();
                            });
                        }
                    }
                    else if (!_status.connectMode && get.config('continue_game') && !ui.continue_game && !_status.brawl && !game.no_continue_game) {
                        ui.continue_game = ui.create.control('再战', game.reloadCurrent);
                    }
                }
                if (!ui.restart) {
                    if (game.onlineroom && typeof game.roomId == 'number') {
                        ui.restart = ui.create.control('restart', function () {
                            game.broadcastAll(function () {
                                if (ui.exit) {
                                    ui.exit.stay = true;
                                    ui.exit.firstChild.innerHTML = '返回房间';
                                }
                            });
                            game.saveConfig('tmp_owner_roomId', game.roomId);
                            setTimeout(game.reload, 100);
                        });
                    }
                    else {
                        ui.restart = ui.create.control('restart', game.reload);
                    }
                }
                if (ui.tempnowuxie) {
                    ui.tempnowuxie.close();
                    delete ui.tempnowuxie;
                }

                if (ui.revive) {
                    ui.revive.close();
                    delete ui.revive;
                }
                if (ui.swap) {
                    ui.swap.close();
                    delete ui.swap;
                }
                for (var i = 0; i < lib.onover.length; i++) {
                    lib.onover[i](resultbool);
                }
                if (game.addRecord) {
                    game.addRecord(resultbool);
                }
                if (window.isNonameServer) {
                    lib.configOL.gameStarted = false;
                    game.saveConfig('pagecfg' + window.isNonameServer, [lib.configOL, game.roomId, _status.onlinenickname, _status.onlineavatar]);
                    game.reload();
                }
                else if (_status.connectMode && !game.online) {
                    setTimeout(game.reload, 15000)
                }
            },
            /**
             * 游戏事件循环
             * @function
             */
            loop: function () {
                var Evt = _status.event;
                var step = Evt.step;
                var source = Evt.source;
                var player = Evt.player;
                var target = Evt.target;
                var targets = Evt.targets;
                var card = Evt.card;
                var cards = Evt.cards;
                var skill = Evt.skill;
                var forced = Evt.forced;
                var num = Evt.num;
                var trigger = Evt._trigger;
                var result = Evt._result;
                if (_status.paused2 || _status.imchoosing) {
                    if (!lib.status.dateDelaying) {
                        lib.status.dateDelaying = new Date();
                    }
                }
                if (_status.paused || _status.paused2 || _status.over) {
                    return;
                }
                if (_status.paused3) {
                    _status.paused3 = 'paused';
                    return;
                }
                if (lib.status.dateDelaying) {
                    lib.status.dateDelayed += lib.getUTC(new Date()) - lib.getUTC(lib.status.dateDelaying);
                    delete lib.status.dateDelaying;
                }
                if (Evt.next.length > 0) {
                    let next = Evt.next.shift();
                    if (next.player && next.player.skipList.contains(next.name)) {
                        Evt.trigger(next.name + 'Skipped');
                        next.player.skipList.remove(next.name);
                        if (lib.phaseName.contains(next.name)) next.player.getHistory('skipped').add(next.name);
                    }
                    else {
                        /**
                         * _status.event.parent(即Evt.parent)：当前正在执行事件的父事件
                         * 当_status.event.next或_status.event.after内的事件被执行时，当前事件会成为被执行事件的父事件
                         * @name _status.event_parent
                         * @type {!Object}
                         */
                        next.parent = Evt;
                        /**
                         * _status.event.player(即Evt.player)：当前正在执行事件的角色
                         * @name _status.event_player
                         * @type {!HTMLDivElement}
                         */
                        /**
                         * _status.event.target(即Evt.target)：当前正在执行事件的目标
                         * @name _status.event_target
                         * @type {!HTMLDivElement}
                         */
                        _status.event = next;
                    }
                }
                else if (Evt.finished) {
                    if (Evt._triggered == 1) {
                        if (Evt.type == 'card') Evt.trigger('useCardToOmitted');
                        Evt.trigger(Evt.name + 'Omitted');
                        Evt._triggered = 4;
                    }
                    else if (Evt._triggered == 2) {
                        if (Evt.type == 'card') Evt.trigger('useCardToEnd');
                        Evt.trigger(Evt.name + 'End');
                        Evt._triggered = 3;
                    }
                    else if (Evt._triggered == 3) {
                        if (Evt.type == 'card') Evt.trigger('useCardToAfter');
                        Evt.trigger(Evt.name + 'After');
                        Evt._triggered++;
                    }
                    else if (Evt.after && Evt.after.length) {
                        let next = Evt.after.shift();
                        if (next.player && next.player.skipList.contains(next.name)) {
                            Evt.trigger(next.name + 'Skipped');
                            next.player.skipList.remove(next.name);
                            if (lib.phaseName.contains(next.name)) next.player.getHistory('skipped').add(next.name)
                        }
                        else {
                            next.parent = Evt;
                            _status.event = next;
                        }
                    }
                    else {
                        if (Evt.parent) {
                            if (Evt.result) {
                                Evt.parent._result = Evt.result;
                            }
                            _status.event = Evt.parent;
                        }
                        else {
                            return;
                        }
                    }
                }
                else {
                    if (Evt._triggered == 0) {
                        if (Evt.type == 'card') Evt.trigger('useCardToBefore');
                        Evt.trigger(Evt.name + 'Before');
                        Evt._triggered++;
                    }
                    else if (Evt._triggered == 1) {
                        if (Evt.type == 'card') Evt.trigger('useCardToBegin');
                        if (Evt.name == 'phase' && !Evt._begun) {
                            let next = game.createEvent('phasing', false, Evt);
                            next.player = Evt.player;
                            next.skill = Evt.skill;
                            next.setContent('phasing');
                            Evt._begun = true;
                        }
                        else {
                            Evt.trigger(Evt.name + 'Begin');
                            Evt._triggered++;
                        }
                    }
                    else {
                        if (player && player.classList.contains('dead') && !Evt.forceDie && Evt.name != 'phaseLoop') {
                            game.broadcastAll(function () {
                                while (_status.dieClose.length) {
                                    _status.dieClose.shift().close();
                                }
                            });
                            if (Evt._oncancel) {
                                Evt._oncancel();
                            }
                            Evt.finish();
                        }
                        else if (player && player.removed && Evt.name != 'phaseLoop') {
                            Evt.finish();
                        }
                        else if (player && player.isOut() && Evt.name != 'phaseLoop' && !Evt.includeOut) {
                            if (Evt.name == 'phase' && player == _status.roundStart && !Evt.skill) {
                                _status.roundSkipped = true;
                            }
                            Evt.finish();
                        }
                        else {
                            if (_status.withError || lib.config.compatiblemode || (_status.connectMode && !lib.config.debug)) {
                                try {
                                    Evt.content(Evt, step, source, player, target, targets,
                                        card, cards, skill, forced, num, trigger, result,
                                        _status, lib, game, ui, get, ai);
                                }
                                catch (e) {
                                    game.print('游戏出错：' + Evt.name);
                                    game.print(e.toString());
                                    console.log(e);
                                }
                            }
                            else {
                                Evt.content(Evt, step, source, player, target, targets,
                                    card, cards, skill, forced, num, trigger, result,
                                    _status, lib, game, ui, get, ai);
                            }
                        }
                        Evt.step++;
                    }
                }
                game.loop();
            },
            pause: function () {
                clearTimeout(_status.timeout);
                _status.paused = true;
            },
            pause2: function () {
                if (_status.connectMode) return;
                _status.paused2 = true;
            },
            resume: function () {
                if (_status.paused) {
                    if (!_status.noclearcountdown) {
                        game.stopCountChoose();
                    }
                    _status.paused = false;
                    delete _status.waitingForTransition;
                    game.loop();
                }
            },
            resume2: function () {
                if (_status.connectMode) return;
                if (_status.paused2) {
                    _status.paused2 = false;
                    game.loop();
                }
            },
            delay: function (time, time2) {
                if (_status.paused) return;
                game.pause();
                if (typeof time != 'number') time = 1;
                if (typeof time2 != 'number') time2 = 0;
                time = time * lib.config.duration + time2;
                if (lib.config.speed == 'vvfast') time /= 3;
                _status.timeout = setTimeout(game.resume, time);
            },
            delayx: function (time, time2) {
                if (typeof time != 'number') time = 1;
                switch (lib.config.game_speed) {
                    case 'vslow': time *= 2.5; break;
                    case 'slow': time *= 1.5; break;
                    case 'fast': time *= 0.7; break;
                    case 'vfast': time *= 0.4; break;
                    case 'vvfast': time *= 0.2; break;
                }
                return game.delay(time, time2);
            },
            /**
             * 检测玩家是否选择完毕(选择按钮`Evt.filterButton`，选择卡牌`Evt.filterCard`，选择对象`Evt.filterTarget`)
             * @param {?GameCores.Bases.Event} Evt 要处理的事件，如果为null，使用当前事件
             * @returns {(undefined|boolean)} 如果事件不需要等待玩家选择，返回undefined；如果事件选择完毕，返回true；否则返回false
             */
            check: function (Evt) {
                var i, j, range;
                if (Evt == undefined) Evt = _status.event;
                var custom = Evt.custom || {};
                var ok = true, auto = true;
                var player = Evt.player;
                var auto_confirm = lib.config.auto_confirm;
                var players = game.players.slice(0);
                if (Evt.deadTarget) players.addArray(game.dead);
                if (!Evt.filterButton && !Evt.filterCard && !Evt.filterTarget && (!Evt.skill || !Evt._backup)) {
                    if (Evt.choosing) {
                        _status.imchoosing = true;//??
                    }
                    return;
                }
                player.node.equips.classList.remove('popequip');
                //button
                if (Evt.filterButton) {
                    var dialog = Evt.dialog;
                    range = get.select(Evt.selectButton);
                    var selectableButtons = false;
                    if (Evt.forceAuto && ui.selected.buttons.length == range[1]) auto = true;
                    else if (range[0] != range[1] || range[0] > 1) auto = false;
                    for (i = 0; i < dialog.buttons.length; i++) {
                        if (dialog.buttons[i].classList.contains('unselectable')) continue;
                        if (Evt.filterButton(dialog.buttons[i], player) && lib.filter.buttonIncluded(dialog.buttons[i])) {
                            if (ui.selected.buttons.length < range[1]) {
                                dialog.buttons[i].classList.add('selectable');
                            }
                            else if (range[1] == -1) {
                                dialog.buttons[i].classList.add('selected');
                                ui.selected.buttons.add(dialog.buttons[i]);
                            }
                            else {
                                dialog.buttons[i].classList.remove('selectable');
                            }
                        }
                        else {
                            dialog.buttons[i].classList.remove('selectable');
                            if (range[1] == -1) {
                                dialog.buttons[i].classList.remove('selected');
                                ui.selected.buttons.remove(dialog.buttons[i]);
                            }
                        }
                        if (dialog.buttons[i].classList.contains('selected')) {
                            dialog.buttons[i].classList.add('selectable');
                        }
                        else if (!selectableButtons && dialog.buttons[i].classList.contains('selectable')) {
                            selectableButtons = true;
                        }
                    }
                    if (ui.selected.buttons.length < range[0]) {
                        if (!Evt.forced || selectableButtons) {
                            ok = false;
                        }
                        if (Evt.complexSelect || Evt.getParent().name == 'chooseCharacter' || Evt.getParent().name == 'chooseButtonOL') {
                            ok = false;
                        }
                    }
                    if (custom.add.button) {
                        custom.add.button();
                    }
                }
                //card
                if (Evt.filterCard) {
                    if (ok == false) {
                        game.uncheck('card');
                    }
                    else {
                        var cards = player.getCards(Evt.position);
                        var firstCheck = false;
                        range = get.select(Evt.selectCard);
                        if (!Evt._cardChoice && typeof Evt.selectCard != 'function' &&
                            !Evt.complexCard && range[1] > -1 && !lib.config.compatiblemode) {
                            Evt._cardChoice = [];
                            firstCheck = true;
                        }
                        if (Evt.isMine() && Evt.name == 'chooseToUse' && Evt.parent.name == 'phaseUse' && !Evt.skill &&
                            !Evt._targetChoice && !firstCheck && window.Map && !lib.config.compatiblemode) {
                            Evt._targetChoice = new Map();
                            for (var i = 0; i < Evt._cardChoice.length; i++) {
                                if (!lib.card[Evt._cardChoice[i].name].complexTarget) {
                                    var targets = [];
                                    for (var j = 0; j < players.length; j++) {
                                        if (Evt.filterTarget(Evt._cardChoice[i], player, players[j])) {
                                            targets.push(players[j]);
                                        }
                                    }
                                    Evt._targetChoice.set(Evt._cardChoice[i], targets);
                                }
                            }
                        }
                        var selectableCards = false;
                        if (range[0] != range[1] || range[0] > 1) auto = false;
                        for (i = 0; i < cards.length; i++) {
                            if (lib.config.cardtempname != 'off') {
                                var cardname = get.name(cards[i]);
                                var cardnature = get.nature(cards[i]);
                                if (cards[i].name != cardname || ((cardnature || cards[i].nature) && cards[i].nature != cardnature)) {
                                    if (!cards[i]._tempName) cards[i]._tempName = ui.create.div('.tempname', cards[i]);
                                    var tempname = get.translation(cardname);
                                    cards[i]._tempName.dataset.nature = 'fire';
                                    if (cardname == 'sha') {
                                        if (cardnature) tempname = get.translation(cardnature) + tempname;
                                        if (cardnature == 'thunder') cards[i]._tempName.dataset.nature = 'thunder';
                                        if (cardnature == 'kami') cards[i]._tempName.dataset.nature = 'kami';
                                        if (cardnature == 'ice') cards[i]._tempName.dataset.nature = 'ice';
                                        if (cardnature == 'ocean') cards[i]._tempName.dataset.nature = 'ocean';
                                        if (cardnature == 'yami') cards[i]._tempName.dataset.nature = 'yami';
                                    }
                                    cards[i]._tempName.innerHTML = lib.config.cardtempname == 'default' ? get.verticalStr(tempname) : tempname;
                                    cards[i]._tempName.tempname = tempname;
                                }
                            }
                            var nochess = true;
                            if (!lib.filter.cardAiIncluded(cards[i])) {
                                nochess = false;
                            }
                            else if (Evt._cardChoice && !firstCheck) {
                                if (!Evt._cardChoice.contains(cards[i])) {
                                    nochess = false;
                                }
                            }
                            else {
                                if (player.isOut() || !lib.filter.cardRespondable(cards[i], player) ||
                                    cards[i].classList.contains('uncheck') ||
                                    !Evt.filterCard(cards[i], player)) {
                                    nochess = false;
                                }
                            }
                            if (nochess) {
                                if (ui.selected.cards.length < range[1]) {
                                    cards[i].classList.add('selectable');
                                    if (Evt._cardChoice && firstCheck) {
                                        Evt._cardChoice.push(cards[i]);
                                    }
                                }
                                else if (range[1] == -1) {
                                    cards[i].classList.add('selected');
                                    cards[i].updateTransform(true);
                                    ui.selected.cards.add(cards[i]);
                                }
                                else {
                                    cards[i].classList.remove('selectable');
                                }
                            }
                            else {
                                cards[i].classList.remove('selectable');
                                if (range[1] == -1) {
                                    cards[i].classList.remove('selected');
                                    cards[i].updateTransform();
                                    ui.selected.cards.remove(cards[i]);
                                }
                            }
                            if (cards[i].classList.contains('selected')) {
                                cards[i].classList.add('selectable');
                            }
                            else if (!selectableCards && cards[i].classList.contains('selectable')) {
                                selectableCards = true;
                            }
                        }
                        if (ui.selected.cards.length < range[0]) {
                            if (!Evt.forced || selectableCards || Evt.complexSelect) {
                                ok = false;
                            }
                        }

                        if (lib.config.popequip && get.is.phoneLayout() &&
                            typeof Evt.position == 'string' && Evt.position.indexOf('e') != -1 &&
                            player.node.equips.querySelector('.card.selectable')) {
                            player.node.equips.classList.add('popequip');
                            auto_confirm = false;
                        }
                    }
                    if (custom.add.card) {
                        custom.add.card();
                    }
                }
                //player
                if (Evt.filterTarget) {
                    if (ok == false) {
                        game.uncheck('target');
                    }
                    else {
                        var card = get.card();
                        var firstCheck = false;
                        range = get.select(Evt.selectTarget);
                        var selectableTargets = false;
                        if (range[0] != range[1] || range[0] > 1) auto = false;
                        for (i = 0; i < players.length; i++) {
                            var nochess = true;
                            if (game.chess && !Evt.chessForceAll && player && get.distance(player, players[i], 'pure') > 7) {
                                nochess = false;
                            }
                            else if (players[i].isOut()) {
                                nochess = false;
                            }
                            else if (Evt._targetChoice && Evt._targetChoice.has(card)) {
                                var targetChoice = Evt._targetChoice.get(card);
                                if (!Array.isArray(targetChoice) || !targetChoice.contains(players[i])) {
                                    nochess = false;
                                }
                            }
                            else if (!Evt.filterTarget(card, player, players[i])) {
                                nochess = false;
                            }
                            if (nochess) {
                                if (ui.selected.targets.length < range[1]) {
                                    players[i].classList.add('selectable');
                                    if (Array.isArray(Evt._targetChoice)) {
                                        Evt._targetChoice.push(players[i]);
                                    }
                                }
                                else if (range[1] == -1) {
                                    players[i].classList.add('selected');
                                    ui.selected.targets.add(players[i]);
                                }
                                else {
                                    players[i].classList.remove('selectable');
                                }
                            }
                            else {
                                players[i].classList.remove('selectable');
                                if (range[1] == -1) {
                                    players[i].classList.remove('selected');
                                    ui.selected.targets.remove(players[i]);
                                }
                            }
                            if (players[i].classList.contains('selected')) {
                                players[i].classList.add('selectable');
                            }
                            else if (!selectableTargets && players[i].classList.contains('selectable')) {
                                selectableTargets = true;
                            }
                            if (players[i].instance) {
                                if (players[i].classList.contains('selected')) {
                                    players[i].instance.classList.add('selected');
                                }
                                else {
                                    players[i].instance.classList.remove('selected');
                                }
                                if (players[i].classList.contains('selectable')) {
                                    players[i].instance.classList.add('selectable');
                                }
                                else {
                                    players[i].instance.classList.remove('selectable');
                                }
                            }
                        }
                        if (ui.selected.targets.length < range[0]) {
                            if (!Evt.forced || selectableTargets || Evt.complexSelect) {
                                ok = false;
                            }
                        }
                        if (range[1] == -1 && ui.selected.targets.length == 0 && Evt.targetRequired) {
                            ok = false;
                        }
                    }
                    if (custom.add.target) {
                        custom.add.target();
                    }
                }
                //skill
                if (!Evt.skill && get.noSelected() && !_status.noconfirm) {
                    var skills = [], enable, info;
                    var skills2;
                    if (Evt._skillChoice) {
                        skills2 = Evt._skillChoice;
                        for (var i = 0; i < skills2.length; i++) {
                            if (Evt.isMine() || !Evt._aiexclude.contains(skills2[i])) {
                                skills.push(skills2[i]);
                            }
                        }
                    }
                    else {
                        var skills2;
                        if (get.mode() == 'guozhan' && player.hasSkillTag('nomingzhi', false, null, true)) {
                            skills2 = player.getSkills(false, true, false);
                        }
                        else {
                            skills2 = player.getSkills(true, true, false);
                        }
                        skills2 = game.filterSkills(skills2.concat(lib.skill.global), player, player.getSkills('e').concat(lib.skill.global));
                        Evt._skillChoice = [];
                        game.expandSkills(skills2);
                        for (i = 0; i < skills2.length; i++) {
                            _status.event.skillBy = skills2[i];
                            info = get.info(skills2[i]);
                            enable = false;
                            if (typeof info.enable == 'function') enable = info.enable(Evt);
                            else if (typeof info.enable == 'object') enable = info.enable.contains(Evt.name);
                            else if (info.enable == 'phaseUse') enable = (Evt.type == 'phase');
                            else if (typeof info.enable == 'string') enable = (info.enable == Evt.name);
                            if (enable) {
                                if (!game.expandSkills(player.getSkills().concat(lib.skill.global)).contains(skills2[i]) && (info.noHidden || get.mode() != 'guozhan' || player.hasSkillTag('nomingzhi', false, null, true))) enable = false;
                                if (info.filter && !info.filter(Evt, player)) enable = false;
                                if (info.viewAs && typeof info.viewAs != 'function' && Evt.filterCard && !Evt.filterCard(info.viewAs, player, Evt)) enable = false;
                                if (info.viewAs && typeof info.viewAs != 'function' && info.viewAsFilter && info.viewAsFilter(player) == false) enable = false;
                                if (info.usable && get.skillCount(skills2[i]) >= info.usable) enable = false;
                                if (info.chooseButton && _status.event.noButton) enable = false;
                                if (info.round && player.storage[_status.event.skillBy + '_roundcount'] > 0) enable = false;
                            }
                            if (enable) {
                                if (Evt.isMine() || !Evt._aiexclude.contains(skills2[i])) {
                                    skills.add(skills2[i]);
                                }
                                Evt._skillChoice.add(skills2[i]);
                            }
                            delete _status.event.skillBy;
                        }
                    }

                    var globalskills = [];
                    var globallist = lib.skill.global.slice(0);
                    game.expandSkills(globallist);
                    for (var i = 0; i < skills.length; i++) {
                        if (globallist.contains(skills[i])) {
                            globalskills.push(skills.splice(i--, 1)[0]);
                        }
                    }
                    var equipskills = [];
                    var ownedskills = player.getSkills(true, false);
                    game.expandSkills(ownedskills);
                    for (var i = 0; i < skills.length; i++) {
                        if (!ownedskills.contains(skills[i])) {
                            equipskills.push(skills.splice(i--, 1)[0]);
                        }
                    }
                    if (equipskills.length) {
                        ui.create.skills3(equipskills);
                    }
                    else if (ui.skills3) {
                        ui.skills3.close();
                    }
                    if (skills.length) {
                        ui.create.skills(skills);
                    }
                    else if (ui.skills) {
                        ui.skills.close();
                    }
                    if (globalskills.length) {
                        ui.create.skills2(globalskills);
                    }
                    else if (ui.skills2) {
                        ui.skills2.close();
                    }
                }
                else {
                    if (ui.skills) {
                        ui.skills.close()
                    }
                    if (ui.skills2) {
                        ui.skills2.close()
                    }
                    if (ui.skills3) {
                        ui.skills3.close()
                    }
                }
                //is multipled targets
                _status.multitarget = false;
                var skillinfo = get.info(_status.event.skill);
                if (_status.event.name == 'chooseToUse') {
                    if (skillinfo && skillinfo.multitarget && !skillinfo.multiline) {
                        _status.multitarget = true;
                    }
                    if ((skillinfo && skillinfo.viewAs && typeof skillinfo.viewAs != 'function') || !_status.event.skill) {
                        var cardinfo = get.info(get.card());
                        if (cardinfo && cardinfo.multitarget && !cardinfo.multiline) {
                            _status.multitarget = true;
                        }
                    }
                }
                else if (_status.event.multitarget) {
                    _status.multitarget = true;
                }

                if (Evt.isMine()) {
                    if (game.chess && game.me && get.config('show_distance')) {
                        for (var i = 0; i < players.length; i++) {
                            if (players[i] == game.me) {
                                players[i].node.action.hide();
                            }
                            else {
                                players[i].node.action.show();
                                var dist = get.distance(game.me, players[i], 'pure');
                                var dist2 = get.distance(game.me, players[i]);
                                players[i].node.action.innerHTML = '距离：' + dist2 + '/' + dist;
                                if (dist > 7) {
                                    players[i].node.action.classList.add('thunder');
                                }
                                else {
                                    players[i].node.action.classList.remove('thunder');
                                }
                            }
                        }
                    }
                    if (ok && auto && (auto_confirm || (skillinfo && skillinfo.direct)) && (!_status.mousedragging || !_status.mouseleft) &&
                        !_status.mousedown && !_status.touchnocheck) {
                        if (ui.confirm) {
                            if (!skillinfo || !skillinfo.preservecancel) {
                                ui.confirm.close();
                            }
                        }
                        if (skillinfo && skillinfo.preservecancel && !ui.confirm) {
                            ui.create.confirm('c');
                        }
                        if (Evt.skillDialog == true) Evt.skillDialog = false;
                        ui.click.ok();
                        _status.mousedragging = null;
                    }
                    else {
                        ui.arena.classList.add('selecting');
                        if (Evt.filterTarget && (!Evt.filterCard || !Evt.position || (typeof Evt.position == 'string' && Evt.position.indexOf('e') == -1))) {
                            ui.arena.classList.add('tempnoe');
                        }
                        game.countChoose();
                        if (!_status.noconfirm && !_status.event.noconfirm) {
                            if (!_status.mousedown || _status.mouseleft) {
                                var str = '';
                                if (ok) str += 'o';
                                if (!Evt.forced && !Evt.fakeforce && get.noSelected()) str += 'c';
                                ui.create.confirm(str);
                            }
                        }
                    }
                    if (ui.confirm && ui.confirm.lastChild.link == 'cancel') {
                        if (_status.event.type == 'phase' && !_status.event.skill) {
                            ui.confirm.lastChild.innerHTML = '结束';
                        }
                        else {
                            ui.confirm.lastChild.innerHTML = '取消';
                        }
                    }
                }
                return ok;
            },
            uncheck: function () {
                var i, j;
                if (game.chess) {
                    var shadows = ui.chessContainer.getElementsByClassName('playergrid temp');
                    while (shadows.length) {
                        shadows[0].remove();
                    }
                }
                var argc = arguments.length;
                var args = new Array(argc);
                for (var i = 0; i < argc; i++) {
                    args[i] = arguments[i];
                }
                if ((args.length == 0 || args.contains('card')) && _status.event.player) {
                    var cards = _status.event.player.getCards('hejs');
                    for (j = 0; j < cards.length; j++) {
                        cards[j].classList.remove('selected');
                        cards[j].classList.remove('selectable');
                        if (cards[j]._tempName) {
                            cards[j]._tempName.delete();
                            delete cards[j]._tempName;
                        }
                        cards[j].updateTransform();
                    }
                    ui.selected.cards.length = 0;
                    _status.event.player.node.equips.classList.remove('popequip');
                }
                var players = game.players.slice(0);
                if (_status.event.deadTarget) players.addArray(game.dead);
                if ((args.length == 0 || args.contains('target'))) {
                    for (j = 0; j < players.length; j++) {
                        players[j].classList.remove('selected');
                        players[j].classList.remove('selectable');
                        if (players[j].instance) {
                            players[j].instance.classList.remove('selected');
                            players[j].instance.classList.remove('selectable');
                        }
                    }
                    ui.selected.targets.length = 0;
                }
                if ((args.length == 0 || args.contains('button')) && _status.event.dialog && _status.event.dialog.buttons) {
                    for (var j = 0; j < _status.event.dialog.buttons.length; j++) {
                        _status.event.dialog.buttons[j].classList.remove('selectable');
                        _status.event.dialog.buttons[j].classList.remove('selected');
                    }
                    ui.selected.buttons.length = 0;
                }
                if (args.length == 0) {
                    ui.arena.classList.remove('selecting');
                    ui.arena.classList.remove('tempnoe');
                    _status.imchoosing = false;
                    _status.lastdragchange.length = 0;
                    _status.mousedragging = null;
                    _status.mousedragorigin = null;

                    while (ui.touchlines.length) {
                        ui.touchlines.shift().delete();
                    }
                }
                ui.canvas.width = ui.arena.offsetWidth;
                ui.canvas.height = ui.arena.offsetHeight;
                for (var i = 0; i < players.length; i++) {
                    players[i].unprompt();
                }
                for (var i = 0; i < _status.dragline.length; i++) {
                    if (_status.dragline[i]) _status.dragline[i].remove();
                }
                ui.arena.classList.remove('dragging');
                _status.dragline.length = 0;
            },
            swapSeat: function (player1, player2, prompt, behind, noanimate) {
                if (noanimate) {
                    player1.style.transition = 'all 0s';
                    player2.style.transition = 'all 0s';
                    ui.refresh(player1);
                    ui.refresh(player2);
                }
                if (behind) {
                    var totalPopulation = game.players.length + game.dead.length + 1;
                    for (var iwhile = 0; iwhile < totalPopulation; iwhile++) {
                        if (player1.next != player2) {
                            game.swapSeat(player1, player1.next, false, false);
                        }
                        else {
                            break;
                        }
                    }
                    if (prompt != false) {
                        game.log(player1, '将座位移至', player2, '后');
                    }
                }
                else {
                    game.addVideo('swapSeat', null, [player1.dataset.position, player2.dataset.position]);
                    var temp1, pos, i, num;
                    temp1 = player1.dataset.position;
                    player1.dataset.position = player2.dataset.position;
                    player2.dataset.position = temp1;
                    game.arrangePlayers();
                    if (!game.chess) {
                        if (player1.dataset.position == '0' || player2.dataset.position == '0') {
                            pos = parseInt(player1.dataset.position);
                            if (pos == 0) pos = parseInt(player2.dataset.position);
                            num = game.players.length + game.dead.length;
                            for (i = 0; i < game.players.length; i++) {
                                temp1 = parseInt(game.players[i].dataset.position) - pos;
                                if (temp1 < 0) temp1 += num;
                                game.players[i].dataset.position = temp1;
                            }
                            for (i = 0; i < game.dead.length; i++) {
                                temp1 = parseInt(game.dead[i].dataset.position) - pos;
                                if (temp1 < 0) temp1 += num;
                                game.dead[i].dataset.position = temp1;
                            }
                        }
                    }
                    if (prompt != false) {
                        game.log(player1, '和', player2, '交换了座位');
                    }
                }
                if (noanimate) {
                    setTimeout(function () {
                        player1.style.transition = '';
                        player2.style.transition = '';
                    }, 200);
                }
            },
            swapPlayer: function (player, player2) {
                if (player2) {
                    if (player == game.me) game.swapPlayer(player2);
                    else if (player2 == game.me) game.swapPlayer(player);
                }
                else {
                    if (player == game.me) return;
                    var players = game.players.concat(game.dead);
                    for (var i = 0; i < players.length; i++) {
                        players[i].style.transition = 'all 0s';
                    }
                    game.addVideo('swapPlayer', player, get.cardsInfo(player.getCards('h')));
                    if (!game.chess) {
                        var pos = parseInt(player.dataset.position);
                        var num = game.players.length + game.dead.length;
                        var players = game.players.concat(game.dead);
                        var temp;
                        for (var i = 0; i < players.length; i++) {
                            temp = parseInt(players[i].dataset.position) - pos;
                            if (temp < 0) temp += num;
                            players[i].dataset.position = temp;
                        }
                    }
                    game.me.node.handcards1.remove();
                    game.me.node.handcards2.remove();
                    var current = game.me;
                    game.me = player;
                    if (current.isDead()) {
                        current.$die();
                    }
                    ui.handcards1 = player.node.handcards1.animate('start').fix();
                    ui.handcards2 = player.node.handcards2.animate('start').fix();
                    ui.handcards1Container.appendChild(ui.handcards1);
                    ui.handcards2Container.appendChild(ui.handcards2);

                    ui.updatehl();
                }
                if (game.me.isAlive()) {
                    if (ui.auto) ui.auto.show();
                    if (ui.wuxie) ui.wuxie.show();
                    if (ui.revive) {
                        ui.revive.close();
                        delete ui.revive;
                    }
                    if (ui.swap) {
                        ui.swap.close();
                        delete ui.swap;
                    }
                    if (ui.restart) {
                        ui.restart.close();
                        delete ui.restart;
                    }
                    if (ui.continue_game) {
                        ui.continue_game.close();
                        delete ui.continue_game;
                    }
                }
                if (lib.config.mode == 'identity') {
                    game.me.setIdentity(game.me.identity);
                }
                setTimeout(function () {
                    for (var i = 0; i < players.length; i++) {
                        players[i].style.transition = '';
                    }
                }, 100);
            },
            swapControl: function (player) {
                if (player == game.me) return;

                game.me.node.handcards1.remove();
                game.me.node.handcards2.remove();

                game.me = player;
                ui.handcards1 = player.node.handcards1.animate('start').fix();
                ui.handcards2 = player.node.handcards2.animate('start').fix();
                ui.handcards1Container.insertBefore(ui.handcards1, ui.handcards1Container.firstChild);
                ui.handcards2Container.insertBefore(ui.handcards2, ui.handcards2Container.firstChild);
                ui.updatehl();
                game.addVideo('swapControl', player, get.cardsInfo(player.getCards('h')));

                if (game.me.isAlive()) {
                    if (ui.auto) ui.auto.show();
                    if (ui.wuxie) ui.wuxie.show();
                    if (ui.revive) {
                        ui.revive.close();
                        delete ui.revive;
                    }
                    if (ui.swap) {
                        ui.swap.close();
                        delete ui.swap;
                    }
                    if (ui.restart) {
                        ui.restart.close();
                        delete ui.restart;
                    }
                    if (ui.continue_game) {
                        ui.continue_game.close();
                        delete ui.continue_game;
                    }
                }
            },
            swapPlayerAuto: function (player) {
                if (game.modeSwapPlayer) {
                    game.modeSwapPlayer(player);
                }
                else {
                    game.swapPlayer(player);
                }
            },
            findNext: function (player) {
                var players = get.players(lib.sort.position);
                var position = parseInt(player.dataset.position);
                for (var i = 0; i < players.length; i++) {
                    if (parseInt(players[i].dataset.position) >= position) {
                        return players[i];
                    }
                }
                return players[0];
            },
            loadModeAsync: function (name, callback) {
                window.game = game;
                var script = lib.init.js(dist(), 'mode', function () {
                    if (!lib.config.dev) delete window.game;
                    script.remove();
                    var content = lib.imported.mode[name];
                    delete lib.imported.mode[name];
                    if (get.is.empty(lib.imported.mode)) {
                        delete lib.imported.mode;
                    }
                    callback(content);
                });
            },
            switchMode: function (name, configx) {
                if (!lib.layoutfixed.contains(name)) {
                    if (lib.config.layout != game.layout) {
                        lib.init.layout(lib.config.layout);
                    }
                    else if (lib.config.mode == 'brawl') {
                        if (lib.config.player_border == 'normal' && (game.layout == 'long' || game.layout == 'long2')) {
                            ui.arena.classList.add('lslim_player');
                        }
                    }
                }
                window.game = game;
                var script = lib.init.js(dist(), 'mode', function () {
                    if (!lib.config.dev) delete window.game;
                    script.remove();
                    var mode = lib.imported.mode;
                    _status.sourcemode = lib.config.mode;
                    lib.config.mode = name;

                    var i, j;
                    for (i in mode[lib.config.mode].element) {
                        if (!lib.element[i]) lib.element[i] = [];
                        for (j in mode[lib.config.mode].element[i]) {
                            if (j == 'init') {
                                if (!lib.element[i].inits) lib.element[i].inits = [];
                                lib.element[i].inits.push(mode[lib.config.mode].element[i][j]);
                            }
                            else {
                                lib.element[i][j] = mode[lib.config.mode].element[i][j];
                            }
                        }
                    }
                    for (i in mode[lib.config.mode].ai) {
                        if (typeof mode[lib.config.mode].ai[i] == 'object') {
                            if (ai[i] == undefined) ai[i] = {};
                            for (j in mode[lib.config.mode].ai[i]) {
                                ai[i][j] = mode[lib.config.mode].ai[i][j];
                            }
                        }
                        else {
                            ai[i] = mode[lib.config.mode].ai[i];
                        }
                    }
                    for (i in mode[lib.config.mode].ui) {
                        if (typeof mode[lib.config.mode].ui[i] == 'object') {
                            if (ui[i] == undefined) ui[i] = {};
                            for (j in mode[lib.config.mode].ui[i]) {
                                ui[i][j] = mode[lib.config.mode].ui[i][j];
                            }
                        }
                        else {
                            ui[i] = mode[lib.config.mode].ui[i];
                        }
                    }
                    for (i in mode[lib.config.mode].game) {
                        game[i] = mode[lib.config.mode].game[i];
                    }
                    for (i in mode[lib.config.mode].get) {
                        get[i] = mode[lib.config.mode].get[i];
                    }
                    if (game.onwash) {
                        lib.onwash.push(game.onwash);
                        delete game.onwash;
                    }
                    if (game.onover) {
                        lib.onover.push(game.onover);
                        delete game.onover;
                    }
                    lib.config.banned = lib.config[lib.config.mode + '_banned'] || [];
                    lib.config.bannedcards = lib.config[lib.config.mode + '_bannedcards'] || [];

                    for (i in mode[lib.config.mode]) {
                        if (i == 'element') continue;
                        if (i == 'game') continue;
                        if (i == 'ai') continue;
                        if (i == 'ui') continue;
                        if (i == 'get') continue;
                        if (i == 'config') continue;
                        if (i == 'start') continue;
                        if (i == 'startBefore') continue;
                        if (lib[i] == undefined) lib[i] = (Array.isArray(mode[lib.config.mode][i])) ? [] : {};
                        for (j in mode[lib.config.mode][i]) {
                            lib[i][j] = mode[lib.config.mode][i][j];
                        }
                    }

                    // var pilecfg=lib.config.customcardpile[get.config('cardpilename')];
                    // if(pilecfg){
                    //     lib.config.bannedpile=pilecfg[0]||{};
                    //     lib.config.addedpile=pilecfg[1]||{};
                    // }

                    _status.event = {
                        finished: true,
                        next: [],
                        after: []
                    };
                    _status.paused = false;

                    if (_status.connectMode && lib.mode[name].connect) {
                        game.saveConfig('connect_mode', name);
                        game.clearConnect();
                        lib.configOL.mode = name;
                        if (configx) {
                            for (var i in configx) {
                                lib.configOL[i] = configx[i];
                            }
                        }
                        else {
                            for (var i in lib.mode[name].connect) {
                                if (i == 'update') continue;
                                lib.configOL[i.slice(8)] = get.config(i);
                            }
                            lib.configOL.characterPack = lib.connectCharacterPack.slice(0);
                            lib.configOL.cardPack = lib.connectCardPack.slice(0);
                            for (var i = 0; i < lib.config.connect_characters.length; i++) {
                                lib.configOL.characterPack.remove(lib.config.connect_characters[i]);
                            }
                            for (var i = 0; i < lib.config.connect_cards.length; i++) {
                                lib.configOL.cardPack.remove(lib.config.connect_cards[i]);
                            }
                            lib.configOL.banned = lib.config['connect_' + name + '_banned'];
                            lib.configOL.bannedcards = lib.config['connect_' + name + '_bannedcards'];
                        }
                        lib.configOL.version = lib.versionOL;
                        for (var i in lib.cardPackList) {
                            if (lib.configOL.cardPack.contains(i)) {
                                lib.card.list = lib.card.list.concat(lib.cardPackList[i]);
                            }
                        }
                        for (i = 0; i < lib.card.list.length; i++) {
                            if (lib.card.list[i][2] == 'huosha') {
                                lib.card.list[i] = lib.card.list[i].slice(0);
                                lib.card.list[i][2] = 'sha';
                                lib.card.list[i][3] = 'fire';
                            }
                            else if (lib.card.list[i][2] == 'leisha') {
                                lib.card.list[i] = lib.card.list[i].slice(0);
                                lib.card.list[i][2] = 'sha';
                                lib.card.list[i][3] = 'thunder';
                            }
                            else if (lib.card.list[i][2] == 'haisha') {
                                lib.card.list[i] = lib.card.list[i].slice(0);
                                lib.card.list[i][2] = 'sha';
                                lib.card.list[i][3] = 'ocean';
                            }
                            else if (lib.card.list[i][2] == 'yamisha') {
                                lib.card.list[i] = lib.card.list[i].slice(0);
                                lib.card.list[i][2] = 'sha';
                                lib.card.list[i][3] = 'yami';
                            }
                            if (lib.card.list[i][2] == 'haitao') {
                                lib.card.list[i] = lib.card.list[i].slice(0);
                                lib.card.list[i][2] = 'tao';
                                lib.card.list[i][3] = 'ocean';
                            }
                            if (lib.card.list[i][2] == 'haijiu') {
                                lib.card.list[i] = lib.card.list[i].slice(0);
                                lib.card.list[i][2] = 'jiu';
                                lib.card.list[i][3] = 'ocean';
                            }
                            if (!lib.card[lib.card.list[i][2]]) {
                                lib.card.list.splice(i, 1); i--;
                            }
                            else if (lib.card[lib.card.list[i][2]].mode &&
                                lib.card[lib.card.list[i][2]].mode.contains(lib.config.mode) == false) {
                                lib.card.list.splice(i, 1); i--;
                            }
                        }
                    }

                    if (!lib.config.show_playerids || !game.showIdentity) {
                        ui.playerids.style.display = 'none';
                    }
                    else {
                        ui.playerids.style.display = '';
                    }

                    if (mode[lib.config.mode].startBefore) mode[lib.config.mode].startBefore();
                    game.createEvent('game', false).setContent(mode[lib.config.mode].start);
                    if (lib.mode[lib.config.mode] && lib.mode[lib.config.mode].fromextension) {
                        var startstr = mode[lib.config.mode].start.toString();
                        if (startstr.indexOf('onfree') == -1) {
                            setTimeout(lib.init.onfree, 500);
                        }
                    }
                    delete lib.imported.mode[name];

                    if (!lib.db) {
                        try {
                            lib.storage = JSON.parse(localStorage.getItem(lib.configprefix + lib.config.mode));
                            if (typeof lib.storage != 'object') throw ('err');
                            if (lib.storage == null) throw ('err');
                        }
                        catch (err) {
                            lib.storage = {};
                            localStorage.setItem(lib.configprefix + lib.config.mode, "{}");
                        }
                        game.loop();
                    }
                    else {
                        game.getDB('data', lib.config.mode, function (obj) {
                            lib.storage = obj || {};
                            game.loop();
                        });
                    }
                });
            },
            loadMode: function (mode) {
                let next = game.createEvent('loadMode', false);
                next.mode = mode;
                next.setContent('loadMode');
            },
            loadPackage: function () {
                let next = game.createEvent('loadPackage');
                next.packages = [];
                for (var i = 0; i < arguments.length; i++) {
                    if (typeof arguments[i] == 'string') {
                        next.packages.push(arguments[i]);
                    }
                }
                next.setContent('loadPackage');
            },
            phaseLoop: function (player) {
                let next = game.createEvent('phaseLoop');
                next.player = player;
                next.setContent('phaseLoop');
            },
            gameDraw: function (player, num) {
                let next = game.createEvent('gameDraw');
                next.player = player || game.me;
                if (num == undefined) next.num = 4;
                else next.num = num;
                next.setContent('gameDraw');
                return next;
            },
            chooseCharacterDouble: function () {
                let next = game.createEvent('chooseCharacter', false);
                var config, width, num, ratio, func, update, list, first;
                for (var i = 0; i < arguments.length; i++) {
                    if (typeof arguments[i] == 'number') {
                        if (!width) {
                            width = arguments[i];
                        }
                        else if (!num) {
                            num = arguments[i];
                        }
                        else {
                            ratio = arguments[i];
                        }
                    }
                    else if (typeof arguments[i] == 'function') {
                        if (!func) {
                            func = arguments[i];
                        }
                        else {
                            update = arguments[i];
                        }
                    }
                    else if (Array.isArray(arguments[i])) {
                        list = arguments[i];
                    }
                    else if (get.objtype(arguments[i]) == 'object') {
                        config = arguments[i];
                    }
                }
                if (!config) {
                    list = config;
                    config = {};
                }
                config.width = config.width || width || 8;
                config.height = 4;
                config.size = config.width * config.height;
                config.num = config.num || num || 3;
                config.ratio = config.ratio || ratio || 1.2;
                config.update = config.update || update;
                if (!config.hasOwnProperty('first')) {
                    if (typeof first == 'boolean') {
                        config.first = first;
                    }
                    else {
                        config.first = 'rand';
                    }
                }
                if (!list) {
                    list = [];
                    for (var i in lib.character) {
                        if (typeof func == 'function') {
                            if (!func(i)) continue;
                        }
                        else {
                            if (lib.filter.characterDisabled(i)) continue;
                        }
                        list.push(i);
                    }
                }
                next.config = config;
                next.list = list;
                next.setContent([function () {
                    Evt.nodes = [];
                    Evt.avatars = [];
                    Evt.friend = [];
                    Evt.enemy = [];
                    Evt.blank = [];
                    for (var i = 0; i < Evt.config.size; i++) {
                        Evt.nodes.push(ui.create.div('.shadowed.reduce_radius.choosedouble'));
                    }
                    Evt.moveAvatar = function (node, i) {
                        if (!node.classList.contains('moved')) {
                            Evt.blank.push(node.index);
                        }
                        Evt.nodes[node.index].style.display = '';
                        Evt.nodes[node.index].show();
                        clearTimeout(Evt.nodes[node.index].choosetimeout);
                        Evt.moveNode(node, i);
                        var nodex = Evt.nodes[node.index];
                        nodex.choosetimeout = setTimeout(function () {
                            nodex.hide();
                            nodex.choosetimeout = setTimeout(function () {
                                nodex.show();
                                nodex.style.display = 'none';
                            }, 300);
                        }, 400);
                    };
                    Evt.aiMove = function (friend) {
                        var list = [];
                        for (var i = 0; i < Evt.avatars.length; i++) {
                            if (!Evt.avatars[i].classList.contains('moved')) {
                                list.push(Evt.avatars[i]);
                            }
                        }
                        for (var i = 0; i < list.length; i++) {
                            if (Math.random() < 0.7 || i == list.length - 1) {
                                if (friend) {
                                    Evt.moveAvatar(list[i], Evt.friend.length + Evt.config.width * (Evt.config.height - 1));
                                    Evt.friend.push(list[i]);
                                }
                                else {
                                    Evt.moveAvatar(list[i], Evt.enemy.length);
                                    Evt.enemy.push(list[i]);
                                }
                                list[i].classList.add('moved');
                                break;
                            }
                        }
                    };
                    Evt.promptbar = ui.create.div('.hidden', ui.window);
                    Evt.promptbar.style.width = '100%';
                    Evt.promptbar.style.left = 0;
                    if (get.is.phoneLayout()) {
                        Evt.promptbar.style.top = '20px';
                    }
                    else {
                        Evt.promptbar.style.top = '58px';
                    }
                    Evt.promptbar.style.pointerEvents = 'none';
                    Evt.promptbar.style.textAlign = 'center';
                    Evt.promptbar.style.zIndex = '2';
                    ui.create.div('.shadowed.reduce_radius', Evt.promptbar);
                    Evt.promptbar.firstChild.style.fontSize = '18px';
                    Evt.promptbar.firstChild.style.padding = '6px 10px';
                    Evt.promptbar.firstChild.style.position = 'relative';
                    Evt.prompt = function (str) {
                        Evt.promptbar.firstChild.innerHTML = str;
                        Evt.promptbar.show();
                    };
                    Evt.moveNode = function (node, i) {
                        var width = Evt.width, height = Evt.height, margin = Evt.margin;
                        var left = -(width + 10) * Evt.config.width / 2 + 5 + (i % Evt.config.width) * (width + 10);
                        var top = -(height + 10) * Evt.config.height / 2 + 5 + Math.floor(i / Evt.config.width) * (height + 10) + margin / 2;
                        node.style.transform = 'translate(' + left + 'px,' + top + 'px)';
                        node.index = i;
                    };
                    Evt.resize = function () {
                        var margin = 0;
                        if (!get.is.phoneLayout()) {
                            margin = 38;
                        }
                        var height = (ui.window.offsetHeight - 10 * (Evt.config.height + 1) - margin) / Evt.config.height;
                        var width = (ui.window.offsetWidth - 10 * (Evt.config.width + 1)) / Evt.config.width;
                        if (width * Evt.config.ratio < height) {
                            height = width * Evt.config.ratio;
                        }
                        else {
                            width = height / Evt.config.ratio;
                        }
                        Evt.width = width;
                        Evt.height = height;
                        Evt.margin = margin;
                        for (var i = 0; i < Evt.config.size; i++) {
                            Evt.moveNode(Evt.nodes[i], i);
                            Evt.nodes[i].style.width = width + 'px';
                            Evt.nodes[i].style.height = height + 'px';
                            if (Evt.avatars[i]) {
                                Evt.moveNode(Evt.avatars[i], Evt.avatars[i].index);
                                Evt.avatars[i].style.width = width + 'px';
                                Evt.avatars[i].style.height = height + 'px';
                                Evt.avatars[i].nodename.style.fontSize = Math.max(14, Math.round(width / 5.6)) + 'px';
                            }
                        }
                        if (Evt.deciding) {
                            var str = 'px,' + (Evt.margin / 2 - Evt.height * 0.5) + 'px)';
                            for (var i = 0; i < Evt.friendlist.length; i++) {
                                Evt.friendlist[i].style.transform = 'scale(1.2) translate(' + (-(Evt.width + 14) * Evt.friendlist.length / 2 + 7 + i * (Evt.width + 14)) + str;
                            }
                        }
                    };
                    lib.onresize.push(Evt.resize);
                    Evt.clickAvatar = function () {
                        if (Evt.deciding) {
                            if (this.index < Evt.config.width) return;
                            if (Evt.friendlist.contains(this)) {
                                Evt.friendlist.remove(this);
                                Evt.moveNode(this, this.index);
                                this.nodename.innerHTML = get.slimName(this.link);
                            }
                            else {
                                Evt.friendlist.push(this);
                            }
                            if (Evt.friendlist.length == Evt.config.num) {
                                Evt.deciding = false;
                                Evt.prompt('比赛即将开始');
                                setTimeout(game.resume, 1000);
                            }
                            if (Evt.config.update) {
                                for (var i = 0; i < Evt.friendlist.length; i++) {
                                    Evt.friendlist[i].nodename.innerHTML = Evt.config.update(i, Evt.friendlist.length) || Evt.friendlist[i].nodename.innerHTML;
                                }
                            }
                            var str = 'px,' + (Evt.margin / 2 - Evt.height * 0.5) + 'px)';
                            for (var i = 0; i < Evt.friendlist.length; i++) {
                                Evt.friendlist[i].style.transform = 'scale(1.2) translate(' + (-(Evt.width + 14) * Evt.friendlist.length / 2 + 7 + i * (Evt.width + 14)) + str;
                            }
                        }
                        else {
                            if (!Evt.imchoosing) return;
                            if (Evt.replacing) {
                                this.link = Evt.replacing;
                                this.setBackground(Evt.replacing, 'character');

                                this.nodename.innerHTML = get.slimName(Evt.replacing);
                                this.nodename.dataset.nature = get.groupnature(lib.character[Evt.replacing][1]);

                                delete Evt.replacing;
                                if (this.classList.contains('moved')) {
                                    Evt.custom.add.window();
                                }
                            }
                            if (this.classList.contains('moved')) return;
                            Evt.moveAvatar(this, Evt.friend.length + Evt.config.width * (Evt.config.height - 1));
                            Evt.friend.push(this.link);
                            this.classList.add('moved');
                            game.resume();
                        }
                    };
                    Evt.skipnode = ui.create.system('跳过', function () {
                        this.remove();
                        Evt._skiprest = true;
                        if (Evt.imchoosing) {
                            game.resume();
                        }
                    });
                    if (get.config('change_choice')) {
                        Evt.replacenode = ui.create.system('换将', function () {
                            Evt.promptbar.hide();
                            while (Evt.avatars.length) {
                                Evt.avatars.shift().remove();
                            }
                            for (var i = 0; i < Evt.config.size; i++) {
                                Evt.nodes[i].show();
                                Evt.nodes[i].style.display = '';
                                clearTimeout(Evt.nodes[i].choosetimeout);
                            }
                            delete Evt.list2;
                            Evt.friend.length = 0;
                            Evt.enemy.length = 0;
                            Evt.blank.length = 0;
                            Evt.redoing = true;
                            if (Evt.imchoosing) {
                                game.resume();
                            }
                        }, true);
                    }
                    if (get.config('change_choice')) {
                        Evt.reselectnode = ui.create.system('重选', function () {
                            Evt.promptbar.hide();
                            Evt.list2 = Evt.list2.concat(Evt.friend).concat(Evt.enemy);
                            Evt.friend.length = 0;
                            Evt.enemy.length = 0;
                            for (var i = 0; i < Evt.avatars.length; i++) {
                                if (Evt.avatars[i].classList.contains('moved')) {
                                    Evt.moveAvatar(Evt.avatars[i], Evt.blank.randomRemove());
                                    Evt.avatars[i].classList.remove('moved');
                                }
                            }
                            Evt.redoing = true;
                            if (Evt.imchoosing) {
                                game.resume();
                            }
                        }, true);
                    }
                    if (get.config('free_choose')) {
                        var createCharacterDialog = function () {
                            Evt.freechoosedialog = ui.create.characterDialog();
                            Evt.freechoosedialog.style.height = '80%';
                            Evt.freechoosedialog.style.top = '10%';
                            Evt.freechoosedialog.style.transform = 'scale(0.8)';
                            Evt.freechoosedialog.style.transition = 'all 0.3s';
                            Evt.freechoosedialog.listen(function (e) {
                                if (!Evt.replacing) {
                                    Evt.dialoglayer.clicked = true;
                                }
                            });
                            Evt.freechoosedialog.classList.add('pointerdialog');
                            Evt.dialoglayer = ui.create.div('.popup-container.hidden', function (e) {
                                if (this.classList.contains('removing')) return;
                                if (this.clicked) {
                                    this.clicked = false;
                                    return;
                                }
                                ui.window.classList.remove('modepaused');
                                this.delete();
                                e.stopPropagation();
                                Evt.freechoosedialog.style.transform = 'scale(0.8)';
                                if (Evt.replacing) {
                                    Evt.prompt('用' + get.translation(Evt.replacing) + '替换一名武将');
                                }
                                else {
                                    if (Evt.side == 0) {
                                        Evt.prompt('请选择两名武将');
                                    }
                                    else {
                                        Evt.prompt('请选择一名武将');
                                    }
                                }
                            });
                            Evt.dialoglayer.classList.add('modenopause');
                            Evt.dialoglayer.appendChild(Evt.freechoosedialog);
                            Evt.freechoosenode.classList.remove('hidden');
                        }

                        Evt.custom.replace.button = function (button) {
                            Evt.replacing = button.link;
                        };
                        Evt.custom.add.window = function () {
                            if (Evt.replacing) {
                                delete Evt.replacing;
                                if (Evt.side == 0) {
                                    Evt.prompt('请选择两名武将');
                                }
                                else {
                                    Evt.prompt('请选择一名武将');
                                }
                            }
                        };
                        Evt.freechoosenode = ui.create.system('自由选将', function () {
                            if (this.classList.contains('hidden')) return;
                            if (!Evt.imchoosing) {
                                Evt.prompt('请等待敌方选将');
                                return;
                            }
                            delete Evt.replacing;
                            ui.window.classList.add('modepaused');
                            ui.window.appendChild(Evt.dialoglayer);
                            ui.refresh(Evt.dialoglayer);
                            Evt.dialoglayer.show();
                            Evt.freechoosedialog.style.transform = 'scale(1)';
                            Evt.promptbar.hide();
                        }, true);
                        if (lib.onfree) {
                            Evt.freechoosenode.classList.add('hidden');
                            lib.onfree.push(createCharacterDialog);
                        }
                        else {
                            createCharacterDialog();
                        }
                    }
                    Evt.checkredo = function () {
                        if (Evt.redoing) {
                            Evt.goto(1);
                            delete Evt.redoing;
                            return true;
                        }
                    };
                    // if(ui.cardPileButton) ui.cardPileButton.style.display='none';
                    ui.auto.hide();
                    ui.wuxie.hide();
                    Evt.resize();
                    for (var i = 0; i < Evt.config.size; i++) {
                        ui.window.appendChild(Evt.nodes[i]);
                    }
                }, function () {
                    var rand = Evt.config.first;
                    if (rand == 'rand') {
                        rand = (Math.random() < 0.5);
                    }
                    if (rand) {
                        _status.color = true;
                        Evt.side = 1;
                    }
                    else {
                        _status.color = false;
                        Evt.side = 3;
                    }
                    if (!Evt.list2) {
                        Evt.list2 = Evt.list.randomGets(Evt.config.width * 2);
                        for (var i = 0; i < Evt.config.width * 2; i++) {
                            Evt.avatars.push(ui.create.div('.shadowed.shadowed2.reduce_radius.character.choosedouble', Evt.clickAvatar));
                            var name = Evt.list2[i];
                            Evt.avatars[i].setBackground(name, 'character');
                            Evt.avatars[i].link = name;
                            Evt.avatars[i].nodename = ui.create.div('.name', Evt.avatars[i], get.slimName(name));
                            Evt.avatars[i].nodename.style.fontFamily = lib.config.name_font;
                            Evt.avatars[i].index = i + Evt.config.width;
                            Evt.avatars[i].animate('start');
                            Evt.nodes[Evt.avatars[i].index].style.display = 'none';
                            Evt.avatars[i].nodename.dataset.nature = get.groupnature(lib.character[name][1]);
                            lib.setIntro(Evt.avatars[i]);
                        }
                        Evt.resize();
                        for (var i = 0; i < Evt.avatars.length; i++) {
                            ui.window.appendChild(Evt.avatars[i]);
                        }
                        Evt.avatars.sort(function (a, b) {
                            return get.rank(b.link, true) - get.rank(a.link, true);
                        })
                    }
                    game.delay();
                    lib.init.onfree();
                }, function () {
                    if (Evt.checkredo()) return;
                    if (Evt._skiprest) return;
                    if (Evt.side < 2) {
                        Evt.imchoosing = true;
                        if (Evt.side == 0) {
                            Evt.prompt('请选择两名武将');
                        }
                        else {
                            Evt.prompt('请选择一名武将');
                            Evt.fast = get.time();
                        }
                        game.pause();
                    }
                    else {
                        Evt.aiMove();
                        game.delay();
                    }
                }, function () {
                    if (typeof Evt.fast == 'number' && get.time() - Evt.fast <= 1000) {
                        Evt.fast = true;
                    }
                    else {
                        Evt.fast = false;
                    }
                    delete Evt.imchoosing;
                    if (Evt.checkredo()) return;
                    if (Evt._skiprest) {
                        while (Evt.enemy.length < Evt.config.width) {
                            Evt.aiMove();
                        }
                        while (Evt.friend.length < Evt.config.width) {
                            Evt.aiMove(true);
                        }
                    }
                    else if (Evt.friend.length + Evt.enemy.length < Evt.config.width * 2 - 1) {
                        if (Evt.side == 1) {
                            game.delay(Evt.fast ? 1 : 2);
                            Evt.promptbar.hide();
                        }
                        Evt.side++;
                        if (Evt.side > 3) {
                            Evt.side = 0;
                        }
                        Evt.goto(2);
                    }
                    else {
                        Evt.promptbar.hide();
                        Evt.side++;
                        if (Evt.side > 3) {
                            Evt.side = 0;
                        }
                        if (Evt.side >= 2) {
                            game.delay()
                        }
                    }
                }, function () {
                    if (Evt.checkredo()) return;
                    if (Evt.skipnode) Evt.skipnode.delete();
                    if (Evt.replacenode) Evt.replacenode.delete();
                    if (Evt.reselectnode) Evt.reselectnode.delete();
                    if (Evt.freechoosenode) Evt.freechoosenode.delete();
                    for (var i = 0; i < Evt.avatars.length; i++) {
                        if (!Evt.avatars[i].classList.contains('moved')) {
                            if (Evt.side < 2) {
                                Evt.moveAvatar(Evt.avatars[i], Evt.friend.length + Evt.config.width * (Evt.config.height - 1));
                                Evt.friend.push(Evt.avatars[i]);
                            }
                            else {
                                Evt.moveAvatar(Evt.avatars[i], Evt.enemy.length);
                                Evt.enemy.push(Evt.avatars[i]);
                            }
                            Evt.avatars[i].classList.add('moved');
                        }
                    }
                    game.delay();
                }, function () {
                    Evt.prompt('选择' + get.cnNumber(Evt.config.num) + '名出场武将');
                    Evt.enemylist = [];
                    for (var i = 0; i < Evt.avatars.length; i++) {
                        if (Evt.avatars[i].index > Evt.config.width) {
                            Evt.avatars[i].classList.add('selecting');
                        }
                    }
                    var rand = [];
                    for (var i = 0; i < Evt.config.width; i++) {
                        for (var j = 0; j < Evt.config.width - i; j++) {
                            rand.push(i);
                        }
                    }
                    for (var i = 0; i < Evt.config.num; i++) {
                        var rand2 = rand.randomGet();
                        for (var j = 0; j < rand.length; j++) {
                            if (rand[j] == rand2) {
                                rand.splice(j--, 1);
                            }
                        }
                        Evt.enemylist.push(Evt.enemy[rand2]);
                    }
                    Evt.enemylist.randomSort();
                    Evt.friendlist = [];
                    Evt.deciding = true;
                    for (var i = 0; i < Evt.config.size; i++) {
                        Evt.nodes[i].hide();
                    }
                    game.pause();
                }, function () {
                    Evt.promptbar.delete();
                    if (ui.cardPileButton) ui.cardPileButton.style.display = '';
                    lib.onresize.remove(Evt.resize);
                    ui.wuxie.show();
                    ui.auto.show();
                    for (var i = 0; i < Evt.avatars.length; i++) {
                        Evt.avatars[i].delete();
                    }
                    for (var i = 0; i < Evt.nodes.length; i++) {
                        Evt.nodes[i].delete();
                    }
                    Evt.result = { friend: [], enemy: [] };
                    for (var i = 0; i < Evt.config.num; i++) {
                        Evt.result.friend[i] = Evt.friendlist[i].link;
                        Evt.result.enemy[i] = Evt.enemylist[i].link;
                    }
                }]);
            },
            updateRoundNumber: function () {
                game.broadcastAll(function (num1, num2, top) {
                    if (ui.cardPileNumber) ui.cardPileNumber.innerHTML = num1 + '轮 剩余牌: ' + num2;
                    _status.pileTop = top;
                }, game.roundNumber, ui.cardPile.childNodes.length, ui.cardPile.firstChild);
            },
            asyncDraw: function (players, num, drawDeck, bottom) {
                for (var i = 0; i < players.length; i++) {
                    var num2 = 1;
                    if (typeof num == 'number') {
                        num2 = num;
                    }
                    else if (Array.isArray(num)) {
                        num2 = num[i];
                    }
                    else if (typeof num == 'function') {
                        num2 = num(players[i]);
                    }
                    if (drawDeck && drawDeck.drawDeck) {
                        players[i].draw(num2, false, drawDeck);
                    }
                    else {
                        if (bottom) players[i].draw(num2, 'nodelay', 'bottom');
                        else players[i].draw(num2, 'nodelay');
                    }
                }
            },
            asyncDrawAuto: function (players, num, drawDeck) {
                if (players.length == 1) {
                    var num2 = 1;
                    if (typeof num == 'number') {
                        num2 = num;
                    }
                    else if (Array.isArray(num)) {
                        num2 = num[0];
                    }
                    else if (typeof num == 'function') {
                        num2 = num(players[0]);
                    }
                    if (drawDeck && drawDeck.drawDeck) {
                        players[0].draw(num2, drawDeck);
                    }
                    else {
                        players[0].draw(num2);
                    }
                }
                else {
                    game.asyncDraw.apply(this, arguments);
                }
            },
            /**
             * 为角色技能添加`translate`文本，设置默认ai，进行预处理
             * 同时将下划线(_)开头的技能添加到{@link lib.skill.global}
             * @param {string} i 技能名
             * @param {*} [sub] 
             * @see{@link game.finishCards}
             */
            finishSkill: function (i, sub) {
                var j;
                var mode = get.mode();
                var info = lib.skill[i];
                if (info.alter) {
                    lib.translate[i + '_info_origin'] = lib.translate[i + '_info'];
                    if (!lib.config.vintageSkills.contains(i)) {
                        lib.translate[i + '_info'] = lib.translate[i + '_info_alter'];
                    }
                }
                else if (lib.translate[i + '_info_' + mode]) {
                    lib.translate[i + '_info'] = lib.translate[i + '_info_' + mode];
                }
                else if (lib.translate[i + '_info_zhu'] && (mode == 'identity' || (mode == 'guozhan' && _status.mode == 'four'))) {
                    lib.translate[i + '_info'] = lib.translate[i + '_info_zhu'];
                }
                else if (lib.translate[i + '_info_combat'] && get.is.versus()) {
                    lib.translate[i + '_info'] = lib.translate[i + '_info_combat'];
                }
                if (info.forbid && info.forbid.contains(mode)) {
                    lib.skill[i] = {};
                    if (lib.translate[i + '_info']) {
                        lib.translate[i + '_info'] = '此模式下不可用';
                    }
                    return;
                }
                if (info.mode && info.mode.contains(mode) == false) {
                    lib.skill[i] = {};
                    if (lib.translate[i + '_info']) {
                        lib.translate[i + '_info'] = '此模式下不可用';
                    }
                    return;
                }
                if (info.available && info.available(mode) == false) {
                    lib.skill[i] = {};
                    if (lib.translate[i + '_info']) {
                        lib.translate[i + '_info'] = '此模式下不可用';
                    }
                    return;
                }
                if (info.viewAs && typeof info.viewAs != 'function') {
                    if (typeof info.viewAs == 'string') {
                        info.viewAs = { name: info.viewAs };
                    }
                    if (!lib.card[info.viewAs.name]) {
                        lib.skill[i] = {};
                        lib.translate[i + '_info'] = '技能不可用';
                        return;
                    }
                    if (info.ai == undefined) info.ai = {};
                    var skill = info.ai;
                    var card = lib.card[info.viewAs.name].ai;
                    for (j in card) {
                        if (skill[j] == undefined) skill[j] = card[j];
                        else if (typeof skill[j] == 'object') {
                            for (var k in card[j]) {
                                if (skill[j][k] == undefined) skill[j][k] = card[j][k];
                            }
                        }
                    }
                }
                if (info.inherit) {
                    var skill = lib.skill[info.inherit];
                    for (j in skill) {
                        if (info[j] == undefined) {
                            if (j == 'audio' && (typeof info[j] == 'number' || typeof info[j] == 'boolean')) {
                                info[j] = info.inherit;
                            }
                            else {
                                info[j] = skill[j];
                            }
                        }
                    }
                    if (lib.translate[i] == undefined) {
                        lib.translate[i] = lib.translate[info.inherit];
                    }
                    if (lib.translate[i + '_info'] == undefined) {
                        lib.translate[i + '_info'] = lib.translate[info.inherit + '_info'];
                    }
                }
                if (info.limited) {
                    if (info.mark === undefined) info.mark = true;
                    if (!info.intro) info.intro = {};
                    if (info.intro.content === undefined) info.intro.content = 'limited';
                    if (info.skillAnimation === undefined) info.skillAnimation = true;
                    if (info.init === undefined) info.init = function (player, skill) {
                        player.storage[skill] = false;
                    }
                }
                if (info.subSkill && !sub) {
                    for (var j in info.subSkill) {
                        lib.skill[i + '_' + j] = info.subSkill[j];
                        lib.skill[i + '_' + j].sub = true;
                        if (info.subSkill[j].name) {
                            lib.translate[i + '_' + j] = info.subSkill[j].name;
                        }
                        else {
                            lib.translate[i + '_' + j] = lib.translate[i + '_' + j] || lib.translate[i];
                        }
                        if (info.subSkill[j].description) {
                            lib.translate[i + '_' + j + '_info'] = info.subSkill[j].description;
                        }
                        if (info.subSkill[j].marktext) {
                            lib.translate[i + '_' + j + '_bg'] = info.subSkill[j].marktext;
                        }
                        game.finishSkill(i + '_' + j, true);
                    }
                }
                if (info.round) {
                    var k = i + '_roundcount';
                    if (typeof info.group == 'string') {
                        info.group = [info.group, k];
                    }
                    else if (Array.isArray(info.group)) {
                        info.group.add(k);
                    }
                    else {
                        info.group = [k];
                    }
                    lib.skill[k] = (function (round, name) {
                        return {
                            init(player) {
                                if (typeof player.storage[name] !== 'number') player.storage[name] = 0;
                            },
                            intro: {
                                content(storage, player) {
                                    let str = '';
                                    let info = get.info(name.slice(0, name.indexOf('_roundcount')));
                                    if (info && info.addintro) {
                                        str += info.addintro(storage, player);
                                    }
                                    // let num = round - (game.roundNumber - storage);
                                    let num = storage
                                    if (num > 0) {
                                        str += get.cnNumber(num) + '轮后' + (info.roundtext || '技能重置');
                                    }
                                    else {
                                        str += '技能可发动';
                                    }
                                    return str;
                                },
                                markcount(storage, player) {
                                    let num = storage;
                                    if (num > 0) {
                                        return num;
                                    }
                                    return 0;
                                }
                            },
                            trigger: { global: 'roundEnd' },
                            forced: true,
                            popup: false,
                            silent: true,
                            content() {
                                var roundname = Evt.name;
                                if (player.storage[roundname] > 0) {
                                    player.storage[roundname]--
                                }
                                if (player.storage[roundname] > 0) {
                                    player.updateMarks();
                                }
                                else {
                                    player.unmarkSkill(roundname);
                                }
                            }
                        };
                    }(info.round, k));
                    lib.translate[k] = lib.translate[i] || '';
                    lib.translate[k + '_bg'] = lib.translate[i + '_bg'] || lib.translate[k][0];
                }
                if (info.marktext) {
                    lib.translate[i + '_bg'] = info.marktext;
                }
                if (info.silent) {
                    if (!info.hasOwnProperty('forced')) info.forced = true;
                    if (!info.hasOwnProperty('popup')) info.popup = false;
                }
                if (i[0] == '_') {
                    game.addGlobalSkill(i);
                }
            },
            /**
             * 为(游戏牌|角色技能)添加`translate`文本，设置默认ai，进行预处理
             * @see {@link game.finishSkill}
             */
            finishCards: function () {
                _status.cardsFinished = true;
                var i, j, k;
                var mode = get.mode();
                for (i in lib.card) {
                    if (lib.translate[i + '_info_' + mode]) {
                        lib.translate[i + '_info'] = lib.translate[i + '_info_' + mode];
                    }
                    else if (lib.translate[i + '_info_zhu'] && (mode == 'identity' || (mode == 'guozhan' && _status.mode == 'four'))) {
                        lib.translate[i + '_info'] = lib.translate[i + '_info_zhu'];
                    }
                    else if (lib.translate[i + '_info_combat'] && get.is.versus()) {
                        lib.translate[i + '_info'] = lib.translate[i + '_info_combat'];
                    }
                    var card = lib.card[i];
                    if (card.filterTarget && card.selectTarget == undefined) {
                        card.selectTarget = 1;
                    }
                    if (card.autoViewAs) {
                        if (!card.ai) {
                            card.ai = {};
                        }
                        if (!card.ai.order) {
                            card.ai.order = lib.card[card.autoViewAs].ai.order;
                            if (!card.ai.order && lib.card[card.autoViewAs].ai.basic) {
                                card.ai.order = lib.card[card.autoViewAs].ai.basic.order;
                            }
                        }
                    }
                    if (card.type == 'equip') {
                        if (card.enable == undefined) card.enable = true;
                        if (card.selectTarget == undefined) card.selectTarget = -1;
                        if (card.filterTarget == undefined) card.filterTarget = function (card, player, target) {
                            return target == player;
                        };
                        if (card.modTarget == undefined) card.modTarget = true;
                        if (card.allowMultiple == undefined) card.allowMultiple = false;
                        if (card.content == undefined) card.content = lib.element.content.equipCard;
                        if (card.toself == undefined) card.toself = true;
                        if (card.ai == undefined) card.ai = { basic: {} };
                        if (card.ai.basic == undefined) card.ai.basic = {};
                        if (card.ai.result == undefined) card.ai.result = { target: 1.5 };
                        if (card.ai.basic.order == undefined) card.ai.basic.order = function (card, player) {
                            if (player && player.hasSkillTag('reverseEquip')) {
                                return 8.5 - get.equipValue(card, player) / 20;
                            }
                            else {
                                return 8 + get.equipValue(card, player) / 20;
                            }
                        };
                        if (card.ai.basic.useful == undefined) card.ai.basic.useful = 2;
                        if (card.subtype == 'equip3') {
                            if (card.ai.basic.equipValue == undefined) card.ai.basic.equipValue = 7;
                        }
                        else if (card.subtype == 'equip4') {
                            if (card.ai.basic.equipValue == undefined) card.ai.basic.equipValue = 4;
                        }
                        else {
                            if (card.ai.basic.equipValue == undefined) card.ai.basic.equipValue = 1;
                        }
                        if (card.ai.basic.value == undefined) card.ai.basic.value = function (card, player, index, method) {
                            if (player.isDisabled(get.subtype(card))) return 0.01;
                            var value = 0;
                            var info = get.info(card);
                            var current = player.getEquip(info.subtype);
                            if (current && card != current) {
                                value = get.value(current, player);
                            }
                            var equipValue = info.ai.equipValue;
                            if (equipValue == undefined) {
                                equipValue = info.ai.basic.equipValue;
                            }
                            if (typeof equipValue == 'function') {
                                if (method == 'raw') return equipValue(card, player);//原装备价值
                                if (method == 'raw2') return equipValue(card, player) - value;//装备牌`card`的相对装备价值(相对当前相同位置的装备。如果没有装备，则为原装备价值)
                                return Math.max(0.1, equipValue(card, player) - value);
                            }
                            if (typeof equipValue != 'number') equipValue = 0;
                            if (method == 'raw') return equipValue;
                            if (method == 'raw2') return equipValue - value;
                            return Math.max(0.1, equipValue - value);
                        }
                        if (!card.ai.result.keepAI) card.ai.result.target = function (player, target, card) {
                            return get.equipResult(player, target, card.name);
                        };
                    }
                    else if (card.type == 'delay') {
                        if (card.enable == undefined) card.enable = true;
                        if (card.filterTarget == undefined) card.filterTarget = lib.filter.judge;
                        if (card.content == undefined) card.content = lib.element.content.addJudgeCard;
                        if (card.allowMultiple == undefined) card.allowMultiple = false;
                    }
                }
                for (i in lib.skill) {
                    game.finishSkill(i);
                }
            },
            //Mod类技能的相关检测
            checkMod: function () {
                var name = arguments[arguments.length - 2];
                var skills = arguments[arguments.length - 1];
                if (skills.getSkills) {
                    if (name != 'cardname') skills = skills.getSkills();
                    else skills = skills.getSkills(null, false);
                }
                skills = skills.concat(lib.skill.global);
                game.expandSkills(skills);
                var arg = [], i, info;
                for (i = 0; i < arguments.length - 2; i++) {
                    arg.push(arguments[i]);
                }
                for (i = 0; i < skills.length; i++) {
                    info = get.info(skills[i]);
                    if (info && info.mod && info.mod[name]) {
                        var result = info.mod[name].apply(this, arg);
                        if (typeof arg[arg.length - 1] != 'object' && result != undefined) arg[arg.length - 1] = result;
                    }
                }
                return arg[arg.length - 1];
            },
            prepareArena: function (num) {
                _status.prepareArena = true;
                game.showHistory(false);
                ui.create.players(num);
                ui.create.me();
                ui.create.cardsAsync();
                game.finishCards();
            },
            clearArena: function () {
                ui.control.innerHTML = '';
                ui.arenalog.innerHTML = '';
                var nodes = [];
                for (var i = 0; i < ui.arena.childNodes.length; i++) {
                    nodes.push(ui.arena.childNodes[i]);
                }
                for (var i = 0; i < nodes.length; i++) {
                    if (nodes[i] == ui.canvas) continue;
                    if (nodes[i] == ui.control) continue;
                    if (nodes[i] == ui.arenalog) continue;
                    if (nodes[i] == ui.roundmenu) continue;
                    if (nodes[i] == ui.timer) continue;
                    if (nodes[i] == ui.autonode) continue;
                    nodes[i].remove();
                }
                ui.sidebar.innerHTML = '';
                ui.cardPile.innerHTML = '';
                ui.discardPile.innerHTML = '';
                ui.special.innerHTML = '';
                ui.ordering.innerHTML = '';
                ui.playerids.remove();
                game.players.length = 0;
                game.dead.length = 0;
                game.me = null;
            },
            clearConnect: function () {
                if (ui.ipnode) {
                    ui.ipnode.remove();
                    delete ui.ipnode;
                }
                if (ui.iptext) {
                    ui.iptext.remove();
                    delete ui.iptext;
                }
                if (ui.ipbutton) {
                    ui.ipbutton.remove();
                    delete ui.ipbutton;
                }
                if (ui.recentIP) {
                    ui.recentIP.remove();
                    delete ui.recentIP;
                }
                if (ui.hall_button) {
                    ui.hall_button.remove();
                    delete ui.hall_button;
                }
                if (ui.startServer) {
                    ui.startServer.remove();
                    delete ui.startServer;
                }
                if (ui.rooms) {
                    for (var i = 0; i < ui.rooms.length; i++) {
                        ui.rooms[i].remove();
                    }
                    delete ui.rooms;
                }
                if (ui.roombase) {
                    ui.roombase.remove();
                    delete ui.roombase;
                }
                if (ui.connectEvents) {
                    ui.connectEvents.remove();
                    ui.connectEventsCount.remove();
                    ui.connectClients.remove();
                    ui.connectClientsCount.remove();
                    ui.createRoomButton.remove();
                    delete ui.connectEvents;
                    delete ui.connectEventsCount;
                    delete ui.connectClients;
                    delete ui.connectClientsCount;
                    delete ui.createRoomButton;
                }
            },
            log: function () {
                var str = '', str2 = '', logvid = null;
                for (var i = 0; i < arguments.length; i++) {
                    var itemtype = get.itemtype(arguments[i]);
                    if (itemtype == 'player' || itemtype == 'players') {
                        str += '<span class="bluetext">' + get.translation(arguments[i]) + '</span>';
                    }
                    else if (itemtype == 'cards' || itemtype == 'card' || (typeof arguments[i] == 'object' && arguments[i] && arguments[i].name)) {
                        str += '<span class="yellowtext">' + get.translation(arguments[i]) + '</span>';
                    }
                    else if (typeof arguments[i] == 'object') {
                        if (arguments[i]) {
                            if (arguments[i].parentNode == ui.historybar) {
                                logvid = arguments[i].logvid;
                            }
                            else {
                                str += get.translation(arguments[i]);
                            }
                        }
                    }
                    else if (typeof arguments[i] == 'string') {
                        if (arguments[i][0] == '【' && arguments[i][arguments[i].length - 1] == '】') {
                            str += '<span class="greentext">' + get.translation(arguments[i]) + '</span>';
                        }
                        else if (arguments[i][0] == '#') {
                            var color = '';
                            switch (arguments[i][1]) {
                                case 'r': color = 'fire'; break;
                                case 'p': color = 'legend'; break;
                                case 'b': color = 'blue'; break;
                                case 'g': color = 'green'; break;
                                case 'y': color = 'yellow'; break;
                                case 'i': color = 'ice'; break;
                            }
                            str += '<span class="' + color + 'text">' + get.translation(arguments[i].slice(2)) + '</span>';
                        }
                        else {
                            str += get.translation(arguments[i]);
                        }
                    }
                    else {
                        str += arguments[i];
                    }

                }
                var node = ui.create.div();
                node.innerHTML = str;
                ui.sidebar.insertBefore(node, ui.sidebar.firstChild);
                game.addVideo('log', null, str);
                game.broadcast(function (str, str2) {
                    game.log(str);
                }, str, str2);
                if (!_status.video && !game.online) {
                    if (!logvid) {
                        logvid = _status.event.getLogv();
                    }
                    if (logvid) {
                        game.logv(logvid, '<div class="text center">' + str + '</div>');
                    }
                }
                if (lib.config.show_log != 'off' && !game.chess) {
                    var nodeentry = node.cloneNode(true);
                    ui.arenalog.insertBefore(nodeentry, ui.arenalog.firstChild);
                    if (!lib.config.clear_log) {
                        while (ui.arenalog.childNodes.length && ui.arenalog.scrollHeight > ui.arenalog.offsetHeight) {
                            ui.arenalog.lastChild.remove();
                        }
                    }
                    if (!lib.config.low_performance) {
                        nodeentry.style.transition = 'all 0s';
                        nodeentry.style.marginBottom = (-nodeentry.offsetHeight) + 'px';
                        ui.refresh(nodeentry);
                        nodeentry.style.transition = '';
                        nodeentry.style.marginBottom = '';
                    }
                    if (lib.config.clear_log) {
                        nodeentry.timeout = setTimeout(function () {
                            nodeentry.delete();
                        }, 1000);
                        for (var i = 0; i < ui.arenalog.childElementCount; i++) {
                            if (!ui.arenalog.childNodes[i].timeout) {
                                ui.arenalog.childNodes[i].remove();
                            }
                        }
                    }
                }
            },
            logv: function (player, card, targets, Evt, forced, logvid) {
                var node = ui.create.div('.hidden');
                node.node = {};
                logvid = logvid || get.id();
                if (!player) {
                    player = _status.event.getParent().logvid;
                    if (!player) return;
                }
                game.broadcast(function (player, card, targets, Evt, forced, logvid) {
                    game.logv(player, card, targets, Evt, forced, logvid);
                }, player, card, targets, Evt, forced, logvid);
                if (typeof player == 'string') {
                    for (var i = 0; i < ui.historybar.childElementCount; i++) {
                        if (ui.historybar.childNodes[i].logvid == player) {
                            ui.historybar.childNodes[i].added.push(card); break;
                        }
                    }
                    return;
                }
                if (typeof card == 'string') {
                    if (card != 'die') {
                        if (lib.skill[card] && lib.skill[card].logv === false && !forced) return;
                        if (!lib.translate[card]) return;
                    }
                    var avatar;
                    if (!player.isUnseen(0)) {
                        avatar = player.node.avatar.cloneNode();
                    }
                    else if (!player.isUnseen(1)) {
                        avatar = player.node.avatar2.cloneNode();
                    }
                    else {
                        return;
                    }
                    node.node.avatar = avatar;
                    avatar.style.transform = '';
                    avatar.className = 'avatar';
                    if (card == 'die') {
                        node.dead = true;
                        node.player = player;
                        var avatar2 = avatar.cloneNode();
                        avatar2.className = 'avatarbg grayscale1';
                        avatar.appendChild(avatar2);
                        avatar.style.opacity = 0.6;
                    }
                    else {
                        node.node.text = ui.create.div('', get.translation(card, 'skill'), avatar);
                        node.node.text.dataset.nature = 'water';
                        node.skill = card;
                    }
                    node.appendChild(avatar);
                    if (card == 'die' && targets && targets != player) {
                        node.source = targets;
                        var avatar;
                        player = targets;
                        if (!player.isUnseen(0)) {
                            avatar = player.node.avatar.cloneNode();
                        }
                        else if (!player.isUnseen(1)) {
                            avatar = player.node.avatar2.cloneNode();
                        }
                        else if (get.mode() == 'guozhan' && player.node && player.node.name_seat) {
                            avatar = ui.create.div('.avatar.cardbg');
                            avatar.innerHTML = player.node.name_seat.innerHTML[0];
                        }
                        else {
                            return;
                        }
                        avatar.style.transform = '';
                        node.node.avatar2 = avatar;
                        avatar.classList.add('avatar2');
                        node.appendChild(avatar);
                    }
                }
                else if (Array.isArray(card)) {
                    node.cards = card[1];
                    card = card[0];
                    var info = [card.suit || '', card.number || '', card.name || '', card.nature || ''];
                    if (!Array.isArray(node.cards) || !node.cards.length) {
                        node.cards = [ui.create.card(node, 'noclick', true).init(info)];
                    }
                    if (card.name == 'wuxie') {
                        if (ui.historybar.firstChild && ui.historybar.firstChild.type == 'wuxie') {
                            ui.historybar.firstChild.players.push(player);
                            ui.historybar.firstChild.cards.addArray(node.cards);
                            return;
                        }
                        else {
                            node.type = 'wuxie';
                            node.players = [player];
                        }
                    }
                    if (card.copy) {
                        card.copy(node, false);
                    }
                    else {
                        card = ui.create.card(node, 'noclick', true);
                        card.init(info);
                    }
                    var avatar;
                    if (!player.isUnseen(0)) {
                        avatar = player.node.avatar.cloneNode();
                    }
                    else if (!player.isUnseen(1)) {
                        avatar = player.node.avatar2.cloneNode();
                    }
                    else if (get.mode() == 'guozhan' && player.node && player.node.name_seat) {
                        avatar = ui.create.div('.avatar.cardbg');
                        avatar.innerHTML = player.node.name_seat.innerHTML[0];
                    }
                    else {
                        return;
                    }
                    node.node.avatar = avatar;
                    avatar.style.transform = '';
                    avatar.classList.add('avatar2');
                    node.appendChild(avatar);

                    if (targets && targets.length == 1 && targets[0] != player && get.itemtype(targets[0]) == 'player') {
                        (function () {
                            var avatar2;
                            var target = targets[0];
                            if (!target.isUnseen(0)) {
                                avatar2 = target.node.avatar.cloneNode();
                            }
                            else if (!player.isUnseen(1)) {
                                avatar2 = target.node.avatar2.cloneNode();
                            }
                            else if (get.mode() == 'guozhan' && target.node && target.node.name_seat) {
                                avatar2 = ui.create.div('.avatar.cardbg');
                                avatar2.innerHTML = target.node.name_seat.innerHTML[0];
                            }
                            else {
                                return;
                            }
                            node.node.avatar2 = avatar2;
                            avatar2.style.transform = '';
                            avatar2.classList.add('avatar2');
                            avatar2.classList.add('avatar3');
                            node.insertBefore(avatar2, avatar);
                        }());
                    }
                }
                if (targets && targets.length) {
                    if (targets.length == 1 && targets[0] == player) {
                        node.targets = [];
                    }
                    else {
                        node.targets = targets;
                    }
                }
                var fullheight = ui.historybar.offsetHeight;
                var num = Math.round((fullheight - 8) / 50);
                var margin = (fullheight - 42 * num) / (num + 1);
                node.style.transform = 'scale(0.8)';
                ui.historybar.insertBefore(node, ui.historybar.firstChild);
                ui.refresh(node);
                node.classList.remove('hidden');
                for (var i = 0; i < ui.historybar.childElementCount; i++) {
                    var current = ui.historybar.childNodes[i];
                    if (i < num) {
                        current.style.transform = 'scale(1) translateY(' + (margin + i * (42 + margin) - 4) + 'px)';
                    }
                    else {
                        if (!current.removetimeout) {
                            current.style.opacity = 0;
                            current.style.transform = 'scale(1) translateY(' + fullheight + 'px)';
                            current.removetimeout = setTimeout((function (current) {
                                return function () {
                                    current.remove();
                                };
                            }(current)), 500);
                        }
                    }
                }
                if (lib.config.touchscreen) {
                    node.addEventListener('touchstart', ui.click.intro);
                }
                else {
                    // node.addEventListener('mouseenter',ui.click.intro);
                    node.addEventListener(lib.config.pop_logv ? 'mousemove' : 'click', ui.click.logv);
                    node.addEventListener('mouseleave', ui.click.logvleave);
                }
                node.logvid = logvid;
                node.added = [];
                if (!game.online) {
                    Evt = Evt || _status.event;
                    Evt.logvid = node.logvid;
                }
                return node;
            },
            /**
             * 从IndexedDB中获取对象仓库(object store)，并更新对象
             * @param {string} type - 仓库名称
             * @param {string} id - 键路径的值
             * @param {any} item - 要插入/更新的对象
             * @param {function} callback - 成功时回调函数
             */
            putDB: function (type, id, item, callback) {
                if (!lib.db) return item;
                if (lib.status.reload) {
                    lib[_status.dburgent ? 'ondb2' : 'ondb'].push(['putDB', Array.from(arguments)]);
                    return;
                }
                lib.status.reload++;
                var put = lib.db.transaction([type], 'readwrite').objectStore(type).put(item, id);
                put.onsuccess = function () {
                    if (callback) {
                        _status.dburgent = true;
                        callback.apply(this, arguments);
                        delete _status.dburgent;
                    }
                    game.reload2();
                };
            },
            /**
             * 从IndexedDB中获取对象仓库(object store)，并获取对象
             * @param {string} type - 仓库名称
             * @param {string} id - 键路径的值
             * @param {!function} callback - 成功时回调函数
             */
            getDB: function (type, id, callback) {
                if (!lib.db) {
                    callback(null);
                    return;
                }
                if (!callback) return;
                if (lib.status.reload) {
                    lib[_status.dburgent ? 'ondb2' : 'ondb'].push(['getDB', Array.from(arguments)]);
                    return;
                }
                lib.status.reload++;
                var store = lib.db.transaction([type], 'readwrite').objectStore(type);
                if (id) {
                    store.get(id).onsuccess = function (e) {
                        _status.dburgent = true;
                        callback(e.target.result);
                        delete _status.dburgent;
                        game.reload2();
                    };
                }
                else {
                    var obj = {};
                    store.openCursor().onsuccess = function (e) {
                        var cursor = e.target.result;
                        if (cursor) {
                            obj[cursor.key] = cursor.value;
                            cursor.continue();
                        }
                        else {
                            _status.dburgent = true;
                            callback(obj);
                            delete _status.dburgent;
                            game.reload2();
                        }
                    }
                }
            },
            /**
             * 从IndexedDB中获取对象仓库(object store)，并删除对象
             * @param {string} type - 仓库名称
             * @param {string} id - 键路径的值
             * @param {function} callback - 成功时回调函数
             */
            deleteDB: function (type, id, callback) {
                if (!lib.db) {
                    callback(false);
                    return;
                }
                if (lib.status.reload) {
                    lib[_status.dburgent ? 'ondb2' : 'ondb'].push(['deleteDB', Array.from(arguments)]);
                    return;
                }
                if (arguments.length == 1) {
                    game.getDB(type, null, function (obj) {
                        var store = lib.db.transaction([type], 'readwrite').objectStore(type);
                        for (var id in obj) {
                            lib.status.reload++;
                        }
                        for (var id in obj) {
                            store.delete(id).onsuccess = game.reload2;
                        }
                        game.reload2();
                    });
                }
                else {
                    lib.status.reload++;
                    var store = lib.db.transaction([type], 'readwrite').objectStore(type);
                    store.delete(id).onsuccess = function () {
                        if (callback) {
                            callback.apply(this, arguments);
                        }
                        game.reload2();
                    };
                }
            },
            save: function (key, value, mode) {
                if (_status.reloading) return;
                mode = mode || lib.config.mode;
                if (!lib.db) {
                    var config = {};
                    if (key) {
                        try {
                            config = JSON.parse(localStorage.getItem(lib.configprefix + mode));
                            if (typeof config != 'object') throw 'err';
                        }
                        catch (err) {
                            config = {};
                        }
                        if (value == undefined) {
                            delete config[key];
                            if (mode == lib.config.mode) delete lib.storage[key];
                        }
                        else {
                            config[key] = value;
                            if (mode == lib.config.mode) lib.storage[key] = value;
                        }
                        config.version = lib.version;
                        localStorage.setItem(lib.configprefix + mode, JSON.stringify(config));
                    }
                    else {
                        localStorage.setItem(lib.configprefix + mode, JSON.stringify(lib.storage));
                    }
                }
                else {
                    if (key) {
                        if (mode == lib.config.mode) {
                            if (value == undefined) {
                                delete lib.storage[key];
                            }
                            else {
                                lib.storage[key] = value;
                            }
                            lib.storage.version = lib.version;
                            game.putDB('data', mode, lib.storage);
                        }
                        else {
                            game.getDB('data', mode, function (config) {
                                if (!config) config = {};
                                if (value == undefined) {
                                    delete config[key];
                                }
                                else {
                                    config[key] = value;
                                }
                                config.version = lib.version;
                                game.putDB('data', mode, config);
                            });
                        }
                    }
                    else {
                        game.putDB('data', mode, get.copy(lib.storage));
                    }
                }
            },
            showChangeLog: function () {
                if (lib.version != lib.config.version || _status.extensionChangeLog) {
                    var ul = document.createElement('ul');
                    ul.style.textAlign = 'left';
                    var caption;
                    var players = null, cards = null;
                    if (lib.version != lib.config.version) {
                        for (var i = 0; i < lib.changeLog.length; i++) {
                            if (lib.changeLog[i].indexOf('players://') == 0) {
                                try {
                                    players = JSON.parse(lib.changeLog[i].slice(10));
                                }
                                catch (e) {
                                    players = null;
                                }
                            }
                            else if (lib.changeLog[i].indexOf('cards://') == 0) {
                                try {
                                    cards = JSON.parse(lib.changeLog[i].slice(8));
                                }
                                catch (e) {
                                    cards = null;
                                }
                            }
                            else {
                                var li = document.createElement('li');
                                li.innerHTML = lib.changeLog[i];
                                ul.appendChild(li);
                            }
                        }
                        caption = lib.version + '更新内容';
                    }
                    else {
                        caption = '扩展更新';
                    }
                    game.saveConfig('version', lib.version);
                    for (var i in _status.extensionChangeLog) {
                        var li = document.createElement('li');
                        li.innerHTML = i + '：' + _status.extensionChangeLog[i];
                        ul.appendChild(li);
                    }
                    var dialog = ui.create.dialog(caption, 'hidden');
                    var lic = ui.create.div(dialog.content);
                    lic.style.display = 'block';
                    ul.style.display = 'inline-block';
                    ul.style.marginLeft = '-40px';
                    lic.appendChild(ul);
                    if (players) {
                        for (var i = 0; i < players.length; i++) {
                            if (!lib.character[players[i]]) {
                                players.splice(i--, 1);
                            }
                        }
                        if (players.length) {
                            dialog.addSmall([players, 'character']);
                            dialog.classList.add('forcebutton');
                            dialog.classList.add('withbg');
                        }
                    }
                    if (cards) {
                        for (var i = 0; i < cards.length; i++) {
                            if (!lib.card[cards[i]]) {
                                cards.splice(i--, 1);
                            }
                        }
                        if (cards.length) {
                            for (var i = 0; i < cards.length; i++) {
                                cards[i] = [get.translation(get.type(cards[i])), '', cards[i]]
                            }
                            dialog.addSmall([cards, 'vcard']);
                            dialog.classList.add('forcebutton');
                            dialog.classList.add('withbg');
                        }
                    }
                    dialog.open();
                    var hidden = false;
                    if (!ui.auto.classList.contains('hidden')) {
                        ui.auto.hide();
                        hidden = true;
                    }
                    game.pause();
                    var control = ui.create.control('确定', function () {
                        dialog.close();
                        control.close();
                        if (hidden) ui.auto.show();
                        game.resume();
                    });
                    lib.init.onfree();
                }
            },
            showExtensionChangeLog: function (str, extname) {
                extname = extname || _status.extension;
                var cfg = 'extension_' + extname + '_changelog';
                if (lib.extensionPack[extname] && lib.extensionPack[extname].version != lib.config[cfg]) {
                    game.saveConfig(cfg, lib.extensionPack[extname].version);
                    if (!_status.extensionChangeLog) {
                        _status.extensionChangeLog = {};
                        _status.extensionChangeLog[extname] = str;
                    }
                }
            },
            /**
             * 保存配置
             * 如果有IndexedDB，使用IndexedDB；否则以`{key:lib.configprefix + 'config', value:{key:value}}`的形式存入localStorage
             * @function
             * @param {!string} key 对应的键名
             * @param {?Object} value 值，如果为虚值表示删除数据，否则添加/更新数据
             * @param {?string} local 模组名，如果指定字符串，更新模组配置(`lib.config.mode_config[local]`)，否则更新全局配置(`lib.config`)
             * @param {function():void} callback 更新完成的回调函数
             */
            saveConfig: function (key, value, local, callback) {
                if (_status.reloading) return;
                if (local) {
                    var localmode;
                    if (typeof local == 'string') {
                        localmode = local;
                    }
                    else {
                        localmode = lib.config.mode;
                    }
                    if (!lib.config.mode_config[localmode]) {
                        lib.config.mode_config[localmode] = {};
                    }
                    if (value == undefined) {
                        delete lib.config.mode_config[localmode][key];
                    }
                    else {
                        lib.config.mode_config[localmode][key] = value;
                    }
                    key += '_mode_config_' + localmode;
                }
                else {
                    if (value == undefined) {
                        delete lib.config[key];
                    }
                    else {
                        lib.config[key] = value;
                    }
                }
                if (!lib.db) {
                    var config;
                    try {
                        config = JSON.parse(localStorage.getItem(lib.configprefix + 'config'));
                        if (!config || typeof config != 'object') throw 'err'
                    }
                    catch (err) {
                        config = {};
                    }
                    if (value === undefined) {
                        delete config[key];
                    }
                    else {
                        config[key] = value;
                    }
                    localStorage.setItem(lib.configprefix + 'config', JSON.stringify(config));
                    if (callback) {
                        callback();
                    }
                }
                else {
                    if (value == undefined) {
                        game.deleteDB('config', key, callback);
                    }
                    else {
                        game.putDB('config', key, value, callback);
                    }
                }
            },
            /**
             * 持久化配置，`lib.config[key]`
             * @function
             * @param {!string} key 键名
             * @see {@link game.saveConfig}
             */
            saveConfigValue: function (key) {
                game.saveConfig(key, lib.config[key]);
            },
            /**
             * 持久化拓展的配置
             * @function
             * @param {!string} extension 拓展名
             * @param {!string} key 键名，自动拓展为`extension_${extension}_${key}`
             * @param {?Object} value
             * @see {@link game.saveConfig}
             */
            saveExtensionConfig: function (extension, key, value) {
                return game.saveConfig('extension_' + extension + '_' + key, value);
            },
            /**
             * 获取拓展的配置
             * @function
             * @param {!string} extension 拓展名
             * @param {!string} key 键名
             * @returns {?Object} 
             */
            getExtensionConfig: function (extension, key) {
                return lib.config['extension_' + extension + '_' + key];
            },
            /**
             * 于IndexedDB/localStorage中清空某个mode的配置
             * @function
             * @param {!string} mode mode名
             */
            clearModeConfig: function (mode) {
                if (_status.reloading) return;
                if (!lib.db) {
                    var config;
                    try {
                        config = JSON.parse(localStorage.getItem(lib.configprefix + 'config'));
                        if (!config || typeof config != 'object') throw 'err'
                    }
                    catch (err) {
                        config = {};
                    }
                    for (var i in config) {
                        if (i.substr(i.indexOf('_mode_config') + 13) == mode) {
                            delete config[i];
                        }
                    }
                    localStorage.setItem(lib.configprefix + 'config', JSON.stringify(config));
                    localStorage.removeItem(lib.configprefix + mode);
                }
                else {
                    game.getDB('config', null, function (config) {
                        for (var i in config) {
                            if (i.substr(i.indexOf('_mode_config') + 13) == mode) {
                                game.saveConfig(i);
                            }
                        }
                    });
                }
            },
            addPlayer: function (position, character, character2) {
                if (position < 0 || position > game.players.length + game.dead.length || position == undefined) {
                    position = Math.ceil(Math.random() * (game.players.length + game.dead.length));
                }
                var players = game.players.concat(game.dead);
                ui.arena.setNumber(players.length + 1);
                for (var i = 0; i < players.length; i++) {
                    if (parseInt(players[i].dataset.position) >= position) {
                        players[i].dataset.position = parseInt(players[i].dataset.position) + 1;
                    }
                }
                var player = ui.create.player(ui.arena).animate('start');
                if (character) player.init(character, character2);
                game.players.push(player);
                player.dataset.position = position;
                game.arrangePlayers();
                return player;
            },
            addFellow: function (position, character, animation) {
                game.addVideo('addFellow', null, [position, character, animation]);
                var player = ui.create.player(ui.arena).animate(animation || 'start');
                player.dataset.position = position || game.players.length + game.dead.length;
                player.getId();
                if (character) player.init(character);
                game.players.push(player); game.arrangePlayers();
                return player;
            },
            triggerEnter: function (player) {
                let next = game.createEvent('enterGame', false);
                next.player = player;
                next.setContent(function () {
                    Evt.trigger('enterGame');
                });
            },
            restorePlayer: function (player) {
                if (game.players.contains(player) || game.dead.contains(player)) return;
                var position = parseInt(player.dataset.position);
                if (position < 0 || position > game.players.length + game.dead.length || position == undefined) {
                    position = Math.ceil(Math.random() * (game.players.length + game.dead.length));
                }
                var players = game.players.concat(game.dead);
                ui.arena.setNumber(players.length + 1);
                for (var i = 0; i < players.length; i++) {
                    if (parseInt(players[i].dataset.position) >= position) {
                        players[i].dataset.position = parseInt(players[i].dataset.position) + 1;
                    }
                }
                game.players.push(player);
                delete player.removed;
                player.removeAttribute('style');
                player.animate('start');
                ui.arena.appendChild(player);
                game.arrangePlayers();
                return player;
            },
            removePlayer: function (player) {
                if (_status.roundStart == player) {
                    _status.roundStart = player.next || player.getNext() || game.players[0];
                }
                var players = game.players.concat(game.dead);
                player.style.left = player.getLeft() + 'px';
                player.style.top = player.getTop() + 'px';
                if (player == undefined) player = game.dead[0] || game.me.next;
                var position = parseInt(player.dataset.position);
                for (var i = 0; i < players.length; i++) {
                    if (parseInt(players[i].dataset.position) > position) {
                        players[i].dataset.position = parseInt(players[i].dataset.position) - 1;
                    }
                }
                if (player.isAlive()) {
                    player.next.previous = player.previous;
                    player.previous.next = player.next;
                }
                player.nextSeat.previousSeat = player.previousSeat;
                player.previousSeat.nextSeat = player.nextSeat;
                player.delete();
                game.players.remove(player);
                game.dead.remove(player);
                ui.arena.setNumber(players.length - 1);
                player.removed = true;
                if (player == game.me) {
                    ui.me.hide();
                    ui.auto.hide();
                    ui.wuxie.hide();
                }
                setTimeout(function () {
                    player.removeAttribute('style');
                }, 500);
                return player;
            },
            replacePlayer: function (player, character, character2) {
                player.removed = true;
                var position = parseInt(player.dataset.position);
                game.players.remove(player);
                game.dead.remove(player);
                player.delete();
                var player2 = ui.create.player(ui.arena).animate('start');
                if (character) player2.init(character, character2);
                game.players.push(player2);
                player2.dataset.position = position;
                player2.nextSeat = player.nextSeat;
                player2.previousSeat = player.previousSeat;
                player2.nextSeat.previousSeat = player2;
                player2.previousSeat.nextSeat = player2;
                var player3 = player2.nextSeat;
                while (player3.isDead()) player3 = player3.nextSeat;
                player3.previous = player2;
                player2.next = player3;
                var player4 = player2.previousSeat;
                while (player4.isDead()) player4 = player4.previousSeat;
                player4.next = player2;
                player2.previous = player4;
                if (_status.roundStart == player) {
                    _status.roundStart = player2;
                }
                return player2;
            },
            arrangePlayers: function () {
                if (game.chess && game.me) {
                    var friendCount = 0;
                    var enemyCount = 0;
                    var rand = Math.random() < 0.5;
                    for (var i = 0; i < game.players.length; i++) {
                        if (game.players[i].side == game.me.side) {
                            if (rand) {
                                if (game.players[i] == game.friendZhu) {
                                    game.players[i]._sortCount = -2;
                                }
                                else {
                                    game.players[i]._sortCount = 2 * friendCount;
                                }
                            }
                            else {
                                if (game.players[i] == game.friendZhu) {
                                    game.players[i]._sortCount = -1;
                                }
                                else {
                                    game.players[i]._sortCount = 2 * friendCount + 1;
                                }
                            }
                            friendCount++;
                        }
                        else {
                            if (rand) {
                                if (game.players[i] == game.enemyZhu) {
                                    game.players[i]._sortCount = -1;
                                }
                                else {
                                    game.players[i]._sortCount = 2 * enemyCount + 1;
                                }
                            }
                            else {
                                if (game.players[i] == game.enemyZhu) {
                                    game.players[i]._sortCount = -2;
                                }
                                else {
                                    game.players[i]._sortCount = 2 * enemyCount;
                                }
                            }
                            enemyCount++;
                        }
                    }
                    game.players.sort(function (a, b) {
                        return a._sortCount - b._sortCount;
                    });
                    for (var i = 0; i < game.players.length; i++) {
                        delete game.players[i]._sortCount;
                    }
                }
                else {
                    game.players.sort(lib.sort.position);
                }
                var players = game.players.concat(game.dead);
                players.sort(lib.sort.position);
                for (var i = 0; i < players.length; i++) {
                    if (i == 0) {
                        players[i].previousSeat = players[players.length - 1];
                    }
                    else {
                        players[i].previousSeat = players[i - 1];
                    }
                    if (i == players.length - 1) {
                        players[i].nextSeat = players[0];
                    }
                    else {
                        players[i].nextSeat = players[i + 1];
                    }
                }
                for (var i = 0; i < game.players.length; i++) {
                    if (i == 0) {
                        game.players[i].previous = game.players[game.players.length - 1];
                    }
                    else {
                        game.players[i].previous = game.players[i - 1];
                    }
                    if (i == game.players.length - 1) {
                        game.players[i].next = game.players[0];
                    }
                    else {
                        game.players[i].next = game.players[i + 1];
                    }
                }
            },
            /**
             * 检测一组技能，返回其中未失效的技能
             * @param {!Array<string>} skills 技能名数组
             * @param {!HTMLDivElement} player 检测角色
             * @param {?Function} exclude 用于筛选的函数
             * @returns {Array<string>} 排除失效技能的数组
             */
            filterSkills: function (skills, player, exclude) {
                let out = skills.slice(0);
                for (let i in player.disabledSkills) {
                    out.remove(i);
                }
                if (player.$.skill_blocker && player.$.skill_blocker.length) {
                    for (let i = 0; i < out.length; i++) {
                        if ((!exclude || !exclude.contains(out[i])) && get.is.blocked(out[i], player)) out.splice(i--, 1);
                    }
                }
                return out;
            },
            /**
             * 对一组技能进行展开，得到由其中每个技能和其子技能组成的数组，返回展开后的技能名数组
             * @param {!Array<string>} skills 技能名数组
             * @returns {Array<string>} 包含子技能的技能名数组
             */
            expandSkills: function (skills) {
                var skills2 = [];
                for (var i = 0; i < skills.length; i++) {
                    var info = get.info(skills[i]);
                    if (info) {
                        if (info.group) skills2 = skills2.concat(info.group);
                    }
                    else {
                        console.log(skills[i]);
                    }
                }
                for (var i = 0; i < skills2.length; i++) {
                    skills.add(skills2[i]);
                }
                return skills;
            },
            css: function (style) {
                for (var i in style) {
                    if (ui.style[i]) ui.style[i].innerHTML = i + JSON.stringify(style[i]).replace(/"/g, "");
                    else {
                        ui.style[i] = document.createElement('style');
                        ui.style[i].innerHTML = i + JSON.stringify(style[i]).replace(/"/g, "");
                        document.head.appendChild(ui.style[i]);
                    }
                }
            },
            players: [],
            dead: [],
            imported: [],
            playerMap: {},
            phaseNumber: 0,
            roundNumber: 0,
            shuffleNumber: 0,
            /**检测类game方法 */
            ...__webpack_require__(5909),
            /**联机类game方法 */
            ...__webpack_require__(6254),
        }
    }
}

/***/ }),

/***/ 4491:
/***/ ((module) => {

module.exports = {
    paused: false,
    paused2: false,
    paused3: false,
    over: false,
    clicked: false,
    auto: false,
    /**
     * 当前事件对象，游戏内所有未定义的event等价于_status.event
     * @name _status.event
     * @type {!Object}
     */
    event: {
        finished: true,
        /**
         * _status.event.next：插入事件列表，当前step结束后，该列表内的事件会被执行
         * {@link game.createEvent}生成的事件默认插入其中
         * @name _status.event_next
         * @type {!Array}
         */
        next: [],
        /**
         * _status.event.after：后续事件列表，当前事件结束后，该列表内的事件会被执行
         * @name _status.event_after
         * @type {!Array}
         */
        after: []
    },
    ai: {},
    lastdragchange: [],
    skillaudio: [],
    dieClose: [],
    dragline: [],
    dying: [],
    globalHistory: [{
        cardMove: [],
        custom: [],
    }],
    cardtag: {
        yingbian_zhuzhan: [],
        yingbian_kongchao: [],
        yingbian_fujia: [],
        yingbian_canqu: [],
    },
    prehidden_skills: [],
}

/***/ }),

/***/ 2860:
/***/ ((module) => {

module.exports = {
    aiFun: (vkCore) => {
        let { game, ui, get, ai, lib, _status } = vkCore
        return {
            basic: {
                chooseButton: function (check) {
                    var Evt = _status.event;
                    var i, j, range, buttons, buttons2;
                    var ok = false, forced = Evt.forced;
                    var iwhile = 100;
                    while (iwhile--) {
                        range = get.select(Evt.selectButton);
                        if (range[1] == -1) {
                            j = 0;
                            for (i = 0; i < ui.selected.buttons.length; i++) {
                                j += check(ui.selected.buttons[i]);
                            }
                            return (j > 0);
                        }
                        buttons = get.selectableButtons();
                        if (buttons.length == 0) {
                            return ok;
                        }
                        buttons2 = buttons.slice(0);
                        var ix = 0;
                        var checkix = check(buttons[0], buttons2);
                        for (i = 1; i < buttons.length; i++) {
                            var checkixtmp = check(buttons[i], buttons2);
                            if (checkixtmp > checkix) {
                                ix = i;
                                checkix = checkixtmp;
                            }
                        }
                        // buttons.sort(function(a,b){
                        //     return check(b,buttons2)-check(a,buttons2);
                        // });
                        if (check(buttons[ix]) <= 0) {
                            if (!forced || ok) {
                                return ok;
                            }
                        }
                        buttons[ix].classList.add('selected');
                        ui.selected.buttons.add(buttons[ix]);
                        game.check();
                        if (ui.selected.buttons.length >= range[0]) {
                            ok = true;
                        }
                        if (ui.selected.buttons.length == range[1]) {
                            return true;
                        }
                    }
                },
                chooseCard: function (check) {
                    var Evt = _status.event;
                    if (Evt.filterCard == undefined) return (check() > 0);
                    var i, j, range, cards, cards2, skills, check, effect;
                    var ok = false, forced = Evt.forced;
                    var iwhile = 100;
                    while (iwhile--) {
                        range = get.select(Evt.selectCard);
                        if (ui.selected.cards.length >= range[0]) {
                            ok = true;
                        }
                        if (range[1] == -1) {
                            if (ui.selected.cards.length == 0) return true;
                            j = 0;
                            for (i = 0; i < ui.selected.cards.length; i++) {
                                effect = check(ui.selected.cards[i]);
                                if (effect < 0) j -= Math.sqrt(-effect);
                                else j += Math.sqrt(effect);
                            }
                            return (j > 0);
                        }
                        cards = get.selectableCards();
                        if (!_status.event.player._noSkill) {
                            cards = cards.concat(get.skills());
                        }
                        if (cards.length == 0) {
                            return ok;
                        }
                        cards2 = cards.slice(0);
                        // cards.sort(function(a,b){
                        //     return (check(b,cards2)-check(a,cards2));
                        // });
                        var ix = 0;
                        var checkix = check(cards[0], cards2);
                        for (i = 1; i < cards.length; i++) {
                            var checkixtmp = check(cards[i], cards2);
                            if (checkixtmp > checkix) {
                                ix = i;
                                checkix = checkixtmp;
                            }
                        }
                        if (check(cards[ix]) <= 0) {
                            if (!forced || ok) {
                                return ok;
                            }
                        }
                        if (typeof cards[ix] == 'string') {
                            ui.click.skill(cards[ix]);
                            var info = get.info(Evt.skill);
                            if (info.filterCard) {
                                check = info.check || get.unuseful2;
                                return (ai.basic.chooseCard(check));
                            }
                            else {
                                return true;
                            }
                        }
                        else {
                            cards[ix].classList.add('selected');
                            ui.selected.cards.add(cards[ix]);
                            game.check();
                            if (ui.selected.cards.length >= range[ix]) {
                                ok = true;
                            }
                            if (ui.selected.cards.length == range[1]) {
                                return true;
                            }
                        }
                    }
                },
                chooseTarget: function (check) {
                    var Evt = _status.event;
                    if (Evt.filterTarget == undefined) return (check() > 0);
                    var i, j, range, targets, targets2, effect;
                    var ok = false, forced = Evt.forced;
                    var iwhile = 100;
                    while (iwhile--) {
                        range = get.select(Evt.selectTarget);
                        if (range[1] == -1) {
                            j = 0;
                            for (i = 0; i < ui.selected.targets.length; i++) {
                                effect = check(ui.selected.targets[i]);
                                if (effect < 0) j -= Math.sqrt(-effect);
                                else j += Math.sqrt(effect);
                            }
                            return (j > 0);
                        }
                        else if (range[1] == 0) {
                            return check() > 0
                        }
                        targets = get.selectableTargets();
                        if (targets.length == 0) {
                            return range[0] == 0 || ok;
                        }
                        targets2 = targets.slice(0);
                        // targets.sort(function(a,b){
                        //     return check(b)-check(a);
                        // });
                        var ix = 0;
                        var checkix = check(targets[0], targets2);
                        for (i = 1; i < targets.length; i++) {
                            var checkixtmp = check(targets[i], targets2);
                            if (checkixtmp > checkix) {
                                ix = i;
                                checkix = checkixtmp;
                            }
                        }
                        if (check(targets[ix]) <= 0) {
                            if (!forced || ok) {
                                return ok;
                            }
                        }
                        targets[ix].classList.add('selected');
                        ui.selected.targets.add(targets[ix]);
                        game.check();
                        if (ui.selected.targets.length >= range[0]) {
                            ok = true;
                        }
                        if (ui.selected.targets.length == range[1]) {
                            return true;
                        }
                    }
                }
            },
            /**
             * AI用取值
             * @see {@link get}
             */
            get: get
        }
    }
}

/***/ }),

/***/ 7806:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
   getFun: (vkCore) => {
      let { game, ui, get, ai, lib, _status } = vkCore
      return {
         /**
          * 返回联机名称
          * @returns {!number} 默认为“无名玩家”
          */
         connectNickname: function () {
            return typeof lib.config.connect_nickname == 'string' ? (lib.config.connect_nickname.slice(0, 12)) : '无名玩家';
         },
         //TODO
         sourceCharacter: function (str) {
            if (str) {
               for (var i in lib.characterReplace) {
                  if (lib.characterReplace[i].contains(str)) return i;
               }
            }
            return str;
         },
         /**
          * 返回一个角色是否是幸运星；
          * 此函数仅单机模式有效，联机模式总返回false
          * @param {GameCores.GameObjects.Player} player 一个角色
          * @returns {!boolean}
          */
         isLuckyStar: function (player) {
            if (player && player.hasSkillTag('luckyStar')) return true;
            if (_status.connectMode) return false;
            return (!player || player == game.me || player.isUnderControl()) && lib.config.lucky_star == true;
         },
         /**
          * 返回模板的hp
          * @param {(number|string)} hp 如果是数值，返回`hp`；如果是字符串，且为`hp/maxHp`的形式，返回那个**hp**的值；其他情况返回0
          * @returns {!number}
          */
         infoHp: function (hp) {
            if (typeof hp == 'number') return hp;
            else if (typeof hp == 'string' && hp.indexOf('/') != -1) {
               return parseInt(hp.slice(0, hp.indexOf('/')));
            }
            return 0;
         },
         /**
          * 返回模板的maxHp
          * @param {(number|string)} hp 如果是数值，返回`hp`；如果是字符串，且为`hp/maxHp`的形式，返回那个**maxHp**的值；其他情况返回0
          * @returns {!number}
          */
         infoMaxHp: function (hp) {
            if (typeof hp == 'number') return hp;
            else if (typeof hp == 'string' && hp.indexOf('/') != -1) {
               return parseInt(hp.slice(hp.indexOf('/') + 1));
            }
            return 0;
         },
         /**
          * 布尔判断封装
          * @namespace
          */
         is: {
            //“保护新手”模式的ban将
            banForBeginner(current) {
               if (current in lib.character) {
                  for (var i in lib.characterPack) {
                     if (!['Beginner', 'hololive', 'nijisanji', 'clubs', 'vtuber'].contains(i)) {
                        if (current in lib.characterPack[i]) {
                           return true
                        }
                     }
                  }
                  if ([
                     're_ShigureUi', 're_NijikawaRaki',
                     'ŌokamiMio',
                     'Elu', 'SuzukaUtako', 'MononobeAlice', 'SakuraRitsuki', 'YagamiKaruta',
                     'Bella', 'Carol', 'Azusa', 'Yousa', 'AkiRinco', 'Lovely', 'Pudding', 'jike', 'Bacharu', 'SephiraSu', 'Reine', 'IsekaiJoucho', 'Rim', 'Harusaruhi',
                     'Bafuko', 'Hiiro', 'Eilene', 'YaotomeNoe', 'Niuniuzi', 'Zaodaoji'
                  ].contains(current)) return true;
                  return false;
               }
               if (current in lib.card) {
                  for (var i in lib.cardPack) {
                     if (!['standard', 'extra'].contains(i)) {
                        if (lib.cardPack[i].contains(current)) {
                           return true
                        }
                     }
                  }
                  return false;
               }
            },
            //检查卡牌是否符合要求的快捷方法(只要求满足至少一种条件，无条件时默认不满足)
            filterCardBy(card, arg) {
               if (!card || !arg) return false;
               if (typeof arg == 'string') {
                  if (arg == get.name(card)) return true;
               }
               else if (typeof arg == 'object') {
                  for (var x in arg) {
                     var value;
                     if (x == 'type' || x == 'subtype' || x == 'color' || x == 'suit' || x == 'number') {
                        value = get[x](card);
                     }
                     else {
                        value = card[x];
                     }
                     if ((['string', 'number'].includes(typeof arg[x]) && value == arg[x]) ||
                        (Array.isArray(arg[x]) && arg[x].contains(value))) {
                        return true;
                     }
                  }
               }
               else if (typeof arg == 'function') {
                  return arg(card);
               }
               return false;
            },
            /**
             * 判断技能是否被封锁
             */
            blocked(skill, player) {
               if (!player.$.skill_blocker || !player.$.skill_blocker.length) return false;
               for (let i of player.$.skill_blocker) {
                  if (lib.skill[i] && lib.skill[i].skillBlocker && lib.skill[i].skillBlocker(skill, player)) return true;
               }
               return false;
            },
            /**
             * 判断角色是否为多势力
             */
            double(name, array) {
               if (!lib.character[name] || !lib.character[name][4]) return false;
               for (let i of lib.character[name][4]) {
                  if (i.indexOf('doublegroup:') == 0) {
                     if (!array) return true;
                     return i.split(':').slice(1);
                  }
               }
               return false;
            },
            /**
             * 判断卡牌是否携带应变标签
             */
            yingbian(node) {
               return get.cardtag(node, 'yingbian_zhuzhan') || get.cardtag(node, 'yingbian_fujia') || get.cardtag(node, 'yingbian_canqu') || get.cardtag(node, 'yingbian_kongchao');
            },
            emoji(substring) {
               if (substring) {
                  var reg = new RegExp("[~#^$@%&!?%*]", 'g');
                  if (substring.match(reg)) {
                     return true;
                  }
                  for (var i = 0; i < substring.length; i++) {
                     var hs = substring.charCodeAt(i);
                     if (0xd800 <= hs && hs <= 0xdbff) {
                        if (substring.length > 1) {
                           var ls = substring.charCodeAt(i + 1);
                           var uc = ((hs - 0xd800) * 0x400) + (ls - 0xdc00) + 0x10000;
                           if (0x1d000 <= uc && uc <= 0x1f77f) {
                              return true;
                           }
                        }
                     }
                     else if (substring.length > 1) {
                        var ls = substring.charCodeAt(i + 1);
                        if (ls == 0x20e3) {
                           return true;
                        }
                     }
                     else {
                        if (0x2100 <= hs && hs <= 0x27ff) {
                           return true;
                        }
                        else if (0x2B05 <= hs && hs <= 0x2b07) {
                           return true;
                        }
                        else if (0x2934 <= hs && hs <= 0x2935) {
                           return true;
                        }
                        else if (0x3297 <= hs && hs <= 0x3299) {
                           return true;
                        }
                        else if (hs == 0xa9 || hs == 0xae || hs == 0x303d || hs == 0x3030
                           || hs == 0x2b55 || hs == 0x2b1c || hs == 0x2b1b
                           || hs == 0x2b50) {
                           return true;
                        }
                     }
                  }
               }
               return false;
            },
            banWords(str) {
               if (get.is.emoji(str)) return true;
               for (let i of (__webpack_require__(476).bannedKeyWords)) {
                  if (str.indexOf(i) != -1) return true;
               }
               return false;
            },
            converted(Evt) {
               return !(Evt.card && Evt.card.isCard);
            },
            safari() {
               var ua = navigator.userAgent.toLowerCase();
               return ua.indexOf('safari' != -1) && ua.indexOf('chrome') == -1;
            },
            freePosition(cards) {
               for (var i = 0; i < cards.length; i++) {
                  if (!cards[i].hasPosition) return false;
                  if (cards[i].hasPosition()) return false;
               }
               return true;
            },
            nomenu(name, item) {
               var menus = ['system', 'menu'];
               var configs = {
                  show_round_menu: lib.config.show_round_menu,
                  round_menu_func: lib.config.round_menu_func,
                  touchscreen: lib.config.touchscreen,
                  swipe_up: lib.config.swipe_up,
                  swipe_down: lib.config.swipe_down,
                  swipe_left: lib.config.swipe_left,
                  swipe_right: lib.config.swipe_right,
                  right_click: lib.config.right_click,
                  phonelayout: lib.config.phonelayout
               };
               configs[name] = item;
               if (!configs.phonelayout) return false;
               if (configs.show_round_menu && menus.contains(configs.round_menu_func)) {
                  return false;
               }
               if (configs.touchscreen) {
                  if (menus.contains(configs.swipe_up)) return false;
                  if (menus.contains(configs.swipe_down)) return false;
                  if (menus.contains(configs.swipe_left)) return false;
                  if (menus.contains(configs.swipe_right)) return false;
               }
               else {
                  if (configs.right_click == 'config') return false;
               }
               if (name) {
                  setTimeout(function () {
                     alert('请将至少一个操作绑定为显示按钮或打开菜单，否则将永远无法打开菜单');
                  });
               }
               return true;
            },
            altered(skill) {
               return false;
               // if(_status.connectMode) return true;
               // return !lib.config.vintageSkills.contains(skill);
            },
            node(obj) {
               var str = Object.prototype.toString.call(obj);
               if (str && str.indexOf('[object HTML')) return true;
               return false;
            },
            div(obj) {
               return Object.prototype.toString.call(obj) === '[object HTMLDivElement]';
            },
            map(obj) {
               return Object.prototype.toString.call(obj) === '[object Map]';
            },
            set(obj) {
               return Object.prototype.toString.call(obj) === '[object Set]';
            },
            object(obj) {
               return Object.prototype.toString.call(obj) === '[object Object]';
            },
            singleSelect(func) {
               if (typeof func == 'function') return false;
               var select = get.select(func);
               return select[0] == 1 && select[1] == 1;
            },
            jun(name) {
               if (get.mode() == 'guozhan') {
                  if (name && typeof name == 'object') {
                     if (name.isUnseen && name.isUnseen(0)) return false;
                     name = name.name1;
                  }
                  if (typeof name == 'string' && name.indexOf('gz_jun_') == 0) {
                     return true;
                  }
               }
               return false;
            },
            versus() {
               return !_status.connectMode && get.mode() == 'versus' && _status.mode == 'three';
            },
            changban() {
               return get.mode() == 'single' && _status.mode == 'changban';
            },
            single() {
               return get.mode() == 'single' && _status.mode == 'normal';
            },
            mobileMe(player) {
               return (game.layout == 'mobile' || game.layout == 'long') && !game.chess && player.dataset.position == 0;
            },
            newLayout() {
               if (game.layout != 'default') return true;
               return false;
            },
            phoneLayout() {
               if (!lib.config.phonelayout) return false;
               return (game.layout == 'mobile' || game.layout == 'long' || game.layout == 'long2' || game.layout == 'nova');
            },
            singleHandcard() {
               if (game.singleHandcard || game.layout == 'mobile' || game.layout == 'long' || game.layout == 'long2' || game.layout == 'nova') {
                  return true;
               }
               return false;
            },
            linked2(player) {
               if (game.chess) return true;
               if (lib.config.link_style2 != 'rotate') return true;
               // if(game.chess) return false;
               if (game.layout == 'long' || game.layout == 'long2' || game.layout == 'nova') return true;
               if (player.dataset.position == '0') {
                  return ui.arena.classList.contains('oblongcard');
               }
               return false;
            },
            empty(obj) {
               for (var i in obj) return false;
               return true;
            },
            pos(str) {
               return (str == 'h' || str == 'e' || str == 'j' || str == 'he' || str == 'hj' || str == 'ej' || str == 'hej');
            },
            /**
             * 判断技能是否为锁定技
             */
            locked(skill, player) {
               var info = lib.skill[skill];
               if (typeof info.locked == 'function') return info.locked(skill, player);
               if (info.locked == false) return false;
               if (info.trigger && info.forced) return true;
               if (info.mod) return true;
               if (info.locked) return true;
               return false;
            },
         },
         /**
          * 从牌堆底抽取指定数量的游戏牌
          * 如果牌堆没有牌，游戏直接平局
          * @param {number} num 要抽的牌数
          * @returns {!Array<GameCores.GameObjects.Card>}
          */
         bottomCards: function (num) {
            if (_status.waitingForCards) {
               ui.create.cards.apply(ui.create, _status.waitingForCards);
               delete _status.waitingForCards;
            }
            var list = [];
            var card = false;
            if (typeof num != 'number') num = 1;
            if (num == 0) { card = true; num = 1; }
            if (num < 0) num = 1;
            while (num--) {
               if (ui.cardPile.hasChildNodes() == false) {
                  if (_status.maxShuffle != undefined) {
                     if (_status.maxShuffle == 0) {
                        if (_status.maxShuffleCheck) {
                           game.over(_status.maxShuffleCheck());
                        }
                        else {
                           game.over('平局');
                        }
                        return [];
                     }
                     _status.maxShuffle--;
                  }
                  game.shuffleNumber++;
                  if (_status.event.trigger) _status.event.trigger('washCard');
                  var cards = [], i;
                  for (var i = 0; i < lib.onwash.length; i++) {
                     if (lib.onwash[i]() == 'remove') {
                        lib.onwash.splice(i--, 1);
                     }
                  }
                  if (_status.discarded) {
                     _status.discarded.length = 0;
                  }
                  for (i = 0; i < ui.discardPile.childNodes.length; i++) {
                     var currentcard = ui.discardPile.childNodes[i];
                     currentcard.vanishtag.length = 0;
                     if (get.info(currentcard).vanish || currentcard.storage.vanish) {
                        currentcard.remove();
                        continue;
                     }
                     cards.push(currentcard);
                  }
                  cards.randomSort();
                  for (var i = 0; i < cards.length; i++) {
                     ui.cardPile.appendChild(cards[i]);
                  }
               }
               if (ui.cardPile.hasChildNodes() == false) {
                  game.over('平局');
                  return [];
               }
               var cardx = ui.cardPile.removeChild(ui.cardPile.lastChild);
               cardx.original = 'c';
               list.push(cardx);
            }
            game.updateRoundNumber();
            if (card) return list[0];
            return list;
         },
         //TODO
         discarded: function () {
            var list = _status.discarded.slice(0);
            for (var i = 0; i < list.length; i++) {
               if (list[i].parentNode != ui.discardPile) {
                  list.splice(i--, 1);
               }
            }
            return list;
         },
         /**
          * 返回横坐标上的一个偏移量
          * #window <- #arena
          * @returns {number}
          */
         cardOffset: function () {
            var x = ui.arena.getBoundingClientRect();
            var y = ui.window.getBoundingClientRect();
            return -y.width / 2 + (x.left + x.width / 2);
         },
         /**
          * @param {string} str color
          * @returns {string} '#r'
          */
         colorspan: function (str) {
            if (str[0] == '#') {
               var color;
               switch (str[1]) {
                  case 'r': color = 'fire'; break;
                  case 'p': color = 'legend'; break;
                  case 'b': color = 'blue'; break;
                  case 'g': color = 'green'; break;
                  case 'y': color = 'yellow'; break;
                  case 'i': color = 'ice'; break;
                  default: return str.slice(2);
               }
               return '<span class="' + color + 'text ' + color + 'auto">' + str.slice(2) + '</span>';
            }
            return str;
         },
         evtprompt: function (next, str) {
            if (next.prompt) {
               next.set('prompt2', str);
            }
            else {
               if (str.indexOf('###') == 0) {
                  var prompts = str.slice(3).split('###');
                  if (prompts[0]) next.set('prompt', prompts[0]);
                  if (prompts[1]) next.set('prompt2', prompts[1]);
               }
               else {
                  next.set('prompt', str);
               }
            }
         },
         /**
          * 将游戏牌(数组)`cards`视为一张给定牌名的游戏牌`card`；
          * 如果游戏牌`card`有属性`autoViewAs`，游戏牌(数组)`cards`视为一张牌名为`autoViewAs`的游戏牌
          * @param {GameCores.GameObjects.Card} card  一个至少有牌名的临时"游戏牌"对象，除了牌名，其他属性、函数可以不指定
          * @param {!string} card.name 牌名
          * @param {(GameCores.GameObjects.Card|Array<GameCores.GameObjects.Card>)} cards 游戏牌(数组)
          * @returns {({name:string, cards:?Array<GameCores.GameObjects.Card>}|{name:string, suit: string, number: (string|number), nature: string}|{name:string, suit: string, number: (string|number), nature: string, isCard: true, cardid: (string|number), wunature: boolean, storage: Object, cards: Array<GameCores.GameObjects.Card>}|GameCores.GameObjects.Card)}
          */
         autoViewAs: function (card, cards) {
            var info = get.info(card);
            if (info.autoViewAs) {
               if (cards === false) {
                  return {
                     name: info.autoViewAs
                  };
               }
               else if (Array.isArray(cards)) {
                  return {
                     name: info.autoViewAs,
                     cards: cards.slice(0)
                  };
               }
               else if (get.itemtype(card) == 'card') {
                  return {
                     name: info.autoViewAs,
                     cards: [card]
                  };
               }
               else {
                  return {
                     name: info.autoViewAs,
                     suit: card.suit,
                     number: card.number,
                     nature: card.nature,
                  };
               }
            }
            else {
               if (card.isCard || get.itemtype(card) == 'card') {
                  let next = {
                     name: get.name(card),
                     suit: get.suit(card),
                     number: get.number(card),
                     nature: get.nature(card),
                     isCard: true,
                     cardid: card.cardid,
                     wunature: card.wunature,
                     storage: card.storage,
                     cards: card.cards,
                  };
                  if (get.itemtype(cards) == 'cards' && !card.cards) next.cards = cards.slice(0);
                  else if (get.itemtype(card) == 'card') next.cards = [card];
                  return next;
               }
               else if (get.is.object(card) && get.itemtype(cards) == 'cards' && !card.cards) {
                  card = get.copy(card);
                  card.cards = cards.slice(0);
               }
               return card;
            }
         },
         max: function (list, func, type) {
            list = list.slice(0);
            if (typeof func == 'string') {
               var key = func;
               func = function (item) {
                  return item[key];
               }
            }
            list.sort(function (a, b) {
               return func(b) - func(a);
            });
            if (type == 'list') {
               var list2 = [];
               for (var i = 0; i < list.length; i++) {
                  if (func(list[i]) == func(list[0])) {
                     list2.push(list[i]);
                  }
               }
               return list2;
            }
            else if (type == 'item') {
               return list[0];
            }
            else {
               return func(list[0]);
            }
         },
         min: function (list, func, type) {
            list = list.slice(0);
            if (typeof func == 'string') {
               var key = func;
               func = function (item) {
                  return item[key];
               }
            }
            list.sort(function (a, b) {
               return func(a) - func(b);
            });
            if (type == 'list') {
               var list2 = [];
               for (var i = 0; i < list.length; i++) {
                  if (func(list[i]) == func(list[0])) {
                     list2.push(list[i]);
                  }
               }
               return list2;
            }
            else if (type == 'item') {
               return list[0];
            }
            else {
               return func(list[0]);
            }
         },
         character: function (name, num) {
            var info = lib.character[name];
            if (!info) {
               for (var i in lib.characterPack) {
                  if (lib.characterPack[i][name]) {
                     info = lib.characterPack[i][name];
                     break;
                  }
               }
            }
            if (info) {
               if (typeof num == 'number') {
                  return info[num];
               }
               return info;
            }
            return null;
         },
         characterIntro: function (name) {
            if (lib.characterIntro[name]) return lib.characterIntro[name];
            var tags = get.character(name, 4);
            if (tags) {
               for (var i = 0; i < tags.length; i++) {
                  if (tags[i].indexOf('des:') == 0) {
                     return tags[i].slice(4);
                  }
               }
            }
            if (name.indexOf('gz_') == 0) {
               name = name.slice(3);
               if (lib.characterIntro[name]) return lib.characterIntro[name];
            }
            if (name.indexOf('_') != -1) {
               name = name.slice(name.indexOf('_') + 1);
            }
            if (lib.characterIntro[name]) return lib.characterIntro[name];
            // return '暂无武将介绍';
            return '';
         },
         characterTag: function (name) {
            var str = '';
            var tags = get.character(name, 4);
            if (!tags) return str;
            if (tags) {
               for (var i = 0; i < tags.length; i++) {
                  if (tags[i].indexOf('des:') == 0) {
                     continue;
                  }
                  var str0 = lib.translate[tags[i] + '_tag'] || lib.translate[tags[i]];
                  if (str0) {
                     if (!str.length) str += '标签:';
                     str += ' ';
                     str += str0;
                  }
               }
            }
            return str;
         },
         groupnature: function (group, method) {
            var nature = lib.groupnature[group];
            if (!nature) return '';
            if (method == 'raw') {
               return nature;
            }
            return nature + 'mm';
         },
         /**
          * 符号函数，提取数值的符号
          * @param {number} 数值
          * @returns {number} (-1|0|1)
          */
         sgn: function (num) {
            if (num > 0) return 1;
            if (num < 0) return -1;
            return 0;
         },
         rand: function (num, num2) {
            if (typeof num2 == 'number') {
               return num + Math.floor(Math.random() * (num2 - num + 1));
            }
            else {
               return Math.floor(Math.random() * num);
            }
         },
         sort: function (arr, method) {
            switch (method) {
               case 'seat': {
                  lib.tempSortSeat = arguments[2];
                  arr.sort(lib.sort.seat);
                  delete lib.tempSortSeat;
                  return arr;
               }
            }
         },
         sortSeat: function (arr, target) {
            lib.tempSortSeat = target;
            arr.sort(lib.sort.seat);
            delete lib.tempSortSeat;
            return arr;
         },
         zip: function (callback) {
            callback(new JSZip());
         },
         delayx: function (num, max) {
            if (typeof num != 'number') num = 1;
            if (typeof max != 'number') max = Infinity;
            switch (lib.config.game_speed) {
               case 'vslow': return Math.min(max, 2.5 * num);
               case 'slow': return Math.min(max, 1.5 * num);
               case 'fast': return Math.min(max, 0.7 * num);
               case 'vfast': return Math.min(max, 0.4 * num);
               case 'vvfast': return Math.min(max, 0.2 * num);
               default: return Math.min(max, num);
            }
         },
         prompt: function (skill, target, player) {
            player = player || _status.event.player;
            if (target) {
               var str = get.translation(target);
               if (target == player) {
                  str += '（你）'
               }
               return '是否对' + str + '发动『' + get.skillTranslation(skill, player) + '』？';
            }
            else {
               return '是否发动『' + get.skillTranslation(skill, player) + '』？';
            }
         },
         prompt2: function (skill, target, player) {
            var str = get.prompt.apply(this, arguments);
            if (!lib.translate[skill + '_info'] && !lib.dynamicTranslate[skill]) return str;
            return '###' + str + '###' + get.skillInfoTranslation(skill, player);
         },
         url: function (master) {
            var url = lib.config.updateURL || lib.updateURL;
            if (url[url.length - 1] != '/') {
               url += '/';
            }
            if (master != 'nodev') {
               return url + 'master/';
            }
            else {
               return url + 'v' + lib.version + '/';
            }
         },
         round: function (num, f) {
            var round = 1;
            for (var i = 0; i < f; i++) {
               round *= 10;
            }
            return Math.round(num * round) / round;
         },
         playerNumber: function () {
            var num;
            if (_status.brawl && _status.brawl.playerNumber) {
               num = _status.brawl.playerNumber
            }
            else {
               num = get.config('player_number');
            }
            return parseInt(num) || 2;
         },
         benchmark: function (func1, func2, iteration, arg) {
            var tic, toc;
            var key1, key2;
            if (!arg) arg = [];
            if (Array.isArray(func2)) {
               key1 = func2[0];
               key2 = func2[1];
            }
            else if (typeof func2 == 'string') {
               key1 = func2;
               func2 = iteration || 100;
            }
            else if (typeof func2 == 'number') {
               arg = iteration || arg;
               iteration = func2;
            }
            tic = get.utc();
            for (var i = 0; i < iteration; i++) {
               if (key1) {
                  func1[key1](arg.randomGet());
               }
               else {
                  func1(arg.randomGet());
               }
            }
            toc = get.utc();
            if (typeof func2 == 'number') {
               return toc - tic;
            }
            console.log('time1: ' + (toc - tic));
            tic = get.utc();
            for (var i = 0; i < iteration; i++) {
               if (key2) {
                  func1[key2](arg.randomGet());
               }
               else {
                  func2(arg.randomGet());
               }
            }
            toc = get.utc();
            console.log('time2: ' + (toc - tic));
         },
         stringify: function (obj, level) {
            level = level || 0;
            var indent = '';
            var str;
            for (var i = 0; i < level; i++) {
               indent += '   ';
            }
            if (get.objtype(obj) == 'object') {
               str = '{\n';
               for (var i in obj) {
                  if (/[^a-zA-Z]/.test(i)) {
                     str += indent + '   "' + i + '":' + get.stringify(obj[i], level + 1) + ',\n';
                  }
                  else {
                     str += indent + '   ' + i + ':' + get.stringify(obj[i], level + 1) + ',\n';
                  }
               }
               str += indent + '}';
               return str;
            }
            else {
               if (typeof obj == 'function') {
                  str = obj.toString();
                  str = str.replace(/\t/g, '    ');
                  var i = str.lastIndexOf('\n');
                  var num = 0;
                  for (var j = i + 1; j < str.length && str[j] == ' '; j++) {
                     num++;
                  }
                  num = Math.floor(num / 4);
                  for (i = 0; i < num - level; i++) {
                     str = str.replace(/\n    /g, '\n');
                  }
               }
               else {
                  try {
                     if (Array.isArray(obj) && obj.contains(Infinity)) {
                        obj = obj.slice(0);
                        var rand = get.id();
                        for (var i = 0; i < obj.length; i++) {
                           if (obj[i] === Infinity) {
                              obj[i] = parseInt(rand);
                           }
                        }
                        str = JSON.stringify(obj).replace(new RegExp(rand, 'g'), 'Infinity');
                     }
                     else {
                        str = JSON.stringify(obj) || '';
                     }
                  }
                  catch (e) {
                     str = '';
                  }
               }
               return str;
            }
         },
         /**
          * 浅拷贝(对象|数组)，要拷贝的对象如果是HTML元素，不做任何操作，返回原对象
          * @param {any} obj 要拷贝的对象
          * @returns {any}
          */
         copy: function (obj) {
            if (get.objtype(obj) == 'object') {
               var copy = {};
               for (var i in obj) {
                  copy[i] = get.copy(obj[i]);
               }
               return copy;
            }
            else if (Array.isArray(obj)) {
               var copy = [];
               for (var i = 0; i < obj.length; i++) {
                  copy.push(get.copy(obj[i]));
               }
               return copy;
            }
            else {
               return obj;
            }
         },
         inpilefull: function (type) {
            var list = [];
            for (var i in lib.cardPile) {
               for (var j = 0; j < lib.cardPile[i].length; j++) {
                  var info = lib.cardPile[i][j];
                  if (lib.inpile.contains(info[2]) && get.type(info[2]) == type) {
                     list.push({
                        name: info[2],
                        suit: info[0],
                        number: info[1],
                        nature: info[3]
                     });
                  }
               }
            }
            return list;
         },
         inpile: function (type, filter) {
            var list = [];
            if (filter == 'trick' || type == 'trick2') {
               if (type == 'trick2') type = 'trick'
               for (var i = 0; i < lib.inpile.length; i++) {
                  if (typeof filter == 'function' && !filter(lib.inpile[i])) continue;
                  if (get.type(lib.inpile[i], 'trick') == type) list.push(lib.inpile[i]);
               }
            }
            else {
               for (var i = 0; i < lib.inpile.length; i++) {
                  if (typeof type == 'function') {
                     if (type(lib.inpile[i])) {
                        list.push(lib.inpile[i]);
                     }
                  }
                  else {
                     if (typeof filter == 'function' && !filter(lib.inpile[i])) continue;
                     if (type.indexOf('equip') == 0 && type.length == 6) {
                        if (get.subtype(lib.inpile[i]) == type) list.push(lib.inpile[i]);
                     }
                     else {
                        if (get.type(lib.inpile[i]) == type) list.push(lib.inpile[i]);
                     }
                  }
               }
            }
            return list;
         },
         inpile2: function (type) {
            return get.inpile(type, 'trick');
         },
         typeCard: function (type, filter) {
            var list = [];
            for (var i in lib.card) {
               if (lib.card[i].mode && lib.card[i].mode.contains(get.mode()) == false) continue;
               // if(lib.card[i].vanish||lib.card[i].destroy) continue;
               if (lib.card[i].destroy) continue;
               if (typeof filter == 'function' && !filter(i)) continue;
               if (lib.config.bannedcards.contains(i)) continue;
               if (!lib.translate[i + '_info']) continue;
               if ((type.indexOf('equip') == 0 && type.length == 6) ||
                  (type.indexOf('hslingjian') == 0 && type.length == 11) ||
                  (type.indexOf('spell_') == 0)) {
                  if (get.subtype(i) == type) list.push(i);
               }
               else {
                  if (get.type(i) == type) list.push(i);
               }
            }
            return list;
         },
         libCard: function (filter) {
            var list = [];
            for (var i in lib.card) {
               if (lib.card[i].mode && lib.card[i].mode.contains(get.mode()) == false) continue;
               // if(lib.card[i].vanish||lib.card[i].destroy) continue;
               if (lib.card[i].destroy) continue;
               if (lib.config.bannedcards.contains(i)) continue;
               if (!lib.translate[i + '_info']) continue;
               if (filter(lib.card[i], i)) {
                  list.push(i);
               }
            }
            return list;
         },
         ip: function () {
            if (false) {}
            var interfaces = (__webpack_require__(2037).networkInterfaces)();
            for (var devName in interfaces) {
               var iface = interfaces[devName];
               for (var i = 0; i < iface.length; i++) {
                  var alias = iface[i];
                  if (alias.family === 'IPv4' && alias.address !== '127.0.0.1' && !alias.internal) {
                     return alias.address;
                  }
               }
            }
         },
         modetrans: function (config, server) {
            if (config.mode == 'doudizhu') {
               switch (config.doudizhu_mode) {
                  case 'kaihei': return '开黑斗地主';
                  case 'huanle': return '欢乐斗地主';
                  case 'binglin': return '兵临城下';
                  case 'online': return '智斗三国';
                  default: return '休闲' + (config.double_character ? '双将' : '') + '斗地主';
               }
            }
            if (config.mode == 'longlaoguan') return '龙牢关';
            if (config.mode == 'versus') {
               switch (config.versus_mode) {
                  case '1v1': return '单人对决';
                  case '2v2': return '欢乐成双';
                  case '3v3': return '血战到底';
                  case '4v4': return '四人对决';
                  case 'guandu': return '官渡之战';
               }
            }
            else if (config.mode == 'single') {
               switch (config.single_mode) {
                  case 'normal': return '新1v1';
                  case 'changban': return '血战长坂坡';
                  case 'dianjiang': return '点将单挑';
               }
            }
            else if (config.mode == 'identity') {
               switch (config.identity_mode) {
                  case 'purple': return '三对三对二';
                  case 'zhong': return (config.double_character ? '双将' : '') + '忠胆英杰';
                  default: return get.cnNumber(parseInt(config.number)) + '人' + (config.double_character ? '双将' : '') + '身份';
               }
            }
            else if (config.mode == 'guozhan' && config.guozhan_mode != 'normal') {
               switch (config.guozhan_mode) {
                  case 'yingbian': return '应变国战';
                  case 'old': return '怀旧国战';
               }
            }
            else {
               if (server) {
                  return get.translation(config.mode) + '模式';
               }
               else {
                  return get.cnNumber(parseInt(config.number)) + '人' + get.translation(config.mode);
               }
            }
         },
         charactersOL: function (func) {
            var list = [];
            var libCharacter = {};
            for (var i = 0; i < lib.configOL.characterPack.length; i++) {
               var pack = lib.characterPack[lib.configOL.characterPack[i]];
               for (var j in pack) {
                  if (typeof func == 'function' && func(j)) continue;
                  if (lib.connectBanned.contains(j)) continue;
                  if (lib.configOL.protect_beginner && get.is.banForBeginner(i)) return true;
                  if (lib.character[j]) libCharacter[j] = pack[j];
               }
            }
            for (i in libCharacter) {
               if (lib.filter.characterDisabled(i, libCharacter)) continue;
               list.push(i);
            }
            return list;
         },
         trimip: function (str) {
            var len = str.length - 5;
            if (str.lastIndexOf(':8080') == len) {
               str = str.slice(0, len);
            }
            return str;
         },
         /**
          * 返回游戏的当前模式
          * @returns {!string}
          */
         mode: function () {
            if (_status.connectMode) {
               return lib.configOL.mode;
            }
            else {
               return lib.config.mode;
            }
         },
         idDialog: function (id) {
            for (var i = 0; i < ui.dialogs.length; i++) {
               if (ui.dialogs[i].videoId == id) {
                  return ui.dialogs[i];
               }
            }
            return null;
         },
         arenaState: function () {
            var state = {
               number: ui.arena.dataset.number,
               players: {},
               mode: _status.mode,
               dying: _status.dying,
               servermode: window.isNonameServer,
               roomId: game.roomId,
               over: _status.over,
               inpile: lib.inpile,
               cardtag: _status.cardtag,
            };
            for (var i in lib.playerOL) {
               state.players[i] = lib.playerOL[i].getState();
            }
            return state;
         },
         skillState: function (player) {
            var skills = {
               global: lib.skill.global
            };
            var skillinfo = {};
            for (var i in lib.playerOL) {
               skills[i] = {
                  skills: lib.playerOL[i].skills,
                  hiddenSkills: lib.playerOL[i].hiddenSkills,
                  additionalSkills: lib.playerOL[i].additionalSkills,
                  disabledSkills: lib.playerOL[i].disabledSkills,
                  tempSkills: lib.playerOL[i].tempSkills,
                  storage: lib.playerOL[i].storage,
               }
            }
            for (var i in lib.skill) {
               if (lib.skill[i].chooseButton && lib.skill[i].enable) {
                  skillinfo[i] = lib.skill[i].chooseButton;
               }
            }
            skills.skillinfo = skillinfo;
            if (player) {
               skills.stat = player.getStat();
            }
            return skills;
         },
         /**
          * 通过随机数生成Id
          * @returns {!number} ID
          */
         id: function () {
            return (Math.floor(1000000 + 9000000 * Math.random())).toString() + (10 + lib.status.globalId++);
         },
         zhu: function (player, skill, unseen) {
            if (typeof player == 'string') {
               skill = player;
               player = null;
            }
            var mode = get.mode();
            if (mode == 'identity') {
               if (_status.mode == 'purple') {
                  if (!player) return null;
                  var zhu = game[player.identity.slice(0, 1) + 'Zhu'];
                  if (!zhu) return null;
                  if (skill && !zhu.hasSkill(skill)) return null;
                  return zhu;
               }
               if (!game.zhu) return null;
               if (skill && !game.zhu.hasSkill(skill)) return null;
               if (game.zhu.isZhu) return game.zhu;
            }
            else if (mode == 'versus' && (_status.mode == 'four' || _status.mode == 'guandu')) {
               for (var i = 0; i < game.players.length; i++) {
                  if (game.players[i].isZhu) {
                     if (skill && !(game.players[i].hasSkill(skill))) continue;
                     if (!player) return game.players[i];
                     if (player.side == game.players[i].side) {
                        return game.players[i];
                     }
                  }
               }
            }
            else if (mode == 'guozhan') {
               for (var i = 0; i < game.players.length; i++) {
                  if (get.is.jun(game.players[i]) && !game.players[i].isUnseen()) {
                     if (skill && !game.players[i].hasSkill(skill)) continue;
                     if (!player) return game.players[i];
                     if (player.identity == game.players[i].identity) {
                        return game.players[i];
                     }
                     else if (unseen && player._group == game.players[i].identity) {
                        return game.players[i];
                     }
                  }
               }
            }
            return null;
         },
         config: function (item, mode) {
            mode = mode || lib.config.mode;
            if (!lib.config.mode_config[mode]) return;
            return lib.config.mode_config[mode][item];
         },
         coinCoeff: function (list) {
            var num = 0;
            for (var i = 0; i < list.length; i++) {
               var rank = get.rank(list[i]);
               switch (rank) {
                  case 'sp': return 0.1;
                  case 's': num += 0.4; break;
                  case 'ap': num += 0.6; break;
                  case 'a': num += 0.8; break;
                  case 'am': num += 0.95; break;
                  case 'bp': num += 1.05; break;
                  case 'b': num += 1.2; break;
                  case 'bm': num += 1.4; break;
                  case 'c': num += 1.6; break;
                  case 'd': num += 1.8; break;
               }
            }
            return num / list.length;
         },
         rank: function (name, num) {
            if (typeof name == 'object' && name.name) {
               name = name.name;
            }
            if (num == true) num = 9;
            if (typeof num != 'number') num = false;
            if (name == _status.lord) return num ? Math.round(7 * (num - 1) / 8 + 1) : 'ap';
            var rank = lib.rank;
            if (lib.characterPack.clubs[name] || lib.characterPack.vtuber[name] || lib.characterPack.yuzu[name] || lib.characterPack.hololive[name] || lib.characterPack.nijisanji[name]) {
               var skills;
               if (lib.character[name]) {
                  skills = lib.character[name][3];
               }
               else {
                  var tmpinfo = get.character(name);
                  if (tmpinfo) {
                     skills = tmpinfo[3];
                  }
                  else {
                     skills = [];
                  }
               }
               for (var i = 0; i < skills.length; i++) {
                  if (skills[i].alter && !lib.config.vintageSkills.contains(skills[i])) {
                     name = lib.rank.a[0]; break;
                  }
               }
            }
            if (rank.s.contains(name)) return num ? Math.round(8 * (num - 1) / 8 + 1) : 's';
            if (rank.ap.contains(name)) return num ? Math.round(7 * (num - 1) / 8 + 1) : 'ap';
            if (rank.a.contains(name)) return num ? Math.round(6 * (num - 1) / 8 + 1) : 'a';
            if (rank.am.contains(name)) return num ? Math.round(5 * (num - 1) / 8 + 1) : 'am';
            if (rank.bp.contains(name)) return num ? Math.round(4 * (num - 1) / 8 + 1) : 'bp';
            if (rank.b.contains(name)) return num ? Math.round(3 * (num - 1) / 8 + 1) : 'b';
            if (rank.bm.contains(name)) return num ? Math.round(2 * (num - 1) / 8 + 1) : 'bm';
            if (rank.c.contains(name)) return num ? Math.round(1 * (num - 1) / 8 + 1) : 'c';
            if (rank.d.contains(name)) return num ? Math.round(0 * (num - 1) / 8 + 1) : 'd';
            if (lib.character[name] && lib.character[name][4]) {
               if (lib.character[name][4].contains('boss') ||
                  lib.character[name][4].contains('bossallowed') ||
                  lib.character[name][4].contains('hiddenboss')) {
                  return num ? Math.round(9 * (num - 1) / 8 + 1) : 'sp';
               }
            }
            return num ? Math.round(9 * (num - 1) / 8 + 1) : 'x';
         },
         skillRank: function (skill, type, grouped) {
            var info = lib.skill[skill];
            var player = _status.event.skillRankPlayer || _status.event.player;
            if (!info) return 0;
            if (info.ai) {
               if (info.ai.halfneg) return 0;
               if (typeof info.ai.combo == 'string' && player && !player.hasSkill(info.ai.combo)) {
                  return 0;
               }
               if (info.ai.neg) return -1;
            }
            var num = 1;
            var threaten = 1;
            if (info.ai && info.ai.threaten) {
               if (typeof info.ai.threaten == 'number') {
                  threaten = info.ai.threaten;
               }
               else if (typeof info.ai.threaten == 'function' && player) {
                  threaten = info.ai.threaten(player, player);
               }
            }
            if (type == 'in') {
               if (info.enable == 'phaseUse') num += 0.5;
               if (info.trigger && info.trigger.player) {
                  var list = Array.isArray(info.trigger.player) ? info.trigger.player : [info.trigger.player];
                  var add = false;
                  for (var i of list) {
                     for (var j of lib.phaseName) {
                        if (i.indexOf[j] == 0) {
                           num += 0.5;
                           add = true;
                           break;
                        }
                     }
                     if (add) break;
                  }
               }
               if (info.trigger && ((typeof info.trigger.player == 'string' && info.trigger.player.indexOf('use') == 0) || info.trigger.source)) {
                  num += 0.3;
               }
               if (num > 1 && threaten > 1) {
                  num += Math.sqrt(threaten) - 1;
               }
            }
            else if (type == 'out') {
               if (threaten < 1) {
                  num = 1 / Math.sqrt(threaten);
               }
               if (info.trigger && (info.trigger.global || info.trigger.target || (typeof info.trigger.player == 'string' &&
                  (info.trigger.player.indexOf('damage') == 0 || info.trigger.player.indexOf('lose') == 0)))) num += 0.1;
               if (info.ai) {
                  if (info.ai.maixie || info.ai.maixie_hp || info.ai.maixie_defend) {
                     num += 0.5;
                  }
                  if (info.ai.nolose || info.ai.noh || info.ai.noe || info.ai.nodiscard) {
                     num += 0.3;
                  }
               }
            }
            if (!grouped) {
               var groups = game.expandSkills([skill]);
               groups.remove(skill);
               var ggt = [];
               for (var i = 0; i < groups.length; i++) {
                  var gi = get.skillRank(groups[i], type, true);
                  if (gi < 0) {
                     num -= 0.5;
                  }
                  else if (gi > 1) {
                     ggt.push(gi);
                  }
               }
               if (ggt.length) {
                  num += Math.max.apply(this, ggt) - 1 + ggt.length / 20;
               }
            }
            return num;
         },
         targetsInfo: function (targets) {
            var info = [];
            for (var i = 0; i < targets.length; i++) {
               info.push(targets[i].dataset.position);
            }
            return info;
         },
         infoTargets: function (info) {
            var targets = [];
            for (var i = 0; i < info.length; i++) {
               targets.push(game.playerMap[info[i]]);
            }
            return targets;
         },
         cardInfo: function (card) {
            if (card.specialEffects) return [card.suit, card.number, card.name, card.nature, card.tags, card.specialEffects];
            else return [card.suit, card.number, card.name, card.nature, card.tags];
         },
         cardsInfo: function (cards) {
            var info = [];
            for (var i = 0; i < cards.length; i++) {
               info.push(get.cardInfo(cards[i]));
            }
            return info;
         },
         infoCard: function (info) {
            var card = ui.create.card();
            if (info[0]) {
               card.init(info);
            }
            return card;
         },
         infoCards: function (info) {
            var cards = [];
            for (var i = 0; i < info.length; i++) {
               cards.push(get.infoCard(info[i]));
            }
            return cards;
         },
         cardInfoOL: function (card) {
            return '_noname_card:' + JSON.stringify([card.cardid, card.suit, card.number, card.name, card.nature, card.tags, card.specialEffects]);
         },
         infoCardOL: function (info) {
            if (!lib.cardOL) return info;
            var card;
            try {
               var info = JSON.parse(info.slice(13));
               var id = info.shift();
               if (!id) {
                  card = ui.create.card();
                  if (info && info[2]) card.init(info);
               }
               else if (lib.cardOL[id]) {
                  if (lib.cardOL[id].name != info[2]) {
                     if (info && info[2]) lib.cardOL[id].init(info);
                  }
                  if (lib.cardOL[id].specialEffects != info[5]) {
                     if (info && info[2]) lib.cardOL[id].init(info);
                  }
                  card = lib.cardOL[id];
               }
               else if (game.online) {
                  card = ui.create.card();
                  card.cardid = id;
                  if (info && info[2]) card.init(info);
                  lib.cardOL[id] = card;
               }
            }
            catch (e) {
               console.log(e);
            }
            return card || info;
         },
         cardsInfoOL: function (cards) {
            var info = [];
            for (var i = 0; i < cards.length; i++) {
               info.push(get.cardInfoOL(cards[i]));
            }
            return info;
         },
         infoCardsOL: function (info) {
            var cards = [];
            for (var i = 0; i < info.length; i++) {
               cards.push(get.infoCardOL(info[i]));
            }
            return cards;
         },
         playerInfoOL: function (player) {
            return '_noname_player:' + player.playerid;
         },
         infoPlayerOL: function (info) {
            if (!lib.playerOL) return info
            return lib.playerOL[info.slice(15)] || info;
         },
         playersInfoOL: function (players) {
            var info = [];
            for (var i = 0; i < players.length; i++) {
               info.push(get.playerInfoOL(players[i]));
            }
            return info;
         },
         infoPlayersOL: function (info) {
            var players = [];
            for (var i = 0; i < info.length; i++) {
               players.push(get.infoPlayerOL(info[i]));
            }
            return players;
         },
         funcInfoOL: function (func) {
            if (typeof func == 'function') {
               if (func._filter_args) {
                  return `_noname_func:${JSON.stringify(get.stringifiedResult(func._filter_args, 3))}`;
               }
               let str = func.toString()
               return `_noname_func:${str.slice(str.indexOf('('))}`;
            }
            return '';
         },
         infoFuncOL: function (info) {
            var func;
            try {
               eval(`func=(function${info.slice(13)});`);
            }
            catch (e) {
               return function () { };
            }
            if (Array.isArray(func)) {
               func = get.filter.apply(this, get.parsedResult(func));
            }
            return func;
         },
         eventInfoOL: function (item, level) {
            if (Object.prototype.toString.call(item) == '[object Object]') {
               var item2 = {};
               for (var i in item) {
                  if (i == '_trigger') {
                     if (level !== false) item2[i] = get.eventInfoOL(item[i], false);
                  }
                  else if (lib.element.event[i] || i == 'content' || get.itemtype(item[i]) == 'event') continue;
                  else item2[i] = get.stringifiedResult(item[i], level - 1);
               }
               return '_noname_event:' + JSON.stringify(item2);
            }
            else {
               return '';
            }
         },
         infoEventOL: function (item) {
            var evt;
            try {
               evt = JSON.parse(item.slice(14));
               for (var i in evt) {
                  evt[i] = get.parsedResult(evt[i]);
               }
               for (var i in lib.element.event) evt[i] = lib.element.event[i];
            }
            catch (e) {
               console.log(e);
            }
            return evt || item;
         },
         stringifiedResult: function (item, level) {
            if (!item) return item;
            if (typeof item == 'function') {
               return get.funcInfoOL(item);
            }
            else if (typeof item == 'object') {
               switch (get.itemtype(item)) {
                  case 'card': return get.cardInfoOL(item);
                  case 'cards': return get.cardsInfoOL(item);
                  case 'player': return get.playerInfoOL(item);
                  case 'players': return get.playersInfoOL(item);
                  case 'event': return get.eventInfoOL(item);
                  default:
                     if (typeof level != 'number') {
                        level = 5;
                     }
                     if (Array.isArray(item)) {
                        if (level == 0) {
                           return [];
                        }
                        var item2 = [];
                        for (var i = 0; i < item.length; i++) {
                           item2.push(get.stringifiedResult(item[i], level - 1));
                        }
                        return item2;
                     }
                     else if (Object.prototype.toString.call(item) == '[object Object]') {
                        if (level == 0) {
                           return {};
                        }
                        var item2 = {};
                        for (var i in item) {
                           item2[i] = get.stringifiedResult(item[i], level - 1);
                        }
                        return item2;
                     }
                     else {
                        return {};
                     }
               }
            }
            else if (item === Infinity) {
               return '_noname_infinity';
            }
            else {
               return item;
            }
         },
         parsedResult: function (item) {
            if (!item) return item;
            if (typeof item == 'string') {
               if (item.indexOf('_noname_func:') == 0) {
                  return get.infoFuncOL(item);
               }
               else if (item.indexOf('_noname_card:') == 0) {
                  return get.infoCardOL(item);
               }
               else if (item.indexOf('_noname_player:') == 0) {
                  return get.infoPlayerOL(item);
               }
               else if (item.indexOf('_noname_event:') == 0) {
                  return get.infoEventOL(item);
               }
               else if (item == '_noname_infinity') {
                  return Infinity;
               }
               else {
                  return item;
               }
            }
            else if (Array.isArray(item)) {
               var item2 = [];
               for (var i = 0; i < item.length; i++) {
                  item2.push(get.parsedResult(item[i]));
               }
               return item2;
            }
            else if (typeof item == 'object') {
               var item2 = {};
               for (var i in item) {
                  item2[i] = get.parsedResult(item[i]);
               }
               return item2;
            }
            else {
               return item;
            }
         },
         /**
          * 字符串垂直化
          * 实际是通过加`<br>`标签实现垂直化
          * @function
          * @param {?string} 原字符串
          * @param {?boolean} sp 'SP'字符是否连接，如果为true，表示'S'和'P'在同一行，否则分割
          * @returns {!string} 垂直化后的字符串
          * @example
          * get.verticalStr('Hello sP')
          * //result:
          * //"H<br>E<br>L<br>L<br>O<br> <br>S<br>P"
          * get.verticalStr('Hello sP', true)
          * //result:
          * //"H<br>E<br>L<br>L<br>O<br> <br>SP"
          * get.verticalStr('`He`llo sP')
          * //result:
          * //"HEL<br>L<br>O<br> <br>S<br>P"
          */
         verticalStr: function (str, sp) {
            if (typeof str != 'string') return '';
            str = str.toUpperCase();
            var str2 = '';
            var nobreak = false;
            for (var i = 0; i < str.length; i++) {
               if (str[i] == '`') {
                  nobreak = !nobreak; continue;
               }
               if (str.slice(i, i + 4) == '<BR>') { i += 3; continue; }
               str2 += str[i];
               if (nobreak) continue;
               if (sp && str[i] == 'S' && str[i + 1] == 'P') continue;
               if (/[0-9]/.test(str[i]) && /[0-9]/.test(str[i + 1])) continue;
               if (i < str.length - 1) {
                  str2 += '<br>';
               }
            }
            return str2;
         },
         numStr: function (num, method) {
            if (num == Infinity) {
               if (method == 'card') return get.selectableCards().length + ui.selected.cards.length;
               if (method == 'target') return get.selectableTargets().length + ui.selected.targets.length;
               return '∞';
            }
            return num.toString();
         },
         rawName: function (str) {
            if (lib.translate[str + '_ab']) return lib.translate[str + '_ab'];
            var str2 = lib.translate[str];
            if (!str2) return '';
            if (str2.indexOf('SP') == 0) {
               str2 = str2.slice(2);
            }
            else if (str2.indexOf('TW') == 0) {
               str2 = str2.slice(2);
            }
            else if (str2.indexOf('OL') == 0) {
               str2 = str2.slice(2);
            }
            else if (str2.indexOf('JSP') == 0) {
               str2 = str2.slice(3);
            }
            else if (str2.indexOf('☆SP') == 0) {
               str2 = str2.slice(3);
            }
            else if (str2.indexOf('手杀') == 0) {
               str2 = str2.slice(2);
            }
            else if (str2.indexOf('界') == 0 && lib.characterPack.refresh && lib.characterPack.refresh[str]) {
               str2 = str2.slice(1);
            }
            else if (str2.indexOf('旧') == 0 && (lib.characterPack.old || lib.characterPack.mobile) && (lib.characterPack.old[str] || lib.characterPack.mobile[str])) {
               str2 = str2.slice(1);
            }
            else if (str2.indexOf('新·') == 0 && str.indexOf('re_') == 0) {
               str2 = str2.slice(2);
            }
            else if (str2.indexOf('新') == 0 && (str.indexOf('re_') == 0 || str.indexOf('new_') == 0)) {
               str2 = str2.slice(1);
            }
            return str2;
         },
         rawName2: function (str) {
            if (lib.translate[str + '_ab']) return lib.translate[str + '_ab'];
            var str2 = lib.translate[str];
            if (!str2) return '';
            if (str2.indexOf('SP') == 0) {
               str2 = str2.slice(2);
            }
            else if (str2.indexOf('TW') == 0) {
               str2 = str2.slice(2);
            }
            else if (str2.indexOf('OL') == 0) {
               str2 = str2.slice(2);
            }
            else if (str2.indexOf('JSP') == 0) {
               str2 = str2.slice(3);
            }
            else if (str2.indexOf('☆SP') == 0) {
               str2 = str2.slice(3);
            }
            else if (str2.indexOf('手杀') == 0) {
               str2 = str2.slice(2);
            }
            else if (str2.indexOf('新·') == 0 && str.indexOf('re_') == 0) {
               str2 = str2.slice(2);
            }
            return str2;
         },
         slimName: function (str) {
            var str2 = lib.translate[str];
            if (lib.translate[str + '_ab']) str2 = lib.translate[str + '_ab'];
            if (str.indexOf('gz_') == 0 && lib.translate[str.slice(3) + '_ab']) str2 = lib.translate[str.slice(3) + '_ab'];
            if (!str2) return '';
            if (str2.indexOf('SP') == 0) {
               str2 = str2.slice(2);
            }
            else if (str2.indexOf('TW') == 0) {
               str2 = str2.slice(2);
            }
            else if (str2.indexOf('OL') == 0) {
               str2 = str2.slice(2);
            }
            else if (str2.indexOf('JSP') == 0) {
               str2 = str2.slice(3);
            }
            else if (str2.indexOf('☆SP') == 0) {
               str2 = str2.slice(3);
            }
            else if (str2.indexOf('手杀') == 0) {
               str2 = str2.slice(2);
            }
            else if (str2.indexOf('新·') == 0 && str.indexOf('re_') == 0) {
               str2 = str2.slice(2);
            }
            else if (str2.indexOf('皇·') == 0 && str.indexOf('sp_') == 0) {
               str2 = str2.replace('皇·', '皇');
            }
            else if (str2.indexOf('海·') == 0 && str.indexOf('sea_') == 0) {
               str2 = str2.replace('海·', '海');
            }
            else if (str2.indexOf('国战') == 0 && lib.config.mode == 'guozhan' && str.indexOf('gz_') == 0) {
               str2 = str2.slice(2);
            }
            return get.verticalStr(str2, true);
         },
         time: function () {
            if (lib.status.dateDelaying) {
               return lib.getUTC(lib.status.dateDelaying) - lib.getUTC(lib.status.date) - lib.status.dateDelayed;
            }
            else {
               return lib.getUTC(new Date()) - lib.getUTC(lib.status.date) - lib.status.dateDelayed;
            }
         },
         /**
          * 返回当前的datetime(`new Date().getTime()`)
          * @returns {number} datetime
          */
         utc: function () {
            return (new Date()).getTime();
         },
         evtDistance: function (e1, e2) {
            var dx = (e1.clientX - e2.clientX) / game.documentZoom;
            var dy = (e1.clientY - e2.clientY) / game.documentZoom;
            return Math.sqrt(dx * dx + dy * dy);
         },
         xyDistance: function (from, to) {
            return Math.sqrt((from[0] - to[0]) * (from[0] - to[0]) + (from[1] - to[1]) * (from[1] - to[1]));
         },
         /**
          * 判断对象物品类型(字符串(区域名|属性名)，玩家及玩家组，卡牌及卡牌组，选择范围，元素坐标，按钮，弹窗，事件)
          * @param {Object} obj 要判断物品类型的对象
          * @returns {?string} 对象的物品类型
          */
         itemtype: function (obj) {
            var i, j;
            if (typeof obj == 'string') {
               if (obj.length <= 4) {
                  var bool = true;
                  for (i = 0; i < obj.length; i++) {
                     if (/h|e|j|s/.test(obj[i]) == false) {
                        bool = false; break;
                     }
                  }
                  if (bool) return 'position';
               }
               if (lib.nature.contains(obj)) return 'nature';
            }
            if (Array.isArray(obj) && obj.length) {
               var isPlayers = true;
               for (i = 0; i < obj.length; i++) {
                  if (get.itemtype(obj[i]) != 'player') { isPlayers = false; break; }
               }
               if (isPlayers) return 'players';

               var isCards = true;
               for (i = 0; i < obj.length; i++) {
                  if (get.itemtype(obj[i]) != 'card') { isCards = false; break; }
               }
               if (isCards) return 'cards';

               if (obj.length == 2) {
                  if (typeof obj[0] == 'number' && typeof obj[1] == 'number') {
                     if (obj[0] <= obj[1] || obj[1] == -1) return 'select';
                  }
               }

               if (obj.length == 4) {
                  var isPosition = true;
                  for (i = 0; i < obj.length; i++) {
                     if (typeof obj[i] != 'number') { isPosition = false; break; }
                  }
                  if (isPosition) return 'divposition';
               }
            }
            if (get.objtype(obj) == 'div') {
               if (obj.classList.contains('button')) return 'button';
               if (obj.classList.contains('card')) return 'card';
               if (obj.classList.contains('player')) return 'player';
               if (obj.classList.contains('dialog')) return 'dialog';
            }
            if (get.is.object(obj)) {
               if (obj.isMine == lib.element.event.isMine) return 'event';
            }
         },
         equipNum: function (card) {
            if (get.type(card) == 'equip') {
               return parseInt(get.subtype(card)[5]);
            }
            return 0;
         },
         /**
          * 判断对象类型(数组，Object对象，Div元素，Table元素，TableRow元素，TableCell元素，Body元素)
          * @param {Object} obj 要判断类型的对象
          * @returns {?string} 对象的类型
          */
         objtype: function (obj) {
            if (Object.prototype.toString.call(obj) === '[object Array]') return 'array';
            if (Object.prototype.toString.call(obj) === '[object Object]') return 'object';
            if (Object.prototype.toString.call(obj) === '[object HTMLDivElement]') return 'div';
            if (Object.prototype.toString.call(obj) === '[object HTMLTableElement]') return 'table';
            if (Object.prototype.toString.call(obj) === '[object HTMLTableRowElement]') return 'tr';
            if (Object.prototype.toString.call(obj) === '[object HTMLTableCellElement]') return 'td';
            if (Object.prototype.toString.call(obj) === '[object HTMLBodyElement]') return 'td';
         },
         type: function (obj, method, player) {
            if (typeof obj == 'string') obj = { name: obj };
            if (typeof obj != 'object') return;
            var name = get.name(obj, player);
            if (!lib.card[name]) return;
            if (method == 'trick' && lib.card[name].type == 'delay') return 'trick';
            return lib.card[name].type;
         },
         type2: function (card, player) {
            return get.type(card, 'trick', player);
         },
         //新增函数
         type3: function (cards, method, player) {
            if (get.itemtype(cards) != 'cards') return;
            var types = [];
            for (let i of cards) {
               types.add(get.type(i, method, player));
            }
            return types;
         },
         subtype: function (obj, player) {
            if (typeof obj == 'string') obj = { name: obj };
            if (typeof obj != 'object') return;
            var name = get.name(obj, player);
            if (!lib.card[name]) return;
            return lib.card[name].subtype;
         },
         equiptype: function (card, player) {
            var subtype = get.subtype(card, player);
            if (subtype.indexOf('equip') == 0) return parseInt(subtype[5]);
            return 0;
         },
         /**
          * 返回手牌牌名
          * @name get.name
          * @function
          * @param {!GameCores.GameObjects.Card} card 卡牌对象
          * @param {boolean} [isCheckMod=true] 是否检测被动技，如果为true，手牌持有者有被动技**cardname**改变牌名，则返回改变后的牌名；如果为false，直接返回牌名
          * @returns {?string} 牌名
          */
         /**
          * 返回游戏牌对象的牌名
          * @name get.name
          * @function
          * @variation 2
          * @param {!GameCores.GameObjects.Card} card 卡牌对象
          * @param {(GameCores.GameObjects.Player|false)} player 如果为角色对象，当角色有被动技**cardname**改变牌名，返回改变后的牌名；如果为false，直接返回牌名
          * @returns {string} 牌名
          */
         name: function (card, player) {
            if (get.itemtype(player) == 'player' || (player !== false && get.position(card) == 'h')) {
               var owner = player || get.owner(card);
               if (owner) {
                  return game.checkMod(card, owner, card.name, 'cardname', owner);
               }
            }
            return card.name;
         },
         suit: function (card, player) {
            if (get.itemtype(card) == 'cards') {
               if (card.length == 1) return get.suit(card[0], player);
               return 'none';
               //var suit=get.suit(card[0])
               //for(var i=1;i<card.length;i++){
               //    if(get.suit(card[i])!=suit) return 'none';
               //}
               //return suit;
            }
            else if (get.itemtype(card.cards) == 'cards' && card.suit != 'none' && !lib.suit.contains(card.suit)) {
               return get.suit(card.cards, player);
            }
            else {
               var owner = player || get.owner(card);
               if (owner) {
                  return game.checkMod(card, card.suit, 'suit', owner);
               }
               return card.suit;
            }
         },
         suit3: function (cards, player) {
            if (get.itemtype(cards) != 'cards') return [];
            var suits = [];
            for (var i of cards) {
               suits.add(get.suit(i, player));
            }
            return suits;
         },
         color: function (card, player) {
            if (_status.event.name == 'judge' && card.color) return card.color;
            if (get.itemtype(card) == 'cards') {
               var color = get.color(card[0], player)
               for (var i = 1; i < card.length; i++) {
                  if (get.color(card[i], player) != color) return 'none';
               }
               return color;
            }
            else if (get.itemtype(card.cards) == 'cards' && card.suit != 'none' && !lib.suit.contains(card.suit)) {
               return get.color(card.cards, player);
            }
            else {
               //柚子：已修改
               var color = 'none'
               if (get.suit(card, player) == 'spade' || get.suit(card, player) == 'club') color = 'black';
               if (get.suit(card, player) == 'heart' || get.suit(card, player) == 'diamond') color = 'red';
               var owner = player || get.owner(card);
               if (owner) {
                  return game.checkMod(card, owner, color, 'color', owner);
               }
               return color;
            }
         },
         color3: function (cards, player) {
            if (get.itemtype(cards) != 'cards') return;
            var colors = [];
            for (var i of cards) {
               colors.add(get.color(i, player));
            }
            return colors;
         },
         number: function (card, player) {
            //柚子：已修改
            var number = null;
            if (card.number && typeof card.number == 'number') number = card.number;
            else if (card.cards && card.cards.length == 1) number = get.number(card.cards[0]);
            if (number != null && get.itemtype(player) == 'player' || (player !== false && get.position(card) == 'h')) {
               var owner = player || get.owner(card);
               if (owner) {
                  return game.checkMod(card, owner, number, 'number', owner);
               }
            }
            return number;
         },
         /**
          * 一个角色查看一张牌的属性，并返回结果；
          * 如果角色有被动技`cardnature`，属性为改变后的值
          * @param {!GameCores.GameObjects.Card} card 被查看的牌
          * @param {(GameCores.GameObjects.Player|false|undefined)} [player] 要查看的角色，如果未指定，使用被查看牌的所属角色，如果所属角色未定义或这个参数为false，直接返回牌的属性；
          * @returns {string}
          */
         nature: function (card, player) {
            if (get.itemtype(player) == 'player' || player !== false) {
               var owner = get.owner(card);
               if (owner) {
                  return game.checkMod(card, owner, card.nature, 'cardnature', owner);
               }
            }
            return card.nature;
         },
         /**
          * 从牌堆顶抽取指定数量的游戏牌
          * 如果牌堆没有牌，游戏直接平局
          * @param {number} num 要抽的牌数
          * @returns {!Array<GameCores.GameObjects.Card>}
          */
         cards: function (num) {
            if (_status.waitingForCards) {
               ui.create.cards.apply(ui.create, _status.waitingForCards);
               delete _status.waitingForCards;
            }
            var list = [];
            var card = false;
            if (typeof num != 'number') num = 1;
            if (num == 0) { card = true; num = 1; }
            if (num < 0) num = 1;
            while (num--) {
               if (ui.cardPile.hasChildNodes() == false) {
                  if (_status.maxShuffle != undefined) {
                     if (_status.maxShuffle == 0) {
                        if (_status.maxShuffleCheck) {
                           game.over(_status.maxShuffleCheck());
                        }
                        else {
                           game.over('平局');
                        }
                        return [];
                     }
                     _status.maxShuffle--;
                  }
                  game.shuffleNumber++;
                  if (_status.event.trigger) _status.event.trigger('washCard');
                  var cards = [], i;
                  for (var i = 0; i < lib.onwash.length; i++) {
                     if (lib.onwash[i]() == 'remove') {
                        lib.onwash.splice(i--, 1);
                     }
                  }
                  if (_status.discarded) {
                     _status.discarded.length = 0;
                  }
                  for (i = 0; i < ui.discardPile.childNodes.length; i++) {
                     var currentcard = ui.discardPile.childNodes[i];
                     currentcard.vanishtag.length = 0;
                     if (get.info(currentcard).vanish || currentcard.storage.vanish) {
                        currentcard.remove();
                        continue;
                     }
                     cards.push(currentcard);
                  }
                  cards.randomSort();
                  for (var i = 0; i < cards.length; i++) {
                     ui.cardPile.appendChild(cards[i]);
                  }
               }
               if (ui.cardPile.hasChildNodes() == false) {
                  game.over('平局');
                  return [];
               }
               var cardx = ui.cardPile.removeChild(ui.cardPile.firstChild);
               cardx.original = 'c';
               list.push(cardx);
            }
            game.updateRoundNumber();
            if (card) return list[0];
            return list;
         },
         /**
          * 返回`info.judge`，如果这张牌可视为其他牌(`viewAs`)，返回视为牌的`info.judge`
          * @param {GameCores.GameObjects.Card} card 游戏牌，除牌名外其他属性和函数可以为空
          * @returns {string}
          */
         judge: function (card) {
            if (card.viewAs) return lib.card[card.viewAs].judge;
            return get.info(card).judge;
         },
         /**
          * 返回两个角色之间的距离；
          * 如果目标角色就是参考角色，即这个角色到自己的距离，不计算任何技能和装备效果，直接返回0；
          * 除此之外，根据`method`参数返回距离，详情见下表:
          * `method`参数表:
          * **Chess Mode:**
          * 
          * |method|type|
          * |:----:|:--:|
          * |undefined|计算距离，此距离计算被动技和装备的效果|
          * |raw, pure, absolute|原距离，不计算被动技和装备的效果|
          * **Stone Mode:**
          * 
          * |method|type|
          * |:----:|:--:|
          * |undefined|计算距离，此距离计算被动技和装备的效果|
          * |raw, pure, absolute|原距离，1|
          * **Others:**
          * 
          * |method|type|
          * |:----:|:--:|
          * |undefined|计算距离，此距离计算[^被动技]和装备的效果|
          * |raw, pure|原距离，不计算被动技和装备的效果|
          * |absolute|右手(逆时针)距离，不计算被动技和装备的效果|
          * |attack|攻击距离，此距离计算被动技和装备的效果|
          * **原距离** 一名角色与其他角色的距离最小为1；如果是到自己的距离，为0
          * **被动技** 如果参考角色`from`有被动技**globalFrom**，计算被动技效果，然后如果目标角色`to`有被动技**globalTo**，计算被动技效果，结果作为计算距离；之后如果参考角色`from`有被动技**attackFrom**, 目标角色`to`有被动技**attackTo**，同理，继续依次计算`from`和`to`的被动技效果，结果作为攻击距离；不计算被动技时，攻击距离等于计算距离；被动技效果计算完成后，继续计算角色的装备效果(如果有装备)
          * @param {!GameCores.GameObjects.Player} from 参考角色
          * @param {!GameCores.GameObjects.Player} to 目标角色
          * @param {?string} method 见method参数表
          * @returns {number} 如果`from`或`to`不在游戏中或未指定，返回`Infinity`；如果`from==to`，返回0
          */
         distance: function (from, to, method) {
            if (from == to) return 0;
            if (!game.players.contains(from) && !game.dead.contains(from)) return Infinity;
            if (!game.players.contains(to) && !game.dead.contains(to)) return Infinity;
            var player = from, m, n = 1, i;
            var fxy, txy;
            if (game.chess) {
               fxy = from.getXY();
               txy = to.getXY();
               n = Math.abs(fxy[0] - txy[0]) + Math.abs(fxy[1] - txy[1]);
               if (method == 'raw' || method == 'pure' || method == 'absolute') return n;
            }
            else if (to.isMin(true) || from.isMin(true)) {
               if (method == 'raw' || method == 'pure' || method == 'absolute') return n;
            }
            else {
               var length = game.players.length;
               var totalPopulation = game.players.length + game.dead.length + 1;
               for (var iwhile = 0; iwhile < totalPopulation; iwhile++) {
                  if (player.nextSeat != to) {
                     player = player.nextSeat;
                     if (player.isAlive() && !player.isOut() && !player.hasSkill('undist') && !player.isMin(true)) n++;
                  }
                  else {
                     break;
                  }
               }
               for (i = 0; i < game.players.length; i++) {
                  if (game.players[i].isOut() || game.players[i].hasSkill('undist') || game.players[i].isMin(true)) length--;
               }
               if (method == 'absolute') return n;
               if (from.isDead()) length++;
               if (to.isDead()) length++;
               var left = from.hasSkillTag('left_hand');
               var right = from.hasSkillTag('right_hand');
               if (left === right) n = Math.min(n, length - n);
               else if (left == true) n = length - n;
               if (method == 'raw' || method == 'pure') return n;
            }

            n = game.checkMod(from, to, n, 'globalFrom', from);
            n = game.checkMod(from, to, n, 'globalTo', to);
            m = n;
            m = game.checkMod(from, to, m, 'attackFrom', from);
            m = game.checkMod(from, to, m, 'attackTo', to);
            var equips1 = from.getCards('e', function (card) {
               return !ui.selected.cards || !ui.selected.cards.contains(card);
            }), equips2 = to.getCards('e', function (card) {
               return !ui.selected.cards || !ui.selected.cards.contains(card);
            });
            for (i = 0; i < equips1.length; i++) {
               var info = get.info(equips1[i]).distance;
               if (!info) continue;
               if (info.globalFrom) {
                  m += info.globalFrom;
                  n += info.globalFrom;
               }
               if (info.attackFrom) {
                  m += info.attackFrom;
               }
            }
            for (i = 0; i < equips2.length; i++) {
               var info = get.info(equips2[i]).distance;
               if (!info) continue;
               if (info.globalTo) {
                  m += info.globalTo;
                  n += info.globalTo;
               }
               if (info.attaclTo) {//[recommend][bug] use attackTo instead of attaclTo
                  m += info.attaclTo;
               }
            }
            if (method == 'attack') return m;
            if (method == 'unchecked') return n;
            return Math.max(1, n);
         },
         /**
          * 返回技能模板
          * @name get.info
          * @function
          * @param {?string} item 技能ID，如果未定义，返回undefined
          * @returns {?GameCores.GameObjects.SkillInfo} 技能模板
          */
         /**
          * 获取游戏牌模板
          * @name get.info
          * @function
          * @variation 2
          * @param {!GameCores.GameObjects.Card} card 游戏牌对象，除了牌名(`card.name`)外，其他属性或函数可以为空
          * @param {(GameCores.GameObjects.Player|boolean|undefined)} option 将根据`option`获取游戏牌牌名，然后根据牌名获取模板。详见{@link game.name}，{@link game.name(2)}
          * @returns {?GameCores.GameObjects.CardInfo} 游戏牌模板
          */
         info: function (item, player) {
            if (typeof item == 'string') {
               return lib.skill[item];
            }
            if (typeof item == 'object') {
               var name = item.name;
               if (player !== false) name = get.name(item, player);
               return lib.card[name];
            }
         },
         /**
          * 将选择范围格式化为`[(number), (number)]`再返回
          * @param {(number|Array<number>|function():Array<number>)} select 如果为数值，返回`[select, select]`；如果为数组且为`[(number), (number)]`的形式，返回`select`；如果为函数，将函数的返回值作为此函数的参数迭代，然后将结果返回；其他情况，返回`[1, 1]`
          * @returns {Array<number>} 一个`[(number), (number)]`形式的数组
          */
         select: function (select) {
            if (typeof select == 'number') return [select, select];
            if (get.itemtype(select) == 'select') return select;
            if (typeof select == 'function') return get.select(select());
            return [1, 1]
         },
         /**
          * 返回本机角色当前选择的一张牌，或将本机角色当前选择的牌视为一张牌返回；
          * 如果`get.info(_status.event.skill).viewAs`存在，然后将当前选择的牌视为一张`viewAs8`返回；如果`viewAs`为函数，且`viewAs(ui.selected.cards, _status.event.player)`有返回值(`card`)，将当前选择的牌视为一张`card`返回；
          * 除此之外，如果`_status.event._get_card`存在，返回`_status.event._get_card`
          * @param {?boolean} [original] 如果为true，返回`ui.selected.cards[0]`；如果为false或未指定，将当前选择的牌视为一张`ui.selected.cards[0]`返回
          * @returns {?GameCores.GameObjects.Card} 如果当前没有选择的牌，返回undefined
          */
         card: function (original) {
            if (_status.event.skill) {
               var card = get.info(_status.event.skill).viewAs;
               if (typeof card == 'function') card = card(ui.selected.cards, _status.event.player);
               if (card) {
                  return get.autoViewAs(card, ui.selected.cards, _status.event.player);
               }
            }
            if (_status.event._get_card) {
               return _status.event._get_card;
            }
            var card = ui.selected.cards[0];
            if (original) return card;
            if (card) {
               card = get.autoViewAs(card, ui.selected.cards, _status.event.player);
            }
            return card;
         },
         /**
          * 返回当前事件角色
          * @returns {GameCores.GameObjects.Player}
          */
         player: function () {
            return _status.event.player;
         },
         /**
          * 返回一个角色数组
          * @param {*} sort 
          * @param {*} dead 
          * @param {*} out 
          * @returns {Array<GameCores.GameObjects.Player>}
          */
         //TODO
         players: function (sort, dead, out) {
            var players = game.players.slice(0);
            if (sort != false) {
               if (typeof sort == 'function') {
                  players.sort(sort);
               }
               else {
                  if (get.itemtype(sort) != 'player') lib.tempSortSeat = _status.event.player;
                  else lib.tempSortSeat = sort;
                  players.sort(lib.sort.seat);
                  delete lib.tempSortSeat;
               }
            }
            if (dead) players = players.concat(game.dead);
            if (!out) {
               for (var i = 0; i < players.length; i++) {
                  if (players[i].isOut()) players.splice(i--, 1);
               }
            }
            return players;
         },
         /**
          * 返回(角色座次|游戏牌所在区域)
          * @param {*} card 
          * @param {*} ordering 
          * @returns {(number|'h'|'e'|'j'|'o'|'s'|'c'|'d'|null)}
          */
         //TODO
         position: function (card, ordering) {
            if (get.itemtype(card) == 'player') return parseInt(card.dataset.position);
            if (card.timeout && card.destiny) {
               if (card.destiny.classList.contains('equips')) return 'e';
               if (card.destiny.classList.contains('judges')) return 'j';
               if (card.destiny.classList.contains('handcards')) return card.classList.contains('glows') ? 's' : 'h';
               if (card.destiny.id == 'cardPile') return 'c';
               if (card.destiny.id == 'discardPile') return 'd';
               if (card.destiny.id == 'special') return 's';
               if (card.destiny.id == 'ordering') return ordering ? 'o' : 'd';
               return null;
            }
            if (!card.parentNode) return;
            if (card.parentNode.classList.contains('equips')) return 'e';
            if (card.parentNode.classList.contains('judges')) return 'j';
            if (card.parentNode.classList.contains('handcards')) return card.classList.contains('glows') ? 's' : 'h';
            if (card.parentNode.id == 'cardPile') return 'c';
            if (card.parentNode.id == 'discardPile') return 'd';
            if (card.parentNode.id == 'special') return 's';
            if (card.parentNode.id == 'ordering') return ordering ? 'o' : 'd';
            return null;
         },
         skillTranslation: function (str, player) {
            var str2, str3;
            if (str.indexOf('re_') == 0) {
               str2 = str.slice(3);
               if (str2) {
                  if (lib.translate[str] == lib.translate[str2]) {
                     if (player.hasSkill(str2)) {
                        return '新·' + lib.translate[str];
                     }
                  }
                  str3 = 'mark_' + str2;
                  if (lib.translate[str3] && lib.translate[str] == lib.translate[str3]) {
                     if (player.hasSkill(str3)) {
                        return '新·' + lib.translate[str];
                     }

                  }
               }
            }
            if (str.indexOf('re') == 0) {
               str2 = str.slice(2);
               if (str2) {
                  if (lib.translate[str] == lib.translate[str2]) {
                     if (player.hasSkill(str2)) {
                        return '界' + lib.translate[str];
                     }
                  }
               }
            }
            else if (str.indexOf('xin') == 0) {
               str2 = str.slice(3);
               if (str2) {
                  if (lib.translate[str] == lib.translate[str2]) {
                     if (player.hasSkill(str2)) {
                        return '新' + lib.translate[str];
                     }
                  }
               }
            }
            return get.translation(str);
         },
         interoperableText(name, player) {
            var _a, _b;
            let str = lib.translate[name];
            if (lib.skill[name] && lib.translate[name + '_info']) {
               str = get.skillInfoTranslation(name, player);
               let info = lib.skill[name];
               let iSkill = [(_a = info.ai) === null || _a === void 0 ? void 0 : _a.combo, info.derivation, info.involve].vkflat();
               iSkill = [...new Set(iSkill)];
               for (let i of iSkill) {
                  let tra = get.translation(i);
                  if (tra.indexOf('(') > 0)
                     tra = tra.substring(0, tra.indexOf('('));
                  let reg = new RegExp(`『(${tra})』`, 'g');
                  str = str.replace(reg, `<span class="iText" data-introLink="${i}">
                              <svg width="${tra.length * 1.1 + 2}em" height="1.3em" style="vertical-align: bottom">
                                  <text x="0" y="80%" fill="white">『$1』</text>
                                  <rect width="100%" height="100%" class="iRec"/>
                              </svg></span>`);
               }
            }
            (_b = ui.interoperableText) !== null && _b !== void 0 ? _b : (ui.interoperableText =
               lib.init.sheet(`
                              .iText{
                                  position: relative;
                                  cursor: pointer;
                                  font-style: italic;
                                  line-height: 1em;
                              }
                          `, `
                              .iRec{
                                  fill:transparent;
                                  stroke:aqua;
                                  stroke-width: 6px;
                                  stroke-dasharray: 100 500;
                                  stroke-dashoffset: 230;
                                  transition: 1.2s;
                              }
                          `, `
                              .iText:hover .iRec{
                                  stroke-width: 4px;
                                  stroke-dasharray: 600;
                                  stroke-dashoffset: 0;
                              }
                          `));
            return str;
         },
         skillInfoTranslation(name, player) {
            let str = lib.translate[name + '_info'];
            if (player && lib.dynamicTranslate[name])
               str = lib.dynamicTranslate[name](player, name);
            if (!str)
               return '';
            str = str
               .replace(/(.*?)(出牌阶段限一次|出牌阶段|准备阶段|每回合限一次|每回合每项限一次|每回合限X次|一轮开始时)，/g, '$1<font style="color:#ccc;font-weight: bold">$2</font>，')
               .replace(/(锁定技) /g, '<font color=#f77>$1 </font>')
               .replace(/(阵法技) /g, '<font color=#fe2>$1 </font>')
               .replace(/(轮次技) /g, '<font color=#fc2>$1 </font>')
               .replace(/(转换技) /g, '<font color=#8ae>$1 </font>')
               .replace(/(限定技) /g, '<font color=#baf>$1 </font>')
               .replace(/(使命技) /g, '<font color=#bf9>$1 </font>')
               .replace(/(觉醒技) /g, '<font color=#fcd>$1 </font>')
               .replace(/(主公技) /g, '<font color=#ff4>$1 </font>');
            return str;
         },
         translation: function (str, arg) {
            if (str && typeof str == 'object' && (str.name || str._tempTranslate)) {
               if (str._tempTranslate) return str._tempTranslate;
               var str2;
               if (arg == 'viewAs' && str.viewAs) {
                  str2 = get.translation(str.viewAs);
               }
               else {
                  str2 = get.translation(str.name);
               }
               if (str2.length == 1) {
                  if (str.nature == 'fire') {
                     str2 = '火' + str2;
                  }
                  else if (str.nature == 'thunder') {
                     str2 = '雷' + str2;
                  }
                  else if (str.nature == 'kami') {
                     str2 = '神' + str2;
                  }
                  else if (str.nature == 'ocean') {
                     str2 = '海' + str2;
                  }
                  else if (str.nature == 'ice') {
                     str2 = '冰' + str2;
                  }
                  else if (str.nature == 'yami') {
                     str2 = '暗' + str2;
                  }
               } else if (str.nature && str.nature.length) {
                  if (str.nature == 'fire') {
                     str2 = str2.replace(str2.charAt(0), '火');
                  }
                  else if (str.nature == 'thunder') {
                     str2 = str2.replace(str2.charAt(0), '雷');
                  }
                  else if (str.nature == 'kami') {
                     str2 = str2.replace(str2.charAt(0), '神');
                  }
                  else if (str.nature == 'ocean') {
                     str2 = str2.replace(str2.charAt(0), '海');
                  }
                  else if (str.nature == 'ice') {
                     str2 = str2.replace(str2.charAt(0), '冰');
                  }
                  else if (str.nature == 'yami') {
                     str2 = str2.replace(str2.charAt(0), '暗');
                  }
               }
               if (get.itemtype(str) == 'card' || str.isCard) {
                  if (_status.cardtag && str.cardid) {
                     var tagstr = '';
                     for (var i in _status.cardtag) {
                        if (_status.cardtag[i].contains(str.cardid)) {
                           tagstr += lib.translate[i + '_tag'];
                        }
                     }
                     if (tagstr) {
                        str2 += '·' + tagstr;
                     }
                  }
                  if (str.suit && str.number) {
                     var cardnum = str.number || '';
                     if ([1, 11, 12, 13, 14].contains(cardnum)) {
                        cardnum = { '1': 'A', '11': 'J', '12': 'Q', '13': 'K', '14': '★' }[cardnum]
                     }
                     if (arg == 'viewAs' && str.viewAs != str.name && str.viewAs) {
                        str2 += '（' + get.translation(str) + '）';
                     }
                     else {
                        str2 += '【' + get.translation(str.suit) + cardnum + '】';
                        // var len=str2.length-1;
                        // str2=str2.slice(0,len)+'<span style="letter-spacing: -2px">'+str2[len]+'·</span>'+get.translation(str.suit)+str.number;
                     }
                  }
               }
               return str2;
            }
            if (Array.isArray(str)) {
               var str2 = get.translation(str[0], arg);
               for (var i = 1; i < str.length; i++) {
                  str2 += '、' + get.translation(str[i], arg);
               }
               return str2;
            }
            if (arg == 'skill') {
               if (lib.translate[str + '_ab']) return lib.translate[str + '_ab'];
               if (lib.translate[str]) return lib.translate[str].slice(0, 2);
               return str;
            }
            else if (arg == 'info') {
               if (lib.translate[str + '_info']) return lib.translate[str + '_info'];
               var str2 = str.slice(0, str.length - 1);
               if (lib.translate[str2 + '_info']) return lib.translate[str2 + '_info'];
               if (str.lastIndexOf('_') > 0) {
                  str2 = str.slice(0, str.lastIndexOf('_'));
                  if (lib.translate[str2 + '_info']) return lib.translate[str2 + '_info'];
               }
               str2 = str.slice(0, str.length - 2);
               if (lib.translate[str2 + '_info']) return lib.translate[str2 + '_info'];
               if (lib.skill[str] && lib.skill[str].prompt) return lib.skill[str].prompt;
            }
            if (lib.translate[str]) {
               return lib.translate[str];
            }
            if (typeof str == 'string') {
               return str;
            }
            if (typeof str == 'number' || typeof str == 'boolean') {
               return str.toString();
            }
            if (str && str.toString) {
               return str.toString();
            }
            return '';
         },
         strNumber: function (num) {
            switch (num) {
               case 1: return 'A';
               case 11: return 'J';
               case 12: return 'Q';
               case 13: return 'K';
               case 14: return '★';
               default: return num.toString();
            }
         },
         cnNumber: function (num, two) {
            if (num == Infinity) return '∞';
            if (isNaN(num)) return '';
            if (typeof num != 'number') return num;
            if (num < 0 || num > 99) return num;
            if (num <= 10) {
               switch (num) {
                  case 0: return '〇';
                  case 1: return '一';
                  case 2: return two ? '二' : '两';
                  case 3: return '三';
                  case 4: return '四';
                  case 5: return '五';
                  case 6: return '六';
                  case 7: return '七';
                  case 8: return '八';
                  case 9: return '九';
                  case 10: return '十';
               }
            }
            if (num < 20) {
               return '十' + get.cnNumber(num - 10, true);
            }
            var x = Math.floor(num / 10);
            return get.cnNumber(x, true) + '十' + (num > 10 * x ? get.cnNumber(num - 10 * x, true) : '');
         },
         selectableButtons: function (sort) {
            if (!_status.event.player) return [];
            var buttons = _status.event.dialog.buttons;
            var selectable = [];
            for (var i = 0; i < buttons.length; i++) {
               if (buttons[i].classList.contains('selectable') &&
                  buttons[i].classList.contains('selected') == false) {
                  selectable.push(buttons[i]);
               }
            }
            if (sort) {
               selectable.sort(sort);
            }
            return selectable;
         },
         selectableCards: function (sort) {
            if (!_status.event.player) return [];
            var cards = _status.event.player.getCards('hes');
            var selectable = [];
            for (var i = 0; i < cards.length; i++) {
               if (cards[i].classList.contains('selectable') &&
                  cards[i].classList.contains('selected') == false) {
                  selectable.push(cards[i]);
               }
            }
            if (sort) {
               selectable.sort(sort);
            }
            return selectable;
         },
         skills: function () {
            var skills = [];
            if (ui.skills) {
               skills = skills.concat(ui.skills.skills);
            }
            if (ui.skills2) {
               skills = skills.concat(ui.skills2.skills);
            }
            if (ui.skills3) {
               skills = skills.concat(ui.skills3.skills);
            }
            return skills;
         },
         /**
          * 返回本角色可获得的技能；
          * @param {?Function} func 筛选条件
          * @param {?HTMLDivElement} player 可选
          * @returns {!Array<string>}
          */
         gainableSkills: function (func, player) {
            var list = [];
            for (var i in lib.character) {
               if (lib.filter.characterDisabled(i)) continue;
               if (lib.filter.characterDisabled2(i)) continue;
               if (lib.character[i][4]) {
                  if (lib.character[i][4].contains('boss')) continue;
                  if (lib.character[i][4].contains('hiddenboss')) continue;
                  if (lib.character[i][4].contains('minskin')) continue;
                  if (lib.character[i][4].contains('unseen')) continue;
               }
               for (var j = 0; j < lib.character[i][3].length; j++) {
                  var skill = lib.character[i][3][j];
                  var info = lib.skill[skill];
                  if (lib.filter.skillDisabled(skill)) continue;
                  if (func && !func(info, skill, i)) continue;
                  if (player && player.hasSkill && info.ai && info.ai.combo && !player.hasSkill(info.ai.combo)) continue;
                  list.add(skill);
               }
            }
            return list;
         },
         /**
          * 返回目标角色可被获得的技能；
          * @param {!string} name 角色名
          * @param {?Function} func 筛选条件
          * @returns {!Array<string>}
          */
         gainableSkillsName: function (name, func) {
            var list = [];
            if (name && lib.character[name]) {
               if (lib.character[name][4]) {
                  if (lib.character[name][4].contains('boss')) return list;
                  if (lib.character[name][4].contains('hiddenboss')) return list;
                  if (lib.character[name][4].contains('minskin')) return list;
                  if (lib.character[name][4].contains('unseen')) return list;
               }
               for (var j = 0; j < lib.character[name][3].length; j++) {
                  var skill = lib.character[name][3][j];
                  var info = lib.skill[skill];
                  if (lib.filter.skillDisabled(skill)) continue;
                  if (func && !func(info, skill, name)) continue;
                  list.add(skill);
               }
            }
            return list;
         },
         /**
          * 返回可获得的武将牌；
          * @param {?Function} func 筛选条件
          * @returns {!Array<string>}
          */
         gainableCharacters: function (func) {
            var list = [];
            for (var i in lib.character) {
               var info = lib.character[i];
               if (!info) continue;
               if (typeof func == 'function' && !func(info, i)) continue;
               if (lib.filter.characterDisabled(i)) continue;
               if (lib.filter.characterDisabled2(i)) continue;
               list.push(i);
            }
            if (func === true) {
               var players = game.players.concat(game.dead);
               for (var i = 0; i < players.length; i++) {
                  list.remove(players[i].name);
                  list.remove(players[i].name1);
                  list.remove(players[i].name2);
               }
            }
            return list;
         },
         selectableTargets: function (sort) {
            var selectable = [];
            var players = game.players.slice(0);
            if (_status.event.deadTarget) players.addArray(game.dead);
            for (var i = 0; i < players.length; i++) {
               if (players[i].classList.contains('selectable') &&
                  players[i].classList.contains('selected') == false) {
                  selectable.push(players[i]);
               }
            }
            selectable.randomSort();
            if (sort) {
               selectable.sort(sort);
            }
            return selectable;
         },
         //检查卡牌是否符合要求的快捷方法(要求满足全部条件，无条件时默认满足)
         filter: function (filter, i) {
            if (typeof filter == 'function') return filter;
            if (i == undefined) i = 0;
            var result = function () {
               if (filter == arguments[i]) return true;
               for (var j in filter) {
                  if (filter.hasOwnProperty(j)) {
                     if (get.itemtype(arguments[i]) == 'card') {
                        if (j == 'name') {
                           if (typeof filter[j] == 'object') {
                              if (filter[j].contains(get.name(arguments[i])) == false) return false;
                           }
                           else if (typeof filter[j] == 'string') {
                              if (get.name(arguments[i]) != filter[j]) return false;
                           }
                        }
                        else if (j == 'type') {
                           if (typeof filter[j] == 'object') {
                              if (filter[j].contains(get.type(arguments[i])) == false) return false;
                           }
                           else if (typeof filter[j] == 'string') {
                              if (get.type(arguments[i]) != filter[j]) return false;
                           }
                        }
                        else if (j == 'subtype') {
                           if (typeof filter[j] == 'object') {
                              if (filter[j].contains(get.subtype(arguments[i])) == false) return false;
                           }
                           else if (typeof filter[j] == 'string') {
                              if (get.subtype(arguments[i]) != filter[j]) return false;
                           }
                        }
                        else if (['color', 'suit', 'number'].contains(j)) {
                           if (typeof filter[j] == 'object') {
                              if (filter[j].contains(get[j](arguments[i])) == false) return false;
                           }
                           else if (typeof filter[j] == 'string') {
                              if (get[j](arguments[i]) != filter[j]) return false;
                           }
                        }
                        else if (typeof filter[j] == 'object') {
                           if (filter[j].contains(arguments[i][j]) == false) return false;
                        }
                        else if (typeof filter[j] == 'string') {
                           if (typeof get[j] == 'function') {
                              if (get[j](arguments[i]) != filter[j]) return false;
                           }
                           else if (arguments[i][j] != filter[j]) return false;
                        }
                     }
                     else {
                        if (arguments[i][j] != filter[j]) return false;
                     }
                  }
               }
               return true;
            }
            result._filter_args = [filter, i];
            return result;
         },
         cardCount: function (card, player) {
            var num;
            if (card == true) {
               num = 0;
               var stat = player.getStat('card');
               for (var i in stat) {
                  if (typeof stat[i] == 'number') num += stat[i];
               }
               return num;
            }
            if (player == undefined) player = _status.event.player;
            if (typeof card == 'object') {
               card = card.name;
            }
            num = player.getStat('card')[card];
            if (num == undefined) return 0;
            return num;
         },
         skillCount: function (skill, player) {
            if (player == undefined) player = _status.event.player;
            var num = player.getStat('skill')[skill];
            if (num == undefined) return 0;
            return num;
         },
         owner: function (card, method) {
            var list = game.players.concat(game.dead);
            for (var i = 0; i < list.length; i++) {
               if (list[i].getCards('hej').contains(card)) return list[i];
               if (list[i].judging[0] == card && method != 'judge') return list[i];
            }
            //for(var i=0;i<game.players.length;i++){
            //    if(game.players[i].using&&game.players[i].using.contains(card)) return game.players[i];
            //}
         },
         noSelected: function () {
            return (ui.selected.buttons.length + ui.selected.cards.length + ui.selected.targets.length == 0)
         },
         population: function (identity) {
            if (identity == undefined) return game.players.length + game.dead.length;
            var i;
            var num = 0;
            for (i = 0; i < game.players.length; i++) {
               if (game.players[i].identity == identity) num++;
            }
            return num;
         },
         totalPopulation: function (identity) {
            if (identity == undefined) return game.players.length + game.dead.length;
            var i, players = game.players.concat(game.dead);
            var num = 0;
            for (i = 0; i < players.length; i++) {
               if (players[i].identity == identity) num++;
            }
            return num;
         },
         //标记
         cardtag: function (item, tag) {
            if (item.cardid && (get.itemtype(item) == 'card' || !item.cards || !item.cards.length || item.name == item.cards[0].name) && _status.cardtag && _status.cardtag[tag] && _status.cardtag[tag].contains(item.cardid)) {
               return true;
            }
            if (item.cardtags && item.cardtags.contains(tag)) return true;
            return false;
         },
         tag: function (item, tag, item2) {
            var result;
            if (get.info(item) && get.info(item).ai && get.info(item).ai.tag) {
               result = get.info(item).ai.tag[tag];
            }
            if (typeof result == 'function') return result(item, item2);
            return result;
         },
         sortCard: function (sort) {
            var func;
            if (sort == 'type_sort') {
               func = function (card) {
                  var type = get.type(card);
                  var subtype = get.subtype(card);
                  if (lib.cardType[subtype]) {
                     return lib.cardType[subtype];
                  }
                  if (lib.cardType[type]) {
                     return lib.cardType[type];
                  }
                  switch (type) {
                     case 'basic': return 2;
                     case 'chess': return 1.5;
                     case 'trick': return -1;
                     case 'delay': return -2;
                     case 'equip': return -3;
                     default: return -4;
                  }
               }
            }
            else if (sort == 'suit_sort') {
               func = function (card) {
                  if (get.suit(card) == 'heart') return 2;
                  if (get.suit(card) == 'diamond') return 1;
                  if (get.suit(card) == 'spade') return -1;
                  if (get.suit(card) == 'club') return -2;
               }
            }
            else if (sort == 'number_sort') {
               func = function (card) {
                  return get.number(card) - 7 + 0.5;
               }
            }
            return func;
         },
         difficulty: function () {
            switch (get.config('difficulty')) {
               case 'easy': return 1;
               case 'normal': return 2;
               case 'hard': return 3;
               default: return 1;
            }
         },
         cardPile: function (name, create) {
            var filter = function (card) {
               if (typeof name == 'string') {
                  if (card.name == name) {
                     return true;
                  }
               }
               else if (typeof name == 'function') {
                  if (name(card)) {
                     return true;
                  }
               }
               return false;
            };
            if (create != 'discardPile') {
               for (var i = 0; i < ui.cardPile.childNodes.length; i++) {
                  if (filter(ui.cardPile.childNodes[i])) {
                     return ui.cardPile.childNodes[i];
                  }
               }
            }
            if (create != 'cardPile') {
               for (var i = 0; i < ui.discardPile.childNodes.length; i++) {
                  if (filter(ui.discardPile.childNodes[i])) {
                     return ui.discardPile.childNodes[i];
                  }
               }
            }
            if (create == 'field') {
               var found = null;
               game.findPlayer(function (current) {
                  var ej = current.getCards('ej');
                  for (var i = 0; i < ej.length; i++) {
                     if (filter(ej[i])) {
                        found = ej[i];
                        return true;
                     }
                  }
               });
               return found;
            }
            if (create && !['cardPile', 'discardPile', 'field'].contains(create)) {
               return game.createCard(name);
            }
            return null;
         },
         cardPile2: function (name) {
            return get.cardPile(name, 'cardPile');
         },
         discardPile: function (name) {
            return get.cardPile(name, 'discardPile');
         },
         aiStrategy: function () {
            switch (get.config('ai_strategy')) {
               case 'ai_strategy_1': return 1;
               case 'ai_strategy_2': return 2;
               case 'ai_strategy_3': return 3;
               case 'ai_strategy_4': return 4;
               case 'ai_strategy_5': return 5;
               case 'ai_strategy_6': return 6;
               default: return 1;
            }
         },
         skillintro: function (name, learn, learn2) {
            var str = '';
            var infoitem = lib.character[name];
            if (!infoitem) {
               for (var itemx in lib.characterPack) {
                  if (lib.characterPack[itemx][name]) {
                     infoitem = lib.characterPack[itemx][name]; break;
                  }
               }
            }
            var skills = infoitem[3];
            var opacity;
            for (var i = 0; i < skills.length; i++) {
               if (lib.translate[skills[i]] && lib.translate[skills[i] + '_info'] && lib.skill[skills[i]]) {
                  if (learn && lib.skill[skills[i]].unique && (learn2 || !lib.skill[skills[i]].gainable)) {
                     opacity = 'opacity:0.5';
                  }
                  else {
                     opacity = '';
                  }
                  var skilltrans = get.translation(skills[i]).slice(0, 2);
                  str += '<div class="skill" style="' + opacity +
                     '">' + skilltrans + '</div><div style="' + opacity + '">' +
                     get.skillInfoTranslation(skills[i]) + '</div><div style="display:block;height:10px"></div>';
               }
            }
            return str;
         },
         intro: function (name) {
            var info = lib.character[name];
            var str = '性别：' + get.translation(info[0]) + '<br/>';
            str += '势力：' + get.translation(info[1]) + '<br/>';
            str += '体力：' + get.translation(info[2]) + '<br/>';
            str += '技能：';
            if (info[3].length) {
               str += get.translation(info[3][0]);
               for (var i = 1; i < info[3].length; i++) {
                  str += '、' + get.translation(info[3][i]);
               }
            }
            return str;
         },
         storageintro: function (type, content, player, dialog, skill) {
            switch (type) {
               case 'mark': {
                  if (content > 0) {
                     return '共有' + content + '个标记';
                  }
                  return false;
               }
               case 'turn': {
                  if (content > 0) {
                     return '剩余' + content + '个回合';
                  }
                  return false;
               }
               case 'time': {
                  if (content > 0) {
                     return '剩余' + content + '次';
                  }
                  return false;
               }
               case 'limited': {
                  if (content) {
                     return '已发动';
                  }
                  return '未发动';
               }
               case 'info': {
                  return lib.translate[skill + '_info'];
               }
               case 'cardCount': {
                  if (typeof content == 'object' && typeof content.length == 'number') {
                     return '共有' + get.cnNumber(content.length) + '张牌';
                  }
                  return false;
               }
               case 'card': case 'cards': {
                  if (get.itemtype(content) == 'card') {
                     content = [content];
                  }
                  if (dialog && get.itemtype(content) == 'cards') {
                     dialog.addAuto(content);
                  }
                  else {
                     if (content && content.length) {
                        return get.translation(content);
                     }
                  }
                  if (Array.isArray(content) && !content.length) {
                     return '没有卡牌';
                  }
                  return false;
               }
               case 'player': case 'players': {
                  if (get.itemtype(content) == 'player') {
                     content = [content];
                  }
                  if (dialog && get.itemtype(content) == 'players') {
                     dialog.addAuto(content);
                     return false;
                  }
                  else {
                     if (content && content.length) {
                        return get.translation(content);
                     }
                     return false;
                  }
               }
               case 'character': case 'characters': {
                  if (typeof content == 'string') {
                     content = [content];
                  }
                  if (dialog && Array.isArray(content)) {
                     dialog.addAuto([content, 'character']);
                     return false;
                  }
                  else {
                     if (content && content.length) {
                        return get.translation(content);
                     }
                     return false;
                  }
               }
               default: {
                  if (typeof type == 'string') {
                     type = type.replace(/#/g, content);
                     type = type.replace(/&/g, get.cnNumber(content));
                     type = type.replace(/\$/g, get.translation(content));
                     return type;
                  }
                  else if (typeof type == 'function') {
                     return type(content, player, skill);
                  }
                  return false;
               }
            }
         },
         /**
          * 生成(触屏: 长按[, 点击])|(鼠标: 悬浮, 右击[, 点击])弹窗
          * @name get.nodeintro
          * @function
          * @param {!HTMLDivElement} node 要弹窗的节点
          * @returns {!HTMLDivElement} 返回生成的弹窗
          * @see {@link lib.setIntro}
          */
         nodeintro: function (node, simple, evt) {
            var uiintro = ui.create.dialog('hidden', 'notouchscroll');
            if (node.classList.contains('player') && !node.name) {
               return uiintro;
            }
            var i, translation, intro, str;
            if (node._nointro) return;
            if (typeof node._customintro == 'function') {
               if (node._customintro(uiintro) === false) return;
            }
            else if (Array.isArray(node._customintro)) {
               var caption = node._customintro[0];
               var content = node._customintro[1];
               if (typeof caption == 'function') {
                  caption = caption(node);
               }
               if (typeof content == 'function') {
                  content = content(node);
               }
               uiintro.add(caption);
               uiintro.add('<div class="text center" style="padding-bottom:5px">' + content + '</div>');
            }
            else if (node.classList.contains('player') || node.linkplayer) {
               if (node.linkplayer) {
                  node = node.link;
               }
               var capt = get.translation(node.name);
               if ((lib.character[node.name] && lib.character[node.name][1]) || lib.group.contains(node.group)) {
                  capt += '&nbsp;&nbsp;' + (lib.group.contains(node.group) ? (lib.translate[node.group + '2'] ? get.translation(node.group + '2') : get.translation(node.group)) : lib.translate[lib.character[node.name][1]]);
               }
               uiintro.add(capt);

               if (lib.characterTitle[node.name]) {
                  uiintro.addText(get.colorspan(lib.characterTitle[node.name]));
               }

               if (true) {
                  var hs = node.getCards('h');
                  if (hs.length) {
                     var ms = [];
                     if (node.isUnderControl() || (!game.observe && game.me && game.me.hasSkillTag('viewHandcard', null, node, true))) {
                        ms.addArray(hs);
                     }
                     for (var i = 0; i < hs.length; i++) {
                        if (hs[i].hasGaintag('ming_')) ms.add(hs[i]);
                        if (hs[i].hasGaintag('an_')) ms.remove(ms[i]);
                     }
                     if (ms.length) {
                        uiintro.add('<div class="text center">手牌</div>');
                        uiintro.addSmall(ms);
                     }
                  }
               }

               var skills = node.getSkills(null, null, false).slice(0);
               var skills2 = game.filterSkills(skills, node);
               if (node == game.me && node.hiddenSkills.length) {
                  skills.addArray(node.hiddenSkills);
               }
               for (let i in node.disabledSkills) {
                  if (node.disabledSkills[i].length == 1 &&
                     node.disabledSkills[i][0] == i + '_awake' &&
                     !node.hiddenSkills.contains(i)) {
                     skills.add(i);
                  }
               }
               for (let i = 0; i < skills.length; i++) {
                  if (lib.skill[skills[i]] && (lib.skill[skills[i]].nopop || lib.skill[skills[i]].equipSkill)) continue;
                  if (lib.translate[skills[i] + '_info']) {
                     translation = lib.translate[skills[i] + '_ab'] || get.translation(skills[i]).slice(0, 5);
                     let info = get.interoperableText(skills[i], node)
                     if (node.forbiddenSkills[skills[i]]) {
                        let forbidstr = '<div style="opacity:0.5"><div class="skill">' + translation + '</div><div' + ((translation.length > 3) ? ' class="skilltext"' : '') + '>';
                        if (node.forbiddenSkills[skills[i]].length) {
                           forbidstr += '（与' + get.translation(node.forbiddenSkills[skills[i]]) + '冲突）<br>';
                        }
                        else {
                           forbidstr += '（双将禁用）<br>';
                        }
                        forbidstr += info + '</div></div>'
                        uiintro.add(forbidstr);
                     }
                     else if (!skills2.contains(skills[i])) {
                        uiintro.add(`<div style="opacity:0.5"><div class="skill">${translation}</div><div${(translation.length > 3) ? ' class="skilltext"' : ''}>${info}</div></div>`);
                     }
                     else if (lib.skill[skills[i]].temp || !node.skills.contains(skills[i]) || lib.skill[skills[i]].thundertext) {
                        if (lib.skill[skills[i]].frequent || lib.skill[skills[i]].subfrequent) {
                           uiintro.add(`<div><div class="skill thundertext thunderauto">${translation}</div><div${(translation.length > 3) ? ' class="skilltext thundertext thunderauto"' : ' class="thundertext thunderauto"'}>${info}<br><div class="underlinenode on gray" style="position:relative;padding-left:0;padding-top:7px">自动发动</div></div></div>`);
                           let underlinenode = uiintro.content.lastChild.querySelector('.underlinenode');
                           if (lib.skill[skills[i]].frequent) {
                              if (lib.config.autoskilllist.contains(skills[i])) {
                                 underlinenode.classList.remove('on');
                              }
                           }
                           if (lib.skill[skills[i]].subfrequent) {
                              for (let j = 0; j < lib.skill[skills[i]].subfrequent.length; j++) {
                                 if (lib.config.autoskilllist.contains(skills[i] + '_' + lib.skill[skills[i]].subfrequent[j])) {
                                    underlinenode.classList.remove('on');
                                 }
                              }
                           }
                           if (lib.config.autoskilllist.contains(skills[i])) {
                              underlinenode.classList.remove('on');
                           }
                           underlinenode.link = skills[i];
                           underlinenode.listen(ui.click.autoskill2);
                        }
                        else {
                           uiintro.add(`<div><div class="skill thundertext thunderauto">${translation}</div><div${(translation.length > 3) ? ' class="skilltext thundertext thunderauto"' : ' class="thundertext thunderauto"'}>${info}</div></div>`);
                        }
                     }
                     else if (lib.skill[skills[i]].frequent || lib.skill[skills[i]].subfrequent) {
                        uiintro.add(`<div><div class="skill">${translation}</div><div${(translation.length > 3) ? ' class="skilltext"' : ''}>${info}<br><div class="underlinenode on gray" style="position:relative;padding-left:0;padding-top:7px">自动发动</div></div></div>`);
                        let underlinenode = uiintro.content.lastChild.querySelector('.underlinenode');
                        if (lib.skill[skills[i]].frequent) {
                           if (lib.config.autoskilllist.contains(skills[i])) {
                              underlinenode.classList.remove('on');
                           }
                        }
                        if (lib.skill[skills[i]].subfrequent) {
                           for (let j = 0; j < lib.skill[skills[i]].subfrequent.length; j++) {
                              if (lib.config.autoskilllist.contains(skills[i] + '_' + lib.skill[skills[i]].subfrequent[j])) {
                                 underlinenode.classList.remove('on');
                              }
                           }
                        }
                        if (lib.config.autoskilllist.contains(skills[i])) {
                           underlinenode.classList.remove('on');
                        }
                        underlinenode.link = skills[i];
                        underlinenode.listen(ui.click.autoskill2);
                     }
                     else if (lib.skill[skills[i]].clickable && node.isIn() && node.isUnderControl(true)) {
                        if (lib.skill[skills[i]].clickChange) {
                           var intronode = uiintro.add(`<div><div class="skill">${translation}</div><div${(translation.length > 3) ? ' class="skilltext"' : ''}>${info}<br><div class="menubutton skillbutton" style="position:relative;margin-top:5px">点击${lib.skill[skills[i]].clickChange}</div></div></div>`).querySelector('.skillbutton');
                           if (!_status.gameStarted || (lib.skill[skills[i]].clickableFilter && !lib.skill[skills[i]].clickableFilter(node))) {
                              intronode.innerHTML = lib.discoloration1 + '已' + lib.skill[skills[i]].clickChange;
                              intronode.classList.add('hrefnode');
                              intronode.style.opacity = 0.8;
                           }
                           intronode.link = node;
                           intronode.func = lib.skill[skills[i]].clickable;
                           intronode.classList.add('pointerdiv');
                           intronode.listen(ui.click.skillbutton);
                        }
                        else {
                           var intronode = uiintro.add(`<div><div class="skill">${translation}</div><div${(translation.length > 3) ? ' class="skilltext"' : ''}>${info}<br><div class="menubutton skillbutton" style="position:relative;margin-top:5px">点击发动</div></div></div>`).querySelector('.skillbutton');
                           if (!_status.gameStarted || (lib.skill[skills[i]].clickableFilter && !lib.skill[skills[i]].clickableFilter(node))) {
                              intronode.classList.add('disabled');
                              intronode.style.opacity = 0.5;
                           }
                           else {
                              intronode.link = node;
                              intronode.func = lib.skill[skills[i]].clickable;
                              intronode.classList.add('pointerdiv');
                              intronode.listen(ui.click.skillbutton);
                           }
                        }
                     }
                     else if (lib.skill[skills[i]].nobracket) {
                        uiintro.add(`<div><div class="skilln">${get.translation(skills[i])}</div><div${(get.translation(skills[i]).length > 3) ? ' class="skilltext"' : ''}>${info}</div></div>`);
                     }
                     else {
                        uiintro.add(`<div><div class="skill">${translation}</div><div${(translation.length > 3) ? ' class="skilltext"' : ''}>${info}</div></div>`);
                     }
                     if (lib.translate[skills[i] + '_append']) {
                        uiintro._place_text = uiintro.add('<div class="text">' + lib.translate[skills[i] + '_append'] + '</div>')
                     }
                     for (let v of uiintro.getElementsByTagName('span')) {
                        v.link = v.dataset.introlink
                        if (v.classList.contains('iText')) lib.setIntro(v)
                     }
                  }
               }
               // if(get.is.phoneLayout()){
               //     var storage=node.storage;
               //     for(i in storage){
               //                  if(get.info(i)&&get.info(i).intro){
               //                               intro=get.info(i).intro;
               //                               if(node.getSkills().concat(lib.skill.global).contains(i)==false&&!intro.show) continue;
               //                               var name=intro.name?intro.name:get.translation(i);
               //                               if(typeof name=='function'){
               //                                            name=name(storage[i],node);
               //                               }
               //                               translation='<div><div class="skill">『'+name.slice(0,2)+'』</div><div>';
               //                               var stint=get.storageintro(intro.content,storage[i],node,null,i);
               //                               if(stint){
               //                                            translation+=stint+'</div></div>';
               //                                            uiintro.add(translation);
               //                               }
               //                  }
               //     }
               // }

               if (lib.config.right_range && _status.gameStarted) {
                  uiintro.add(ui.create.div('.placeholder'));
                  var table, tr, td;
                  table = document.createElement('table');
                  tr = document.createElement('tr');
                  table.appendChild(tr);
                  td = document.createElement('td');
                  td.innerHTML = '距离';
                  tr.appendChild(td);
                  td = document.createElement('td');
                  td.innerHTML = game.chess ? '道具' : '手牌';
                  tr.appendChild(td);
                  td = document.createElement('td');
                  td.innerHTML = '行动';
                  tr.appendChild(td);
                  td = document.createElement('td');
                  td.innerHTML = game.chess ? '职业' : '伤害';
                  tr.appendChild(td);

                  tr = document.createElement('tr');
                  table.appendChild(tr);
                  td = document.createElement('td');
                  if (node == game.me || !game.me || !game.me.isIn()) {
                     td.innerHTML = '-';
                  }
                  else {
                     let dist1 = get.numStr(Math.max(1, game.me.distanceTo(node)));
                     let dist2 = get.numStr(Math.max(1, node.distanceTo(game.me)));
                     if (dist1 == dist2) {
                        td.innerHTML = dist1;
                     }
                     else {
                        td.innerHTML = dist1 + '/' + dist2;
                     }
                  }
                  tr.appendChild(td);
                  td = document.createElement('td');
                  if (node.needsToDiscard()) {
                     td.classList.add('warnning_flash')
                  }
                  {
                     let card1 = node.countCards('h');
                     let card2 = node.getHandcardLimit();
                     if (!card2 || card2 == Infinity) {
                        td.innerHTML = card1;
                     }
                     else {
                        td.innerHTML = card1 + '/' + card2;
                     }
                  }
                  tr.appendChild(td);
                  td = document.createElement('td');
                  td.innerHTML = node.phaseNumber;
                  tr.appendChild(td);
                  td = document.createElement('td');
                  if (game.chess) {
                     if (node.$.curClass) td.innerHTML = get.translation(node.$.curClass);
                     else td.innerHTML = '-';
                  } else {
                     (function () {
                        num = 0;
                        for (let j = 0; j < node.stat.length; j++) {
                           if (typeof node.stat[j].damage == 'number') num += node.stat[j].damage;
                        }
                        td.innerHTML = num;
                     }());
                  }
                  tr.appendChild(td);
                  table.style.width = 'calc(100% - 20px)';
                  table.style.marginLeft = '10px';

                  uiintro.content.appendChild(table);
                  if (!lib.config.show_favourite) {
                     table.style.paddingBottom = '5px'
                  }
               }
               if (!simple || get.is.phoneLayout()) {
                  let es = node.getCards('e');
                  for (let i = 0; i < es.length; i++) {
                     if (es[i].viewAs && es[i].originalName && es[i].originalName != es[i].name) {
                        uiintro.add('<div><div class="equip">' + es[i].outerHTML + '</div><div>' + lib.translate[es[i].viewAs] + '：' + lib.translate[es[i].viewAs + '_info'] + '</div></div>');
                     }
                     else {
                        uiintro.add('<div><div class="equip">' + es[i].outerHTML + '</div><div>' + lib.translate[es[i].name + '_info'] + '</div></div>');
                     }
                     uiintro.content.lastChild.querySelector('.equip>.card').style.transform = '';
                  }
                  let js = node.getCards('j');
                  for (let i = 0; i < js.length; i++) {
                     if (js[i].viewAs && js[i].viewAs != js[i].name) {
                        uiintro.add('<div><div class="equip">' + js[i].outerHTML + '</div><div>' + lib.translate[js[i].viewAs] + '：' + lib.translate[js[i].viewAs + '_info'] + '</div></div>');
                     }
                     else {
                        uiintro.add('<div><div class="equip">' + js[i].outerHTML + '</div><div>' + lib.translate[js[i].name + '_info'] + '</div></div>');
                     }
                     uiintro.content.lastChild.querySelector('.equip>.card').style.transform = '';
                  }
                  if (get.is.phoneLayout()) {
                     let markCoutainer = ui.create.div('.mark-container.marks');
                     for (let i in node.marks) {
                        let nodemark = node.marks[i].cloneNode(true);
                        nodemark.classList.add('pointerdiv');
                        nodemark.link = node.marks[i];
                        nodemark.style.transform = '';
                        markCoutainer.appendChild(nodemark);
                        nodemark.listen(function () {
                           uiintro.noresume = true;
                           let rect = this.link.getBoundingClientRect();
                           ui.click.intro.call(this.link, {
                              clientX: rect.left + rect.width,
                              clientY: rect.top + rect.height / 2,
                           });
                           if (lib.config.touchscreen) {
                              uiintro._close();
                           }
                        });
                     }
                     if (markCoutainer.childElementCount) {
                        uiintro.addText('标记');
                        uiintro.add(markCoutainer);
                     }
                  }
               }
               if (!game.observe && _status.gameStarted && game.me && node != game.me) {
                  ui.throwEmotion = [];
                  uiintro.addText('发送交互表情');
                  var click = function () {
                     if (_status.dragged) return;
                     if (_status.justdragged) return;
                     if (_status.throwEmotionWait) return;
                     var emotion = this.link;
                     if (game.online) {
                        game.send('throwEmotion', node, emotion);
                     }
                     else game.me.throwEmotion(node, emotion);
                     uiintro._close();
                     _status.throwEmotionWait = true;
                     setTimeout(function () {
                        _status.throwEmotionWait = false;
                        if (ui.throwEmotion) {
                           for (var i of ui.throwEmotion) i.classList.remove('exclude');
                        }
                     }, (emotion == 'flower' || emotion == 'egg') ? 5000 : 10000)
                  };
                  var td;
                  var table = document.createElement('div');
                  table.classList.add('add-setting');
                  table.style.margin = '0';
                  table.style.width = '100%';
                  table.style.position = 'relative';
                  var listi = ['flower', 'egg', 'wine', 'shoe'];
                  for (var i = 0; i < listi.length; i++) {
                     td = ui.create.div('.menubutton.reduce_radius.pointerdiv.tdnode');
                     ui.throwEmotion.add(td);
                     if (_status.throwEmotionWait) td.classList.add('exclude');
                     td.link = listi[i];
                     table.appendChild(td);
                     td.innerHTML = '<span>' + get.translation(listi[i]) + '</span>';
                     td.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', click);
                  }
                  uiintro.content.appendChild(table);
                  table = document.createElement('div');
                  table.classList.add('add-setting');
                  table.style.margin = '0';
                  table.style.width = '100%';
                  table.style.position = 'relative';
                  var listi = ['yuxisx', 'shoukao', 'sc', 'ship'];
                  for (var i = 0; i < listi.length; i++) {
                     td = ui.create.div('.menubutton.reduce_radius.pointerdiv.tdnode');
                     ui.throwEmotion.add(td);
                     if (_status.throwEmotionWait) td.classList.add('exclude');
                     td.link = listi[i];
                     table.appendChild(td);
                     td.innerHTML = '<span>' + get.translation(listi[i]) + '</span>';
                     td.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', click);
                  }
                  uiintro.content.appendChild(table);
               }
               var modepack = lib.characterPack['mode_' + get.mode()];
               if (lib.config.show_favourite && lib.character[node.name] && game.players.contains(node) &&
                  (!modepack || !modepack[node.name]) && (!simple || get.is.phoneLayout())) {
                  var addFavourite = ui.create.div('.text.center.pointerdiv');
                  addFavourite.link = node.link;
                  if (lib.config.favouriteCharacter.contains(node.name)) {
                     addFavourite.innerHTML = '移除收藏';
                  }
                  else {
                     addFavourite.innerHTML = '添加收藏';
                  }
                  addFavourite.listen(ui.click.favouriteCharacter)
                  uiintro.add(addFavourite);
               }
               if (!simple || get.is.phoneLayout()) {
                  if ((lib.config.change_skin || lib.skin) && !node.isUnseen()) {
                     var num = 1;
                     var introadded = false;
                     var createButtons = function (num, avatar2) {
                        if (!introadded) {
                           introadded = true;
                           uiintro.add('<div class="text center">更改皮肤</div>');
                        }
                        var buttons = ui.create.div('.buttons.smallzoom.scrollbuttons');
                        lib.setMousewheel(buttons);
                        var nameskin = (avatar2 ? node.name2 : node.name1);
                        var nameskin2 = nameskin;
                        var gzbool = false;
                        if (nameskin.indexOf('gz_shibing') == 0) {
                           nameskin = nameskin.slice(3, 11);
                        }
                        else if (nameskin.indexOf('gz_') == 0) {
                           nameskin = nameskin.slice(3);
                           gzbool = true;
                        }
                        for (var i = 0; i <= num; i++) {
                           var button = ui.create.div('.button.character.pointerdiv', buttons, function () {
                              if (this._link) {
                                 if (avatar2) {
                                    lib.config.skin[nameskin] = this._link;
                                    node.node.avatar2.style.backgroundImage = this.style.backgroundImage;
                                 }
                                 else {
                                    lib.config.skin[nameskin] = this._link;
                                    node.node.avatar.style.backgroundImage = this.style.backgroundImage;
                                 }
                              }
                              else {
                                 delete lib.config.skin[nameskin];
                                 if (avatar2) {
                                    if (gzbool && lib.character[nameskin2][4].contains('gzskin') && lib.config.mode_config.guozhan.guozhanSkin) node.node.avatar2.setBackground(nameskin2, 'character');
                                    else node.node.avatar2.setBackground(nameskin, 'character');
                                 }
                                 else {
                                    if (gzbool && lib.character[nameskin2][4].contains('gzskin') && lib.config.mode_config.guozhan.guozhanSkin) node.node.avatar.setBackground(nameskin2, 'character');
                                    else node.node.avatar.setBackground(nameskin, 'character');
                                 }
                              }
                              game.saveConfig('skin', lib.config.skin);
                           });
                           button._link = i;
                           if (i) {
                              button.setBackgroundImage('image/skin/' + nameskin + '/' + i + '.jpg');
                           }
                           else {
                              if (gzbool && lib.character[nameskin2][4].contains('gzskin') && lib.config.mode_config.guozhan.guozhanSkin) button.setBackground(nameskin2, 'character', 'noskin');
                              else button.setBackground(nameskin, 'character', 'noskin');
                           }
                        }
                        uiintro.add(buttons);
                     };
                     var loadImage = function (avatar2) {
                        var img = new Image();
                        img.onload = function () {
                           num++;
                           loadImage(avatar2);
                        }
                        img.onerror = function () {
                           num--;
                           if (num) {
                              createButtons(num, avatar2);
                           }
                           if (!avatar2) {
                              if (!node.classList.contains('unseen2') && node.name2) {
                                 num = 1;
                                 loadImage(true);
                              }
                           }
                        }
                        var nameskin = (avatar2 ? node.name2 : node.name1);
                        var nameskin2 = nameskin;
                        var gzbool = false;
                        if (nameskin.indexOf('gz_shibing') == 0) {
                           nameskin = nameskin.slice(3, 11);
                        }
                        else if (nameskin.indexOf('gz_') == 0) {
                           nameskin = nameskin.slice(3);
                           gzbool = true;
                        }
                        img.src = lib.assetURL + 'image/skin/' + nameskin + '/' + num + '.jpg';
                     }
                     if (lib.config.change_skin) {
                        if (!node.isUnseen(0)) {
                           loadImage();
                        }
                        else if (node.name2) {
                           loadImage(true);
                        }
                     }
                     else {
                        setTimeout(function () {
                           var nameskin1 = node.name1;
                           var nameskin2 = node.name2;
                           if (nameskin1 && nameskin1.indexOf('gz_') == 0) {
                              nameskin1 = nameskin1.slice(3);
                           }
                           if (nameskin2 && nameskin2.indexOf('gz_') == 0) {
                              nameskin2 = nameskin2.slice(3);
                           }
                           if (!node.isUnseen(0) && lib.skin[nameskin1]) {
                              createButtons(lib.skin[nameskin1]);
                           }
                           if (!node.isUnseen(1) && lib.skin[nameskin2]) {
                              createButtons(lib.skin[nameskin2], true);
                           }
                        });
                     }
                  }
               }

               uiintro.add(ui.create.div('.placeholder.slim'));
            }
            else if (node.classList.contains('mark') && node.info &&
               node.parentNode && node.parentNode.parentNode && node.parentNode.parentNode.classList.contains('player')) {
               var info = node.info;
               var player = node.parentNode.parentNode;
               if (info.name) {
                  if (typeof info.name == 'function') {
                     var named = info.name(player.storage[node.skill], player);
                     if (named) {
                        uiintro.add(named);
                     }
                  }
                  else {
                     uiintro.add(info.name);
                  }
               }
               else if (info.name !== false) {
                  uiintro.add(get.translation(node.skill));
               }
               if (typeof info.id == 'string' && info.id.indexOf('subplayer') == 0 &&
                  player.isUnderControl(true) && player.storage[info.id] && !_status.video) {
                  var storage = player.storage[info.id];
                  uiintro.addText('当前体力：' + storage.hp + '/' + storage.maxHp);
                  if (storage.hs.length) {
                     uiintro.addText('手牌区');
                     uiintro.addSmall(storage.hs);
                  }
                  if (storage.es.length) {
                     uiintro.addText('装备区');
                     uiintro.addSmall(storage.es);
                  }
               }
               if (typeof info.mark == 'function') {
                  var stint = info.mark(uiintro, player.storage[node.skill], player);
                  if (stint) {
                     var placetext = uiintro.add('<div class="text" style="display:inline">' + stint + '</div>');
                     if (stint.indexOf('<div class="equip"') != 0) {
                        uiintro._place_text = placetext;
                     }
                     // if(stint.length<=100){
                     //     uiintro.add('<div class="text center">'+stint+'</div>');
                     // }
                     // else{
                     //     uiintro.add('<div class="text">'+stint+'</div>');
                     // }
                  }
               }
               else {
                  var stint = get.storageintro(info.content, player.storage[node.skill], player, uiintro, node.skill);
                  if (stint) {
                     if (stint[0] == '@') {
                        uiintro.add('<div class="caption">' + stint.slice(1) + '</div>');
                     }
                     else {
                        var placetext = uiintro.add('<div class="text" style="display:inline">' + stint + '</div>');
                        if (stint.indexOf('<div class="equip"') != 0) {
                           uiintro._place_text = placetext;
                        }
                     }
                     // else if(stint.length<=100){
                     //     uiintro.add('<div class="text center">'+stint+'</div>');
                     // }
                     // else{
                     //     uiintro.add('<div class="text">'+stint+'</div>');
                     // }
                  }
               }
               uiintro.add(ui.create.div('.placeholder.slim'));
            }
            else if (node.classList.contains('card')) {
               //卡牌长按介绍
               if (ui.arena.classList.contains('observe') && node.parentNode.classList.contains('handcards')) {
                  return;
               }
               var name = node.name;
               if (node.parentNode.cardMod) {
                  var moded = false;
                  for (var i in node.parentNode.cardMod) {
                     var item = node.parentNode.cardMod[i](node);
                     if (Array.isArray(item)) {
                        moded = true;
                        uiintro.add(item[0]);
                        uiintro._place_text = uiintro.add('<div class="text" style="display:inline">' + item[1] + '</div>');
                     }
                  }
                  if (moded) return uiintro;
               }
               if (node.link && node.link.name && lib.card[node.link.name]) {
                  name = node.link.name;
               }
               if ((get.position(node) == 'j' || get.position(node) == 'e') && node.viewAs && (node.viewAs != name || node.originalName != name)) {
                  uiintro.add(get.translation(node.viewAs));
                  console.log(node.originalName)
                  uiintro.add('<div class="text center">（' + get.translation(get.translation(node.originalName || node)) + '）</div>');
                  // uiintro.add(get.translation(node.viewAs)+'<br><div class="text center" style="padding-top:5px;">（'+get.translation(node)+'）</div>');
                  uiintro.nosub = true;
                  name = node.viewAs;
               }
               else {
                  uiintro.add(get.translation(node));
               }
               if (node._banning) {
                  var clickBanned = function () {
                     var banned = lib.config[this.bannedname] || [];
                     if (banned.contains(name)) {
                        banned.remove(name);
                     }
                     else {
                        banned.push(name);
                     }
                     game.saveConfig(this.bannedname, banned);
                     this.classList.toggle('on');
                     if (node.updateBanned) {
                        node.updateBanned();
                     }
                  };
                  var modeorder = lib.config.modeorder || [];
                  for (var i in lib.mode) {
                     modeorder.add(i);
                  }
                  var list = [];
                  uiintro.contentContainer.listen(function (e) {
                     ui.click.touchpop();
                     e.stopPropagation();
                  });
                  for (var i = 0; i < modeorder.length; i++) {
                     if (node._banning == 'online') {
                        if (!lib.mode[modeorder[i]].connect) continue;
                     }
                     else if (modeorder[i] == 'connect' || modeorder[i] == 'brawl') {
                        continue;
                     }
                     if (lib.config.all.mode.contains(modeorder[i])) {
                        list.push(modeorder[i]);
                     }
                  }
                  var page = ui.create.div('.menu-buttons.configpopped', uiintro.content);
                  var banall = false;
                  for (var i = 0; i < list.length; i++) {
                     var cfg = ui.create.div('.config', lib.translate[list[i]] + '模式', page);
                     cfg.classList.add('toggle');
                     if (node._banning == 'offline') {
                        cfg.bannedname = list[i] + '_bannedcards';
                     }
                     else {
                        cfg.bannedname = 'connect_' + list[i] + '_bannedcards';
                     }
                     cfg.listen(clickBanned);
                     ui.create.div(ui.create.div(cfg));
                     var banned = lib.config[cfg.bannedname] || [];
                     if (!banned.contains(name)) {
                        cfg.classList.add('on');
                        banall = true;
                     }
                  }
                  ui.create.div('.menubutton.pointerdiv', banall ? '全部禁用' : '全部启用', uiintro.content, function () {
                     if (this.innerHTML == '全部禁用') {
                        for (var i = 0; i < page.childElementCount; i++) {
                           if (page.childNodes[i].bannedname && page.childNodes[i].classList.contains('on')) {
                              clickBanned.call(page.childNodes[i]);
                           }
                        }
                        this.innerHTML = '全部启用';
                     }
                     else {
                        for (var i = 0; i < page.childElementCount; i++) {
                           if (page.childNodes[i].bannedname && !page.childNodes[i].classList.contains('on')) {
                              clickBanned.call(page.childNodes[i]);
                           }
                        }
                        this.innerHTML = '全部禁用';
                     }
                  }).style.marginTop = '-10px';
                  ui.create.div('.placeholder.slim', uiintro.content);
               }
               else {
                  if (lib.translate[name + '_info']) {
                     if (!uiintro.nosub) {
                        if (get.subtype(node) == 'equip1') {
                           var added = false;
                           if (lib.card[node.name] && lib.card[node.name].distance) {
                              var dist = lib.card[node.name].distance;
                              if (dist.attackFrom) {
                                 added = true;
                                 uiintro.add('<div class="text center">攻击范围：' + (-dist.attackFrom + 1) + '</div>');
                              }
                           }
                           if (!added) {
                              uiintro.add('<div class="text center">攻击范围：1</div>');
                           }
                        }
                        else if (get.subtype(node)) {
                           uiintro.add('<div class="text center">' + get.translation(get.subtype(node)) + '</div>');
                        }
                        else if (lib.card[name] && lib.card[name].addinfomenu) {
                           uiintro.add('<div class="text center">' + lib.card[name].addinfomenu + '</div>');
                        }
                        else if (lib.card[name] && lib.card[name].derivation) {
                           if (typeof lib.card[name].derivation == 'string') {
                              uiintro.add('<div class="text center">来源：' + get.translation(lib.card[name].derivation) + '</div>');
                           }
                           else if (lib.card[name].derivationpack) {
                              uiintro.add('<div class="text center">来源：' + get.translation(lib.card[name].derivationpack + '_card_config') + '</div>');
                           }
                        }
                        else {
                           if (lib.card[name].unique) {
                              uiintro.add('<div class="text center">特殊' + get.translation(lib.card[name].type) + '牌</div>');
                           }
                           else {
                              if (lib.card[name].type && lib.translate[lib.card[name].type] && lib.translate[lib.card[name].type] != ' ') uiintro.add('<div class="text center">' + get.translation(lib.card[name].type) + '牌</div>');
                           }
                        }
                        if (lib.card[name].unique && lib.card[name].type == 'equip') {
                           if (lib.cardPile.guozhan && lib.cardPack.guozhan.contains(name)) {
                              uiintro.add('<div class="text center">专属装备</div>').style.marginTop = '-5px';
                           }
                           else {
                              uiintro.add('<div class="text center">特殊装备</div>').style.marginTop = '-5px';
                           }
                        }
                     }
                     if (lib.translate[name + '_info']) {
                        var placetext = uiintro.add('<div class="text" style="display:inline">' + lib.translate[name + '_info'] + '</div>');
                        if (lib.translate[name + '_info'].indexOf('<div class="equip"') != 0) {
                           uiintro._place_text = placetext;
                        }
                     }
                     if (lib.card[name].materials) {
                        if (lib.card[name].materials_prompt) uiintro.add('<div class="text" style="font-family: yuanli">★升阶：' + lib.card[name].materials_prompt + '</div>');
                        else if (typeof lib.card[name].materials == 'function') uiintro.add('<div class="text" style="font-family: yuanli">★升阶：' + lib.card[name].materials_prompt(node.link || node) + '</div>');
                        else if (Array.isArray(lib.card[name].materials)) uiintro.add('<div class="text" style="font-family: yuanli">★升阶：' + get.translation(lib.card[name].materials) + '</div>');
                        else uiintro.add('<div class="text" style="font-family: yuanli">★升阶卡牌</div>');
                     }
                     if (lib.card[name].yingbian_prompt && get.is.yingbian(node.link || node)) {
                        if (typeof lib.card[name].yingbian_prompt == 'function') uiintro.add('<div class="text" style="font-family: yuanli">应变：' + lib.card[name].yingbian_prompt(node.link || node) + '</div>');
                        else uiintro.add('<div class="text" style="font-family: yuanli">应变：' + lib.card[name].yingbian_prompt + '</div>');
                     }
                     if (node.nature == 'ocean') {
                        uiintro.add('<div class="text" style="font-family: yuanli;zoom: 0.8">' + '<span class="bluetext">海洋</span>' + '：海洋属性的牌被使用时，若此牌没有「伤害」标签且目标没有护甲，则令目标获得1点护甲；有护甲的角色受到海洋伤害时，此伤害+1且不产生传递' + '</div>');
                     }
                     if (node.nature == 'yami') {
                        uiintro.add('<div class="text" style="font-family: yuanli;zoom: 0.8">' + '<span class="legendtext">暗影</span>' + '：暗影属性的牌可以在其他角色的结束阶段对其使用；暗影属性的牌被使用时，若目标手牌数多于使用者，则其不能响应此牌且此牌造成的伤害不产生传递' + '</div>');
                     }
                     if (lib.translate[name + '_append']) {
                        uiintro.add('<div class="text" style="display:inline">' + lib.translate[name + '_append'] + '</div>');
                     }
                  }
                  uiintro.add(ui.create.div('.placeholder.slim'));
               }
            }
            else if (node.classList.contains('character')) {
               var character = node.link;
               if (lib.character[node.link] && lib.character[node.link][1]) {
                  var group = get.is.double(node.link, true);
                  if (group) {
                     var str = get.translation(character) + '&nbsp;&nbsp;';
                     for (var i = 0; i < group.length; i++) {
                        str += get.translation(group[i]);
                        if (i < group.length - 1) str += '/';
                     }
                     uiintro.add(str);
                  }
                  else uiintro.add(get.translation(character) + '&nbsp;&nbsp;' + lib.translate[lib.character[node.link][1]] || lib.character[node.link][1]);
               }
               else {
                  uiintro.add(get.translation(character));
               }

               if (lib.characterTitle[node.link]) {
                  uiintro.addText(get.colorspan(lib.characterTitle[node.link]));
               }

               if (node._banning) {
                  var clickBanned = function () {
                     var banned = lib.config[this.bannedname] || [];
                     if (banned.contains(character)) {
                        banned.remove(character);
                     }
                     else {
                        banned.push(character);
                     }
                     game.saveConfig(this.bannedname, banned);
                     this.classList.toggle('on');
                     if (node.updateBanned) {
                        node.updateBanned();
                     }
                  };
                  var modeorder = lib.config.modeorder || [];
                  for (var i in lib.mode) {
                     modeorder.add(i);
                  }
                  var list = [];
                  uiintro.contentContainer.listen(function (e) {
                     ui.click.touchpop();
                     e.stopPropagation();
                  });
                  for (var i = 0; i < modeorder.length; i++) {
                     if (node._banning == 'online') {
                        if (!lib.mode[modeorder[i]].connect) continue;
                        if (!lib.config['connect_' + modeorder[i] + '_banned']) {
                           lib.config['connect_' + modeorder[i] + '_banned'] = [];
                        }
                     }
                     else if (modeorder[i] == 'connect' || modeorder[i] == 'brawl') {
                        continue;
                     }
                     if (lib.config.all.mode.contains(modeorder[i])) {
                        list.push(modeorder[i]);
                     }
                  }
                  var page = ui.create.div('.menu-buttons.configpopped', uiintro.content);
                  var banall = false;
                  for (var i = 0; i < list.length; i++) {
                     var cfg = ui.create.div('.config', lib.translate[list[i]] + '模式', page);
                     cfg.classList.add('toggle');
                     if (node._banning == 'offline') {
                        cfg.bannedname = list[i] + '_banned';
                     }
                     else {
                        cfg.bannedname = 'connect_' + list[i] + '_banned';
                     }
                     cfg.listen(clickBanned);
                     ui.create.div(ui.create.div(cfg));
                     var banned = lib.config[cfg.bannedname] || [];
                     if (!banned.contains(character)) {
                        cfg.classList.add('on');
                        banall = true;
                     }
                  }
                  if (node._banning == 'offline') {
                     var cfg = ui.create.div('.config', '随机选将可用', page);
                     cfg.classList.add('toggle');
                     cfg.listen(function () {
                        this.classList.toggle('on');
                        if (this.classList.contains('on')) {
                           lib.config.forbidai_user.remove(character);
                        }
                        else {
                           lib.config.forbidai_user.add(character);
                        }
                        game.saveConfig('forbidai_user', lib.config.forbidai_user);
                     });
                     ui.create.div(ui.create.div(cfg));
                     if (!lib.config.forbidai_user.contains(character)) {
                        cfg.classList.add('on');
                     }
                  }
                  ui.create.div('.menubutton.pointerdiv', banall ? '全部禁用' : '全部启用', uiintro.content, function () {
                     if (this.innerHTML == '全部禁用') {
                        for (var i = 0; i < page.childElementCount; i++) {
                           if (page.childNodes[i].bannedname && page.childNodes[i].classList.contains('on')) {
                              clickBanned.call(page.childNodes[i]);
                           }
                        }
                        this.innerHTML = '全部启用';
                     }
                     else {
                        for (var i = 0; i < page.childElementCount; i++) {
                           if (page.childNodes[i].bannedname && !page.childNodes[i].classList.contains('on')) {
                              clickBanned.call(page.childNodes[i]);
                           }
                        }
                        this.innerHTML = '全部禁用';
                     }
                  }).style.marginTop = '-10px';
                  ui.create.div('.placeholder.slim', uiintro.content);
               }
               else {
                  var infoitem = lib.character[character];
                  if (!infoitem) {
                     for (var itemx in lib.characterPack) {
                        if (lib.characterPack[itemx][character]) {
                           infoitem = lib.characterPack[itemx][character]; break;
                        }
                     }
                  }
                  var skills = infoitem[3];
                  for (i = 0; i < skills.length; i++) {
                     if (lib.translate[skills[i] + '_info']) {
                        translation = lib.translate[skills[i] + '_ab'] || get.translation(skills[i]).slice(0, 5);
                        let info = get.interoperableText(skills[i])
                        if (lib.skill[skills[i]] && lib.skill[skills[i]].nobracket) {
                           uiintro.add('<div><div class="skilln">' + get.translation(skills[i]) + '</div><div' + ((get.translation(skills[i]).length > 3) ? ' class="skilltext"' : '') + '>' + info + '</div></div>');
                        }
                        else {
                           uiintro.add('<div><div class="skill">' + translation + '</div><div' + ((translation.length > 3) ? ' class="skilltext"' : '') + '>' + info + '</div></div>');
                        }
                        if (lib.translate[skills[i] + '_append']) {
                           uiintro._place_text = uiintro.add('<div class="text">' + lib.translate[skills[i] + '_append'] + '</div>')
                        }
                        for (let v of uiintro.getElementsByTagName('span')) {
                           v.link = v.dataset.introlink
                           if (v.classList.contains('iText')) lib.setIntro(v)
                        }
                     }
                  }
                  var modepack = lib.characterPack['mode_' + get.mode()];
                  if (lib.config.show_favourite &&
                     lib.character[node.link] && (!modepack || !modepack[node.link]) && (!simple || get.is.phoneLayout())) {
                     var addFavourite = ui.create.div('.text.center.pointerdiv');
                     addFavourite.link = node.link;
                     addFavourite.style.marginBottom = '15px';
                     if (lib.config.favouriteCharacter.contains(node.link)) {
                        addFavourite.innerHTML = '移除收藏';
                     }
                     else {
                        addFavourite.innerHTML = '添加收藏';
                     }
                     addFavourite.listen(ui.click.favouriteCharacter)
                     uiintro.add(addFavourite);
                  }
                  else {
                     uiintro.add(ui.create.div('.placeholder.slim'));
                  }
                  var addskin = false;
                  if (node.parentNode.classList.contains('menu-buttons')) {
                     addskin = !lib.config.show_charactercard;
                  }
                  else {
                     addskin = lib.config.change_skin || lib.skin;
                  }
                  if (addskin && (!simple || get.is.phoneLayout())) {
                     var num = 1;
                     var introadded = false;
                     var nameskin = node.link;
                     var nameskin2 = nameskin;
                     var gzbool = false;
                     if (nameskin.indexOf('gz_shibing') == 0) {
                        nameskin = nameskin.slice(3, 11);
                     }
                     else if (nameskin.indexOf('gz_') == 0) {
                        nameskin = nameskin.slice(3);
                        gzbool = true;
                     }
                     var createButtons = function (num) {
                        if (!num) return;
                        if (!introadded) {
                           introadded = true;
                           uiintro.add('<div class="text center">更改皮肤</div>');
                        }
                        var buttons = ui.create.div('.buttons.smallzoom.scrollbuttons');
                        lib.setMousewheel(buttons);
                        for (var i = 0; i <= num; i++) {
                           var button = ui.create.div('.button.character.pointerdiv', buttons, function () {
                              if (this._link) {
                                 lib.config.skin[nameskin] = this._link;
                                 node.style.backgroundImage = this.style.backgroundImage;
                                 game.saveConfig('skin', lib.config.skin);
                              }
                              else {
                                 delete lib.config.skin[nameskin];
                                 if (gzbool && lib.character[nameskin2][4].contains('gzskin') && lib.config.mode_config.guozhan.guozhanSkin) node.setBackground(nameskin2, 'character');
                                 else node.setBackground(nameskin, 'character');
                                 game.saveConfig('skin', lib.config.skin);
                              }
                           });
                           button._link = i;
                           if (i) {
                              button.setBackgroundImage('image/skin/' + nameskin + '/' + i + '.jpg');
                           }
                           else {
                              if (gzbool && lib.character[nameskin2][4].contains('gzskin') && lib.config.mode_config.guozhan.guozhanSkin) button.setBackground(nameskin2, 'character', 'noskin');
                              else button.setBackground(nameskin, 'character', 'noskin');
                           }
                        }
                        uiintro.add(buttons);
                     };
                     var loadImage = function () {
                        var img = new Image();
                        img.onload = function () {
                           num++;
                           loadImage();
                        }
                        img.onerror = function () {
                           num--;
                           createButtons(num);
                        }
                        img.src = lib.assetURL + 'image/skin/' + nameskin + '/' + num + '.jpg';
                     }
                     if (lib.config.change_skin) {
                        loadImage();
                     }
                     else {
                        setTimeout(function () {
                           createButtons(lib.skin[nameskin]);
                        });
                     }
                  }
               }
            }
            else if (node.classList.contains('iText')) {
               if (node.curUiintro) node.curUiintro.close();
               let name = node.link;
               if (lib.translate[name + '_info']) {
                  node.curUiintro = uiintro
                  translation = lib.translate[name + '_ab'] || get.translation(name).slice(0, 5);
                  if (lib.skill[name] && lib.skill[name].nobracket) {
                     uiintro.add('<div><div class="skilln">' + get.translation(name) + '</div><div' + ((get.translation(name).length > 3) ? ' class="skilltext"' : '') + '>' + get.skillInfoTranslation(name) + '</div></div>');
                  }
                  else {
                     uiintro.add('<div><div class="skill">' + translation + '</div><div' + ((translation.length > 3) ? ' class="skilltext"' : '') + '>' + get.skillInfoTranslation(name) + '</div></div>');
                  }
                  if (lib.translate[name + '_append']) {
                     uiintro._place_text = uiintro.add('<div class="text">' + lib.translate[name + '_append'] + '</div>')
                  }
               }
            }
            else if (node.classList.contains('equips') && ui.arena.classList.contains('selecting')) {
               (function () {
                  uiintro.add('选择装备');
                  uiintro.addSmall(Array.from(node.childNodes), true);
                  uiintro.clickintro = true;
                  ui.control.hide();
                  uiintro._onclose = function () {
                     ui.control.show();
                  }
                  var confirmbutton;
                  for (var i = 0; i < uiintro.buttons.length; i++) {
                     var button = uiintro.buttons[i];
                     button.classList.add('pointerdiv');
                     if (button.link.classList.contains('selected')) {
                        button.classList.add('selected');
                     }
                     button.listen(function (e) {
                        ui.click.card.call(this.link, 'popequip');
                        ui.click.window.call(ui.window, e);
                        if (this.link.classList.contains('selected')) {
                           this.classList.add('selected');
                        }
                        else {
                           this.classList.remove('selected');
                        }
                        if (ui.confirm && ui.confirm.str && ui.confirm.str.indexOf('o') != -1) {
                           confirmbutton.classList.remove('disabled');
                        }
                        else {
                           confirmbutton.classList.add('disabled');
                        }
                     });
                  }
                  var buttoncontainer = uiintro.add(ui.create.div());
                  buttoncontainer.style.display = 'block';
                  confirmbutton = ui.create.div('.menubutton.large.pointerdiv', '确定', function () {
                     if (ui.confirm && ui.confirm.str && ui.confirm.str.indexOf('o') != -1) {
                        uiintro._clickintro();
                        ui.click.ok(ui.confirm.firstChild);
                     }
                  }, buttoncontainer);
                  confirmbutton.style.position = 'relative';
                  setTimeout(function () {
                     if (ui.confirm && ui.confirm.str && ui.confirm.str.indexOf('o') != -1) {
                        confirmbutton.classList.remove('disabled');
                     }
                     else {
                        confirmbutton.classList.add('disabled');
                     }
                  }, 300);
               }());
            }
            else if (node.classList.contains('identity') && node.dataset.career) {
               var career = node.dataset.career;
               uiintro.add(get.translation(career));
               uiintro.add('<div class="text center" style="padding-bottom:5px">' + lib.translate['_' + career + '_skill_info'] + '</div>');
            }
            else if (node.classList.contains('skillbar')) {
               if (node == ui.friendBar) {
                  uiintro.add('友方怒气值');
                  uiintro.add('<div class="text center" style="padding-bottom:5px">' + _status.friendRage + '/100</div>');
               }
               else if (node == ui.enemyBar) {
                  uiintro.add('敌方怒气值');
                  uiintro.add('<div class="text center" style="padding-bottom:5px">' + _status.enemyRage + '/100</div>');
               }
            }
            else if (node.parentNode == ui.historybar) {
               if (node.dead) {
                  if (!node.source || node.source == node.player) {
                     uiintro.add('<div class="text center">' + get.translation(node.player) + '阵亡</div>');
                     uiintro.addSmall([node.player]);
                  }
                  else {
                     uiintro.add('<div class="text center">' + get.translation(node.player) + '被' + get.translation(node.source) + '杀害</div>');
                     uiintro.addSmall([node.source]);
                  }
               }
               if (node.skill) {
                  uiintro.add('<div class="text center">' + get.translation(node.skill, 'skill') + '</div>');
                  uiintro._place_text = uiintro.add('<div class="text" style="display:inline">' + get.translation(node.skill, 'info') + '</div>');
               }
               if (node.targets && get.itemtype(node.targets) == 'players') {
                  uiintro.add('<div class="text center">目标</div>');
                  uiintro.addSmall(node.targets);
               }
               if (node.players && node.players.length > 1) {
                  uiintro.add('<div class="text center">使用者</div>');
                  uiintro.addSmall(node.players);
               }
               if (node.cards && node.cards.length) {
                  uiintro.add('<div class="text center">卡牌</div>');
                  uiintro.addSmall(node.cards);
               }
               for (var i = 0; i < node.added.length; i++) {
                  uiintro.add(node.added[i]);
               }
               if (node.added.length) {
                  uiintro.add(ui.create.div('.placeholder.slim'));
               }
               if (uiintro.content.firstChild) {
                  uiintro.content.firstChild.style.paddingTop = '3px';
               }
            }
            if (lib.config.touchscreen) {
               lib.setScroll(uiintro.contentContainer);
            }
            return uiintro;
         },
         linkintro: function (dialog, content, player) {
            dialog.content.firstChild.remove();
            dialog.add('<div class="text center">已横置</div>');
            var list = [];
            for (var i = 0; i < game.players.length; i++) {
               if (game.players[i].isLinked() && game.players[i].name && game.players[i].name.indexOf('unknown') != 0) {
                  list.push(game.players[i]);
               }
            }
            if (list.length) {
               dialog.add(list, true, true);
            }
         },
         groups: function () {
            return [...lib.group].remove('shen');
         },
         types: function () {
            var types = [];
            for (var i in lib.card) {
               if (lib.card[i].mode && lib.card[i].mode.contains(lib.config.mode) == false) continue;
               if (lib.card[i].forbid && lib.card[i].forbid.contains(lib.config.mode)) continue;
               if (lib.card[i].type) {
                  if (lib.card[i].type == 'delay') types.add('trick');
                  else types.add(lib.card[i].type);
               }
            }
            return types;
         },
         links: function (buttons) {
            var links = [];
            for (var i = 0; i < buttons.length; i++) {
               if (buttons[i].link != undefined) links.push(buttons[i].link);
            }
            return links;
         },
         /**
          * 返回目标对一个角色$P$的嘲讽值$threaten$，即这个角色对目标的仇恨度，该值越高越容易被攻击，这个值与目标角色$T$有嘲讽值`info.ai.threaten`的技能$S_n$，以及目标角色的血量$h$和手牌数量$c$有关，计算公式如下:
          * <p>
          * \begin{align*}
          * {threaten} & = \alpha{F(h,c)}\\
          * \alpha & = \left\{\begin{aligned}&1,\,n = 0\\
          * &\prod_{i=1}^{n-1}{f(S_i)},\,n \geq 1\\
          * \end{aligned}\right.\\
          * {f(x)} & = \left\{\begin{aligned}{S_i.ai.threaten},\,\textrm{threaten是number类型}\\
          * S_i.ai.threaten(P, T),\,\textrm{threaten为function类型}
          * \end{aligned}\right.\\
          * {F(x, y)} & = \left\{\begin{aligned}&1,\,\textrm{不计算血量和手牌的影响}\\
          * &g(x)g(y),\,\textrm{计算血量和手牌的影响}\\
          * \end{aligned}\right.\\
          * {g(x)} & = \left\{\begin{aligned}&1.5,\,x = 0\\
          * &1.2,\,x = 1\\
          * &1,\,x \not = 0 \land x \not = 1
          * \end{aligned}\right.
          * \end{align*}
          * </p>
          * @param {?GameCores.GameObjects.Player} [player] 角色，如果未指定，使用当前事件角色；如果为false，角色为空，忽略此参数
          * @param {GameCores.GameObjects.Player} [target] 目标，如果未指定，使用`player`
          * @param {?boolean} [hp] 目标角色的血量和手牌数量是否影响嘲讽值，如果为true，会返回计算影响后的嘲讽值；如果为false或未指定，不影响结果
          * @returns {number}
          */
         threaten: function (target, player, hp) {
            var threaten = 1;
            var skills = target.getSkills();
            if (!player && player !== false) {
               player = _status.event.player;
            }
            for (var i = 0; i < skills.length; i++) {
               var info = get.info(skills[i]);
               if (info && info.ai && info.ai.threaten) {
                  if (typeof info.ai.threaten == 'function' && player) {
                     var tmp = info.ai.threaten(player, target);
                     if (typeof tmp == 'number') {
                        threaten *= tmp;
                     }
                  }
                  else if (typeof info.ai.threaten == 'number') {
                     threaten *= info.ai.threaten;
                  }
               }
            }
            if (hp) {
               switch (target.hp) {
                  case 0: threaten *= 1.5; break;
                  case 1: threaten *= 1.2; break;
               }
               switch (target.countCards('h')) {
                  case 0: threaten *= 1.5; break;
                  case 1: threaten *= 1.2; break;
               }
            }
            return threaten;
         },
         /**
          * 返回一个角色状态值$condition$，这个值受角色血量$h$、手牌数量$H$、装备收益$E_n$影响，计算公式如下:
          * <p>
          * \begin{align*}
          * {condition} & = \left\{\begin{aligned}
          * & {h}+\frac{H}{2},\,n=0 \\
          * & {h}+\frac{H}{2}+\sum_{i=0}^{n-1}{M(E_i)},\,n\geq1
          * \end{aligned}\right.\\
          * {M(x)} & = \left\{\begin{aligned}
          * & 0.8,\,x\geq7\\
          * & 0.5,\,x\geq5\\
          * & 0.2,\,x\geq3\\
          * & 0,\,x<3
          * \end{aligned}\right.\\
          * E_n & = {get.equipValueNumber(equips[n])}\\
          * {equips} & = {player.getCards('e')}
          * \end{align*}
          * </p>
          * @param {GameCores.GameObjects.Player} player 要计算的角色
          * @returns {number}
          * @see {@link get.equipValueNumber}
          */
         condition: function (player) {
            var num = player.hp;
            if (num > 4) {
               num = 4 + Math.sqrt(num - 4);
            }
            else {
               if (player.isHealthy()) {
                  if (player.hp == 3) {
                     num += 0.5;
                  }
                  else if (player.hp < 3) {
                     num++;
                  }
               }
            }
            num += player.countCards('h') / 2;
            var es = player.getCards('e');
            for (var i = 0; i < es.length; i++) {
               var val = get.equipValueNumber(es[i]);
               if (val >= 7) num += 0.8;
               if (val >= 5) num += 0.5;
               if (val >= 3) num += 0.2;
            }
            return num;
         },
         /**
          * 返回一个角色对目标角色的态度值，正值为友方，负值为敌方；
          * 如果这个角色处于混乱状态，则对友方的态度变负、对敌方的态度变正，态度值为原来的相反数；
          * 此后，
          * 如果目标角色处于混乱状态，当态度值为正值时，返回0；当态度值为正值，目标角色的身份为主公时返回1
          * @param {!GameCores.GameObjects.Player} from 参考角色，如果未指定，会返回0
          * @param {!GameCores.GameObjects.Player} to 目标角色，如果未指定，会返回0
          * @returns {number}
          */
         attitude: function (from, to) {
            if (!from || !to) return 0;
            from = from._trueMe || from;
            arguments[0] = from;
            var att = get.rawAttitude.apply(this, arguments);
            if (from.isMad()) att = -att;
            if (to.isMad() && att > 0) {
               if (to.identity == 'zhu') {
                  att = 1;
               }
               else {
                  att = 0;
               }
            }
            if (!_status.tempnofake) {
               _status.tempnofake = true;
               if (from.ai.modAttitudeFrom) {
                  att = from.ai.modAttitudeFrom(from, to, att);
               }
               if (to.ai.modAttitudeTo) {
                  att = to.ai.modAttitudeTo(from, to, att);
               }
               delete _status.tempnofake;
            }
            return att;
         },
         /**
          * 返回态度值的符号
          * @param {...any} args 此函数的参数会作为{@link get.attitude}的参数调用
          * @returns {number} (-1|0|1)
          */
         sgnAttitude: function () {
            return get.sgn(get.attitude.apply(this, arguments));
         },
         /**
          * 返回牌的留牌收益(`info.ai.useful`|`info.ai.basic.useful`)，留牌收益低的牌，在弃牌时会被丢弃，而留牌收益高的则会保留；
          * 如果`card._modUseful`存在，则返回`card._modUseful()`；
          * 如果`useful`是函数，则留牌收益值为`useful(card, cardIndex)`，`cardIndex`为`card`在当前事件角色`player`手牌中同名(`card.name`)牌数组中的索引，如果(当前事件没有角色|没有找到此牌)，`cardIndex`为0
          * @param {!GameCores.GameObjects.Card} card 游戏牌对象
          * @returns {number} 如果是判定区的牌，返回-1；如果 `useful`未定义，此函数返回-1(`useful`默认为-1)
          */
         useful: function (card, player) {
            if (get.position(card) == 'j') return -1;
            if (get.position(card) == 'e') return get.equipValue(card);
            if (card._modUseful) {
               return card._modUseful();
            }
            var i = 0;
            player = player || _status.event.player;
            if (player) {
               i = player.getCards('h', card.name).indexOf(card);
               if (i < 0) i = 0;
            }
            var aii = get.info(card).ai;
            var useful;
            if (aii && aii.useful) useful = aii.useful;
            else if (aii && aii.basic) useful = aii.basic.useful;
            var result;
            if (useful == undefined) result = -1;
            else if (typeof useful == 'function') {
               result = useful(card, i);
            }
            else if (typeof useful == 'number') result = useful;
            else if (i < useful.length) {
               result = useful[i];
            }
            else result = useful[useful.length - 1];
            result = game.checkMod(player, card, result, 'aiUseful', player);
            return result;
         },
         /**
          * 返回牌的留牌收益，但是此函数返回的留牌收益为原留牌收益的相反数
          * @param {!GameCores.GameObjects.Card} card 游戏牌对象
          * @returns {!number}
          */
         unuseful: function (card) {
            return -get.useful(card);
         },
         /**
          * 返回牌的留牌收益，但是此函数返回的留牌收益为`10 - oriUseful`，oriUseful为原留牌收益
          * @param {!GameCores.GameObjects.Card} card 游戏牌对象
          * @returns {!number}
          */
         unuseful2: function (card) {
            return 10 - get.useful(card);
         },
         /**
          * 返回牌的留牌收益，但是此函数返回的留牌收益为`10 - oriUseful`，oriUseful为原留牌收益；
          * 一种特别的情况是，游戏牌的牌名(card.name)为'du'，此时返回20
          * @param {!GameCores.GameObjects.Card} card 游戏牌对象
          * @returns {!number}
          */
         unuseful3: function (card) {
            if (card.name == 'du') return 20;
            return 10 - get.useful(card);
         },
         /**
          * 返回一个角色$P$当前使用一组游戏牌$C_n$的收益值$value$，受`method`$m$影响，计算公式:
          * <p>
          * \begin{align*}
          * {value} & = \frac{\sum_{i=0}^{n-1}F(C_i)}{\sqrt{n}}\\
          * {F(x)} & = {get.value(x, P, m)}
          * \end{align*}
          * </p>
          * @name get.value
          * @function
          * @param {!Array<GameCores.GameObjects.Card>} cards 游戏牌数组。**注意**：一种特别的情况是，此数组为空数组，此时收益值为`0/0`，即`NaN`值
          * @param {?GameCores.GameObjects.Player} [player] 角色，如果未指定，使用当前事件角色
          * @param {?string} [method] 'raw'
          * @returns {number}
          */
         /**
          * 返回一个角色当前使用一张游戏牌的收益值(`info.ai.value`|`info.ai.basic.value`)；
          * 如果`card._modValue`存在，则返回`card._modValue(player, method)`；
          * 除此之外：
          * 如果`value`是函数，则收益值为`value(card, player, cardIndex, method)`，`cardIndex`为`card`在角色`player`手牌中同名(`card.name`)牌数组中的索引，如果`card`不在其中，返回同名牌数组的长度
          * 如果此角色有被动技**aiValue**，则返回改变后的收益值
          * @name get.value
          * @function
          * @variation 2
          * @param {(!GameCores.GameObjects.Card)} card 游戏牌对象
          * @param {?GameCores.GameObjects.Player} [player] 角色，如果未指定，使用当前事件角色
          * @param {?string} [method] 'raw'
          * @returns {number}
          */
         value: function (card, player, method) {
            var result = 0;
            var value;
            if (Array.isArray(card)) {
               value = 0;
               for (var i = 0; i < card.length; i++) {
                  value += get.value(card[i], player, method);
               }
               return value / Math.sqrt(card.length);
            }
            if (card._modValue) {
               return card._modValue(player, method);
            }
            var aii = get.info(card).ai;
            if (aii && aii.value) value = aii.value;
            else if (aii && aii.basic) value = aii.basic.value;
            if (player == undefined || get.itemtype(player) != 'player') player = _status.event.player;
            var geti = function () {
               var num = 0, i;
               var cards = player.getCards('hs', card.name);
               if (cards.contains(card)) {
                  return cards.indexOf(card);
               }
               return cards.length;
            };
            if (typeof value == 'function') {
               result = value(card, player, geti(), method);
            }
            if (typeof value == 'number') result = value;
            if (Array.isArray(value)) {
               if (method == 'raw') result = value[0];//??
               var num = geti();
               if (num < value.length) result = value[num];
               else result = value[value.length - 1];
            }
            result = game.checkMod(player, card, result, 'aiValue', player);
            return result;
         },
         /**
          * 返回装备收益，如果**原装备收益大于0而且不需要弃牌**的时候，就不用装备(除非装备牌有tag`valueswap`)，返回0值；
          * 此函数返回的装备收益$equipValue$正比于新装备的装备收益$v$与原装备$v_{0}$的差值，
          * 其计算公式如下:
          * $${equipValue}=\frac{max(0, {v}-{v_{0}})}{5}$$
          * @param {GameCores.GameObjects.Player} player [never used]牌的使用者
          * @param {GameCores.GameOjbects.Player} target 装备牌的角色
          * @param {!string} name 装备牌牌名，如果当前没有选择的牌或那个牌的牌名与此牌名不同，使用`{name:name}`
          * @returns {number}
          */
         equipResult: function (player, target, name) {
            var card = get.card();
            if (!card || card.name != name) {
               card = { name: name };
            }
            var value1 = get.equipValue(card, target);
            var value2 = 0;
            var current = target.getEquip(card);
            if (current && current != card) {
               value2 = get.equipValue(current, target);
               if (value2 > 0 && !target.needsToDiscard() && !get.tag(card, 'valueswap')) {
                  return 0;
               }
            }
            return Math.max(0, value1 - value2) / 5;
         },
         /**
          * 返回游戏牌的装备收益(`info.ai.equipValue`|`info.ai.basic.equipValue`)；
          * 如果装备收益未定义，返回0值；
          * 如果`equipValue`是函数，则装备收益为`equipValue(card, player, null, 'raw2')`，其中`player`为装备的目标角色，`card`与`player`不会为空值
          * @param {!GameCores.GameObjects.Card} card 游戏牌对象，除了牌名外其他属性或函数可以为空
          * @param {?GameCores.GameObjects.Player} [player] 装备的目标角色，如果未指定，使用游戏牌`card`的所属角色，如果`card`没有所属角色，使用当前事件角色
          * @returns {!number}
          */
         equipValue: function (card, player) {
            if (player == undefined || get.itemtype(player) != 'player') player = get.owner(card);
            if (player == undefined || get.itemtype(player) != 'player') player = _status.event.player;
            var info = get.info(card);
            if (!info.ai) return 0;
            var value = info.ai.equipValue;
            if (value == undefined) {
               if (info.ai.basic && info.ai.basic.equipValue != undefined) {
                  value = info.ai.basic.equipValue;
               }
               else return 0;
            }
            if (typeof value == 'number') return value;
            if (typeof value == 'function') return value(card, player, null, 'raw2');
            return 0;
         },
         /**
          * 返回游戏牌的装备收益(`info.ai.equipValue`|`info.ai.basic.equipValue`)；
          * 如果装备收益未定义或者`equipValue`不是'number'类型，返回0值
          * @param {!GameCores.GameObjects.Card} card 游戏牌对象，除了牌名外其他属性或函数可以为空
          * @returns {number}
          */
         equipValueNumber: function (card) {
            var info = get.info(card);
            if (info.ai) {
               if (typeof info.ai.equipValue == 'number') return info.ai.equipValue;
               if (info.ai.basic && typeof info.ai.basic.equipValue == 'number') return info.ai.basic.equipValue;
            }
            return 0;
         },
         /**
          * 返回一个角色使用一张游戏牌的收益值，但是此函数返回的收益值是计算收益值的相反数
          * @param {GameCores.GameObjects.Card} card 游戏牌对象
          * @param {GameCores.GameObjects.Player} player 角色
          * @returns {number}
          */
         disvalue: function (card, player) {
            return -get.value(card, player);
         },
         /**
          * 返回一个角色使用一张游戏牌的收益值，但是此函数返回的收益值是原收益值的相反数
          * @param {GameCores.GameObjects.Card} card 游戏牌对象
          * @param {GameCores.GameObjects.Player} player 角色
          * @returns {number}
          */
         disvalue2: function (card, player) {
            return -get.value(card, player, 'raw');
         },
         /**
          * 返回目标对一个角色的使用某个技能的嘲讽值(对应技能的`info.ai.threaten`)，即这个角色对目标的仇恨度，该值越高越容易被攻击；
          * 如果`threaten`是函数，则嘲讽值为函数的返回值；
          * 该函数会以`order(player, target)`调用`threaten`
          * @param {!string} skill 技能名
          * @param {?GameCores.GameObjects.Player} [player] 角色，如果未指定，使用当前事件角色
          * @param {GameCores.GameObjects.Player} [target] 目标，如果未指定，使用`player`
          * @returns {number} 如果没有找到技能，返回1；如果 `info.ai.threaten`未定义，此函数返回1(`threaten`默认为1)
          */
         skillthreaten: function (skill, player, target) {
            if (!lib.skill[skill]) return 1;
            if (!lib.skill[skill].ai) return 1;
            var threaten = lib.skill[skill].ai.threaten;
            if (typeof threaten == 'number') return threaten;
            if (typeof threaten == 'function') {
               player = player || _status.event.player;
               target = target || player;
               return threaten(player, target);
            }
            return 1;
         },
         /**
          * 返回(技能使用|游戏牌发动)的优先级(`info.ai.order`|`info.ai.basic.order`)；
          * 如果`order`是函数，则优先级为函数的返回值；
          * 该函数会以`order(item, _status.event.player)`调用`order`，`_status.event.player`为当前事件角色；
          * 如果当前事件角色有被动技**aiOrder**，则返回改变后的优先级
          * @param {(string|GameCores.GameObjects.Card)} item 技能名或游戏牌对象，游戏牌对象除牌名外其他属性或函数可以为空
          * @returns {!number} 如果`{@link get.info() get.info(item)}`返回undefined，此函数返回-1；如果`info.ai.order`或`info.ai.basic.order`未定义，此函数返回-1
          */
         order: function (item) {
            var info = get.info(item);
            if (!info) return -1;
            var aii = info.ai;
            var order;
            if (aii && aii.order) order = aii.order;
            else if (aii && aii.basic) order = aii.basic.order;
            if (order == undefined) return -1;
            var num = order;
            if (typeof (order) == 'function') {
               num = order(item, _status.event.player);
            }
            if (typeof item == 'object' && _status.event.player) {
               var player = _status.event.player;
               num = game.checkMod(player, item, num, 'aiOrder', player);
            }
            return num;
         },
         /**
          * 返回`get.info(item).ai.result`的浅拷贝对象，如果`ai.result`是函数，返回`get.info(item).ai.result(item)`
          * @private
          * @param {GameCores.GameObjects.Card} item 
          * @param {?} skill 
          * @returns {!Object}
          */
         result: function (item, skill) {
            var result;
            var info = get.info(item);
            if (info.ai) result = get.copy(info.ai.result);
            if (typeof (result) == 'function') result = result(item);
            if (!result) result = {};
            if (skill) {
               var info2 = get.info(skill);
               if (info2.ai) {
                  info2 = info2.ai.result;
                  for (var i in info2) {
                     result[i] = info2[i];
                  }
               }
            }
            return result;
         },
         /**
          * 返回源对目标使用一张游戏牌的效果值
          * @param {GameCores.GameObjects.Player} target 目标
          * @param {*} card 
          * @param {?GameCores.GameObjects.Player} [player] 源，如果未指定，使用当前事件角色
          * @param {?GameCores.GameObjects.Player} player2 观察者
          * @param {?boolean} [isLink] 
          * @returns {number}
          */
         effect_use: function (target, card, player, player2, isLink) {
            var Evt = _status.event;
            var eventskill = null;
            if (player == undefined) player = _status.event.player;
            if (typeof card != 'string' && (typeof card != 'object' || !card.name)) {
               var skillinfo = get.info(Evt.skill);
               if (Evt.skill && skillinfo.viewAs == undefined) card = _status.event.skill;
               else {
                  card = get.card();
                  if (skillinfo && skillinfo.viewAs && card.name === skillinfo.viewAs.name) {
                     eventskill = Evt.skill;
                  }
               }
            }
            var info = get.info(card);
            if (typeof card == 'object' && info && info.changeTarget) {
               var targets = [target];
               info.changeTarget(player, targets);
               var eff = 0;
               for (var i of targets) {
                  eff += get.effect(i, card, player, player2, isLink);
               }
               return eff;
            }
            var result = get.result(card, eventskill);
            var result1 = result.player_use || result.player, result2 = result.target_use || result.target;
            if (typeof result1 == 'function') result1 = result1(player, target, card, isLink);
            if (typeof result2 == 'function') result2 = result2(player, target, card, isLink);

            if (typeof result1 != 'number') result1 = 0;
            if (typeof result2 != 'number') result2 = 0;
            var temp1, temp2, temp3, temp01 = 0, temp02 = 0, threaten = 1;
            var skills1 = player.getSkills().concat(lib.skill.global);
            game.expandSkills(skills1);
            var zerotarget = false, zeroplayer = false;
            for (var i = 0; i < skills1.length; i++) {
               temp1 = get.info(skills1[i]).ai;
               if (temp1 && typeof temp1.effect == 'object' && typeof temp1.effect.player_use == 'function') {
                  temp1 = temp1.effect.player_use(card, player, target, result1, isLink);
               }
               else if (temp1 && typeof temp1.effect == 'object' && typeof temp1.effect.player == 'function') {
                  temp1 = temp1.effect.player(card, player, target, result1, isLink);
               }
               else temp1 = undefined;
               if (typeof temp1 == 'object') {
                  if (temp1.length == 2 || temp1.length == 4) {
                     result1 *= temp1[0];
                     temp01 += temp1[1];
                  }
                  if (temp1.length == 4) {
                     result2 *= temp1[2];
                     temp02 += temp1[3];
                  }
               }
               else if (typeof temp1 == 'number') {
                  result1 *= temp1;
               }
               else if (temp1 == 'zeroplayer') {
                  zeroplayer = true;
               }
               else if (temp1 == 'zerotarget') {
                  zerotarget = true;
               }
               else if (temp1 == 'zeroplayertarget') {
                  zeroplayer = true;
                  zerotarget = true;
               }
            }
            if (target) {
               var skills2 = target.getSkills().concat(lib.skill.global);
               game.expandSkills(skills2);
               for (var i = 0; i < skills2.length; i++) {
                  temp2 = get.info(skills2[i]).ai;
                  if (temp2 && temp2.threaten) temp3 = temp2.threaten;
                  else temp3 = undefined;
                  if (temp2 && typeof temp2.effect == 'function') {
                     if (!player.hasSkillTag('ignoreSkill', true, {
                        card: card,
                        target: target,
                        skill: skills2[i],
                        isLink: isLink,
                     })) temp2 = temp2.effect(card, player, target, result2, isLink);
                     else temp2 = undefined;
                  }
                  else if (temp2 && typeof temp2.effect == 'object' && typeof temp2.effect.target_use == 'function') {
                     if (!player.hasSkillTag('ignoreSkill', true, {
                        card: card,
                        target: target,
                        skill: skills2[i],
                        isLink: isLink,
                     })) temp2 = temp2.effect.target_use(card, player, target, result2, isLink);
                     else temp2 = undefined;
                  }
                  else if (temp2 && typeof temp2.effect == 'object' && typeof temp2.effect.target == 'function') {
                     if (!player.hasSkillTag('ignoreSkill', true, {
                        card: card,
                        target: target,
                        skill: skills2[i],
                        isLink: isLink,
                     })) temp2 = temp2.effect.target(card, player, target, result2, isLink);
                     else temp2 = undefined;
                  }
                  else temp2 = undefined;
                  if (typeof temp2 == 'object') {
                     if (temp2.length == 2 || temp2.length == 4) {
                        result2 *= temp2[0];
                        temp02 += temp2[1];
                     }
                     if (temp2.length == 4) {
                        result1 *= temp2[2];
                        temp01 += temp2[3];
                     }
                  }
                  else if (typeof temp2 == 'number') {
                     result2 *= temp2;
                  }
                  else if (temp2 == 'zeroplayer') {
                     zeroplayer = true;
                  }
                  else if (temp2 == 'zerotarget') {
                     zerotarget = true;
                  }
                  else if (temp2 == 'zeroplayertarget') {
                     zeroplayer = true;
                     zerotarget = true;
                  }
                  if (typeof temp3 == 'function' && temp3(player, target) != undefined) {
                     threaten *= temp3(player, target);
                  }
                  else if (typeof temp3 == 'object') {
                     if (typeof temp3.target == 'number') {
                        threaten *= temp3;
                     }
                     else if (typeof temp3.target == 'function' && temp3(player, target) != undefined) {
                        threaten *= temp3(player, target);
                     }
                  }
                  else if (typeof temp3 == 'number') {
                     threaten *= temp3;
                  }
               }
               result2 += temp02;
               result1 += temp01;
               if (get.attitude(player, target) < 0) {
                  result2 *= Math.sqrt(threaten);
               }
               else {
                  result2 *= Math.sqrt(Math.sqrt(threaten));
               }
               if (target.hp == 1) result2 *= 2.5;
               if (target.hp == 2) result2 *= 1.8;
               if (target.countCards('h') == 0) {
                  if (get.tag(card, 'respondSha') || get.tag(card, 'respondShan')) {
                     result2 *= 1.7;
                  }
                  else {
                     result2 *= 1.5;
                  }
               }
               if (target.countCards('h') == 1) result2 *= 1.3;
               if (target.countCards('h') == 2) result2 *= 1.1;
               if (target.countCards('h') > 3) result2 *= 0.5;
               if (target.hp == 4) result2 *= 0.9;
               if (target.hp == 5) result2 *= 0.8;
               if (target.hp > 5) result2 *= 0.6;
            }
            else {
               result2 += temp02;
               result1 += temp01;
            }
            if (zeroplayer) result1 = 0;
            if (zerotarget) result2 = 0;
            var final = 0;
            if (player2) {
               final = (result1 * get.attitude(player2, player) + (target ? result2 * get.attitude(player2, target) : 0));
            }
            else final = (result1 * get.attitude(player, player) + (target ? result2 * get.attitude(player, target) : 0));
            if (!isLink && get.tag(card, 'natureDamage') && !zerotarget) {
               var info = get.info(card);
               if (!info || !info.ai || !info.ai.canLink) {
                  if (target.isLinked()) game.countPlayer(function (current) {
                     if (current != target && current.isLinked()) final += get.effect(current, card, player, player2, true);
                  });
               }
               else if (info.ai.canLink(player, target, card)) {
                  game.countPlayer(function (current) {
                     if (current != target && current.isLinked()) final += get.effect(current, card, player, player2, true);
                  });
               }
            }
            return final;
         },
         /**
          * 返回一个角色对目标(使用一张游戏牌|造成伤害|回复血量)的效果值
          * @param {?GameCores.GameObjects.Player} target 目标
          * @param {!GameCores.GameObjects.Card} card 游戏牌对象，除了牌名，其他属性或函数可以为空
          * @param {?string} [card.name] 牌名，如果未指定，`card`使用`_status.event.skill`
          * @param {?GameCores.GameObjects.Player} [player] 角色，如果未指定，使用当前事件角色
          * @param {?GameCores.GameObjects.Player} player2 观察者
          * @param {?boolean} [isLink] 是否计算被链接的角色，如果为true，不计算；如果为false或未指定，对效果值$effect$，被链接的角色$P_n$(包括`target`)，游戏牌$C$，角色$P2$，观察者$O$，计算公式：${effect}=\sum_{i=0}^{n-1}{get.effect(P_i, C, P2, O, true)})$。
          * @returns {number}
          */
         effect: function (target, card, player, player2, isLink) {
            var Evt = _status.event;
            var eventskill = null;
            if (player == undefined) player = _status.event.player;
            if (typeof card != 'string' && (typeof card != 'object' || !card.name)) {
               var skillinfo = get.info(Evt.skill);
               if (Evt.skill && skillinfo.viewAs == undefined) card = _status.event.skill;
               else {
                  card = get.card();
                  if (skillinfo && skillinfo.viewAs && card.name === skillinfo.viewAs.name) {
                     eventskill = Evt.skill;
                  }
               }
            }
            var result = get.result(card, eventskill);
            var result1 = result.player, result2 = result.target;
            if (typeof result1 == 'function') result1 = result1(player, target, card, isLink);
            if (typeof result2 == 'function') result2 = result2(player, target, card, isLink);

            if (typeof result1 != 'number') result1 = 0;
            if (typeof result2 != 'number') result2 = 0;
            var temp1, temp2, temp3, temp01 = 0, temp02 = 0, threaten = 1;
            var skills1 = player.getSkills().concat(lib.skill.global);
            game.expandSkills(skills1);
            var zerotarget = false, zeroplayer = false;
            for (var i = 0; i < skills1.length; i++) {
               temp1 = get.info(skills1[i]).ai;
               if (temp1 && typeof temp1.effect == 'object' && typeof temp1.effect.player == 'function') {
                  temp1 = temp1.effect.player(card, player, target, result1, isLink);
               }
               else temp1 = undefined;
               if (typeof temp1 == 'object') {
                  if (temp1.length == 2 || temp1.length == 4) {
                     result1 *= temp1[0];
                     temp01 += temp1[1];
                  }
                  if (temp1.length == 4) {
                     result2 *= temp1[2];
                     temp02 += temp1[3];
                  }
               }
               else if (typeof temp1 == 'number') {
                  result1 *= temp1;
               }
               else if (temp1 == 'zeroplayer') {
                  zeroplayer = true;
               }
               else if (temp1 == 'zerotarget') {
                  zerotarget = true;
               }
               else if (temp1 == 'zeroplayertarget') {
                  zeroplayer = true;
                  zerotarget = true;
               }
            }
            if (target) {
               var skills2 = target.getSkills().concat(lib.skill.global);
               game.expandSkills(skills2);
               for (var i = 0; i < skills2.length; i++) {
                  temp2 = get.info(skills2[i]).ai;
                  if (temp2 && temp2.threaten) temp3 = temp2.threaten;
                  else temp3 = undefined;
                  if (temp2 && typeof temp2.effect == 'function') {
                     if (!player.hasSkillTag('ignoreSkill', true, {
                        card: card,
                        target: target,
                        skill: skills2[i],
                        isLink: isLink,
                     })) temp2 = temp2.effect(card, player, target, result2, isLink);
                     else temp2 = undefined;
                  }
                  else if (temp2 && typeof temp2.effect == 'object' && typeof temp2.effect.target == 'function') {
                     if (!player.hasSkillTag('ignoreSkill', true, {
                        card: card,
                        target: target,
                        skill: skills2[i],
                        isLink: isLink,
                     })) temp2 = temp2.effect.target(card, player, target, result2, isLink);
                     else temp2 = undefined;
                  }
                  else temp2 = undefined;
                  if (typeof temp2 == 'object') {
                     if (temp2.length == 2 || temp2.length == 4) {
                        result2 *= temp2[0];
                        temp02 += temp2[1];
                     }
                     if (temp2.length == 4) {
                        result1 *= temp2[2];
                        temp01 += temp2[3];
                     }
                  }
                  else if (typeof temp2 == 'number') {
                     result2 *= temp2;
                  }
                  else if (temp2 == 'zeroplayer') {
                     zeroplayer = true;
                  }
                  else if (temp2 == 'zerotarget') {
                     zerotarget = true;
                  }
                  else if (temp2 == 'zeroplayertarget') {
                     zeroplayer = true;
                     zerotarget = true;
                  }
                  if (typeof temp3 == 'function' && temp3(player, target) != undefined) {
                     threaten *= temp3(player, target);
                  }
                  else if (typeof temp3 == 'object') {
                     if (typeof temp3.target == 'number') {
                        threaten *= temp3;
                     }
                     else if (typeof temp3.target == 'function' && temp3(player, target) != undefined) {
                        threaten *= temp3(player, target);
                     }
                  }
                  else if (typeof temp3 == 'number') {
                     threaten *= temp3;
                  }
               }
               result2 += temp02;
               result1 += temp01;
               if (typeof card == 'object') {
                  if (get.attitude(player, target) < 0) {
                     result2 *= Math.sqrt(threaten);
                  }
                  else {
                     result2 *= Math.sqrt(Math.sqrt(threaten));
                  }
                  // *** continue here ***
                  if (target.hp == 1) result2 *= 2.5;
                  if (target.hp == 2) result2 *= 1.8;
                  if (target.countCards('h') == 0) {
                     if (get.tag(card, 'respondSha') || get.tag(card, 'respondShan')) {
                        result2 *= 1.7;
                     }
                     else {
                        result2 *= 1.5;
                     }
                  }
                  if (target.countCards('h') == 1) result2 *= 1.3;
                  if (target.countCards('h') == 2) result2 *= 1.1;
                  if (target.countCards('h') > 3) result2 *= 0.5;
                  if (target.hp == 4) result2 *= 0.9;
                  if (target.hp == 5) result2 *= 0.8;
                  if (target.hp > 5) result2 *= 0.6;
               }
            }
            else {
               result2 += temp02;
               result1 += temp01;
            }
            if (zeroplayer) result1 = 0;
            if (zerotarget) result2 = 0;
            var final = 0;
            if (player2) {
               final = (result1 * get.attitude(player2, player) + (target ? result2 * get.attitude(player2, target) : 0));
            }
            else final = (result1 * get.attitude(player, player) + (target ? result2 * get.attitude(player, target) : 0));
            if (!isLink && get.tag(card, 'natureDamage') && !zerotarget) {
               var info = get.info(card);
               if (!info || !info.ai || !info.ai.canLink) {
                  if (target.isLinked()) game.countPlayer(function (current) {
                     if (current != target && current.isLinked()) final += get.effect(current, card, player, player2, true);
                  });
               }
               else if (info.ai.canLink(player, target, card)) {
                  game.countPlayer(function (current) {
                     if (current != target && current.isLinked()) final += get.effect(current, card, player, player2, true);
                  });
               }
            }
            return final;
         },
         /**
          * 返回源对目标进行伤害的效果值
          * @param {GameCores.GameObjects.Player} target 目标
          * @param {?GameCores.GameObjects.Player} [player] 源，如果未指定，使用`target`
          * @param {?GameCores.GameObjects.Player} [viewer] 观察者，用于判断最后的效果是正效果(对观察者或其方有益)还是负效果(对观察者敌方有益)；如果未指定，使用`target`
          * @param {?string} [nature] 伤害属性，如果未指定，则非属性伤害
          * @returns {number}
          */
         damageEffect: function (target, player, viewer, nature) {
            if (!player) {
               player = target;
            }
            if (!viewer) {
               viewer = target;
            }
            var name = 'damage';
            if (nature == 'fire') {
               name = 'firedamage';
            }
            else if (nature == 'thunder') {
               name = 'thunderdamage';
            }
            else if (nature == 'ocean') {
               name = 'oceandamage';
            }
            else if (nature == 'ice') {
               name = 'icedamage';
            }
            else if (nature == 'yami') {
               name = 'yamidamage';
            }
            var eff = get.effect(target, { name: name }, player, viewer);
            if (eff > 0 && target.hujia > 0) return 0;
            return eff;
         },
         /**
          * 返回源对目标回复血量的效果值，如果目标当前没有损失血量，返回0值(无效果)
          * @param {GameCores.GameObjects.Player} target 目标
          * @param {?GameCores.GameObjects.Player} [player] 源，如果未指定，使用`target`
          * @param {?GameCores.GameObjects.Player} [viewer] 观察者，用于判断最后的效果是正效果(对观察者或其方有益)还是负效果(对观察者敌方有益)；如果未指定，使用`target`
          * @returns {number}
          */
         recoverEffect: function (target, player, viewer) {
            if (target.hp == target.maxHp) return 0;
            if (!player) {
               player = target;
            }
            if (!viewer) {
               viewer = target;
            }
            return get.effect(target, { name: 'recover' }, player, viewer);
         },
         /**
          * 返回按钮绑定(手牌|装备区|判定区|正在判定的)卡牌所属的角色使用此牌的收益
          * 如果是其他区域的牌，返回当前事件的角色使用此牌的收益，**这个时候**，此函数假定当前事件的角色(`_status.event.player`)存在，所以如果当前事件的角色未定义或者为空，此函数会报错
          * @param {HTMLDivElement} button 按钮，返回此按钮的收益
          * @returns {number}
          */
         buttonValue: function (button) {
            var card = button.link;
            var player = get.owner(card);
            if (!player) player = _status.event.player;
            if (player.getCards('j').contains(card)) {
               var efff = get.effect(player, {
                  name: card.viewAs || card.name,
                  cards: [card],
               }, player, player);
               if (efff > 0) return 0.5;
               if (efff == 0) return 0;
               return -1.5;
            }
            if (player.getCards('e').contains(card)) {
               var evalue = get.value(card, player);
               if (player.hasSkillTag('noe')) {
                  if (evalue >= 7) {
                     return evalue / 6;
                  }
                  return evalue / 10;
               }
               return evalue / 3;
            }
            if (player.hasSkillTag('noh')) return 0.1;
            var nh = player.countCards('h');
            switch (nh) {
               case 1: return 2;
               case 2: return 1.6;
               case 3: return 1;
               case 4: return 0.8;
               case 5: return 0.6;
               default: return 0.4;
            }
         },
         /**
          * 返回当前事件角色对一个角色的态度值
          * @param {GameCores.GameObjects.Player} to 一个角色，返回对该角色的态度值
          * @param {number}
          */
         attitude2: function (to) {
            return get.attitude(_status.event.player, to);
         },
         get $t() {
            return this.translation
         },
         get $a() {
            return this.attitude
         },
         get $a2() {
            return this.attitude2
         },
         get $dis() {
            return this.distance
         },
         get $pro() {
            return this.prompt
         },
         get $pro2() {
            return this.prompt2
         }
      }

   }
}

/***/ }),

/***/ 5248:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  libFun: (vkCore) => {
    let { game, ui, get, ai, lib, _status } = vkCore
    /**
     * 游戏基础对象和状态机
     * @name element
     * @namespace
     * @see {@link content}
     * @see {@link element.player}
     * @see {@link element.card}
     */
    const element = __webpack_require__(7747)
    /**
     * 游戏模式菜单
     * @name configMenu.mode
     * @type {!Object}
     */
    const _mode = {
      connect: {
        name: '联机',
        config: {
          connect_nickname: {
            name: '联机昵称',
            input: true,
            frequent: true,
          },
          connect_avatar: {
            name: '联机头像',
            init: 'KizunaAI',
            item: {},
            frequent: true,
            onclick: function (item) {
              game.saveConfig('connect_avatar', item);
              game.saveConfig('connect_avatar', item, 'connect');
            },
            visualMenu: function (node, link, name, config) {
              node.className = 'button character themebutton';
              if (!node.chara) {
                node.chara = true
                node.setBackground(link, 'character')
              }
            },
          },
          hall_ip: {
            name: '联机大厅',
            input: true,
            frequent: true,
          },
          hall_button: {
            name: '联机大厅按钮',
            init: true,
            frequent: true,
            onclick: function (bool) {
              game.saveConfig('hall_button', bool, 'connect');
              if (ui.hall_button) {
                if (bool) {
                  ui.hall_button.style.display = '';
                }
                else {
                  ui.hall_button.style.display = 'none';
                }
              }
            }
          },
        }
      },
      //引导
      yindao: {
        name: '引导',
        config: {
          update: function (config, map) {
          },
        }
      },
      // richer: {
      //     name: '大富翁',
      //     connect: {
      //         connect_player_number: {
      //             name: '游戏人数',
      //             init: '6',
      //             item: {
      //                 '2': '两人',
      //                 '3': '三人',
      //                 '4': '四人',
      //                 '5': '五人',
      //                 '6': '六人',
      //             },
      //             frequent: true,
      //             restart: true,
      //         },
      //         update: function (config, map) {
      //         },
      //         connect_show_range: {
      //             name: '显示卡牌范围',
      //             init: true,
      //         },
      //         // connect_show_distance:{
      //         // 	name:'显示距离',
      //         // 	init:true,
      //         // },
      //         connect_chessscroll_speed: {
      //             name: '边缘滚动速度',
      //             init: '20',
      //             intro: '鼠标移至屏幕边缘时自动滚屏',
      //             item: {
      //                 '0': '不滚动',
      //                 '10': '10格/秒',
      //                 '20': '20格/秒',
      //                 '30': '30格/秒',
      //             }
      //         },
      //     },
      //     config: {
      //         player_number: {
      //             name: '游戏人数',
      //             init: '6',
      //             item: {
      //                 '2': '两人',
      //                 '3': '三人',
      //                 '4': '四人',
      //                 '5': '五人',
      //                 '6': '六人',
      //             },
      //             frequent: true,
      //             restart: true,
      //         },
      //         update: function (config, map) {
      //             switch (config.player_number) {
      //                 case 4:
      //                 case 6: {
      //                     map.team_number.show();
      //                     break;
      //                 }
      //                 default: {
      //                     map.team_number.hide();
      //                     break;
      //                 }

      //             }
      //         },
      //         show_range: {
      //             name: '显示卡牌范围',
      //             init: true,
      //         },
      //         team_number: {
      //             name: '每队人数',
      //             init: '1',
      //             item: {
      //                 '1': '单人',
      //                 '2': '两人',
      //             },
      //             frequent: true,
      //             restart: true,
      //         },
      //         chessscroll_speed: {
      //             name: '边缘滚动速度',
      //             init: '20',
      //             intro: '鼠标移至屏幕边缘时自动滚屏',
      //             item: {
      //                 '0': '不滚动',
      //                 '10': '10格/秒',
      //                 '20': '20格/秒',
      //                 '30': '30格/秒',
      //             }
      //         },
      //     }
      // },
      identity: {
        name: '身份',
        connect: {
          update: function (config, map) {
            if (config.connect_identity_mode == 'zhong') {
              map.connect_change_choice.hide();
              map.choice_ex.hide();
              map.connect_player_number.hide();
              map.connect_enhance_zhu.hide();
              map.connect_double_nei.hide();
              map.connect_zhong_card.show();
              map.connect_special_identity.hide();
              map.connect_double_character.show();
            }
            else if (config.connect_identity_mode == 'purple') {
              map.connect_change_choice.hide();
              map.choice_ex.hide();
              map.connect_player_number.hide();
              map.connect_enhance_zhu.hide();
              map.connect_double_nei.hide();
              map.connect_zhong_card.hide();
              map.connect_special_identity.hide();
              map.connect_double_character.hide();
            }
            else {
              map.connect_change_choice.show();
              map.choice_ex.show();
              map.connect_double_character.show();
              map.connect_player_number.show();
              map.connect_enhance_zhu.show();
              if (config.connect_player_number != '2') {
                map.connect_double_nei.show();
              }
              else {
                map.connect_double_nei.hide();
              }
              map.connect_zhong_card.hide();

              if (config.connect_player_number == '8') {
                map.connect_special_identity.show();
              }
              else {
                map.connect_special_identity.hide();
              }
            }
          },
          connect_identity_mode: {
            name: '游戏模式',
            init: 'normal',
            item: {
              normal: '标准',
              zhong: '明忠',
              purple: '3v3v2',
            },
            restart: true,
            frequent: true,
            intro: '明忠模式和3v3v2模式详见帮助'
          },
          connect_player_number: {
            name: '游戏人数',
            init: '8',
            item: {
              '2': '两人',
              '3': '三人',
              '4': '四人',
              '5': '五人',
              '6': '六人',
              '7': '七人',
              '8': '八人'
            },
            frequent: true,
            restart: true,
          },
          connect_zhong_card: {
            name: '明忠卡牌替换',
            init: true,
            frequent: true,
            restart: true
          },
          connect_double_nei: {
            name: '双内奸',
            init: false,
            restart: true,
            // frequent:true,
            intro: '开启后游戏中将有两个内奸（内奸胜利条件仍为主内1v1时击杀主公）'
          },
          connect_double_character: {
            name: '双将模式',
            init: false,
            frequent: true,
            restart: true,
          },
          connect_change_card: {
            name: '启用手气卡',
            init: false,
            frequent: true,
            restart: true,
          },
          connect_change_choice: {
            name: '点将模式',
            init: false,
            frequent: true,
            restart: true,
          },
          connect_special_identity: {
            name: '特殊身份',
            init: false,
            restart: true,
            frequent: true,
            intro: '开启后游戏中将增加军师、大将、贼首三个身份'
          },
          connect_enhance_zhu: {
            name: '加强主公',
            init: false,
            restart: true,
            intro: '为主公增加一个额外技能'
          },
          choice_ex: {
            name: '额外选将框',
            init: '0',
            restart: true,
            item: {
              '0': '〇',
              '1': '一',
              '2': '二',
              '3': '三',
              '4': '四',
              '5': '五',
            },
            intro: '为所有玩家分配额外选将框'
          },
          card_remark: {
            name: '装备回调',
            init: false,
            frequent: true,
            restart: true,
            intro: '将军争和基础包的装备牌回调至《三国杀》原版'
          }
        },
        config: {
          update: function (config, map) {
            if (config.identity_mode == 'zhong') {
              map.player_number.hide();
              map.enhance_zhu.hide();
              map.double_nei.hide();
              map.auto_identity.hide();
              map.choice_ex.hide();
              map.choice_zhu.hide();
              map.choice_zhong.hide();
              map.choice_nei.hide();
              map.choice_fan.hide();
              map.ban_identity.hide();
              map.ban_identity2.hide();
              map.ban_identity3.hide();
              map.zhong_card.show();
              map.special_identity.hide();
              map.choose_group.show();
              map.change_choice.show();
              map.auto_mark_identity.show();
              map.double_character.show();
              map.free_choose.show();
              map.change_identity.show();
              if (config.double_character) {
                map.double_hp.show();
              }
              else {
                map.double_hp.hide();
              }
              map.continue_game.show();
            }
            else if (config.identity_mode == 'purple') {
              map.player_number.hide();
              map.enhance_zhu.hide();
              map.double_nei.hide();
              map.auto_identity.hide();
              map.choice_ex.hide();
              map.choice_zhu.hide();
              map.choice_zhong.hide();
              map.choice_nei.hide();
              map.choice_fan.hide();
              map.ban_identity.hide();
              map.ban_identity2.hide();
              map.ban_identity3.hide();
              map.zhong_card.hide();
              map.special_identity.hide();
              map.double_character.hide();
              map.double_hp.hide();
              map.choose_group.hide();
              map.auto_mark_identity.hide();
              map.change_choice.hide();
              map.free_choose.hide();
              map.change_identity.hide();
              map.continue_game.hide();
            }
            else {
              map.continue_game.show();
              map.player_number.show();
              map.enhance_zhu.show();
              map.auto_identity.show();
              if (config.player_number != '2') {
                map.double_nei.show();
              }
              else {
                map.double_nei.hide();
              }
              map.choice_ex.show();
              map.choice_zhu.show();
              map.choice_zhong.show();
              map.choice_nei.show();
              map.choice_fan.show();
              map.ban_identity.show();
              if (config.ban_identity == 'off') {
                map.ban_identity2.hide();
              }
              else {
                map.ban_identity2.show();
              }
              if (config.ban_identity == 'off' || config.ban_identity2 == 'off') {
                map.ban_identity3.hide();
              }
              else {
                map.ban_identity3.show();
              }
              map.zhong_card.hide();
              map.choose_group.show();
              map.auto_mark_identity.show();
              map.change_choice.show();
              map.free_choose.show();
              map.change_identity.show();
              if (config.player_number == '8') {
                map.special_identity.show();
              }
              else {
                map.special_identity.hide();
              }
              map.double_character.show();
              if (config.double_character) {
                map.double_hp.show();
              }
              else {
                map.double_hp.hide();
              }
            }
          },
          identity_mode: {
            name: '游戏模式',
            init: 'normal',
            item: {
              normal: '标准',
              zhong: '明忠',
              purple: '3v3v2',
            },
            restart: true,
            frequent: true,
            intro: '明忠模式详见帮助'
          },
          player_number: {
            name: '游戏人数',
            init: '3',
            item: {
              '2': '两人',
              '3': '三人',
              '4': '四人',
              '5': '五人',
              '6': '六人',
              '7': '七人',
              '8': '八人'
            },
            frequent: true,
            restart: true,
          },
          double_nei: {
            name: '双内奸',
            init: false,
            restart: true,
            frequent: true,
            intro: '开启后游戏中将有两个内奸（内奸胜利条件仍为主内1v1时击杀主公）'
          },
          choose_group: {
            name: '神武将选择势力',
            init: true,
            restart: true,
            frequent: true,
            intro: '若开启此选项，选择神武将的玩家需在亮出自己的武将牌之前为自己选择一个势力。'
          },
          nei_fullscreenpop: {
            name: '主内单挑特效',
            intro: '在进入主内单挑时，弹出全屏文字特效',
            init: true,
            unfrequent: true,
          },
          double_character: {
            name: '双将模式',
            init: false,
            frequent: true,
            restart: true,
          },
          special_identity: {
            name: '特殊身份',
            init: false,
            restart: true,
            frequent: true,
            intro: '开启后游戏中将增加军师、大将、贼首三个身份'
          },
          zhong_card: {
            name: '明忠卡牌替换',
            init: true,
            frequent: true,
            restart: true
          },
          double_hp: {
            name: '双将体力上限',
            init: 'pingjun',
            item: {
              hejiansan: '和减三',
              pingjun: '平均值',
              zuidazhi: '最大值',
              zuixiaozhi: '最小值',
              zonghe: '相加',
            },
            restart: true,
          },
          auto_identity: {
            name: '自动显示身份',
            item: {
              off: '关闭',
              one: '一轮',
              two: '两轮',
              three: '三轮',
              always: '始终'
            },
            init: 'off',
            onclick: function (bool) {
              game.saveConfig('auto_identity', bool, this._link.config.mode);
              if (get.config('identity_mode') == 'zhong') return;
              var num;
              switch (bool) {
                case '一轮': num = 1; break;
                case '两轮': num = 2; break;
                case '三轮': num = 3; break;
                default: num = 0; break;
              }
              if (num && !_status.identityShown && game.phaseNumber > game.players.length * num && game.showIdentity) {
                _status.identityShown = true;
                game.showIdentity(false);
              }
            },
            intro: '游戏进行若干轮将自动显示所有角色的身份',
          },
          auto_mark_identity: {
            name: '自动标记身份',
            init: true,
            intro: '根据角色的出牌行为自动标记可能的身份',
          },
          // ban_weak:{
          //     name:'屏蔽弱将',
          //     init:true,
          //     restart:true,
          // },
          // ban_strong:{
          //     name:'屏蔽强将',
          //     init:false,
          //     restart:true,
          // },
          enhance_zhu: {
            name: '加强主公',
            init: false,
            restart: true,
            intro: '为主公增加一个额外技能'
          },
          free_choose: {
            name: '自由选将',
            init: true,
            onclick: function (bool) {
              game.saveConfig('free_choose', bool, this._link.config.mode);
              if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
              if (!ui.cheat2 && get.config('free_choose')) ui.create.cheat2();
              else if (ui.cheat2 && !get.config('free_choose')) {
                ui.cheat2.close();
                delete ui.cheat2;
              }
            }
          },
          change_identity: {
            name: '自由选择身份和座位',
            init: true,
            onclick: function (bool) {
              game.saveConfig('change_identity', bool, this._link.config.mode);
              if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
              var dialog;
              if (ui.cheat2 && ui.cheat2.backup) dialog = ui.cheat2.backup;
              else dialog = _status.event.dialog;
              if (!_status.brawl || !_status.brawl.noAddSetting) {
                if (!dialog.querySelector('table') && get.config('change_identity')) _status.event.getParent().addSetting(dialog);
                else _status.event.getParent().removeSetting(dialog);
              }
              ui.update();
            }
          },
          change_choice: {
            name: '开启换将卡',
            init: true,
            onclick: function (bool) {
              game.saveConfig('change_choice', bool, this._link.config.mode);
              if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
              if (!ui.cheat && get.config('change_choice')) ui.create.cheat();
              else if (ui.cheat && !get.config('change_choice')) {
                ui.cheat.close();
                delete ui.cheat;
              }
            }
          },
          change_card: {
            name: '开启手气卡',
            init: 'disabled',
            item: {
              disabled: '禁用',
              once: '一次',
              twice: '两次',
              unlimited: '无限',
            },
          },
          continue_game: {
            name: '显示再战',
            init: false,
            onclick: function (bool) {
              game.saveConfig('continue_game', bool, this._link.config.mode);
              if (get.config('continue_game')) {
                if (!ui.continue_game && _status.over && !_status.brawl && !game.no_continue_game) {
                  ui.continue_game = ui.create.control('再战', game.reloadCurrent);
                }
              }
              else if (ui.continue_game) {
                ui.continue_game.close();
                delete ui.continue_game;
              }
            },
            intro: '游戏结束后可选择用相同的武将再进行一局游戏'
          },
          dierestart: {
            name: '死亡后显示重来',
            init: true,
            onclick: function (bool) {
              game.saveConfig('dierestart', bool, this._link.config.mode);
              if (get.config('dierestart')) {
                if (!ui.restart && game.me.isDead() && !_status.connectMode) {
                  ui.restart = ui.create.control('restart', game.reload);
                }
              }
              else if (ui.restart) {
                ui.restart.close();
                delete ui.restart;
              }
            }
          },
          revive: {
            name: '死亡后显示复活',
            init: false,
            onclick: function (bool) {
              game.saveConfig('revive', bool, this._link.config.mode);
              if (get.config('revive')) {
                if (!ui.revive && game.me.isDead()) {
                  ui.revive = ui.create.control('revive', ui.click.dierevive);
                }
              }
              else if (ui.revive) {
                ui.revive.close();
                delete ui.revive;
              }
            }
          },
          ban_identity: {
            name: '屏蔽身份',
            init: 'off',
            item: {
              off: '关闭',
              zhu: '主公',
              zhong: '忠臣',
              nei: '内奸',
              fan: '反贼',
            },
          },
          ban_identity2: {
            name: '屏蔽身份2',
            init: 'off',
            item: {
              off: '关闭',
              zhu: '主公',
              zhong: '忠臣',
              nei: '内奸',
              fan: '反贼',
            },
          },
          ban_identity3: {
            name: '屏蔽身份3',
            init: 'off',
            item: {
              off: '关闭',
              zhu: '主公',
              zhong: '忠臣',
              nei: '内奸',
              fan: '反贼',
            },
          },
          ai_strategy: {
            name: '内奸策略',
            init: 'ai_strategy_1',
            item: {
              ai_strategy_1: '均衡',
              ai_strategy_2: '偏反',
              ai_strategy_3: '偏忠',
              ai_strategy_4: '酱油',
              ai_strategy_5: '天使',
              ai_strategy_6: '仇主',
            },
            intro: '设置内奸对主忠反的态度'
          },
          difficulty: {
            name: 'AI对人类态度',
            init: 'normal',
            item: {
              easy: '友好',
              normal: '一般',
              hard: '仇视',
            },
          },
          choice_ex: {
            name: '额外选将框',
            init: '0',
            restart: true,
            item: {
              '0': '关闭',
              '1': '一',
              '2': '二',
              '4': '四',
              '6': '六',
              '8': '八',
            },
            intro: '为所有玩家分配额外选将框'
          },
          choice_zhu: {
            name: '主公候选武将数',
            init: '3',
            restart: true,
            item: {
              '3': '三',
              '4': '四',
              '5': '五',
              '6': '六',
              '8': '八',
              '10': '十',
            },
          },
          choice_zhong: {
            name: '忠臣候选武将数',
            init: '4',
            restart: true,
            item: {
              '3': '三',
              '4': '四',
              '5': '五',
              '6': '六',
              '8': '八',
              '10': '十',
            },
          },
          choice_nei: {
            name: '内奸候选武将数',
            init: '5',
            restart: true,
            item: {
              '3': '三',
              '4': '四',
              '5': '五',
              '6': '六',
              '8': '八',
              '10': '十',
            },
          },
          choice_fan: {
            name: '反贼候选武将数',
            init: '3',
            restart: true,
            item: {
              '3': '三',
              '4': '四',
              '5': '五',
              '6': '六',
              '8': '八',
              '10': '十',
            },
          },
          card_remark: {
            name: '装备回调',
            init: false,
            frequent: true,
            restart: true,
            intro: '将军争和基础包的装备牌回调至《三国杀》原版'
          }
        }
      },
      guozhan: {
        name: '国战',
        connect: {
          update: function (config, map) {
            if (config.connect_onlyguozhan) {
              map.connect_junzhu.show();
            }
            else {
              map.connect_junzhu.hide();
            }
          },
          connect_guozhan_mode: {
            name: '游戏模式',
            init: 'normal',
            item: {
              normal: '势备',
              yingbian: '应变',
              old: '怀旧',
            },
            frequent: true,
            restart: true,
            intro: '<li>势备：默认模式，使用线下《君临天下·势备篇》的牌堆进行游戏。<br><li>应变：使用OL的应变国战牌堆进行游戏。<br><li>怀旧：使用传统国战的牌堆进行游戏。',
          },
          connect_player_number: {
            name: '游戏人数',
            init: '8',
            item: {
              '3': '三人',
              '4': '四人',
              '5': '五人',
              '6': '六人',
              '7': '七人',
              '8': '八人'
            },
            frequent: true,
            restart: true,
          },
          connect_initshow_draw: {
            name: '首亮奖励',
            item: {
              'off': '关闭',
              'draw': '摸牌',
              'mark': '标记',
            },
            init: 'mark',
            frequent: true,
            intro: '第一个明置武将牌的角色可获得首亮奖励'
          },
          connect_aozhan: {
            name: '鏖战模式',
            init: true,
            intro: '若开启此选项，则将在游戏中引入“鏖战模式”的规则：<br>当游戏中仅剩四名或更少角色时（七人以下游戏时改为三名或更少），若此时全场没有超过一名势力相同的角色，则从一个新的回合开始，游戏进入鏖战模式直至游戏结束。<br>◇在鏖战模式下，【桃】只能当做【杀】或【闪】使用或打出，不能用来回复体力。<br>注：进入鏖战模式后，即使之后有两名或者更多势力相同的角色出现，仍然不会取消鏖战模式。',
            frequent: true,
            restart: true,
          },
          connect_viewnext: {
            name: '观看下家副将',
            init: false,
            intro: '若开启此选项，所有的玩家将在挑选武将后，分发起始手牌之前，分别观看自己下家的副将。',
          },
          connect_zhulian: {
            name: '珠联璧合',
            init: true,
            // frequent:true,
            intro: '主将和副将都明置后，若为特定组合，可获得【珠联璧合】标记'
          },
          connect_junzhu: {
            name: '替换君主',
            init: true,
            // frequent:true,
            restart: true,
            intro: '若开启此选项，玩家的第一个回合开始时，若其主武将牌有对应的君主武将牌，则其可以将此武将牌替换为对应的君主武将牌，然后重新调整体力上限。若玩家的体力上限因此增大，则玩家回复等量的体力。'
          },
          connect_change_card: {
            name: '启用手气卡',
            init: false,
            frequent: true,
            restart: true,
          },
          card_remark: {
            name: '装备回调',
            init: false,
            frequent: true,
            restart: true,
            intro: '将军争和基础包的装备牌回调至《三国杀》原版'
          }
        },
        config: {
          update: function (config, map) {
            if (config.onlyguozhan) {
              map.junzhu.show();
            }
            else {
              map.junzhu.hide();
            }
          },
          guozhan_mode: {
            name: '游戏模式',
            init: 'normal',
            item: {
              normal: '势备',
              yingbian: '应变',
              old: '怀旧',
              free: '自由',
            },
            frequent: true,
            restart: true,
            intro: '<li>势备：默认模式，使用线下《君临天下·势备篇》的牌堆进行游戏。<br><li>应变：使用OL的应变国战牌堆进行游戏。<br><li>怀旧：使用传统国战的牌堆进行游戏。<br><li>自由：使用玩家的自定义牌堆进行游戏。',
          },
          player_number: {
            name: '游戏人数',
            init: '8',
            item: {
              '3': '三人',
              '4': '四人',
              '5': '五人',
              '6': '六人',
              '7': '七人',
              '8': '八人'
            },
            frequent: true,
            restart: true,
          },
          initshow_draw: {
            name: '首亮奖励',
            item: {
              'off': '关闭',
              'draw': '摸牌',
              'mark': '标记',
            },
            init: 'mark',
            frequent: true,
            intro: '第一个明置身份牌的角色可获得摸牌奖励'
          },
          aozhan: {
            name: '鏖战模式',
            init: true,
            frequent: true,
            restart: true,
            intro: '若开启此选项，则将在游戏中引入“鏖战模式”的规则：<br>当游戏中仅剩四名或更少角色时（七人以下游戏时改为三名或更少），若此时全场没有超过一名势力相同的角色，则从一个新的回合开始，游戏进入鏖战模式直至游戏结束。<br>◇在鏖战模式下，【桃】只能当做【杀】或【闪】使用或打出，不能用来回复体力。<br>注：进入鏖战模式后，即使之后有两名或者更多势力相同的角色出现，仍然不会取消鏖战模式。',
          },
          viewnext: {
            name: '观看下家副将',
            init: false,
            intro: '若开启此选项，所有的玩家将在挑选武将后，分发起始手牌之前，分别观看自己下家的副将。',
          },
          aozhan_bgm: {
            name: '鏖战背景音乐',
            item: {
              disabled: '不启用',
              online: 'Online',
              rewrite: 'Rewrite',
              chaoming: '潮鸣',
            },
            init: 'rewrite',
            onclick: function (item) {
              game.saveConfig('aozhan_bgm', item, this._link.config.mode);
              if (_status._aozhan == true) game.playBackgroundMusic();
            },
          },
          zhulian: {
            name: '珠联璧合',
            init: true,
            // frequent:true,
            intro: '主将和副将都明置后，若为特定组合，可获得【珠联璧合】标记'
          },
          changeViceType: {
            name: '副将变更方式',
            init: 'default',
            item: {
              default: '发现式',
              online: '随机式',
            },
            frequent: true,
            restart: true,
          },
          onlyguozhan: {
            name: '使用国战武将',
            init: true,
            frequent: true,
            restart: true,
            intro: '开启武将技能将替换为国战版本并禁用非国战武将'
          },
          guozhanSkin: {
            name: '使用国战皮肤',
            init: true,
            frequent: true,
            restart: true,
            intro: '开启此选项后，将会把有国战专属皮肤的武将替换为国战皮肤'
          },
          junzhu: {
            name: '替换君主',
            init: true,
            // frequent:true,
            restart: true,
            intro: '若开启此选项，玩家的第一个回合开始时，若其主武将牌有对应的君主武将牌，则其可以将此武将牌替换为对应的君主武将牌，然后重新调整体力上限。若玩家的体力上限因此增大，则玩家回复等量的体力。'
          },
          double_hp: {
            name: '双将体力上限',
            init: 'pingjun',
            item: {
              hejiansan: '和减三',
              pingjun: '平均值',
              zuidazhi: '最大值',
              zuixiaozhi: '最小值',
              zonghe: '相加',
            },
            restart: true,
          },
          // ban_weak:{
          //     name:'屏蔽弱将',
          //     init:true,
          //     restart:true,
          // },
          // ban_strong:{
          //     name:'屏蔽强将',
          //     init:false,
          //     restart:true,
          // },
          free_choose: {
            name: '自由选将',
            init: true,
            onclick: function (bool) {
              game.saveConfig('free_choose', bool, this._link.config.mode);
              if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
              if (!ui.cheat2 && get.config('free_choose')) ui.create.cheat2();
              else if (ui.cheat2 && !get.config('free_choose')) {
                ui.cheat2.close();
                delete ui.cheat2;
              }
            }
          },
          onlyguozhanexpand: {
            name: '默认展开自由选将',
            init: false,
            restart: true,
            intro: '开启后自由选将对话框将默认显示全部武将'
          },
          change_identity: {
            name: '自由选择座位',
            init: true,
            onclick: function (bool) {
              game.saveConfig('change_identity', bool, this._link.config.mode);
              if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
              var dialog;
              if (ui.cheat2 && ui.cheat2.backup) dialog = ui.cheat2.backup;
              else dialog = _status.event.dialog;
              if (!_status.brawl || !_status.brawl.noAddSetting) {
                if (!dialog.querySelector('table') && get.config('change_identity')) _status.event.getParent().addSetting(dialog);
                else _status.event.getParent().removeSetting(dialog);
              }
              ui.update();
            }
          },
          change_choice: {
            name: '开启换将卡',
            init: true,
            onclick: function (bool) {
              game.saveConfig('change_choice', bool, this._link.config.mode);
              if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
              if (!ui.cheat && get.config('change_choice')) ui.create.cheat();
              else if (ui.cheat && !get.config('change_choice')) {
                ui.cheat.close();
                delete ui.cheat;
              }
            }
          },
          change_card: {
            name: '开启手气卡',
            init: 'disabled',
            item: {
              disabled: '禁用',
              once: '一次',
              twice: '两次',
              unlimited: '无限',
            }
          },
          continue_game: {
            name: '显示再战',
            init: true,
            intro: '游戏结束后可选择用相同的武将再进行一局游戏',
            onclick: function (bool) {
              game.saveConfig('continue_game', bool, this._link.config.mode);
              if (get.config('continue_game')) {
                if (!ui.continue_game && _status.over && !_status.brawl && !game.no_continue_game) {
                  ui.continue_game = ui.create.control('再战', game.reloadCurrent);
                }
              }
              else if (ui.continue_game) {
                ui.continue_game.close();
                delete ui.continue_game;
              }
            }
          },
          dierestart: {
            name: '死亡后显示重来',
            init: true,
            onclick: function (bool) {
              game.saveConfig('dierestart', bool, this._link.config.mode);
              if (get.config('dierestart')) {
                if (!ui.restart && game.me.isDead() && !_status.connectMode) {
                  ui.restart = ui.create.control('restart', game.reload);
                }
              }
              else if (ui.restart) {
                ui.restart.close();
                delete ui.restart;
              }
            }
          },
          revive: {
            name: '死亡后显示复活',
            init: false,
            onclick: function (bool) {
              game.saveConfig('revive', bool, this._link.config.mode);
              if (get.config('revive')) {
                if (!ui.revive && game.me.isDead()) {
                  ui.revive = ui.create.control('revive', ui.click.dierevive);
                }
              }
              else if (ui.revive) {
                ui.revive.close();
                delete ui.revive;
              }
            }
          },
          difficulty: {
            name: 'AI对人类态度',
            init: 'normal',
            item: {
              easy: '友好',
              normal: '一般',
              hard: '仇视',
            }
          },
          choice_num: {
            name: '候选武将数',
            init: '7',
            restart: true,
            item: {
              '5': '五',
              '6': '六',
              '7': '七',
              '8': '八',
              '9': '九',
              '10': '十',
            }
          },
          card_remark: {
            name: '装备回调',
            init: false,
            frequent: true,
            restart: true,
            intro: '将军争和基础包的装备牌回调至《三国杀》原版'
          }
        }
      },
      versus: {
        name: '对决',
        connect: {
          update: function (config, map) {
            if (config.connect_versus_mode == '1v1') {
              map.connect_choice_num.show();
              map.connect_replace_number.show();
            }
            else {
              map.connect_choice_num.hide();
              map.connect_replace_number.hide();
            }
            if (config.connect_versus_mode == '2v2' || config.connect_versus_mode == '3v3') {
              map.connect_replace_handcard.show();
            }
            else {
              map.connect_replace_handcard.hide();
            }
          },
          connect_versus_mode: {
            name: '游戏模式',
            init: '1v1',
            item: {
              '1v1': '1v1',
              '2v2': '2v2',
              '3v3': '3v3',
              '4v4': '4v4',
              //'guandu':'官渡',
            },
            frequent: true
          },
          connect_replace_handcard: {
            name: '四号位保护',
            init: true,
            frequent: true,
            intro: '最后行动的角色起始手牌数+1'
          },
          connect_choice_num: {
            name: '侯选武将数',
            init: '20',
            frequent: true,
            item: {
              '12': '12人',
              '16': '16人',
              '20': '20人',
              '24': '24人',
              '40': '40人',
            }
          },
          connect_replace_number: {
            name: '替补人数',
            init: '2',
            frequent: true,
            item: {
              '0': '无',
              '1': '1人',
              '2': '2人',
              '3': '3人',
              '4': '4人',
              '5': '5人',
            }
          },
        },
        config: {
          update: function (config, map) {
            if (config.versus_mode == 'four') {
              map.change_choice.hide();
              map.ladder.show();
              if (config.ladder) {
                map.ladder_monthly.show();
                map.ladder_reset.show();
              }
              else {
                map.ladder_monthly.hide();
                map.ladder_reset.hide();
              }
              map.enable_all.show();
              map.enable_all_cards_four.show();
              map.four_assign.show();
              map.four_phaseswap.show();
              map.expand_dialog.show();
              map.fouralign.show();
            }
            else {
              map.change_choice.show();
              map.ladder.hide();
              map.ladder_monthly.hide();
              map.ladder_reset.hide();
              map.enable_all.hide();
              map.enable_all_cards_four.hide();
              map.four_assign.hide();
              map.four_phaseswap.hide();
              map.expand_dialog.hide();
              map.fouralign.hide();
            }
            if (config.versus_mode == 'three' || config.versus_mode == 'one') {
              map.enable_all_three.show();
              map.enable_all_cards.show();
            }
            else {
              map.enable_all_three.hide();
              map.enable_all_cards.hide();
            }
            if (config.versus_mode == 'jiange' || config.versus_mode == 'two' || config.versus_mode == 'endless' ||
              config.versus_mode == 'three' || config.versus_mode == 'one' || config.versus_mode == 'siguo') {
              map.free_choose.show();
            }
            else {
              map.free_choose.hide();
            }
            if (config.versus_mode == 'jiange') {
              map.double_character_jiange.show();
            }
            else {
              map.double_character_jiange.hide();
            }
            if (config.versus_mode == 'two') {
              map.replace_handcard_two.show();
              map.replace_character_two.show();
              map.two_assign.show();
              map.two_phaseswap.show();
            }
            else {
              map.replace_handcard_two.hide();
              map.replace_character_two.hide();
              map.two_assign.hide();
              map.two_phaseswap.hide();
            }
            if (config.versus_mode == 'two' || config.versus_mode == 'siguo' || config.versus_mode == 'four') {
              if (config.versus_mode == 'four' && (config.four_assign || config.four_phaseswap)) {
                map.change_identity.hide();
              }
              else {
                map.change_identity.show();
              }
            }
            else {
              map.change_identity.hide();
            }
            if (config.versus_mode == 'siguo') {
              map.siguo_character.show();
            }
            else {
              map.siguo_character.hide();
            }
          },
          versus_mode: {
            name: '游戏模式',
            init: 'four',
            item: {
              four: '对抗',
              three: '统率',
              two: '欢乐',
              //guandu:'官渡',
              jiange: '战场',
              siguo: '四国',
              standard: '自由'
              // endless:'无尽',
              // triple:'血战',
              // one:'<span style="display:inline-block;width:100%;text-align:center">1v1</span>',
            },
            restart: true,
            frequent: true,
          },
          ladder: {
            name: '天梯模式',
            init: true,
            frequent: true,
            restart: true
          },
          ladder_monthly: {
            name: '每月重置天梯',
            init: true,
            frequent: true,
          },
          enable_all: {
            name: '启用全部武将',
            init: false,
            frequent: true,
            restart: true,
          },
          enable_all_cards_four: {
            name: '启用全部卡牌',
            init: false,
            frequent: true,
            restart: true,
          },
          enable_all_three: {
            name: '启用全部武将',
            init: false,
            frequent: true,
            restart: true,
          },
          enable_all_cards: {
            name: '启用全部卡牌',
            init: false,
            frequent: true,
            restart: true,
          },
          four_assign: {
            name: '代替队友选将',
            init: false,
            restart: true,
          },
          four_phaseswap: {
            name: '代替队友行动',
            init: false,
            restart: true,
          },
          two_assign: {
            name: '代替队友选将',
            init: false,
            restart: true,
          },
          two_phaseswap: {
            name: '代替队友行动',
            init: false,
            restart: true,
          },
          free_choose: {
            name: '自由选将',
            init: true,
            frequent: true,
            onclick: function (bool) {
              game.saveConfig('free_choose', bool, this._link.config.mode);
              if (!ui.create.cheat2) return;
              if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
              if (!ui.cheat2 && get.config('free_choose')) ui.create.cheat2();
              else if (ui.cheat2 && !get.config('free_choose')) {
                ui.cheat2.close();
                delete ui.cheat2;
              }
            }
          },
          fouralign: {
            name: '自由选择阵型',
            init: false
          },
          change_identity: {
            name: '自由选择座位',
            init: true,
            onclick: function (bool) {
              game.saveConfig('change_identity', bool, this._link.config.mode);
              if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
              if (_status.mode == 'four') {
                if (get.config('four_assign') || get.config('four_phaseswap')) return;
                if (bool) {
                  if (_status.event.parent.addSetting) {
                    _status.event.parent.addSetting();
                  }
                }
                else {
                  var seats = _status.event.parent.seatsbutton;
                  if (seats) {
                    while (seats.length) {
                      seats.shift().remove();
                    }
                    delete _status.event.parent.seatsbutton;
                  }
                }
              }
              else {
                var dialog;
                if (ui.cheat2 && ui.cheat2.backup) dialog = ui.cheat2.backup;
                else dialog = _status.event.dialog;
                if (!_status.brawl || !_status.brawl.noAddSetting) {
                  if (!dialog.querySelector('table') && get.config('change_identity')) _status.event.getParent().addSetting(dialog);
                  else _status.event.getParent().removeSetting(dialog);
                }
                ui.update();
              }
            }
          },
          change_choice: {
            name: '开启换将卡',
            init: true,
            onclick: function (bool) {
              game.saveConfig('change_choice', bool, this._link.config.mode);
              if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
              if (!ui.cheat && get.config('change_choice')) ui.create.cheat();
              else if (ui.cheat && !get.config('change_choice')) {
                ui.cheat.close();
                delete ui.cheat;
              }
            },
            frequent: true,
          },
          double_character_jiange: {
            name: '双将模式',
            init: false,
            frequent: true,
          },
          replace_handcard_two: {
            name: '四号位保护',
            init: true,
            frequent: true,
            intro: '最后行动的角色起始手牌+1'
          },
          replace_character_two: {
            name: '替补模式',
            init: false,
            frequent: true,
            intro: '每个额外选择一名武将，死亡后用该武将代替重新上场，替补武将用完时失败'
          },
          expand_dialog: {
            name: '默认展开选将框',
            intro: '选将框打开时直接显示全部武将（可能使游戏在开始时卡顿）',
            init: false,
          },
          siguo_character: {
            name: '专属武将出场率',
            init: 'increase',
            item: {
              increase: '大概率',
              normal: '默认概率',
              off: '不出现',
            },
            frequent: true
          },
          // ban_weak:{
          //     name:'屏蔽弱将',
          //     init:true,
          //     restart:true,
          // },
          // ban_strong:{
          //     name:'屏蔽强将',
          //     init:false,
          //     restart:true
          // },
          ladder_reset: {
            name: '重置天梯数据',
            onclick: function () {
              var node = this;
              if (node._clearing) {
                game.save('ladder', {
                  current: 900,
                  top: 900,
                  month: (new Date()).getMonth()
                });
                ui.ladder.innerHTML = '卫士五';
                clearTimeout(node._clearing);
                node.firstChild.innerHTML = '重置天梯数据';
                delete node._clearing;
                return;
              }
              node.firstChild.innerHTML = '单击以确认 (3)';
              node._clearing = setTimeout(function () {
                node.firstChild.innerHTML = '单击以确认 (2)';
                node._clearing = setTimeout(function () {
                  node.firstChild.innerHTML = '单击以确认 (1)';
                  node._clearing = setTimeout(function () {
                    node.firstChild.innerHTML = '重置天梯数据';
                    delete node._clearing;
                  }, 1000);
                }, 1000);
              }, 1000);
            },
            clear: true,
          },
        }
      },
      boss: {
        name: '挑战',
        config: {
          free_choose: {
            name: '自由选将',
            init: true,
            frequent: true,
            onclick: function (bool) {
              game.saveConfig('free_choose', bool, this._link.config.mode);
              if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
              if (!ui.cheat2 && get.config('free_choose')) ui.create.cheat2();
              else if (ui.cheat2 && !get.config('free_choose')) {
                ui.cheat2.close();
                delete ui.cheat2;
              }
            }
          },
          change_choice: {
            name: '开启换将卡',
            init: true,
            onclick: function (bool) {
              game.saveConfig('change_choice', bool, this._link.config.mode);
              if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
              if (!ui.cheat && get.config('change_choice')) ui.create.cheat();
              else if (ui.cheat && !get.config('change_choice')) {
                ui.cheat.close();
                delete ui.cheat;
              }
            },
            frequent: true,
          },
          single_control: {
            name: '单人控制',
            init: true,
            frequent: true,
            onclick: function (bool) {
              game.saveConfig('single_control', bool, this._link.config.mode);
              if (ui.single_swap && game.me != game.boss) {
                if (bool) {
                  ui.single_swap.style.display = 'none';
                }
                else {
                  ui.single_swap.style.display = '';
                }
              }
            },
            intro: '只控制一名角色，其他角色由AI控制'
          },
          // ban_weak:{
          //     name:'屏蔽弱将',
          //     init:true,
          //     restart:true,
          // },
          // ban_strong:{
          //     name:'屏蔽强将',
          //     init:false,
          //     restart:true,
          // },
        }
      },
      doudizhu: {
        name: '斗地主',
        connect: {
          update: function (config, map) {
            if (config.connect_doudizhu_mode == 'online') {
              map.connect_change_card.hide();
            }
            else {
              map.connect_change_card.show();
            }
            if (config.connect_doudizhu_mode != 'normal') {
              map.connect_double_character.hide();
            }
            else {
              map.connect_double_character.show();
            }
          },
          connect_doudizhu_mode: {
            name: '游戏模式',
            init: 'normal',
            item: {
              normal: '休闲',
              kaihei: '开黑',
              huanle: '欢乐',
              binglin: '兵临',
              online: '智斗',
            },
            restart: true,
            frequent: true,
          },
          connect_double_character: {
            name: '双将模式',
            init: false,
            frequent: true,
            restart: true,
          },
          connect_change_card: {
            name: '启用手气卡',
            init: false,
            frequent: true,
            restart: true,
          },
        },
        config: {
          update: function (config, map) {
            if (config.doudizhu_mode == 'online') {
              map.change_card.hide();
            }
            else {
              map.change_card.show();
            }
            if (config.doudizhu_mode != 'normal') {
              map.double_character.hide();
              map.free_choose.hide();
              map.change_identity.hide();
              map.change_choice.hide();
              map.continue_game.hide();
              map.dierestart.hide();
              map.choice_zhu.hide();
              map.choice_fan.hide();
              map.revive.hide();
            }
            else {
              map.double_character.show();
              map.free_choose.show();
              map.change_identity.show();
              map.change_choice.show();
              map.continue_game.show();
              map.dierestart.show();
              map.choice_zhu.show();
              map.choice_fan.show();
              map.revive.show();
            }
            if (config.double_character && config.doudizhu_mode == 'normal') {
              map.double_hp.show();
            }
            else {
              map.double_hp.hide();
            }
          },
          doudizhu_mode: {
            name: '游戏模式',
            init: 'normal',
            item: {
              normal: '休闲',
              kaihei: '开黑',
              huanle: '欢乐',
              binglin: '兵临',
              online: '智斗',
            },
            restart: true,
            frequent: true,
          },
          double_character: {
            name: '双将模式',
            init: false,
            frequent: true,
            restart: true,
          },
          double_hp: {
            name: '双将体力上限',
            init: 'pingjun',
            item: {
              hejiansan: '和减三',
              pingjun: '平均值',
              zuidazhi: '最大值',
              zuixiaozhi: '最小值',
              zonghe: '相加',
            },
            restart: true,
          },
          free_choose: {
            name: '自由选将',
            init: true,
            onclick: function (bool) {
              game.saveConfig('free_choose', bool, this._link.config.mode);
              if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
              if (!ui.cheat2 && get.config('free_choose')) ui.create.cheat2();
              else if (ui.cheat2 && !get.config('free_choose')) {
                ui.cheat2.close();
                delete ui.cheat2;
              }
            }
          },
          change_identity: {
            name: '自由选择身份和座位',
            init: true,
            onclick: function (bool) {
              game.saveConfig('change_identity', bool, this._link.config.mode);
              if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
              var dialog;
              if (ui.cheat2 && ui.cheat2.backup) dialog = ui.cheat2.backup;
              else dialog = _status.event.dialog;
              if (!_status.brawl || !_status.brawl.noAddSetting) {
                if (!dialog.querySelector('table') && get.config('change_identity')) _status.event.getParent().addSetting(dialog);
                else _status.event.getParent().removeSetting(dialog);
              }
              ui.update();
            }
          },
          change_choice: {
            name: '开启换将卡',
            init: true,
            onclick: function (bool) {
              game.saveConfig('change_choice', bool, this._link.config.mode);
              if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
              if (!ui.cheat && get.config('change_choice')) ui.create.cheat();
              else if (ui.cheat && !get.config('change_choice')) {
                ui.cheat.close();
                delete ui.cheat;
              }
            }
          },
          change_card: {
            name: '开启手气卡',
            init: 'disabled',
            item: {
              disabled: '禁用',
              once: '一次',
              twice: '两次',
              unlimited: '无限',
            },
          },
          continue_game: {
            name: '显示再战',
            init: false,
            onclick: function (bool) {
              game.saveConfig('continue_game', bool, this._link.config.mode);
              if (get.config('continue_game')) {
                if (!ui.continue_game && _status.over && !_status.brawl && !game.no_continue_game) {
                  ui.continue_game = ui.create.control('再战', game.reloadCurrent);
                }
              }
              else if (ui.continue_game) {
                ui.continue_game.close();
                delete ui.continue_game;
              }
            },
            intro: '游戏结束后可选择用相同的武将再进行一局游戏'
          },
          dierestart: {
            name: '死亡后显示重来',
            init: true,
            onclick: function (bool) {
              game.saveConfig('dierestart', bool, this._link.config.mode);
              if (get.config('dierestart')) {
                if (!ui.restart && game.me.isDead() && !_status.connectMode) {
                  ui.restart = ui.create.control('restart', game.reload);
                }
              }
              else if (ui.restart) {
                ui.restart.close();
                delete ui.restart;
              }
            }
          },
          revive: {
            name: '死亡后显示复活',
            init: false,
            onclick: function (bool) {
              game.saveConfig('revive', bool, this._link.config.mode);
              if (get.config('revive')) {
                if (!ui.revive && game.me.isDead()) {
                  ui.revive = ui.create.control('revive', ui.click.dierevive);
                }
              }
              else if (ui.revive) {
                ui.revive.close();
                delete ui.revive;
              }
            }
          },
          choice_zhu: {
            name: '地主候选武将数',
            init: '3',
            restart: true,
            item: {
              '3': '三',
              '4': '四',
              '5': '五',
              '6': '六',
              '8': '八',
              '10': '十',
            },
          },
          choice_fan: {
            name: '农民候选武将数',
            init: '3',
            restart: true,
            item: {
              '3': '三',
              '4': '四',
              '5': '五',
              '6': '六',
              '8': '八',
              '10': '十',
            },
          },
        }
      },
      longlaoguan: {
        name: '龙牢关',
        connect: {
          update: function (config, map) { },
          connect_change_card: {
            name: '启用手气卡',
            init: false,
            frequent: true,
            restart: true,
          },
        },
        config: {
          update: function (config, map) {
            if (config.double_character) {
              map.double_hp.show();
            }
            else {
              map.double_hp.hide();
            }
          },
          double_character: {
            name: '双将模式',
            init: false,
            frequent: true,
            restart: true,
          },
          double_hp: {
            name: '双将体力上限',
            init: 'pingjun',
            item: {
              hejiansan: '和减三',
              pingjun: '平均值',
              zuidazhi: '最大值',
              zuixiaozhi: '最小值',
              zonghe: '相加',
            },
            restart: true,
          },
          free_choose: {
            name: '自由选将',
            init: true,
            onclick: function (bool) {
              game.saveConfig('free_choose', bool, this._link.config.mode);
              if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
              if (!ui.cheat2 && get.config('free_choose')) ui.create.cheat2();
              else if (ui.cheat2 && !get.config('free_choose')) {
                ui.cheat2.close();
                delete ui.cheat2;
              }
            }
          },
          change_identity: {
            name: '自由选择身份和座位',
            init: true,
            onclick: function (bool) {
              game.saveConfig('change_identity', bool, this._link.config.mode);
              if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
              var dialog;
              if (ui.cheat2 && ui.cheat2.backup) dialog = ui.cheat2.backup;
              else dialog = _status.event.dialog;
              if (!_status.brawl || !_status.brawl.noAddSetting) {
                if (!dialog.querySelector('table') && get.config('change_identity')) _status.event.getParent().addSetting(dialog);
                else _status.event.getParent().removeSetting(dialog);
              }
              ui.update();
            }
          },
          change_choice: {
            name: '开启换将卡',
            init: true,
            onclick: function (bool) {
              game.saveConfig('change_choice', bool, this._link.config.mode);
              if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
              if (!ui.cheat && get.config('change_choice')) ui.create.cheat();
              else if (ui.cheat && !get.config('change_choice')) {
                ui.cheat.close();
                delete ui.cheat;
              }
            }
          },
          change_card: {
            name: '开启手气卡',
            init: 'disabled',
            item: {
              disabled: '禁用',
              once: '一次',
              twice: '两次',
              unlimited: '无限',
            },
          },
          continue_game: {
            name: '显示再战',
            init: false,
            onclick: function (bool) {
              game.saveConfig('continue_game', bool, this._link.config.mode);
              if (get.config('continue_game')) {
                if (!ui.continue_game && _status.over && !_status.brawl) {
                  ui.continue_game = ui.create.control('再战', game.reloadCurrent);
                }
              }
              else if (ui.continue_game) {
                ui.continue_game.close();
                delete ui.continue_game;
              }
            },
            intro: '游戏结束后可选择用相同的武将再进行一局游戏'
          },
          dierestart: {
            name: '死亡后显示重来',
            init: true,
            onclick: function (bool) {
              game.saveConfig('dierestart', bool, this._link.config.mode);
              if (get.config('dierestart')) {
                if (!ui.restart && game.me.isDead() && !_status.connectMode) {
                  ui.restart = ui.create.control('restart', game.reload);
                }
              }
              else if (ui.restart) {
                ui.restart.close();
                delete ui.restart;
              }
            }
          },
          revive: {
            name: '死亡后显示复活',
            init: false,
            onclick: function (bool) {
              game.saveConfig('revive', bool, this._link.config.mode);
              if (get.config('revive')) {
                if (!ui.revive && game.me.isDead()) {
                  ui.revive = ui.create.control('revive', ui.click.dierevive);
                }
              }
              else if (ui.revive) {
                ui.revive.close();
                delete ui.revive;
              }
            }
          },
          choice_zhu: {
            name: '龙皇候选武将数',
            init: '1',
            restart: true,
            item: {
              '1': '一',
            },
          },
          choice_fan: {
            name: '反抗军候选武将数',
            init: '5',
            restart: true,
            item: {
              '3': '三',
              '4': '四',
              '5': '五',
              '6': '六',
              '8': '八',
              '10': '十',
            },
          },
        }
      },
      strategy: {
        name: '战略',
        connect: {
          connect_single_mode: {
            name: '游戏模式',
            init: 'normal',
            item: {
              normal: '通常',
            },
            restart: true,
            frequent: true,
          },
          update: function (config, map) {
          },
        },
        config: {
          single_mode: {
            name: '游戏模式',
            init: 'dianjiang',
            item: {
              dianjiang: '点将单挑',
              // normal:'新1v1',
              // changban:'血战长坂坡',
            },
            restart: true,
            frequent: true,
          },
          enable_jin: {
            name: '启用晋势力武将',
            init: false,
            restart: true,
            frequent: true,
          },
          update: function (config, map) {
            if (config.single_mode != 'normal') {
              map.enable_jin.hide();
            }
            else {
              map.enable_jin.show();
            }
          },
        }
      },
      brawl: {
        name: '乱斗',
        config: {
          huanhuazhizhan: {
            name: '幻化之战',
            init: true,
            frequent: true
          },
          qunxionggeju: {
            name: '群雄割据',
            init: true,
            frequent: true
          },
          duzhansanguo: {
            name: '毒战三国',
            init: true,
            frequent: true
          },
          daoshiyueying: {
            name: '导师爱璃',
            init: true,
            frequent: true
          },
          weiwoduzun: {
            name: '唯我独尊',
            init: true,
            frequent: true
          },
          tongxingzhizheng: {
            name: '同姓之争',
            init: true,
            frequent: true
          },
          jiazuzhizheng: {
            name: '家族之争',
            init: true,
            frequent: true
          },
          // tongqueduopao:{
          // 	name:'铜雀夺袍',
          // 	init:true,
          // 	frequent:true
          // },
          tongjiangmoshi: {
            name: '同将模式',
            init: true,
            frequent: true
          },
          // baiyidujiang:{
          // 	name:'白衣渡江',
          // 	init:true,
          // 	frequent:true
          // },
          qianlidanji: {
            name: '千里单骑',
            init: true,
            frequent: true
          },
          // liangjunduilei:{
          // 	name:'两军对垒',
          // 	init:true,
          // 	frequent:true
          // },
          scene: {
            name: '创建场景',
            init: true,
            frequent: true
          }
        }
      },
      single: {
        name: '单挑',
        connect: {
          connect_single_mode: {
            name: '游戏模式',
            init: 'dianjiang',
            item: {
              dianjiang: '点将单挑',
              // normal:'新1v1',
              // changban:'血战长坂坡',
            },
            restart: true,
            frequent: true,
          },
          connect_enable_jin: {
            name: '启用晋势力武将',
            init: false,
            restart: true,
            frequent: true,
          },
          update: function (config, map) {
            if (config.connect_single_mode != 'normal') {
              map.connect_enable_jin.hide();
            }
            else {
              map.connect_enable_jin.show();
            }
          },
        },
        config: {
          single_mode: {
            name: '游戏模式',
            init: 'dianjiang',
            item: {
              dianjiang: '点将单挑',
              // normal:'新1v1',
              // changban:'血战长坂坡',
            },
            restart: true,
            frequent: true,
          },
          enable_jin: {
            name: '启用晋势力武将',
            init: false,
            restart: true,
            frequent: true,
          },
          update: function (config, map) {
            if (config.single_mode != 'normal') {
              map.enable_jin.hide();
            }
            else {
              map.enable_jin.show();
            }
          },
        }
      },
    };
    /**
     * 网络部分的消息处理（回调）函数
     * @type {!Object}
     */
    const _message = {
      server: {
        init: function (version, config, banned_info) {
          if (lib.node.banned.contains(banned_info)) {
            this.send('denied', 'banned');
          }
          else if (config.id && lib.playerOL && lib.playerOL[config.id]) {
            var player = lib.playerOL[config.id];
            player.setNickname();
            player.ws = this;
            player.isAuto = false;
            this.id = config.id;
            game.broadcast(function (player) {
              player.setNickname();
            }, player);
            this.send('reinit', lib.configOL, get.arenaState(), game.getState ? game.getState() : {}, game.ip, null, _status.onreconnect, _status.cardtag);
          }
          else if (version != lib.versionOL) {
            this.send('denied', 'version');
            lib.node.clients.remove(this);
            this.closed = true;
          }
          else if (!_status.waitingForPlayer) {
            if (game.phaseNumber && lib.configOL.observe) {
              lib.node.observing.push(this);
              this.send('reinit', lib.configOL, get.arenaState(), game.getState ? game.getState() : {}, game.ip, game.players[0].playerid, null, _status.cardtag);
              if (!ui.removeObserve) {
                ui.removeObserve = ui.create.system('移除旁观', function () {
                  lib.configOL.observe = false;
                  if (game.onlineroom) {
                    game.send('server', 'config', lib.configOL);
                  }
                  while (lib.node.observing.length) {
                    lib.node.observing.shift().ws.close();
                  }
                  this.remove();
                  delete ui.removeObserve;
                }, true);
              }
            }
            else {
              this.send('denied', 'gaming');
              lib.node.clients.remove(this);
              this.closed = true;
            }
          }
          else if (lib.node.clients.length - (window.isNonameServer ? 1 : 0) >= parseInt(lib.configOL.number)) {
            this.send('denied', 'number');
            lib.node.clients.remove(this);
            this.closed = true;
          }
          else {
            if (config) {
              this.avatar = config.avatar;
              this.nickname = config.nickname;
            }
            for (var i = 0; i < game.connectPlayers.length; i++) {
              if (game.connectPlayers[i].classList.contains('unselectable2')) continue;
              if (game.connectPlayers[i] != game.me && !game.connectPlayers[i].playerid) {
                game.connectPlayers[i].playerid = this.id;
                game.connectPlayers[i].initOL(this.nickname, this.avatar);
                game.connectPlayers[i].ws = this;
                break;
              }
            }
            this.send('init', this.id, lib.configOL, game.ip, window.isNonameServer, game.roomId);
          }
        },
        inited: function () {
          this.inited = true;
          if (_status.waitingForPlayer) {
            game.updateWaiting();
          }
        },
        reinited: function () {
          this.inited = true;
        },
        result: function (result) {
          if (lib.node.observing.contains(this)) return;
          var player = lib.playerOL[this.id];
          if (player) {
            player.unwait(result);
          }
        },
        startGame: function () {
          if (this.id == game.onlinezhu) {
            game.resume();
          }
        },
        changeRoomConfig: function (config) {
          if (this.id == game.onlinezhu) {
            game.broadcastAll(function (config) {
              for (var i in config) {
                lib.configOL[i] = config[i];
              }
              if (ui.connectStartBar) {
                ui.connectStartBar.firstChild.innerHTML = get.modetrans(lib.configOL, true);
              }
            }, config);
            if (lib.configOL.mode == 'identity' && lib.configOL.identity_mode == 'zhong' && game.connectPlayers) {
              for (var i = 0; i < game.connectPlayers.length; i++) {
                game.connectPlayers[i].classList.remove('unselectable2');
              }
              lib.configOL.number = 8;
              game.updateWaiting();
            }
            if (game.onlineroom) {
              game.send('server', 'config', lib.configOL);
            }
            for (var i = 0; i < game.connectPlayers.length; i++) {
              if (game.connectPlayers[i].playerid == this.id) {
                game.connectPlayers[i].chat('房间设置已更改');
              }
            }
          }
        },
        changeNumConfig: function (num, index, bool) {
          if (this.id == game.onlinezhu) {
            lib.configOL.number = num;
            game.send('server', 'config', lib.configOL);
            if (game.connectPlayers && game.connectPlayers[index]) {
              if (bool) {
                game.connectPlayers[index].classList.add('unselectable2');
              }
              else {
                game.connectPlayers[index].classList.remove('unselectable2');
              }
              game.updateWaiting();
            }
          }
        },
        throwEmotion: function (target, emotion) {
          if (lib.node.observing.contains(this)) return;
          var player = lib.playerOL[this.id];
          if (player) {
            player.throwEmotion(target, emotion);
          }
        },
        emotion: function (id, pack, emotion) {
          if (lib.node.observing.contains(this)) return;
          var that = this;
          if (!this.id || (!lib.playerOL[this.id] && (!game.connectPlayers || !function () {
            for (var i = 0; i < game.connectPlayers.length; i++) {
              if (game.connectPlayers[i].playerid == that.id) {
                return true;
              }
            }
            return false;
          }()))) return;
          var player;
          if (lib.playerOL[id]) {
            player = lib.playerOL[id];
          }
          else if (game.connectPlayers) {
            for (var i = 0; i < game.connectPlayers.length; i++) {
              if (game.connectPlayers[i].playerid == id) {
                player = game.connectPlayers[i]; break;
              }
            }
          }
          if (player) element.player.emotion.apply(player, [pack, emotion]);
        },
        chat: function (id, str) {
          var that = this;
          if (!this.id || (!lib.playerOL[this.id] && (!game.connectPlayers || !function () {
            for (var i = 0; i < game.connectPlayers.length; i++) {
              if (game.connectPlayers[i].playerid == that.id) {
                return true;
              }
            }
            return false;
          }()))) return;
          var player;
          if (lib.playerOL[id]) {
            player = lib.playerOL[id];
          }
          else if (game.connectPlayers) {
            for (var i = 0; i < game.connectPlayers.length; i++) {
              if (game.connectPlayers[i].playerid == id) {
                player = game.connectPlayers[i]; break;
              }
            }
          }
          if (player) element.player.chat.call(player, str);
        },
        giveup: function (player) {
          if (lib.node.observing.contains(this) || !player || !player._giveUp) return;
          _status.event.next.length = 0;
          game.createEvent('giveup', false).setContent(function () {
            game.log(player, '投降');
            player.popup('投降');
            player.die('nosource');
          }).player = player;
        },
        auto: function () {
          if (lib.node.observing.contains(this)) return;
          var player = lib.playerOL[this.id];
          if (player) {
            player.isAuto = true;
            player.setNickname(player.nickname + ' - 托管');
            game.broadcast(function (player) {
              player.setNickname(player.nickname + ' - 托管');
            }, player);
          }
        },
        unauto: function () {
          if (lib.node.observing.contains(this)) return;
          var player = lib.playerOL[this.id];
          if (player) {
            player.isAuto = false;
            player.setNickname(player.nickname);
            game.broadcast(function (player) {
              player.setNickname(player.nickname);
            }, player);
          }
        },
        exec: function (func) {
          // if(typeof func=='function'){
          //     var args=Array.from(arguments);
          //     args.shift();
          //     func.apply(this,args);
          // }
        },
        log: function () {
          var items = [];
          try {
            for (var i = 0; i < arguments.length; i++) {
              eval('items.push(' + arguments[i] + ')');
            }
          }
          catch (e) {
            this.send('log', ['err']);
            return;
          }
          this.send('log', items);
        }
      },
      client: {
        log: function (arr) {
          if (Array.isArray(arr)) {
            for (var i = 0; i < arr.length; i++) {
              console.log(arr[i]);
            }
          }
        },
        opened: function () {
          game.send('init', lib.versionOL, {
            id: game.onlineID,
            avatar: lib.config.connect_avatar,
            nickname: get.connectNickname()
          }, lib.config.banned_info);
          if (ui.connecting && !ui.connecting.splashtimeout) {
            ui.connecting.firstChild.innerHTML = '重连成功';
          }
        },
        onconnection: function (id) {
          var ws = { wsid: id };
          for (var i in element.nodews) {
            ws[i] = element.nodews[i];
          }
          lib.wsOL[id] = ws;
          init.connection(ws);
        },
        onmessage: function (id, message) {
          if (lib.wsOL[id]) {
            lib.wsOL[id].onmessage(message);
          }
        },
        onclose: function (id) {
          if (lib.wsOL[id]) {
            lib.wsOL[id].onclose();
          }
        },
        selfclose: function () {
          if (game.online || game.onlineroom) {
            if ((game.servermode || game.onlinehall) && _status.over) {
              // later
            }
            else {
              game.saveConfig('tmp_user_roomId');
            }
          }
          game.ws.close();
        },
        reloadroom: function (forced) {
          if (window.isNonameServer && (forced || !_status.protectingroom)) {
            game.reload();
          }
        },
        createroom: function (index, config, mode) {
          game.online = false;
          game.onlineroom = true;
          game.roomId = index;
          lib.node = {};
          if (config && mode && window.isNonameServer) {
            if (mode == 'auto') {
              mode = lib.configOL.mode;
            }
            game.switchMode(mode, config);
          }
          else {
            game.switchMode(lib.configOL.mode);
          }
          ui.create.connecting(true);
        },
        enterroomfailed: function () {
          alert('请稍后再试');
          _status.enteringroom = false;
          ui.create.connecting(true);
        },
        roomlist: function (list, events, clients, wsid) {
          game.send('server', 'key', [game.onlineKey, lib.version]);
          game.online = true;
          game.onlinehall = true;
          lib.config.recentIP.remove(_status.ip);
          lib.config.recentIP.unshift(_status.ip);
          lib.config.recentIP.splice(5);
          if (!lib.config.reconnect_info || lib.config.reconnect_info[0] != _status.ip) {
            game.saveConfig('reconnect_info', [_status.ip, null]);
          }
          game.saveConfig('recentIP', lib.config.recentIP);
          _status.connectMode = true;

          game.clearArena();
          game.clearConnect();
          ui.pause.hide();
          ui.auto.hide();

          clearTimeout(_status.createNodeTimeout);
          game.send('server', 'changeAvatar', get.connectNickname(), lib.config.connect_avatar);

          var proceed = function () {
            game.ip = get.trimip(_status.ip);
            ui.create.connectRooms(list);
            if (events) {
              ui.connectEvents = ui.create.div('.forceopaque.menubutton.large.connectevents.pointerdiv', '约战', ui.window, ui.click.connectEvents);
              ui.connectEventsCount = ui.create.div('.forceopaque.menubutton.icon.connectevents.highlight.hidden', '', ui.window);
              ui.connectClients = ui.create.div('.forceopaque.menubutton.large.connectevents.pointerdiv.left', '在线', ui.window, ui.click.connectClients);
              ui.connectClientsCount = ui.create.div('.forceopaque.menubutton.icon.connectevents.highlight.left', '1', ui.window);
              ui.createRoomButton = ui.create.div('.forceopaque.menubutton.large.connectevents.pointerdiv.left2', '创建房间', ui.window, function () {
                if (!_status.creatingroom) {
                  _status.creatingroom = true;
                  ui.click.connectMenu();
                }
              });
              if (events.length) {
                ui.connectEventsCount.innerHTML = events.filter(function (evt) {
                  return evt.creator == game.onlineKey || !get.is.banWords(evt.content)
                }).length;
                ui.connectEventsCount.show();
              }
            }
            game.wsid = wsid;
            _message.client.updaterooms(list, clients);
            _message.client.updateevents(events);
            ui.exitroom = ui.create.system('退出房间', function () {
              game.saveConfig('tmp_owner_roomId');
              game.saveConfig('tmp_user_roomId');
              if (ui.rooms) {
                game.saveConfig('reconnect_info');
              }
              else {
                if (lib.config.reconnect_info) {
                  lib.config.reconnect_info.length = 1;
                  game.saveConfig('reconnect_info', lib.config.reconnect_info);
                }
              }
              game.reload();
            }, true);

            var findRoom = function (id) {
              for (var room of ui.rooms) {
                if (room.key == id) return room;
              }
              return false;
            };
            if (typeof lib.config.tmp_owner_roomId == 'string') {
              if (typeof game.roomId != 'string' && !findRoom(lib.config.tmp_owner_roomId)) {
                lib.configOL.mode = lib.config.connect_mode;
                game.roomId = lib.config.tmp_owner_roomId;
              }
              game.saveConfig('tmp_owner_roomId');
            }
            if (typeof lib.config.tmp_user_roomId == 'string') {
              if (typeof game.roomId != 'string') {
                if (findRoom(lib.config.tmp_user_roomId)) {
                  game.roomId = lib.config.tmp_user_roomId;
                }
                else {
                  ui.create.connecting();
                  (function () {
                    var n = 10;
                    var id = lib.config.tmp_user_roomId;
                    var interval = setInterval(function () {
                      if (n > 0) {
                        n--;
                        if (findRoom(id)) {
                          clearInterval(interval);
                          game.send('server', 'enter', id, get.connectNickname(), lib.config.connect_avatar);
                        }
                      }
                      else {
                        ui.create.connecting(true);
                        clearInterval(interval);
                      }
                    }, 500);
                  }());
                }
              }
              game.saveConfig('tmp_user_roomId');
            }

            if (window.isNonameServer) {
              var cfg = 'pagecfg' + window.isNonameServer;
              if (lib.config[cfg]) {
                lib.configOL = lib.config[cfg][0];
                game.send('server', 'server', lib.config[cfg].slice(1));
                game.saveConfig(cfg);
                _status.protectingroom = true;
                setTimeout(function () {
                  _status.protectingroom = false;
                  if (!lib.node || !lib.node.clients || !lib.node.clients.length) {
                    game.reload();
                  }
                }, 15000);
              }
              else {
                game.send('server', 'server');
              }
            }
            else if (typeof game.roomId == 'string') {
              var room = findRoom(game.roomId);
              if (game.roomIdServer && room && (room.serving || !room.version)) {
                console.log();
                if (lib.config.reconnect_info) {
                  lib.config.reconnect_info[2] = null;
                  game.saveConfig('reconnect_info', lib.config.reconnect_info);
                }
              }
              else {
                ui.create.connecting();
                game.send('server', (game.roomId == game.onlineKey) ? 'create' : 'enter', game.roomId, get.connectNickname(), lib.config.connect_avatar);
              }
            }
            init.onfree();
          }
          if (_status.event.parent) {
            game.forceOver('noover', proceed);
          }
          else {
            proceed();
          }
        },
        updaterooms: function (list, clients) {
          if (ui.rooms) {
            var map = {}, map2 = {};
            for (var i of ui.rooms) map2[i.key] = true;
            for (var i of list) {
              if (!i) continue;
              map[i[4]] = i;
            }
            ui.window.classList.add('more_room');
            for (var i = 0; i < ui.rooms.length; i++) {
              if (!map[ui.rooms[i].key]) {
                ui.rooms[i].remove();
                ui.rooms.splice(i--, 1);
              }
              else ui.rooms[i].initRoom(list[i]);
            }
            for (var i of list) {
              if (!i) continue;
              map[i[4]] = i;
              if (!map2[i[4]]) {
                var player = ui.roombase.add('<div class="popup text pointerdiv" style="width:calc(100% - 10px);display:inline-block;white-space:nowrap">空房间</div>');
                player.roomindex = i;
                player.initRoom = element.player.initRoom;
                player.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.connectroom);
                player.initRoom(i);
                ui.rooms.push(player);
              }
            }
          }
          _message.client.updateclients(clients, true);
        },
        updateclients: function (clients, bool) {
          if (clients && ui.connectClients) {
            ui.connectClients.info = clients;
            ui.connectClientsCount.innerHTML = clients.length;
          }
          if (_status.connectClientsCallback) {
            _status.connectClientsCallback();
          }
        },
        updateevents: function (events) {
          if (events && ui.connectEvents) {
            ui.connectEvents.info = events;
            var num = events.filter(function (evt) {
              return typeof evt.creator == 'string' && (evt.creator == game.onlineKey || !get.is.banWords(evt.content))
            }).length;
            if (num) {
              ui.connectEventsCount.innerHTML = num;
              ui.connectEventsCount.show();
            }
            else {
              ui.connectEventsCount.hide();
            }
            if (_status.connectEventsCallback) {
              _status.connectEventsCallback();
            }
          }
        },
        eventsdenied: function (reason) {
          var str = '创建约战失败';
          if (reason == 'total') {
            str += '，约战总数不能超过20';
          }
          else if (reason == 'time') {
            str += '，时间已过';
          }
          else if (reason == 'ban') {
            str += '，请注意文明发言';
          }
          alert(str);
        },
        init: function (id, config, ip, servermode, roomId) {
          game.online = true;
          game.onlineID = id;
          game.ip = ip;
          game.servermode = servermode;
          game.roomId = roomId;
          if (game.servermode) {
            game.saveConfig('reconnect_info', [_status.ip, id, game.roomId]);
          }
          else {
            game.saveConfig('reconnect_info', [_status.ip, id]);
            game.saveConfig('tmp_user_roomId', roomId);
          }
          lib.config.recentIP.remove(_status.ip);
          lib.config.recentIP.unshift(_status.ip);
          lib.config.recentIP.splice(5);
          game.saveConfig('recentIP', lib.config.recentIP);
          _status.connectMode = true;
          lib.configOL = config;
          lib.playerOL = {};
          lib.cardOL = {};

          game.clearArena();
          game.finishCards();
          ui.create.roomInfo();
          ui.create.chat();
          if (game.servermode) {
            ui.create.connectPlayers(get.modetrans(config, true));
          }
          else {
            ui.create.connectPlayers(ip);
          }
          ui.pause.hide();
          ui.auto.hide();
          game.clearConnect();
          clearTimeout(_status.createNodeTimeout);

          var proceed = function () {
            game.loadModeAsync(config.mode, function (mode) {
              for (var i in mode.ai) {
                if (typeof mode.ai[i] == 'object') {
                  if (ai[i] == undefined) ai[i] = {};
                  for (var j in mode.ai[i]) {
                    ai[i][j] = mode.ai[i][j];
                  }
                }
                else {
                  ai[i] = mode.ai[i];
                }
              }
              for (var i in mode.get) {
                if (typeof mode.get[i] == 'object') {
                  if (get[i] == undefined) get[i] = {};
                  for (var j in mode.get[i]) {
                    get[i][j] = mode.get[i][j];
                  }
                }
                else {
                  get[i] = mode.get[i];
                }
              }
              for (var i in mode.translate) {
                lib.translate[i] = mode.translate[i];
              }
              if (mode.game) {
                game.getIdentityList = mode.game.getIdentityList;
                game.updateState = mode.game.updateState;
                game.getRoomInfo = mode.game.getRoomInfo;
              }
              if (mode.element && mode.element.player) {
                for (var i in mode.element.player) {
                  element.player[i] = mode.element.player[i];
                }
              }
              if (mode.skill) {
                for (var i in mode.skill) {
                  lib.skill[i] = mode.skill[i];
                }
              }
              if (mode.card) {
                for (var i in mode.card) {
                  lib.card[i] = mode.card[i];
                }
              }
              game.finishCards();
              if (mode.characterPack) {
                for (var i in mode.characterPack) {
                  lib.characterPack[i] = mode.characterPack[i];
                }
              }
              _status.event = {
                finished: true,
                next: [],
                after: []
              };
              _status.paused = false;
              game.createEvent('game', false).setContent(init.startOnline);
              game.loop();
              game.send('inited');
              ui.create.connecting(true);
            });
          }
          if (_status.event.parent) {
            game.forceOver('noover', proceed);
          }
          else {
            proceed();
          }
          for (var i in lib.characterPack) {
            for (var j in lib.characterPack[i]) {
              lib.character[j] = lib.character[j] || lib.characterPack[i][j];
            }
          }
        },
        reinit: function (config, state, state2, ip, observe, onreconnect, cardtag) {
          ui.auto.show();
          ui.pause.show();
          game.clearConnect();
          clearTimeout(_status.createNodeTimeout);
          game.online = true;
          game.ip = ip;
          game.servermode = state.servermode;
          game.roomId = state.roomId;
          if (state.over) {
            _status.over = true;
          }
          if (observe) {
            game.observe = true;
            game.onlineID = null;
            game.roomId = null;
          }
          if (game.servermode && !observe) {
            game.saveConfig('reconnect_info', [_status.ip, game.onlineID, game.roomId]);
          }
          else {
            game.saveConfig('reconnect_info', [_status.ip, game.onlineID]);
            if (!observe) {
              game.saveConfig('tmp_user_roomId', game.roomId);
            }
          }
          _status.connectMode = true;
          lib.configOL = config;
          lib.playerOL = {};
          lib.cardOL = {};

          game.loadModeAsync(config.mode, function (mode) {
            for (var i in mode.ai) {
              if (typeof mode.ai[i] == 'object') {
                if (ai[i] == undefined) ai[i] = {};
                for (var j in mode.ai[i]) {
                  ai[i][j] = mode.ai[i][j];
                }
              }
              else {
                ai[i] = mode.ai[i];
              }
            }
            for (var i in mode.get) {
              if (typeof mode.get[i] == 'object') {
                if (get[i] == undefined) get[i] = {};
                for (var j in mode.get[i]) {
                  get[i][j] = mode.get[i][j];
                }
              }
              else {
                get[i] = mode.get[i];
              }
            }
            for (var i in mode.translate) {
              lib.translate[i] = mode.translate[i];
            }
            if (mode.game) {
              game.getIdentityList = mode.game.getIdentityList;
              game.updateState = mode.game.updateState;
            }
            if (mode.element && mode.element.player) {
              for (var i in mode.element.player) {
                element.player[i] = mode.element.player[i];
              }
            }
            if (mode.skill) {
              for (var i in mode.skill) {
                lib.skill[i] = mode.skill[i];
              }
            }
            game.finishCards();
            if (mode.characterPack) {
              for (var i in mode.characterPack) {
                lib.characterPack[i] = mode.characterPack[i];
              }
            }
            if (mode.onreinit) {
              mode.onreinit();
            }
            _status.cardtag = get.parsedResult(cardtag);
            state = get.parsedResult(state);
            game.players = [];
            game.dead = [];
            for (var i in lib.characterPack) {
              for (var j in lib.characterPack[i]) {
                lib.character[j] = lib.character[j] || lib.characterPack[i][j];
              }
            }
            game.clearArena();
            game.finishCards();
            if (!observe) {
              ui.create.chat();
              if (ui.exitroom) {
                ui.exitroom.remove();
                delete ui.exitroom;
              }
            }
            else {
              if (!ui.exitroom) {
                ui.create.system('退出旁观', function () {
                  game.saveConfig('reconnect_info');
                  game.reload();
                }, true);
              }
              if (!lib.configOL.observe_handcard) {
                ui.arena.classList.add('observe');
              }
            }
            ui.arena.setNumber(state.number);
            _status.mode = state.mode;
            lib.inpile = state.inpile;
            var pos = state.players[observe || game.onlineID].position;
            for (var i in state.players) {
              var info = state.players[i];
              var player = ui.create.player(ui.arena).animate('start');
              player.dataset.position = (info.position < pos) ? info.position - pos + parseInt(state.number) : info.position - pos;
              if (i == observe || i == game.onlineID) {
                game.me = player;
              }
              if (player.setModeState) {
                player.setModeState(info);
              }
              else {
                player.init(info.name1, info.name2);
              }
              if (!info.unseen) player.classList.remove('unseen');
              if (!info.unseen2) player.classList.remove('unseen2');
              if (!player.isUnseen(2) && player.$.nohp) {
                delete player.$.nohp;
                player.node.hp.show();
              }
              player.playerid = i;
              player.nickname = info.nickname;
              player.changeGroup(info.group, false, false);
              player.identity = info.identity;
              player.identityShown = info.identityShown;
              player.hp = info.hp;
              player.maxHp = info.maxHp;
              player.hujia = info.hujia;
              player.sex = info.sex;
              player.side = info.side;
              player.phaseNumber = info.phaseNumber,
                player.setNickname();
              if (info.dead) {
                player.classList.add('dead');
                if (lib.config.die_move) {
                  player.$dieflip();
                }
                if (element.player.$dieAfter) {
                  element.player.$dieAfter.call(player);
                }
                game.dead.push(player);
              }
              else {
                game.players.push(player);
              }
              if (info.linked) {
                player.addLink();
              }
              if (info.turnedover) {
                player.classList.add('turnedover');
              }
              if (info.disableJudge) {
                player.$disableJudge();
              }
              if (Array.isArray(info.disableEquip)) {
                for (var ii = 0; ii < info.disableEquip.length; ii++) {
                  player.$disableEquip(info.disableEquip[ii]);
                }
              }

              player.directgain(info.handcards);
              lib.playerOL[i] = player;
              for (var i = 0; i < info.equips.length; i++) {
                player.$equip(info.equips[i]);
              }
              for (var i = 0; i < info.handcards.length; i++) {
                info.handcards[i].addGaintag(info.gaintag[i]);
              }
              for (var i = 0; i < info.specials.length; i++) {
                info.specials[i].classList.add('glows');
              }
              for (var i = 0; i < info.judges.length; i++) {
                if (info.views[i] && info.views[i] != info.judges[i]) {
                  info.judges[i].classList.add('fakejudge');
                  info.judges[i].viewAs = info.views[i];
                  info.judges[i].node.background.innerHTML = lib.translate[info.views[i] + '_bg'] || get.translation(info.views[i])[0]
                }
                player.node.judges.appendChild(info.judges[i]);
              }
              ui.updatej(player);
              if (!player.setModeState) {
                if (!game.getIdentityList && info.identityNode) {
                  player.node.identity.innerHTML = info.identityNode[0];
                  player.node.identity.dataset.color = info.identityNode[1];
                }
                else if (player == game.me || player.identityShown || observe) {
                  player.setIdentity();
                  player.forceShown = true;
                }
                else {
                  player.setIdentity('cai');
                }
                if (!lib.configOL.observe_handcard && (lib.configOL.mode == 'identity' || lib.configOL.mode == 'guozhan')) {
                  if (observe && !player.identityShown) {
                    player.setIdentity('cai');
                    player.forceShown = false;
                  }
                }
              }
              player.update();
            }
            game.arrangePlayers();
            ui.create.me(true);

            _status.event = {
              finished: true,
              next: [],
              after: []
            };
            _status.paused = false;
            _status.dying = get.parsedResult(state.dying) || [];

            if (game.updateState) {
              game.updateState(state2);
            }
            var next = game.createEvent('game', false);
            next.setContent(init.startOnline);
            if (observe) {
              next.custom.replace.target = function (player) {
                if (!lib.configOL.observe_handcard && lib.configOL.mode == 'guozhan') {
                  return;
                }
                if (player.isAlive()) {
                  if (!game.me.identityShown && lib.configOL.mode == 'guozhan') {
                    game.me.node.identity.firstChild.innerHTML = '猜';
                    game.me.node.identity.dataset.color = 'unknown';
                  }
                  game.swapPlayer(player);
                  if (!game.me.identityShown && lib.configOL.mode == 'guozhan') {
                    game.me.node.identity.firstChild.innerHTML = '';
                  }
                }
              }
            }
            else {
              if (Array.isArray(onreconnect)) {
                onreconnect.shift().apply(this, onreconnect);
              }
            }
            game.loop();
            game.send('reinited');
            game.showHistory();
            _status.gameStarted = true;
            if (lib.config.show_cardpile) {
              ui.cardPileButton.style.display = '';
            }
            if (!observe && game.me && (game.me.isDead() || _status.over)) {
              ui.create.exit();
            }
            ui.updatehl();
            ui.create.connecting(true);
          });
        },
        exec: function (func) {
          var key = game.onlineKey;
          if (typeof func == 'function') {
            var args = Array.from(arguments);
            args.shift();
            func.apply(this, args);
          }
          if (key) {
            game.onlineKey = key;
            localStorage.setItem(lib.configprefix + 'key', game.onlineKey);
          }
        },
        denied: function (reason) {
          switch (reason) {
            case 'version':
              alert('加入失败：版本不匹配，请将游戏更新至最新版');
              game.saveConfig('tmp_owner_roomId');
              game.saveConfig('tmp_user_roomId');
              game.saveConfig('reconnect_info');
              break;
            case 'gaming': alert('加入失败：游戏已开始'); break;
            case 'number': alert('加入失败：房间已满'); break;
            case 'banned': alert('加入失败：房间拒绝你加入'); break;
            case 'key':
              alert('您的游戏版本过低，请升级到最新版');
              game.saveConfig('tmp_owner_roomId');
              game.saveConfig('tmp_user_roomId');
              game.saveConfig('reconnect_info');
              break;
            case 'offline':
              if (_status.paused && _status.event.name == 'game') {
                setTimeout(game.resume, 500);
              }
              break;
          }
          game.ws.close();
          if (_status.connectDenied) {
            _status.connectDenied();
          }
        },
        cancel: function (id) {
          if (_status.event.id == id && _status.event.isMine() && _status.paused && _status.imchoosing) {
            ui.click.cancel();
            if (ui.confirm) {
              ui.confirm.close();
            }
            if (_status.event.result) {
              _status.event.result.id = id;
            }
          }
        },
        closeDialog: function (id) {
          var dialog = get.idDialog(id);
          if (dialog) {
            dialog.close();
          }
        },
        createDialog: function (id) {
          var args = Array.from(arguments);
          args.shift();
          ui.create.dialog.apply(this, args).videoId = id;
        },
        gameStart: function () {
          for (var i = 0; i < game.connectPlayers.length; i++) {
            game.connectPlayers[i].delete();
          }
          delete game.connectPlayers;
          if (ui.connectStartButton) {
            ui.connectStartButton.delete();
            delete ui.connectStartButton;
          }
          if (ui.connectStartBar) {
            ui.connectStartBar.delete();
            delete ui.connectStartBar;
          }
          if (ui.roomInfo) {
            ui.roomInfo.remove();
            delete ui.roomInfo;
          }
          if (ui.exitroom) {
            ui.exitroom.remove();
            delete ui.exitroom;
          }
          ui.auto.show();
          ui.pause.show();
          if (lib.config.show_cardpile) {
            ui.cardPileButton.style.display = '';
          }
          _status.gameStarted = true;
          game.showHistory();
        },
        updateWaiting: function (map) {
          if (!game.connectPlayers) return;
          if (!lib.translate.zhu) {
            lib.translate.zhu = '主';
          }
          game.onlinezhu = false;
          _status.waitingForPlayer = true;
          for (var i = 0; i < map.length; i++) {
            if (map[i] == 'disabled') {
              game.connectPlayers[i].classList.add('unselectable2');
            }
            else {
              game.connectPlayers[i].classList.remove('unselectable2');
              if (map[i]) {
                game.connectPlayers[i].initOL(map[i][0], map[i][1]);
                game.connectPlayers[i].playerid = map[i][2];
                if (map[i][3] == 'zhu') {
                  game.connectPlayers[i].setIdentity('zhu');
                  if (map[i][2] == game.onlineID) {
                    game.onlinezhu = true;
                    if (ui.roomInfo) {
                      ui.roomInfo.innerHTML = '房间设置';
                    }
                    if (ui.connectStartButton) {
                      ui.connectStartButton.innerHTML = '开始游戏';
                    }
                  }
                }
                else {
                  game.connectPlayers[i].node.identity.firstChild.innerHTML = '';
                }
              }
              else {
                game.connectPlayers[i].uninitOL();
                delete game.connectPlayers[i].playerid;
              }
            }
          }
        }
      }
    };
    /**
     * 初始化
     * @namespace
     */
    const init = __webpack_require__(669)(element, _mode, _message)
    return {
      figure: '<span style="font-family: LuoLiTi2;color: #dbb">',
      figurer: (text) => ` ${lib.figure}${text}</span> `,
      spanClass: (str, classes) => {
        return `<span class="${classes}">${str}</span>`
      },
      discoloration1: "<samp id='渐变'><font face='yuanli'><style>#渐变{animation:change 0.8s linear 0s infinite;}@keyframes change{0% {color:#FF0000;}20%{color:#F0A00F;}50% {color:#F000FF;}80%{color: #F0A00F;}100%{color:#FF0000;}}</style>",

      changeLog: [],
      updates: [],
      canvasUpdates: [],
      video: [],
      skilllist: [],
      connectBanned: [],
      characterIntro: {},
      characterTitle: {},
      characterPack: {},
      characterFilter: {},
      characterSort: {},
      characterReplace: {},
      dynamicTranslate: {},
      cardPack: {},
      onresize: [],
      onphase: [],
      onwash: [],
      onover: [],
      ondb: [],
      ondb2: [],
      chatHistory: [],
      animate: {
        skill: {},
        card: {},
      },
      arenaReady: [],
      onfree: [],
      inpile: [],
      extensions: [],
      extensionPack: {},
      cardType: {},
      hook: { globaltrigger: {}, globalskill: {} },
      hookmap: {},
      imported: {},
      layoutfixed: ['chess', 'tafang', 'stone'],//特殊样式模式
      /**
       * 角色选择弹窗中的特殊选项
       * ['收藏', '最近']
       * @name lib.characterDialogGroup
       * @see {@link ui.create.characterDialog}
       */
      characterDialogGroup: {
        '收藏': function (name, capt) {
          return lib.config.favouriteCharacter.contains(name) ? capt : null;
        },
        '最近': function (name, capt) {
          var list = get.config('recentCharacter') || [];
          return list.contains(name) ? capt : null;
        }
      },
      /**
       * 监听节点动画结束
       * @param {HTMLDivELement} node 节点
       */
      listenEnd: function (node) {
        if (!node._listeningEnd) {
          node._listeningEnd = true;
          node.listenTransition(function () {
            delete node._listeningEnd;
            if (node._onEndMoveDelete) {
              node.moveDelete(node._onEndMoveDelete);
            }
            else if (node._onEndDelete) {
              node.delete();
            }
            node._transitionEnded = true;
          });
        }
      },
      /**
       * lib状态，储存如delayed、videoId等动态数据
       * @type {!Object}
       */
      status: {
        running: false,
        canvas: false,
        time: 0,
        reload: 0,
        delayed: 0,
        frameId: 0,
        videoId: 0,
        globalId: 0,
      },
      /**
       * 帮助菜单
       * @type {!Object}
       */
      help: {
        'FAQ': '<ul><li>Q：关于家长麦技能中的“除外”，有详细的说明吗？<li>A：你不执行奖惩，不能发动技能或使用牌，不能指定目标或被选择为目标（令角色解除除外状态除外）；计算有关全场角色的数据时，不计算你的存在：当你于回合内被除外时，结束你的回合（若当前有卡牌正在结算，则结算后再结束你的回合）。<br>' +
          '<li>Q：若角色有出牌阶段限制次数的技能，则其会因额外的出牌阶段多次发动此技能吗？<li>A：是的，但是一般情况仅限于主动释放的技能（比如下地的『引流』和MEA的『掠财』）。若不做特殊说明，额外出牌阶段结束时，角色回合内的技能使用次数均会清空，而卡牌使用次数不变。<br>' +
          '<li>Q：夜雾和lulu的技能改变出牌效果时，影响牌的使用次数吗？<li>A：不影响，牌的使用次数始终在牌使用或打出时计入。特别的，lulu的技能可以改变牌名，有可能影响牌的后续结算；而夜雾的技能不改变牌名，（虽然效果已经变化）与原牌名关联的效果不会受影响（如【初始服】之于【杀】【万箭】【南蛮】）<br>',

        '游戏操作': '<ul><li>长按/鼠标悬停/右键单击显示信息<li>触屏模式中，双指点击切换暂停；下划显示菜单，上划切换托管<li>键盘快捷键<br>' +
          '<table><tr><td>A<td>切换托管<tr><td>W<td>切换不询问无懈<tr><td>空格<td>暂停</table><li>编辑牌堆<br>在卡牌包中修改牌堆后，将自动创建一个临时牌堆，在所有模式中共用，当保存当前牌堆后，临时牌堆被清除。每个模式可设置不同的已保存牌堆，设置的牌堆优先级大于临时牌堆</ul>',
        // '游戏命令':'<div style="margin:10px">变量名</div><ul style="margin-top:0"><li>场上角色<br>game.players<li>阵亡角色<br>game.dead'+
        // '<li>玩家<br>game.me<li>玩家的上/下家<br>game.me.previous/next'+
        // '<li>玩家的上/下家（含阵亡）<br>game.me.previousSeat/<br>nextSeat'+
        // '<li>牌堆<br>ui.cardPile<li>弃牌堆<br>ui.discardPile</ul>'+
        // '<div style="margin:10px">角色属性</div><ul style="margin-top:0"><li>体力值<br>player.hp'+
        // '<li>体力上限<br>player.maxHp<li>身份<br>player.identity<li>手牌<br>player.getCards("h")<li>装备牌<br>player.getCards("e")<li>判定牌<br>player.getCards("j")'+
        // '<li>是否存活/横置/翻面<br>player.isAlive()/<br>isLinked()/<br>isTurnedOver()</ul>'+
        // '<div style="margin:10px">角色操作</div><ul style="margin-top:0"><li>受到伤害<br>player.damage(source,<br>num)'+
        // '<li>回复体力<br>player.recover(num)<li>摸牌<br>player.draw(num)<li>获得牌<br>player.gain(cards)<li>弃牌<br>player.discard(cards)'+
        // '<li>使用卡牌<br>player.useCard(card,<br>targets)<li>死亡<br>player.die()<li>复活<br>player.revive(hp)</ul>'+
        // '<div style="margin:10px">游戏操作</div><ul style="margin-top:0"><li>在命令框中输出结果<br>game.print(str)<li>清除命令框中的内容<br>cls<li>上一条/下一条输入的内容<br>up/down<li>游戏结束<br>game.over(bool)'+
        // '<li>角色资料<br>lib.character<li>卡牌资料<br>lib.card</ul>',
        '游戏名词': '<ul><li>智囊：无名杀默认为过河拆桥/无懈可击/无中生有/洞烛先机。牌堆中没有的智囊牌会被过滤。可在卡牌设置中自行增减。若没有可用的智囊，则改为随机选取的三种锦囊牌的牌名。' +
          '<li>仁库：部分武将使用的游戏外共通区域。至多包含六张牌。当有新牌注入后，若牌数超过上限，则将最早进入仁库的溢出牌置入弃牌堆。' +
          '<li>护甲：和体力类似，每点护甲可抵挡一点伤害，但不影响手牌上限。' +
          '<li>随从：通过技能获得，拥有独立的技能、手牌区和装备区（共享判定区），出场时替代主武将的位置；随从死亡时自动切换回主武将。' +
          '<li>发现：从三张随机亮出的牌中选择一张，若无特殊说明，则获得此牌。' +
          '<li>蓄力技：发动时可以增大黄色的数字。若如此做，红色数字于技能的结算过程中改为原来的两倍。'
      },
      /**
       * 设置(触屏: 长按[, 点击])|(鼠标: 悬浮, 右击[, 点击])弹窗
       * @name lib.setIntro
       * @param {!HTMLDivElement} node 要弹窗的节点
       * @param {?function} func 用于自定义弹窗的回调函数
       * @param {?boolean} left 如果为true，点击事件也能触发弹窗
       * @see {@link get.nodeintro}
       */
      setIntro: function (node, func, left) {
        if (lib.config.touchscreen) {
          if (left) {
            node.listen(ui.click.touchintro);
          }
          else {
            lib.setLongPress(node, ui.click.intro);
          }
        }
        else {
          if (left) {
            node.listen(ui.click.intro);
          }
          if (lib.config.hover_all) {
            lib.setHover(node, ui.click.hoverplayer);
          }
          if (lib.config.right_info) {
            node.oncontextmenu = ui.click.rightplayer;
          }
        }
        // if(!left){
        //     lib.setPressure(node,ui.click.rightpressure);
        // }
        if (func) {
          node._customintro = func;
        }
      },
      // setPressure:function(node,func){
      //     if(window.Pressure){
      //         window.Pressure.set(node,{change: func}, {polyfill: false});
      //     }
      // },
      setPopped: function (node, func, width, height, forceclick, paused2) {
        node._poppedfunc = func;
        node._poppedwidth = width;
        node._poppedheight = height;
        if (forceclick) {
          node.forceclick = true;
        }
        if (lib.config.touchscreen || forceclick) {
          node.listen(ui.click.hoverpopped);
        }
        else {
          node.addEventListener('mouseenter', ui.click.hoverpopped);
          // node.addEventListener('mouseleave',ui.click.hoverpopped_leave);
        }
        if (paused2) {
          node._paused2 = true;
        }
      },
      placePoppedDialog: function (dialog, e) {
        if (dialog._place_text) {
          if (dialog._place_text.firstChild.offsetWidth >= 190 ||
            dialog._place_text.firstChild.offsetHeight >= 30) {
            dialog._place_text.style.textAlign = 'left';
            dialog._place_text.style.marginLeft = '14px';
          }
        }
        if (e.touches && e.touches[0]) {
          e = e.touches[0];
        }
        var height = Math.min(ui.window.offsetHeight - 20, dialog.content.scrollHeight);
        if (dialog._mod_height) {
          height += dialog._mod_height;
        }
        dialog.style.height = height + 'px';
        if (e.clientX / game.documentZoom < ui.window.offsetWidth / 2) {
          dialog.style.left = (e.clientX / game.documentZoom + 10) + 'px';
        }
        else {
          dialog.style.left = (e.clientX / game.documentZoom - dialog.offsetWidth - 10) + 'px';
        }
        var idealtop = (e.clientY || 0) / game.documentZoom - dialog.offsetHeight / 2;
        if (typeof idealtop != 'number' || isNaN(idealtop) || idealtop <= 5) {
          idealtop = 5;
        }
        else if (idealtop + dialog.offsetHeight + 10 > ui.window.offsetHeight) {
          idealtop = ui.window.offsetHeight - 10 - dialog.offsetHeight;
        }
        dialog.style.top = idealtop + 'px';
      },
      /**
       * @callback lib.setHover~callback
       * @param {MouseEvent} e MouseEvent on mouse move
       * @returns {*}TODO
       */
      /**
       * 设置悬浮
       * 监听悬停事件
       * @function
       * @param {!HTMLElement} node
       * @param {?lib.setHover~callback} func 回调函数
       * @param {?number} hoveration 悬停的时间，如果为null，使用默认悬停事件 {@link GameConfig}
       * @param {?number} width 弹窗宽度，为null时不设置
       * @returns {!HTMLElement}
       */
      setHover: function (node, func, hoveration, width) {
        node._hoverfunc = func;
        if (typeof hoveration == 'number') {
          node._hoveration = hoveration;
        }
        if (typeof width == 'number') {
          node._hoverwidth = width
        }
        node.addEventListener('mouseenter', ui.click.mouseenter);
        node.addEventListener('mouseleave', ui.click.mouseleave);
        node.addEventListener('mousedown', ui.click.mousedown);
        node.addEventListener('mousemove', ui.click.mousemove);
        return node;
      },
      /**
       * 设置滚轮
       * 为节点监听滚动事件
       * @function
       * @param {!HTMLElement} node 要监听滚动事件的节点
       * @returns {!HTMLElement}
       */
      setScroll: function (node) {
        node.ontouchstart = ui.click.touchStart;
        node.ontouchmove = ui.click.touchScroll;
        node.style.WebkitOverflowScrolling = 'touch';
        return node;
      },
      /**
       * 设置鼠标滚轮（用于切换皮肤菜单）
       * 为节点监听鼠标滚轮事件
       * @function
       * @param {!HTMLElement} node 要监听鼠标滚轮事件的节点
       * @returns {!HTMLElement}
       */
      setMousewheel: function (node) {
        if (lib.config.mousewheel) node.onmousewheel = ui.click.mousewheel;
      },
      /**
       * 设置长按
       * 监听长按事件
       * @param {!HTMLElement} node 要监听长按事件的节点
       * @param {?function} func 回调事件
       * @returns {!HTMLElement}
       */
      setLongPress: function (node, func) {
        node.addEventListener('touchstart', ui.click.longpressdown);
        node.addEventListener('touchend', ui.click.longpresscancel);
        node._longpresscallback = func;
        return node;
      },
      /**
       * 更新`ui.canvas`
       * @param {!number} time 当前时间
       * @returns {(undefined|false)} 如果没有需要更新的`<canvas>`返回false
       */
      updateCanvas: function (time) {
        if (lib.canvasUpdates.length === 0) {
          lib.status.canvas = false;
          return false;
        }
        ui.canvas.width = ui.arena.offsetWidth;
        ui.canvas.height = ui.arena.offsetHeight;
        var ctx = ui.ctx;
        ctx.shadowBlur = 5;
        ctx.shadowColor = 'rgba(0,0,0,0.3)';
        ctx.strokeStyle = 'white';
        // ctx.lineCap='round';
        ctx.lineWidth = 3;
        ctx.save();
        for (var i = 0; i < lib.canvasUpdates.length; i++) {
          ctx.restore();
          ctx.save();
          var update = lib.canvasUpdates[i];
          if (!update.starttime) {
            update.starttime = time;
          }
          if (update(time - update.starttime, ctx) === false) {
            lib.canvasUpdates.splice(i--, 1);
          }
        }
      },
      /**
       * 一个启动函数，其中循环更新`lib.updates`直至没有需要更新的函数
       * @param {!number} time 当前时间
       */
      run: function (time) {
        lib.status.time = time;
        for (var i = 0; i < lib.updates.length; i++) {
          if (!lib.updates[i].hasOwnProperty('_time')) {
            lib.updates[i]._time = time;
          }
          if (lib.updates[i](time - lib.updates[i]._time - lib.status.delayed) === false) {
            lib.updates.splice(i--, 1);
          }
        }
        if (lib.updates.length) {
          lib.status.frameId = requestAnimationFrame(lib.run);
        }
        else {
          lib.status.time = 0;
          lib.status.delayed = 0;
        }
      },
      /**
       * 将date转化为对应的datetime并返回转化后的datetime
       * [recommend] 移到{@link get}中
       * @function
       * @param {Date} date
       * @returns {number} datetime
       * @see {@link get.utc}
       */
      getUTC: function (date) {
        return date.getTime();
      },
      /**
       * 保存录像
       */
      saveVideo: function () {
        if (_status.videoToSave) {
          game.export(init.encode(JSON.stringify(_status.videoToSave)),
            '无名杀 - 录像 - ' + _status.videoToSave.name[0] + ' - ' + _status.videoToSave.name[1]);
        }
      },
      /**
       * 测试用作弊方法
       * @name cheat
       */
      cheat: {
        i: function () {
          window.cheat = lib.cheat;
          window.game = game;
          window.ui = ui;
          window.get = get;
          window.ai = ai;
          window.lib = lib;
          window._status = _status;
        },
        dy: function () {
          var next = game.me.next;
          for (var i = 0; i < 10; i++) {
            if (next.identity != 'zhu') {
              break;
            }
            next = next.next;
          }
          next.die();
        },
        x: function () {
          var gl = function (dir, callback) {
            var files = [], folders = [];
            dir = '/Users/widget/Documents/extension/' + dir;
            lib.node.fs.readdir(dir, function (err, filelist) {
              for (var i = 0; i < filelist.length; i++) {
                if (filelist[i][0] != '.' && filelist[i][0] != '_') {
                  if (lib.node.fs.statSync(dir + '/' + filelist[i]).isDirectory()) {
                    folders.push(filelist[i]);
                  }
                  else {
                    files.push(filelist[i]);
                  }
                }
              }
              callback(folders, files);
            });
          }
          var args = Array.from(arguments);
          for (var i = 0; i < args.length; i++) {
            args[i] = args[i][0];
          }
          gl('', function (list) {
            if (args.length) {
              for (var i = 0; i < list.length; i++) {
                if (!args.contains(list[i][0])) {
                  list.splice(i--, 1);
                }
              }
            }
            if (list.length) {
              for (var i = 0; i < list.length; i++) {
                (function (str) {
                  gl(str, function (folders, files) {
                    if (files.length > 1) {
                      for (var i = 0; i < files.length; i++) {
                        if (files[i].indexOf('extension.js') != -1) {
                          files.splice(i--, 1);
                        }
                        else {
                          if (i % 5 == 0) {
                            str += '\n\t\t\t';
                          }
                          str += '"' + files[i] + '",';
                        }
                      }
                      console.log(str.slice(0, str.length - 1));
                    }
                  });
                }(list[i]));
              }
            }
          });
        },
        cfg: function () {
          var mode = lib.config.all.mode.slice(0);
          mode.remove('connect');
          mode.remove('brawl');
          var banned = ['shen_guanyu', 'shen_caocao', 'caopi', 're_daqiao', 'caorui',
            'daqiao', 'lingcao', 'liuzan', 'lusu', 'luxun', 'yanwen', 'zhouyu', 'ns_wangyue', 'gw_yenaifa',
            'old_caozhen', 'swd_jiangziya', 'xuhuang', 'maliang', 'guojia', 'simayi', 'swd_kangnalishi', 'hs_siwangzhiyi', 'hs_nozdormu', 'old_zhuzhi'];
          var bannedcards = ['zengbin'];
          var favs = ["hs_tuoqi", "hs_siwangxianzhi", "hs_xukongzhiying", "hs_hsjiasha", "gjqt_xieyi", "gjqt_yunwuyue", "gjqt_beiluo",
            "gjqt_cenying", "shen_lvmeng", "shen_zhaoyun", "shen_zhugeliang", "ow_ana", "chenlin", "ns_guanlu", "hs_guldan", "swd_guyue",
            "pal_jiangyunfan", "mtg_jiesi", "swd_lanyin", "pal_liumengli", "swd_muyun", "pal_nangonghuang", "swd_muyue", "pal_murongziying",
            "swd_qiner", "pal_shenqishuang", "hs_taisi", "wangji", "pal_xingxuan", "xunyou", "hs_yelise", "pal_yuejinzhao", "pal_yueqi",
            "gjqt_yuewuyi", "swd_yuxiaoxue", "ow_zhaliya", "zhangchunhua", "hs_zhihuanhua", "swd_zhiyin", "old_zhonghui", "gjqt_bailitusu",
            "hs_barnes", "ow_dva", "swd_hengai", "pal_jushifang", "hs_kazhakusi", "hs_lafamu", "ow_liekong", "hs_lreno", "pal_mingxiu",
            "swd_murongshi", "gw_oudimu", "gjqt_ouyangshaogong", "hs_pyros", "qinmi", "gw_sanhanya", "hs_selajin", "swd_shuwaner",
            "swd_situqiang", "hs_xialikeer", "pal_xuejian", "swd_yuchiyanhong", "swd_yuwentuo", "swd_zhaoyun", "zhugeliang", "gw_aigeleisi",
            "gw_aimin", "gjqt_aruan", "hs_aya", "swd_cheyun", "swd_chenjingchou", "gw_diandian", "swd_huzhongxian", "hs_jinglinglong",
            "hs_kaituozhe", "hs_kalimosi", "gw_linjing", "ow_luxiao", "re_luxun", "hs_morgl", "swd_sikongyu", "hs_sthrall", "sunquan",
            "sunshangxiang", "gw_yioufeisisp", "gw_yisilinni", "hs_yogg", "hs_ysera", "pal_yuntianhe", "zhugejin", "zhugeke", "gw_zhuoertan",
            "hs_anduin", "swd_anka", "ow_banzang", "ow_chanyata", "diaochan", "swd_duguningke", "sp_diaochan", "hetaihou", "ns_huamulan",
            "swd_huanglei", "swd_huanyuanzhi", "re_huatuo", "gw_huoge", "pal_jiangcheng", "yj_jushou", "swd_kendi", "yxs_libai",
            "mtg_lilianna", "xin_liru", "liuxie", "pal_lixiaoyao", "pal_longkui", "ns_nanhua", "swd_qi", "swd_septem", "gw_shasixiwusi",
            "ow_tianshi", "swd_weida", "gjqt_xiayize", "swd_xiyan", "hs_xsylvanas", "hs_yelinlonghou", "ow_yuanshi", "zuoci"];
          var vintage = ['tianjian', 'shuiyun', 'zhuyue', 'zhimeng', 'poyun', 'qianfang', 'xfenxin', 'danqing', 'ywuhun', 'tianwu', 'xuelu',
            'shahun', 'yuling', 'duhun', 'liaoyuan', 'touxi', 'wangchen', 'poyue', 'kunlunjing', 'huanhun', 'yunchou', 'tuzhen', 'cyqiaoxie',
            'mufeng', 'duanyi', 'guozao', 'yaotong', 'pozhen', 'tanlin', 'susheng', 'jikong', 'shouyin', 'jilve', 'hxunzhi', 'huodan', 'shanxian',
            'ziyu', 'kuoyin', 'feiren', 'zihui', 'jidong', 'baoxue', 'aqianghua', 'maoding', 'bfengshi', 'zhongdun', 'pingzhang', 'maichong',
            'guozai', 'jingxiang', 'yuelu', 'liechao', 'fengnu', 'hanshuang', 'enze', 'malymowang', 'xshixin', 'qingzun'];
          var favmodes = ["versus|three", "versus|four", "versus|two", "chess|combat"];
          for (var i = 0; i < mode.length; i++) {
            game.saveConfig(mode[i] + '_banned', banned);
            game.saveConfig(mode[i] + '_bannedcards', bannedcards);
          }
          var characters = lib.config.all.characters.slice(0);
          characters.remove('standard');
          characters.remove('old');
          game.saveConfig('vintageSkills', vintage);
          game.saveConfig('favouriteCharacter', favs);
          game.saveConfig('favouriteMode', favmodes);
          game.saveConfig('theme', 'simple');
          game.saveConfig('player_border', 'slim');
          game.saveConfig('cards', lib.config.all.cards);
          game.saveConfig('characters', characters);
          game.saveConfig('change_skin', false);
          game.saveConfig('show_splash', 'off');
          game.saveConfig('show_favourite', false);
          game.saveConfig('animation', false);
          game.saveConfig('hover_all', false);
          game.saveConfig('asset_version', 'v1.9');
          // game.saveConfig('characters',lib.config.all.characters);
          // game.saveConfig('cards',lib.config.all.cards);
          game.saveConfig('plays', ['cardpile']);
          game.saveConfig('skip_shan', false);
          game.saveConfig('tao_enemy', true);
          game.saveConfig('layout', 'long2');
          game.saveConfig('hp_style', 'ol');
          game.saveConfig('background_music', 'music_off');
          game.saveConfig('background_audio', false);
          game.saveConfig('background_speak', false);
          game.saveConfig('show_volumn', false);
          game.saveConfig('show_replay', true);
          game.saveConfig('autostyle', true);
          game.saveConfig('debug', true);
          game.saveConfig('dev', true);
          if (!lib.device) {
            game.saveConfig('sync_speed', false);
          }
          game.reload();
        },
        o: function () {
          ui.arena.classList.remove('observe');
        },
        pt: function () {
          var list = Array.from(arguments);
          while (list.length) {
            var card = cheat.gn(list.pop());
            if (card) ui.cardPile.insertBefore(card, ui.cardPile.firstChild);
          }
        },
        q: function () {
          // if(lib.config.layout!='mobile') init.layout('mobile');
          if (arguments.length == 0) {
            var style = ui.css.card_style;
            if (lib.config.card_style != 'simple') {
              lib.config.card_style = 'simple';
              ui.css.card_style = init.css(lib.assetURL + 'theme/style/card', 'simple');
            }
            else {
              lib.config.card_style = 'default';
              ui.css.card_style = init.css(lib.assetURL + 'theme/style/card', 'default');
            }
            style.remove();
          }
          else {
            for (var i = 0; i < arguments.length; i++) {
              cheat.g(arguments[i]);
            }
          }
          ui.arena.classList.remove('selecting');
          ui.arena.classList.remove('tempnoe');
        },
        p: function (name, i, skin) {
          var list = ['swd', 'hs', 'pal', 'gjqt', 'ow', 'gw'];
          if (!lib.character[name]) {
            for (var j = 0; j < list.length; j++) {
              if (lib.character[list[j] + '_' + name]) {
                name = list[j] + '_' + name; break;
              }
            }
          }
          if (skin) {
            lib.config.skin[name] = skin
          }
          var target;
          if (typeof i == 'number') {
            target = game.players[i];
          }
          else {
            target = game.me.next;
          }
          if (!lib.character[name]) {
            target.node.avatar.setBackground(name, 'character');
            target.node.avatar.show();
          }
          else {
            target.init(name);
          }
          if (i === true) {
            if (lib.config.layout == 'long2') {
              init.layout('mobile');
            }
            else {
              init.layout('long2');
            }
          }
        },
        e: function () {
          var cards = [], target;
          for (var i = 0; i < arguments.length; i++) {
            if (get.itemtype(arguments[i]) == 'player') {
              target = arguments[i];
            }
            else {
              cards.push(game.createCard(arguments[i]));
            }
          }
          if (!cards.length) {
            cards.push(game.createCard('qinglong'));
            cards.push(game.createCard('bagua'));
            cards.push(game.createCard('dilu'));
            cards.push(game.createCard('chitu'));
            cards.push(game.createCard('muniu'));
          }
          target = target || game.me;
          for (var i = 0; i < cards.length; i++) {
            var card = target.getEquip(cards[i]);
            if (card) {
              card.discard();
              target.removeEquipTrigger(card);
            }
            target.$equip(cards[i]);
          }
        },
        c: function () {
          (function () {
            var a = 0, b = 0, c = 0, d = 0;
            var aa = 0, bb = 0, cc = 0, dd = 0;
            var sa = 0, sb = 0, sc = 0, sd = 0;
            var sha = 0, shan = 0, tao = 0, jiu = 0, wuxie = 0, heisha = 0, hongsha = 0;
            var num = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0, 13: 0 };
            for (var i in lib.card) {
              if (get.objtype(lib.card[i]) == 'object' && lib.translate[i + '_info']) {
                switch (lib.card[i].type) {
                  case 'basic': a++; break;
                  case 'trick': b++; break;
                  case 'equip': c++; break;
                  default: d++; break;
                }
              }
            }
            for (var i = 0; i < lib.card.list.length; i++) {
              if (typeof lib.card[lib.card.list[i][2]] == 'object') {
                switch (lib.card[lib.card.list[i][2]].type) {
                  case 'basic': aa++; break;
                  case 'trick': case 'delay': bb++; break;
                  case 'equip': cc++; break;
                  default: dd++; break;
                }
                switch (lib.card.list[i][0]) {
                  case 'heart': sa++; break;
                  case 'diamond': sb++; break;
                  case 'club': sc++; break;
                  case 'spade': sd++; break;
                }
                if (lib.card.list[i][2] == 'sha') {
                  sha++;
                  if (lib.card.list[i][0] == 'club' || lib.card.list[i][0] == 'spade') {
                    heisha++;
                  }
                  else {
                    hongsha++;
                  }
                }
                if (lib.card.list[i][2] == 'shan') {
                  shan++;
                }
                if (lib.card.list[i][2] == 'tao') {
                  tao++;
                }
                if (lib.card.list[i][2] == 'jiu') {
                  jiu++;
                }
                if (lib.card.list[i][2] == 'wuxie') {
                  wuxie++;
                }
                num[lib.card.list[i][1]]++;
              }
            }
            var str = '基本牌' + aa + '； ' + '锦囊牌' + bb + '； ' + '装备牌' + cc + '； ' + '其它牌' + dd
            console.log(str);
            str = '红桃牌' + sa + '； ' + '方片牌' + sb + '； ' + '梅花牌' + sc + '； ' + '黑桃牌' + sd
            console.log(str);
            str = '杀' + sha + '； ' + '黑杀' + heisha + '； ' + '红杀' + hongsha + '； ' + '闪' + shan + '； ' + '桃' + tao + '； ' + '酒' + jiu + '； ' + '无懈' + wuxie
            console.log(str);
            if (arguments[1]) {
              for (var i = 1; i <= 13; i++) {
                if (i < 10) {
                  console.log(i + ' ', num[i]);
                }
                else {
                  console.log(i, num[i]);
                }
              }
            }
            var arr = [];
            for (var i = 1; i <= 13; i++) {
              arr.push(num[i]);
            }
            console.log((a + b + c + d) + '/' + (aa + bb + cc + dd), ...arr)
          }());
        },
        id: function () {
          game.showIdentity();
        },
        b: function () {
          if (!ui.dialog || !ui.dialog.buttons) return;
          for (var i = 0; i < Math.min(arguments.length, ui.dialog.buttons.length); i++) {
            ui.dialog.buttons[i].link = arguments[i];
          }
        },
        a: function (bool) {
          if (lib.config.test_game) {
            game.saveConfig('test_game');
          }
          else {
            if (bool) {
              if (typeof bool === 'string') {
                game.saveConfig('test_game', bool);
              }
              else {
                game.saveConfig('test_game', '_');
              }
            }
            else {
              game.saveConfig('test_game', true);
            }
          }
          game.reload();
        },
        as: function () {
          ui.window.classList.remove('testing');
          var bg = ui.window.querySelector('.pausedbg');
          if (bg) {
            bg.remove();
          }
        },
        uj: function () {
          cheat.e('qilin');
          game.me.next.useCard({ name: 'jiedao' }, [game.me, game.me.previous]);
        },
        u: function () {
          var card = { name: 'sha' }, source = game.me.next, targets = [];
          for (var i = 0; i < arguments.length; i++) {
            if (get.itemtype(arguments[i]) == 'player') {
              source = arguments[i];
            }
            else if (Array.isArray(arguments[i])) {
              targets = arguments[i];
            }
            else if (typeof arguments[i] == 'object' && arguments[i]) {
              card = arguments[i];
            }
            else if (typeof arguments[i] == 'string') {
              card = { name: arguments[i] }
            }
          }
          if (!targets.length) targets.push(game.me);
          source.useCard(game.createCard(card.name, card.suit, card.number, card.nature), targets);
        },
        r: function (bool) {
          var list = ['s', 'ap', 'a', 'am', 'bp', 'b', 'bm', 'c', 'd'];
          var str = '';
          for (var i = 0; i < list.length; i++) {
            if (str) str += ' 、 ';
            str += list[i] + '-' + lib.rank[list[i]].length;
          }
          console.log(str);
          for (var i in lib.characterPack) {
            if (!bool && lib.config.all.sgscharacters.contains(i)) continue;
            var map = {};
            var str = '';
            for (var j in lib.characterPack[i]) {
              var rank = get.rank(j);
              if (!map[rank]) {
                map[rank] = 1;
              }
              else {
                map[rank]++;
              }
            }
            for (var j = 0; j < list.length; j++) {
              if (map[list[j]]) {
                if (str) str += ' 、 ';
                str += list[j] + '-' + map[list[j]];
              }
            }
            if (str) {
              console.log(lib.translate[i + '_character_config'] + '：' + str);
            }
          }

          var list = lib.rank.s.concat(lib.rank.ap).concat(lib.rank.a).concat(lib.rank.am).
            concat(lib.rank.bp).concat(lib.rank.b).concat(lib.rank.bm).concat(lib.rank.c).concat(lib.rank.d);
          for (var i in lib.character) {
            if (lib.config.forbidai.contains(i)) continue;
            if (i.indexOf('boss_') != 0 && i.indexOf('tafang_') != 0 && !list.contains(i)) console.log(get.translation(i), i);
          }
        },
        h: function (player) {
          console.log(get.translation(player.getCards('h')));
        },
        g: function () {
          for (var i = 0; i < arguments.length; i++) {
            if (i > 0 && typeof arguments[i] == 'number') {
              for (var j = 0; j < arguments[i] - 1; j++) {
                cheat.gx(arguments[i - 1]);
              }
            }
            else {
              cheat.gx(arguments[i]);
            }
          }
        },
        ga: function (type) {
          for (var i in lib.card) {
            if (lib.card[i].type == type || lib.card[i].subtype == type) {
              cheat.g(i);
            }
          }
        },
        gg: function () {
          for (var i = 0; i < game.players.length; i++) {
            for (var j = 0; j < arguments.length; j++) {
              cheat.gx(arguments[j], game.players[i]);
            }
          }
        },
        gx: function (name, target) {
          target = target || game.me;
          var card = cheat.gn(name);
          if (!card) return;
          target.node.handcards1.appendChild(card);
          delete _status.event._cardChoice;
          delete _status.event._targetChoice;
          delete _status.event._skillChoice;
          game.check();
          target.update();
          ui.updatehl();
        },
        gn: function (name) {
          var nature = null;
          var suit = null;
          var suits = ['club', 'spade', 'diamond', 'heart'];
          for (var i = 0; i < suits.length; i++) {
            if (name.indexOf(suits[i]) == 0) {
              suit = suits[i];
              name = name.slice(suits[i].length);
              break;
            }
          }
          if (name.indexOf('red') == 0) {
            name = name.slice(3);
            suit = ['diamond', 'heart'].randomGet();
          }
          if (name.indexOf('black') == 0) {
            name = name.slice(5);
            suit = ['spade', 'club'].randomGet();
          }

          if (name == 'huosha') {
            name = 'sha';
            nature = 'fire';
          }
          else if (name == 'leisha') {
            name = 'sha';
            nature = 'thunder';
          }
          else if (name == 'haisha') {
            name = 'sha';
            nature = 'ocean';
          }
          else if (name == 'yamisha') {
            name = 'sha';
            nature = 'yami';
          }
          else if (name == 'haitao') {
            name = 'tao';
            nature = 'ocean';
          }
          if (!lib.card[name]) {
            return null;
          }
          return game.createCard(name, suit, null, nature);
        },
        ge: function (target) {
          if (target) {
            cheat.gx('zhuge', target);
            cheat.gx('qinglong', target);
            cheat.gx('bagua', target);
            cheat.gx('dilu', target);
            cheat.gx('chitu', target);
            cheat.gx('muniu', target);
          }
          else {
            cheat.g('zhuge');
            cheat.g('qinglong');
            cheat.g('bagua');
            cheat.g('dilu');
            cheat.g('chitu');
            cheat.g('muniu');
          }
        },
        gj: function () {
          cheat.g('shandian');
          cheat.g('huoshan');
          cheat.g('hongshui');
          cheat.g('lebu');
          cheat.g('bingliang');
          cheat.g('guiyoujie');
        },
        gf: function () {
          for (var i in lib.card) {
            if (lib.card[i].type == 'food') {
              cheat.g(i);
            }
          }
        },
        d: function (num, target) {
          if (num == undefined) num = 1;
          var cards = get.cards(num);
          for (var i = 0; i < num; i++) {
            var card = cards[i];
            game.me.node.handcards1.appendChild(card);
            delete _status.event._cardChoice;
            delete _status.event._targetChoice;
            delete _status.event._skillChoice;
            game.check();
            game.me.update();
            ui.updatehl();
          }
        },
        s: function () {
          for (var i = 0; i < arguments.length; i++) {
            game.me.addSkill(arguments[i], true);
          }
          delete _status.event._cardChoice;
          delete _status.event._targetChoice;
          delete _status.event._skillChoice;
          game.check();
        },
        t: function (num) {
          if (game.players.contains(num)) {
            num = game.players.indexOf(num);
          }
          if (num == undefined) {
            for (var i = 0; i < game.players.length; i++) cheat.t(i);
            return;
          }
          var player = game.players[num];
          var cards = player.getCards('hej');
          for (var i = 0; i < cards.length; i++) {
            cards[i].discard();
          }
          player.removeEquipTrigger();
          player.update();
        },
        to: function () {
          for (var i = 0; i < game.players.length; i++) {
            if (game.players[i] != game.me) {
              cheat.t(i);
            }
          }
        },
        tm: function () {
          for (var i = 0; i < game.players.length; i++) {
            if (game.players[i] == game.me) {
              cheat.t(i);
            }
          }
        },
        k: function (i) {
          if (i == undefined) i = 1;
          game.players[i].hp = 1;
          cheat.t(i);
          cheat.g('juedou');
        },
        z: function (name) {
          switch (name) {
            case 'cc': name = 're_caocao'; break;
            case 'lb': name = 're_liubei'; break;
            case 'sq': name = 'sunquan'; break;
            case 'dz': name = 'dongzhuo'; break;
            case 'ys': name = 're_yuanshao'; break;
            case 'zj': name = 'sp_zhangjiao'; break;
            case 'ls': name = 'liushan'; break;
            case 'sc': name = 'sunce'; break;
            case 'cp': name = 'caopi'; break;
            case 'cr': name = 'caorui'; break;
            case 'sx': name = 'sunxiu'; break;
            case 'lc': name = 'liuchen'; break;
            case 'sh': name = 'sunhao'; break;
          }
          game.zhu.init(name);
          game.zhu.maxHp++;
          game.zhu.hp++;
          game.zhu.update();
        },
      },
      /**
       * {@link GameCores}的公共技能组
       * @namespace
       */
      skill: {
        //升阶
        _shengjie: {
          enable: 'phaseUse',
          usable: 1,
          filter: function (Evt, player) {
            return player.canPromotion(player.getCards('h'));
          },
          content: [function () {
            player.choosePromotion(player.getCards('h'))
          }, function () {
            if (result.bool) {
              player.lose(result.cards, ui.discardPile, 'visible');
              player.$throw(result.cards);
              game.log(player, '将', result.cards, '置入了弃牌堆');
              Evt.star = result.star;
            }
            if (!result.bool) {
              var skill = player.getStat().skill;
              skill._shengjie--;
              if (typeof skill._shengjietried == 'number') {
                skill._shengjietried++;
              }
              else {
                skill._shengjietried = 1;
              }
            }
          }, function () {
            if (Evt.star) {
              player.gain(Evt.star, 'gain2').gaintag.add('_shengjie');
            }
          }
          ],
          ai: {
            basic: {
              order: 6
            },
            result: {
              player: function (player) {
                if (player.getStat().skill._shengjietried >= 10) {
                  return 0;
                }
                return 0;
              }
            }
          }
        },
        //搬过来的应变
        _yingbian: {
          trigger: { player: 'useCard1' },
          forced: true,
          popup: false,
          firstDo: true,
          ruleSkill: true,
          forceLoad: true,
          filter: function (Evt, player) {
            if (Evt.card.yingbian) return false;
            var bool = player.hasSkillTag('forceYingbian');
            var card = Evt.card;
            if (get.cardtag(card, 'yingbian_kongchao') && (!player.countCards('h') || bool)) return true;
            if (get.cardtag(card, 'yingbian_canqu') && (player.hp == 1 || bool)) return true;
            if (get.cardtag(card, 'yingbian_fujia') && (player.isMaxHandcard() || bool)) return true;
            if (get.cardtag(card, 'yingbian_zhuzhan')) return true;
            return false;
          },
          content: [function () {
            var card = trigger.card;
            Evt.card = card;
            var bool = false;
            if (get.cardtag(card, 'yingbian_kongchao') && !player.countCards('h')) {
              player.popup('空巢', 'soil');
              bool = true;
            }
            else if (get.cardtag(card, 'yingbian_canqu') && player.hp == 1) {
              player.popup('残躯', 'fire');
              bool = true;
            }
            else if (get.cardtag(card, 'yingbian_fujia') && player.isMaxHandcard()) {
              player.popup('富甲', 'orange');
              bool = true;
            }
            else if (player.hasSkillTag('forceYingbian')) {
              player.popup('应变', 'metal');
              bool = true;
            }
            if (bool) {
              game.log(player, '触发了', card, '的应变条件');
              Evt.goto(10);
            }
          }, function () {
            Evt._global_waiting = true;
            Evt.send = function (player, card, source, targets, id, id2, skillState) {
              if (skillState) {
                player.applySkills(skillState);
              }
              var type = get.type2(card);
              var str = get.translation(source);
              if (targets && targets.length) {
                str += '对';
                str += get.translation(targets);
              }
              str += '使用了';
              var next = player.chooseCard({
                filterCard: function (card) {
                  return get.type2(card) == type && lib.filter.cardDiscardable.apply(this, arguments);
                },
                prompt: str += (get.translation(card) + '，是否弃置一张' + get.translation(type) + '为其助战？'),
                position: 'h',
                _global_waiting: true,
                id: id,
                id2: id2,
                ai: function (cardx) {
                  var info = get.info(card);
                  if (info && info.ai && info.ai.yingbian) {
                    var ai = info.ai.yingbian(card, source, targets, player);
                    if (!ai) return 0;
                    return ai - get.value(cardx);
                  }
                  else if (get.attitude(player, source) <= 0) return 0;
                  return 5 - get.value(cardx);
                },
              });
              if (game.online) {
                _status.event._resultid = id;
                game.resume();
              }
            };
          }, function () {
            var type = get.type2(card);
            var list = game.filterPlayer(function (current) {
              if (current == player) return false;
              if (!current.countCards('h')) return false;
              return _status.connectMode || current.countCards('h', function (cardx) {
                return get.type2(cardx) == type;
              })
            });
            Evt.list = list;
            Evt.id = get.id();
            list.sort(function (a, b) {
              return get.distance(Evt.source, a, 'absolute') - get.distance(Evt.source, b, 'absolute');
            });
          }, function () {
            if (Evt.list.length == 0) {
              Evt.finish();
              return;
            }
            else if (_status.connectMode && (Evt.list[0].isOnline() || Evt.list[0] == game.me)) {
              Evt.goto(5);
            }
            else {
              Evt.current = Evt.list.shift();
              Evt.send(Evt.current, Evt.card, player, trigger.targets, Evt.id, trigger.parent.id);
            }
          }, function () {
            if (result.bool) {
              Evt.zhuzhanresult = Evt.current;
              Evt.zhuzhanresult2 = result;
              if (Evt.current != game.me) game.delayx();
              Evt.goto(9);
            }
            else {
              Evt.goto(3);
            }
          }, function () {
            var id = Evt.id;
            var sendback = function (result, player) {
              if (result && result.id == id && !Evt.zhuzhanresult && result.bool) {
                Evt.zhuzhanresult = player;
                Evt.zhuzhanresult2 = result;
                game.broadcast('cancel', id);
                if (_status.event.id == id && _status.event.name == 'chooseCard' && _status.paused) {
                  return (function () {
                    Evt.resultOL = _status.event.resultOL;
                    ui.click.cancel();
                    if (ui.confirm) ui.confirm.close();
                  });
                }
              }
              else {
                if (_status.event.id == id && _status.event.name == 'chooseCard' && _status.paused) {
                  return (function () {
                    Evt.resultOL = _status.event.resultOL;
                  });
                }
              }
            };

            var withme = false;
            var withol = false;
            var list = Evt.list;
            for (var i = 0; i < list.length; i++) {
              if (list[i].isOnline()) {
                withol = true;
                list[i].wait(sendback);
                list[i].send(Evt.send, list[i], Evt.card, player, trigger.targets, Evt.id, trigger.parent.id, get.skillState(list[i]));
                list.splice(i--, 1);
              }
              else if (list[i] == game.me) {
                withme = true;
                Evt.send(list[i], Evt.card, player, trigger.targets, Evt.id, trigger.parent.id);
                list.splice(i--, 1);
              }
            }
            if (!withme) {
              Evt.goto(7);
            }
            if (_status.connectMode) {
              if (withme || withol) {
                for (var i = 0; i < game.players.length; i++) {
                  if (game.players[i] != player) game.players[i].showTimer();
                }
              }
            }
            Evt.withol = withol;
          }, function () {
            if (result && result.bool && !Evt.zhuzhanresult) {
              game.broadcast('cancel', Evt.id);
              Evt.zhuzhanresult = game.me;
              Evt.zhuzhanresult2 = result;
            }
          }, function () {
            if (Evt.withol && !Evt.resultOL) {
              game.pause();
            }
          }, function () {
            for (var i = 0; i < game.players.length; i++) {
              game.players[i].hideTimer();
            }
          }, function () {
            if (Evt.zhuzhanresult) {
              var target = Evt.zhuzhanresult;
              target.line(player, 'green');
              target.discard(Evt.zhuzhanresult2.cards);
              target.popup('助战', 'wood');
              game.log(target, '响应了', player, '发起的助战');
              target.addExpose(0.2);
            }
            else Evt.finish();
          }, function () {
            trigger.card.yingbian = true;
            var info = get.info(trigger.card);
            if (info && info.yingbian) info.yingbian(trigger);
            player.addTempSkill('yingbian_changeTarget');
          }],
        },
        yingbian_changeTarget: {
          trigger: { player: 'useCard2' },
          forced: true,
          popup: false,
          filter: function (Evt, player) {
            if (Evt.yingbian_removeTarget && Evt.targets && Evt.targets.length > 1) return true;
            if (!Evt.yingbian_addTarget) return false;
            var info = get.info(Evt.card);
            if (info.allowMultiple == false) return false;
            if (Evt.targets && !info.multitarget) {
              if (game.hasPlayer(function (current) {
                return !Evt.targets.contains(current) && lib.filter.targetEnabled2(Evt.card, player, current) && lib.filter.targetInRange(Evt.card, player, current);
              })) {
                return true;
              }
            }
            return false;
          },
          content: [function () {
            if (trigger.yingbian_addTarget) player.chooseTarget('应变：是否为' + get.translation(trigger.card) + '增加一个目标？', function (card, player, target) {
              var trigger = _status.event.getTrigger();
              var card = trigger.card;
              return !trigger.targets.contains(target) && lib.filter.targetEnabled2(card, player, target) && lib.filter.targetInRange(card, player, target);
            }).set('ai', function (target) {
              var player = _status.event.player;
              var card = _status.event.getTrigger().card;
              return get.effect(target, card, player, player);
            });
            else Evt.goto(2);
          },
          function () {
            if (result.bool) {
              var target = result.targets[0];
              player.line(target, 'green');
              game.log(player, '发动应变效果，令', target, '也成为了', trigger.card, '的目标');
              trigger.targets.add(target);
            }
          },
          function () {
            if (trigger.yingbian_removeTarget && trigger.targets.length > 1) player.chooseTarget('应变：是否为' + get.translation(trigger.card) + '减少一个目标？', function (card, player, target) {
              var trigger = _status.event.getTrigger();
              return trigger.targets.contains(target);
            }).set('ai', function (target) {
              var player = _status.event.player;
              var card = _status.event.getTrigger().card;
              return -get.effect(target, card, player, player);
            });
            else Evt.finish();
          },
          function () {
            if (result.bool) {
              var target = result.targets[0];
              player.line(target, 'green');
              game.log(player, '发动应变效果，将', target, '从', trigger.card, '的目标中移除了');
              trigger.targets.remove(target);
            }
          }],
        },
        //
        _showHiddenCharacter: {
          trigger: { player: ['changeHp', 'phaseBeginStart', 'loseMaxHpBegin'] },
          firstDo: true,
          forced: true,
          popup: false,
          priority: 25,
          filter: function (Evt, player, name) {
            return player.isUnseen(2) && get.mode() != 'guozhan';
          },
          content: function () {
            player.showCharacter(2);
            player.removeSkill('g_hidden_ai');
          },
        },
        _kamisha: {
          trigger: { source: 'damageBegin2' },
          //forced:true,
          popup: false,
          prompt: function (Evt, player) {
            return '是否防止即将对' + get.translation(Evt.player) + '造成的伤害，改为令其减少' + get.cnNumber(Evt.num) + '点体力上限？';
          },
          filter: function (Evt, player) {
            return Evt.nature == 'kami' && Evt.num > 0;
          },
          ruleSkill: true,
          check: function (Evt, player) {
            var att = get.attitude(player, Evt.player);
            if (Evt.player.hp == Evt.player.maxHp) return att < 0;
            if (Evt.player.hp == Evt.player.maxHp - 1 &&
              (Evt.player.maxHp <= 3 || Evt.player.hasSkillTag('maixie'))) return att < 0;
            return att > 0;
          },
          content: function () {
            trigger.cancel();
            trigger.player.loseMaxHp(trigger.num).source = player;
          },
        },
        //海洋伤害特性
        _oceansha: {
          trigger: { source: 'damageBegin4' },
          forced: true,
          priority: 7,
          logTarget: 'player',
          equipSkill: false,
          ruleSkill: true,
          filter: function (Evt, player) {
            return Evt.nature == 'ocean' && Evt.num > 0 && Evt.player.hujia > 0;
          },
          ruleSkill: true,
          content: function () {
            trigger.num++;
            trigger.oceanAddDam = true;
          },
        },
        //暗影伤害特性
        _yamisha: {
          trigger: { player: 'useCardToPlayered' },
          forced: true,
          priority: 7,
          logTarget: 'target',
          equipSkill: false,
          ruleSkill: true,
          filter: function (Evt, player) {
            return Evt.card.nature == 'yami' && Evt.target.countCards('h') > player.countCards('h');
          },
          ruleSkill: true,
          content: function () {
            trigger.getParent().directHit.add(trigger.target);
            trigger.getParent().yamiDirect = true;
          },
        },
        _yamisha2: {
          trigger: { player: 'phaseJieshu' },
          priority: 1,
          popup: false,
          forced: true,
          ruleSkill: true,
          filter: function (Evt, player) {
            if (Evt.getParent().noyami) return false;
            if (Evt.player.hasSkillTag('playernoyami', false, Evt)) return false;
            return game.countPlayer(function (cur) {
              return cur.hasYami();
            })
          },
          content: [function () {
            Evt.target = trigger.player;
            Evt.state = true;
            Evt._global_waiting = true;
            Evt.filterCard = function (card, player) {
              if (get.nature(card) != 'yami') return false;
              return lib.filter.cardEnabled(card, player, 'forceEnable');
            };
            Evt.send = function (player, state, target, id, skillState) {
              if (skillState) {
                player.applySkills(skillState);
              }
              state = state ? 1 : -1;
              var str = '';
              if (target) {
                str += '在' + get.translation(target);
              }
              str += '的结束阶段，是否对其使用暗影属性的牌？';

              var next = player.chooseToUse({
                filterCard: function (card, player) {
                  if (get.nature(card) != 'yami') return false;
                  return player.canUse(card, target, false);
                },
                filterTarget: target,
                prompt: str,
                type: 'yami',//
                state: state,
                _global_waiting: true,
                ai1: function () {
                  if (target) {
                    var triggerevent = _status.event.getTrigger();
                    if (triggerevent && triggerevent.parent &&
                      triggerevent.parent.postAi &&
                      triggerevent.player.isUnknown(_status.event.player)) {
                      return 0;
                    }
                    if (Math.abs(get.attitude(_status.event.player, target)) < 0) return Math.random() - 0.2;
                  }
                  else {
                    return 0;
                  }
                },
                id: id,
              });
              if (_status.event.stateplayer && _status.event.statecard) next.set('respondTo', [_status.event.stateplayer]);
              if (game.online) {
                _status.event._resultid = id;
                game.resume();
              }
              else {
                next.nouse = true;
              }
            };
            Evt.settle = function () {
              Evt.finish();
            };
          },
          function () {
            var list = game.filterPlayer(function (current) {
              if (current == Evt.target) return false;
              if (Evt.noyami) return false;
              if (Evt.directHit && Evt.directHit.contains(current)) return false;
              return current.hasYami();
            });
            Evt.list = list;
            Evt.id = get.id();
            list.sort(function (a, b) {
              return get.distance(Evt.target, a, 'absolute') - get.distance(Evt.target, b, 'absolute');
            });
          },
          function () {
            if (Evt.list.length == 0) {
              Evt.settle();
            }
            else if (_status.connectMode && (Evt.list[0].isOnline() || Evt.list[0] == game.me)) {
              Evt.goto(4);
            }
            else {
              Evt.current = Evt.list.shift();
              Evt.send(Evt.current, Evt.state, Evt.target, Evt.id);
            }
          },
          function () {
            if (result.bool) {
              Evt.yamiresult = Evt.current;
              Evt.yamiresult2 = result;
              Evt.goto(8);
            }
            else {
              Evt.goto(2);
            }
          },
          function () {
            var id = Evt.id;
            var sendback = function (result, player) {
              if (result && result.id == id && !Evt.yamiresult && result.bool) {
                Evt.yamiresult = player;
                Evt.yamiresult2 = result;
                game.broadcast('cancel', id);
                if (_status.event.id == id && _status.event.name == 'chooseToUse' && _status.paused) {
                  return (function () {
                    Evt.resultOL = _status.event.resultOL;
                    ui.click.cancel();
                    if (ui.confirm) ui.confirm.close();
                  });
                }
              }
              else {
                if (_status.event.id == id && _status.event.name == 'chooseToUse' && _status.paused) {
                  return (function () {
                    Evt.resultOL = _status.event.resultOL;
                  });
                }
              }
            };

            var withme = false;
            var withol = false;
            var list = Evt.list;
            for (var i = 0; i < list.length; i++) {
              if (list[i].isOnline()) {
                withol = true;
                list[i].wait(sendback);
                list[i].send(Evt.send, list[i], Evt.state, Evt.target, Evt.id, get.skillState(list[i]));
                list.splice(i--, 1);
              }
              else if (list[i] == game.me) {
                withme = true;
                Evt.send(list[i], Evt.state, Evt.target, Evt.id);
                list.splice(i--, 1);
              }
            }
            if (!withme) {
              Evt.goto(6);
            }
            if (_status.connectMode) {
              if (withme || withol) {
                for (var i = 0; i < game.players.length; i++) {
                  game.players[i].showTimer();
                }
              }
            }
            Evt.withol = withol;
          },
          function () {
            if (result && result.bool && !Evt.yamiresult) {
              game.broadcast('cancel', Evt.id);
              Evt.yamiresult = game.me;
              Evt.yamiresult2 = result;
            }
          },
          function () {
            if (Evt.withol && !Evt.resultOL) {
              game.pause();
            }
          },
          function () {
            for (var i = 0; i < game.players.length; i++) {
              game.players[i].hideTimer();
            }
          },
          function () {
            if (Evt.yamiresult) {
              var next = Evt.yamiresult.useResult(Evt.yamiresult2);
              if (Evt.stateplayer) next.respondTo = [Evt.stateplayer, Evt];
            }
          },
          function () {
            if (Evt.yamiresult) {
              if (result) {
                Evt.goto(1);
              }
              else Evt.settle();
            }
            else if (Evt.list.length) {
              Evt.goto(2);
            }
            else {
              Evt.settle();
            }
            delete Evt.resultOL;
            delete Evt.yamiresult;
            delete Evt.yamiresult2;
          }]
        },
        aozhan: {
          charlotte: true,
          mod: {
            targetEnabled: function (card) {
              if (card.name == 'tao' && (card.isCard && card.cardid || get.itemtype(card) == 'card')) return false;
            },
            cardSavable: function (card) {
              if (card.name == 'tao' && (card.isCard && card.cardid || get.itemtype(card) == 'card')) return false;
            },
          },
          group: ["aozhan_sha", "aozhan_shan"],
          subSkill: {
            sha: {
              enable: ["chooseToUse", "chooseToRespond"],
              filterCard: {
                name: "tao",
              },
              viewAs: {
                name: "sha",
                isCard: true,
              },
              viewAsFilter: function (player) {
                if (!player.countCards('hs', 'tao')) return false;
              },
              position: 'hs',
              prompt: "将一张桃当杀使用或打出",
              check: function () { return 1 },
              ai: {
                respondSha: true,
                skillTagFilter: function (player) {
                  if (!player.countCards('hs', 'tao')) return false;
                },
                order: function () {
                  return get.order({ name: 'sha' }) - 0.1;
                },
              },
              sub: true,
            },
            shan: {
              enable: ["chooseToRespond", "chooseToUse"],
              filterCard: {
                name: "tao",
              },
              viewAs: {
                name: "shan",
                isCard: true,
              },
              prompt: "将一张桃当闪打出",
              check: function () { return 1 },
              viewAsFilter: function (player) {
                if (!player.countCards('hs', 'tao')) return false;
              },
              position: 'hs',
              ai: {
                respondShan: true,
                skillTagFilter: function (player) {
                  if (!player.countCards('hs', 'tao')) return false;
                },
              },
              sub: true,
            },
          },
        },
        /**
         * 特殊_全局技能
         * 将全局技能的技能名储存于此数组中
         * @type {!Array<string>}
         * @see {@link game.addGlobalSkill}
         */
        global: [],
        globalmap: {},
        storage: {},
        undist: {},
        others: {},
        zhu: {},
        zhuSkill: {},
        land_used: {},
        unequip: { ai: { unequip: true } },
        subplayer: {
          trigger: { player: 'dieBefore' },
          forced: true,
          priority: -9,
          onremove: true,
          mark: 'character',
          intro: {
            content: function (storage, player) {
              if (typeof storage.intro2 == 'string') return storage.intro2;
              if (typeof storage.intro2 == 'function') return storage.intro2(storage, player);
              return '死亡前切换回主武将'
            },
            name: function (storage) {
              return get.rawName(storage.name);
            }
          },
          content: function () {
            trigger.cancel();
            var evt = trigger.getParent('damage');
            if (evt.player == player) {
              evt.untrigger(false, player);
            }
            player.exitSubPlayer(true);
          },
          ai: {
            nosave: true
          }
        },
        autoswap: {
          firstDo: true,
          trigger: {
            player: ['playercontrol', 'chooseToUseBegin', 'chooseToRespondBegin', 'chooseToDiscardBegin', 'chooseToCompareBegin',
              'chooseButtonBegin', 'chooseCardBegin', 'chooseTargetBegin', 'chooseCardTargetBegin', 'chooseControlBegin',
              'chooseBoolBegin', 'choosePlayerCardBegin', 'discardPlayerCardBegin', 'gainPlayerCardBegin', 'chooseToMoveBegin', 'chooseToPlayBeatmapBegin']
          },
          forced: true,
          priority: 100,
          forceDie: true,
          popup: false,
          filter: function (Evt, player) {
            if (Evt.autochoose && Evt.autochoose()) return false;
            if (lib.filter.wuxieSwap(Evt)) return false;
            if (_status.auto || !player.isUnderControl()) return false;
            return true;
          },
          content: function () {
            game.swapPlayerAuto(player);
          },
        },
        dualside: {
          subSkill: {
            turn: {
              trigger: { player: ['turnOverAfter', 'dieBefore'] },
              silent: true,
              filter: function (Evt, player) {
                if (player.$.dualside_over) return false;
                return Array.isArray(player.$.dualside);
              },
              content: function () {
                var cfg = player.$.dualside;
                var bool = player.isTurnedOver();
                if (trigger.name == 'die') {
                  bool = !bool;
                }
                if (bool) {
                  cfg[1] = player.hp;
                  cfg[2] = player.maxHp;
                  player.reinit(cfg[0], cfg[3], [cfg[4], cfg[5]]);
                  player.unmarkSkill('dualside');
                  player.markSkillCharacter('dualside', { name: cfg[0] }, '正面', '当前体力：' + cfg[1] + '/' + cfg[2]);
                }
                else {
                  cfg[4] = player.hp;
                  cfg[5] = player.maxHp;
                  player.reinit(cfg[3], cfg[0], [cfg[1], cfg[2]]);
                  player.unmarkSkill('dualside');
                  player.markSkillCharacter('dualside', { name: cfg[3] }, '背面', '当前体力：' + cfg[4] + '/' + cfg[5]);
                }

                if (trigger.name == 'die') {
                  trigger.cancel();
                  delete player.$.dualside;
                  player.$.dualside_over = true;
                  player.unmarkSkill('dualside');
                }
              }
            },
            init: {
              trigger: { global: 'gameStart', player: 'enterGame' },
              silent: true,
              content: function () {
                var list = [player.name, player.name1, player.name2];
                for (var i = 0; i < list.length; i++) {
                  if (list[i] && lib.character[list[i]]) {
                    var info = lib.character[list[i]];
                    if (info[3].contains('dualside') && info[4]) {
                      player.$.dualside = [list[i], player.hp, player.maxHp];
                      for (var j = 0; j < info[4].length; j++) {
                        if (info[4][j].indexOf('dualside:') == 0) {
                          var name2 = info[4][j].slice(9);
                          var info2 = lib.character[name2];
                          player.$.dualside.push(name2);
                          player.$.dualside.push(get.infoHp(info2[2]));
                          player.$.dualside.push(get.infoMaxHp(info2[2]));
                        }
                      }
                    }
                  }
                }
                var cfg = player.$.dualside;
                if (get.mode() == 'guozhan') {
                  if (player.name1 == cfg[0]) {
                    player.showCharacter(0);
                  }
                  else {
                    player.showCharacter(1);
                  }
                }
                player.markSkillCharacter('dualside', { name: cfg[3] }, '背面', '当前体力：' + cfg[4] + '/' + cfg[5]);
              }
            }
          },
          group: ['dualside_init', 'dualside_turn']
        },
        _disableJudge: {
          marktext: "废",
          intro: {
            content: "已经废除了判定区",
          },
          mod: {
            targetEnabled: function (card, player, target) {
              if (target.$._disableJudge && get.type(card) == 'delay') return false;
            },
          },
        },
        "_disableEquip": {
          marktext: "废",
          intro: {
            content: function (storage, player, skill) {
              var str = '';
              for (var i = 0; i < player.$.disableEquip.length; i++) {
                str += '、' + get.translation(player.$.disableEquip[i]) + '栏';
              };
              str = str.slice(1, str.length)
              str = '已经废除了' + str;
              return str;
            },
          },
          mod: {
            targetEnabled: function (card, player, target) {
              if (target.isDisabled(get.subtype(card))) return false;
            },
          },
          trigger: {
            player: ['disableEquipBefore', 'enableEquipBefore', 'enterGame'],
            global: 'gameStart',
          },
          forced: true,
          popup: false,
          filter: function (Evt, player) {
            return player.$.disableEquip == undefined;
          },
          content: function () {
            player.$.disableEquip = [];
          },
        },
        /**
         * 技能_封印
         * 使非锁定技失效
         */
        fengyin: {
          init: function (player, skill) {
            player.addSkillBlocker(skill);
          },
          onremove: function (player, skill) {
            player.removeSkillBlocker(skill);
          },
          charlotte: true,
          skillBlocker: function (skill, player) {
            return !lib.skill[skill].charlotte && !get.is.locked(skill, player);
          },
          mark: true,
          intro: {
            content: function (storage, player, skill) {
              var list = player.getSkills(null, false, false).filter(function (i) {
                return lib.skill.fengyin.skillBlocker(i, player);
              });
              if (list.length) return '失效技能：' + get.translation(list);
              return '无失效技能';
            }
          }
        },
        /**
         * 技能_白板
         * 使全部技能失效
         */
        baiban: {
          init: function (player, skill) {
            player.addSkillBlocker(skill);
          },
          onremove: function (player, skill) {
            player.removeSkillBlocker(skill);
          },
          charlotte: true,
          skillBlocker: function (skill, player) {
            return !lib.skill[skill].charlotte;
          },
          mark: true,
          intro: {
            content: function (storage, player, skill) {
              var list = player.getSkills(null, false, false).filter(function (i) {
                return lib.skill.baiban.skillBlocker(i, player);
              });
              if (list.length) return '失效技能：' + get.translation(list);
              return '无失效技能';
            }
          }
        },
        qianxing: {
          mark: true,
          nopop: true,
          init: function (player) {
            game.log(player, '获得了', '【潜行】');
          },
          intro: {
            content: '锁定技，你不能成为其他角色的卡牌的目标'
          },
          mod: {
            targetEnabled: function (card, player, target) {
              if (player != target) return false;
            }
          }
        },
        /**
         * 技能_免疫
         * 防止受到的伤害
         */
        mianyi: {
          trigger: { player: 'damageBefore' },
          mark: true,
          forced: true,
          init: function (player) {
            game.log(player, '获得了', '【免疫】');
          },
          content: function () {
            trigger.cancel();
          },
          ai: {
            noyami: true,
            nofire: true,
            nothunder: true,
            noocean: true,
            nodamage: true,
            effect: {
              target: function (card, player, target, current) {
                if (get.tag(card, 'damage')) return [0, 0];
              }
            },
          },
          intro: {
            content: '防止一切伤害'
          }
        },
        mad: {
          mark: true,
          locked: true,
          intro: {
            content: '已进入混乱状态',
            name: '混乱',
            onunmark: function (storage, player) {
              game.log(player, '解除混乱状态');
            }
          }
        },
        ghujia: {
          intro: {
            content: function (content, player) {
              return '已有' + get.cnNumber(player.hujia) + '点护甲值';
            }
          }
        },
        counttrigger: {
          trigger: { global: 'phaseAfter' },
          silent: true,
          charlotte: true,
          priority: -100,
          content: function () {
            player.removeSkill('counttrigger');
            delete player.$.counttrigger;
          }
        },
        _recovercheck: {
          trigger: { player: 'recoverBefore' },
          forced: true,
          priority: 100,
          firstDo: true,
          popup: false,
          filter: function (Evt, player) {
            return player.hp >= player.maxHp;
          },
          content: function () {
            trigger.cancel();
          },
        },
        /**
         * 规则技能_翻面
         * 被翻面的角色跳过回合
         */
        _turnover: {
          trigger: { player: 'phaseBefore' },
          forced: true,
          priority: 100,
          popup: false,
          firstDo: true,
          content: [function () {
            if ((player == _status.roundStart || _status.roundSkipped) && !trigger.skill) {
              Evt.trigger('roundEnd');
            }
          },
          function () {
            if (player.isTurnedOver()) {
              trigger.cancel();
              player.turnOver();
              player.phaseSkipped = true;
            }
            else {
              player.phaseSkipped = false;
            }
          },
          function () {
            if ((player == _status.roundStart || _status.roundSkipped) && !trigger.skill) {
              delete _status.roundSkipped;
              game.roundNumber++;
              trigger._roundStart = true;
              game.updateRoundNumber();
              for (var i = 0; i < game.players.length; i++) {
                if (game.players[i].isOut() && game.players[i].outCount > 0) {
                  game.players[i].outCount--;
                  if (game.players[i].outCount == 0 && !game.players[i].outSkills) {
                    game.players[i].in();
                  }
                }
              }
              Evt.trigger('roundStart');
            }
          }],
        },
        /**
         * 规则技能_使用
         * 使用一张牌结算后，通过{@link ui.clear}清除残留ui
         */
        _usecard: {
          trigger: { global: 'useCardAfter' },
          forced: true,
          popup: false,
          priority: -100,
          lastDo: true,
          filter: function (Evt) {
            return !Evt._cleared && Evt.card.name != 'wuxie';
          },
          content: function () {
            game.broadcastAll(function () {
              ui.clear();
            });
            Evt._cleared = true;
          }
        },
        /**
         * 规则技能_弃牌
         * 弃牌结算后，延时一段时间清除残留弃牌效果
         */
        _discard: {
          trigger: { global: 'discardAfter' },
          forced: true,
          popup: false,
          priority: -100,
          lastDo: true,
          filter: function (Evt) {
            return ui.todiscard[Evt.discardid] ? true : false;
          },
          content: function () {
            game.broadcastAll(function (id) {
              var todiscard = ui.todiscard[id];
              delete ui.todiscard[id];
              if (todiscard) {
                var time = 1000;
                if (typeof todiscard._discardtime == 'number') {
                  time += todiscard._discardtime - get.time();
                }
                if (time < 0) {
                  time = 0;
                }
                setTimeout(function () {
                  for (var i = 0; i < todiscard.length; i++) {
                    todiscard[i].delete();
                  }
                }, time);
              }
            }, trigger.discardid);
          }
        },
        _save: {
          //trigger:{source:'dying2',player:'dying2'},
          priority: 5,
          forced: true,
          popup: false,
          filter: function (Evt, player) {
            //if(!Evt.player.isDying()) return false;
            //if(Evt.source&&Evt.source.isIn()&&Evt.source!=player) return false;
            //return true;
            return false;
          },
          content: [function () {
            Evt.dying = trigger.player;
            if (!Evt.acted) Evt.acted = [];
          },
          function () {
            if (trigger.player.isDead()) {
              Evt.finish();
              return;
            }
            Evt.acted.push(player);
            var str = `${get.translation(trigger.player)}濒死，是否帮助？`;
            {
              let evt = Evt.getParent('dying')
              if (evt.reason && evt.reason.nofatal) str += `<br>（本次伤害不致命）`
            }
            var str2 = '当前体力：' + trigger.player.hp;
            if (lib.config.tao_enemy && Evt.dying.side != player.side && lib.config.mode != 'identity' && lib.config.mode != 'guozhan' && !Evt.dying.hasSkillTag('revertsave')) {
              Evt._result = { bool: false }
            }
            else if (player.canSave(Evt.dying)) {
              player.chooseToUse({
                filterCard: function (card, player, Evt) {
                  Evt = Evt || _status.event;
                  return lib.filter.cardSavable(card, player, Evt.dying);
                },
                filterTarget: trigger.player,
                prompt: str,
                prompt2: str2,
                ai1: function (card) {
                  if (typeof card == 'string') {
                    var info = get.info(card);
                    if (info.ai && info.ai.order) {
                      if (typeof info.ai.order == 'number') {
                        return info.ai.order;
                      }
                      else if (typeof info.ai.order == 'function') {
                        return info.ai.order();
                      }
                    }
                  }
                  return 1;
                },
                ai2: get.effect_use,
                type: 'dying',
                targetRequired: true,
                dying: Evt.dying
              });
            }
            else {
              Evt._result = { bool: false }
            }
          },
          function () {
            if (result.bool) {
              if (trigger.player.hp <= 0 && !trigger.player.nodying && trigger.player.isAlive() && !trigger.player.isOut() && !trigger.player.removed) Evt.goto(0);
              else trigger.untrigger();
            }
            else {
              for (var i = 0; i < 20; i++) {
                if (Evt.acted.contains(Evt.player.next)) {
                  break;
                }
                else {
                  Evt.player = Evt.player.next;
                  if (!Evt.player.isOut()) {
                    Evt.goto(1);
                    break;
                  }
                }
              }
            }
          }]
        },
        _ismin: {
          mod: {
            cardEnabled: function (card, player) {
              if (player.isMin()) {
                if (get.type(card) == 'equip') return false;
              }
            }
          }
        },
        /**
         * 规则技能_重铸
         * 令角色可以重铸特定的牌
         */
        _chongzhu: {
          enable: 'phaseUse',
          logv: false,
          visible: true,
          prompt: '将要重铸的牌置入弃牌堆并摸一张牌',
          filter: function (Evt, player) {
            return player.hasCard(function (card) {
              return lib.skill._chongzhu.filterCard(card, player);
            });
          },
          filterCard: function (card, player) {
            var mod = game.checkMod(card, player, 'unchanged', 'cardChongzhuable', player);
            if (mod != 'unchanged') return mod;
            var info = get.info(card);
            if (typeof info.chongzhu == 'function') {
              return info.chongzhu(card, player);
            }
            return info.chongzhu;
          },
          prepare: function (cards, player) {
            player.$throw(cards, 1000);
            game.log(player, '将', cards, '置入了弃牌堆');
          },
          check: function (card) {
            // if(get.type(card)=='stonecharacter'&&_status.event.player.countCards('h',{type:'stonecharacter'})<=1){
            //     return 0;
            // }
            return 1;
          },
          discard: false,
          loseTo: 'discardPile',
          delay: 0.5,
          content: [function () {
            if (lib.config.mode == 'stone' && _status.mode == 'deck' &&
              !player.isMin() && get.type(cards[0]).indexOf('stone') == 0) {
              var list = get.stonecard(1, player.career);
              if (list.length) {
                player.gain(game.createCard(list.randomGet()), 'draw');
              }
              else {
                player.draw({ drawDeck: 1 })
              }
            }
            else if (get.subtype(cards[0]) == 'spell_gold') {
              var list = get.libCard(function (info) {
                return info.subtype == 'spell_silver';
              });
              if (list.length) {
                player.gain(game.createCard(list.randomGet()), 'draw');
              }
              else {
                player.draw();
              }
            }
            else if (get.subtype(cards[0]) == 'spell_silver') {
              var list = get.libCard(function (info) {
                return info.subtype == 'spell_bronze';
              });
              if (list.length) {
                player.gain(game.createCard(list.randomGet()), 'draw');
              }
              else {
                player.draw();
              }
            }
            else {
              player.draw();
            }
          }],
          ai: {
            basic: {
              order: 6
            },
            result: {
              player: 1,
            },
          }
        },
        /**
         * 规则技能_连环
         * 被横置的角色传递属性伤害
         */
        _lianhuan: {
          trigger: { player: 'damageAfter' },
          filter: function (Evt, player) {
            return Evt.lianhuanable == true;
          },
          forced: true,
          popup: false,
          logv: false,
          forceDie: true,
          //priority:-5,
          content: [() => {
            Evt.logvid = trigger.getLogv();
          },
          () => {
            Evt.targets = game.filterPlayer(function (current) {
              return current != Evt.player && current.isLinked();
            });
            lib.tempSortSeat = _status.currentPhase || player;
            Evt.targets.sort(lib.sort.seat);
            delete lib.tempSortSeat;
            Evt._args = [trigger.num, trigger.nature, trigger.cards, trigger.card];
            if (trigger.source)
              Evt._args.push(trigger.source);
            else
              Evt._args.push("nosource");
            if (trigger.nofatal)
              Evt.args.push('nofatal')
          },
          () => {
            if (Evt.targets.length) {
              var target = Evt.targets.shift();
              if (target.isLinked())
                target.damage.apply(target, Evt._args.slice(0));
              Evt.redo();
            }
          }],
        },
        _lianhuan4: {
          trigger: { player: 'changeHp' },
          priority: -10,
          forced: true,
          popup: false,
          forceDie: true,
          filter: function (Evt, player) {
            var evt = Evt.getParent();
            return evt && evt.name == 'damage' && evt.nature && lib.linked.contains(evt.nature) && player.isLinked();
          },
          content: function () {
            var overNature = trigger.getParent().oceanAddDam || false;
            if (trigger.getParent(2).type == 'card' && get.nature(trigger.getParent(2).card) == 'yami' && trigger.getParent(3).yamiDirect) overNature = true;
            if (!overNature) {
              player.link();
              if (trigger.getParent().notLink()) trigger.getParent().lianhuanable = true;
            }
          }
        }
      },
      character: {},
      init,
      element,
      mode: _mode,
      message: _message,
      /**
       * 珠联璧合映射
       * @type {!Object}
       */
      perfectPair: {},
      cardPile: {},
      /**
       * 游戏牌颜色
       * @type {('red'|'black'|'none')}
       */
      color: ['red', 'black', 'none'],
      /**
       * 游戏牌花色
       * @type {('club'|'spade'|'diamond'|'heart')}
       */
      suit: ['club', 'spade', 'diamond', 'heart'],
      /**
       * 游戏牌点数
       * @type {('A'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'X'|'J'|'Q'|'K')}
       */
      number: ['A', '2', '3', '4', '5', '6', '7', '8', '9', 'X', 'J', 'Q', 'K'],
      /**
       * 游戏阶段
       * 
       * @type {string[]}
       */
      phaseName: ['phaseZhunbei', 'phaseJudge', 'phaseDraw', 'phaseUse', 'phaseDiscard', 'phaseJieshu'],
      /**
       * 历史记录
       * 
       * @type {Object}
       */
      historyRecorder: {
        useCard: [],
        respond: [],
        skipped: [],
        lose: [],
        gain: [],
        sourceDamage: [],
        damage: [],
        recover: [],
        changeHujia: [],
        judge: [],
        custom: []
      },
      /**
       * 快捷语音 - TODO
       * @type {string[]}
       */
      quickVoice: [
        '我从未见过如此厚颜无耻之人！',
        '这波不亏',
        '请收下我的膝盖',
        '你咋不上天呢',
        '放开我的队友，冲我来',
        '你随便杀，闪不了算我输',
        '见证奇迹的时刻到了',
        '能不能快一点啊，兵贵神速啊',
        '主公，别开枪，自己人',
        '小内再不跳，后面还怎么玩儿啊',
        '你们忍心，就这么让我酱油了？',
        '我，我惹你们了吗',
        '姑娘，你真是条汉子',
        '三十六计，走为上，容我去去便回',
        '人心散了，队伍不好带啊',
        '昏君，昏君啊！',
        '风吹鸡蛋壳，牌去人安乐',
        '小内啊，您老悠着点儿',
        '不好意思，刚才卡了',
        '你可以打得再烂一点吗',
        '哥们，给力点儿行嘛',
        '哥哥，交个朋友吧',
        '妹子，交个朋友吧',
      ],

      group: (__webpack_require__(8430).group),
      group2: (__webpack_require__(8430).group2),
      groupnature: (__webpack_require__(8430).groupnature),
      nature: (__webpack_require__(4270).nature),
      linked: (__webpack_require__(4270).linked),
      translate: (__webpack_require__(8456).translate),
    }
  }
}

/***/ }),

/***/ 7747:
/***/ (function(module) {

{
  /**
   * 基础属性
   * @namespace
   */
  const { game, ui, get, ai, lib, _status } = vkCore
  module.exports = {
    /**
     * 内容方法，setContent所调用的方法，即事件的具体内容
     * 状态机
     * @name content
     * @namespace
     * @global
     */
    content: {
      resetRound: function () {
        let skill = Evt.resetSkill || Evt.name.slice(0, Evt.name.indexOf('_roundcount'));
        if (!player || !lib.skill[skill]) return;
        let roundname = skill + '_roundcount';
        if (player.storage[roundname] > 0) {
          player.storage[roundname]--
        }
        if (player.storage[roundname] > 0) {
          player.updateMarks();
        }
        else {
          player.unmarkSkill(roundname);
        }
      },
      //崭新出炉
      choosePromotion: [() => {
        let list = [];
        if (!lib.cardPack.mode_derivation || !lib.cardPack.mode_derivation.length)
          Evt.finish();
        for (let i of lib.cardPack.mode_derivation) {
          let info = lib.card[i];
          if (info && info.materials && (typeof info.materials == 'function' || Array.isArray(info.materials)))
            list.push(i);
        }
        if (Evt.filterProduct)
          list = list.filter(Evt.filterProduct);
        Evt.list = list;
      }, () => {
        let next = player.chooseButton([Evt.prompt, '###额外区###（可以右键/长按查看合成路线）', [Evt.list, 'vcard'], '素材区', [Evt.materials, 'card'], 'hidden'], Evt.forced);
        next.set('filterButton', function (button) {
          let ub = ui.selected.buttons;
          if (get.itemtype(button.link) == 'card') {
            if (!ub.length)
              return false;
            let card = button.link;
            let scards = ub.slice(1).map(function (scard) {
              return scard.link;
            });
            let product = ub[0].link[2];
            scards = scards.filter(function (scard) {
              return get.itemtype(scard) == 'card';
            });
            if (_status.event.filterMaterial && !_status.event.filterMaterial(button.link, scards))
              return false;
            let filter = get.info({ name: product }).materials;
            if (Array.isArray(filter)) {
              if (filter.length > scards.length) {
                let mate = filter.slice(0);
                let smate = [];
                for (let j = 0; j < mate.length; j++) {
                  for (let k of scards) {
                    if (!smate.contains(k)) {
                      if (get.is.filterCardBy(k, mate[j])) {
                        smate.push(k);
                        mate.splice(j--, 1);
                      }
                    }
                  }
                }
                for (let j = 0; j < mate.length; j++) {
                  if (mate[j].number) console.log(mate[j], get.number(card))
                  if (get.is.filterCardBy(card, mate[j])) {
                    return true;
                  }
                }

              }
              return false;
            }
            return true;
          }
          if (ub.length)
            return false;
          return true;
        });
        next.set('selectButton', function () {
          let ub = ui.selected.buttons;
          if (ub.length) {
            let scards = ub.slice(1).map(function (scard) {
              return scard.link;
            });
            let product = ub[0].link[2];
            if (get.info({ name: product })) {
              let filter = get.info({ name: product }).materials;
              if (Array.isArray(filter)) {
                if (filter.length == scards.length) {
                  let mate = filter.slice(0);
                  for (let j = 0; j < mate.length; j++) {
                    for (let k of scards) {
                      if (get.is.filterCardBy(k, mate[j])) {
                        mate.splice(j--, 1);
                      }
                    }
                  }
                  if (mate.length == 0)
                    return ub.length;
                }
              }
            }
            else {
              ui.selected.buttons.length = 0
            }
          }
          return [ub.length + 1, ub.length + 2];
        });
        next.set('filterMaterial', Evt.filterMaterial);
        let fun = function () {
          if (!ui.promotionbutton)
            lib.init.sheet(`
              .promotionbutton{
                width: calc(90% - 100px);
                left: calc(5% + 50px);
              }`, `
              .promotion{
                transition: .5s;
              }`)
          return ui.create.control('切换弹窗大小', () => {
            ui.dialog.classList.add('promotion')
            ui.dialog.classList.toggle('promotionbutton')
            if (ui.dialog.classList.contains('promotionbutton')) {
              ui.dialog._heightset = 'calc(90% - 120px)'
              ui.dialog.promotionbutton = true
            }
            else {
              ui.dialog.style.height = ''
              ui.dialog.promotionbutton = false
            }
            ui.update()
          })
        }
        if (player.isOnline2()) {
          player.send(fun);
        }
        Evt.control = fun();
        if (player != game.me || _status.auto) {
          Evt.control.style.display = 'none';
        }
      }, () => {
        if (player.isOnline2()) {
          player.send(function () { ui.controls[0].close() });
        }
        Evt.control.close()
        if (result.bool) {
          let cards = result.links.slice(1);
          let star = game.createCard2(result.links[0][2], get.suit3(cards).randomGet(), 14);
          Evt.result = {
            bool: true,
            cards: cards,
            materials: cards,
            star: star,
          };
        }
        else
          Evt.result = { bool: false };
      }],
      emptyEvent: function () {
        Evt.trigger(Evt.name);
      },
      chooseToPlayBeatmap: function () {
        'step 0'
        if (game.online) return;
        if (_status.connectMode) event.time = lib.configOL.choose_timeout;
        event.videoId = lib.status.videoId++;
        //给其他角色看的演奏框
        game.broadcastAll(function (player, id, beatmap) {
          if (_status.connectMode) lib.configOL.choose_timeout = (Math.ceil((beatmap.timeleap[beatmap.timeleap.length - 1] + beatmap.speed * 100 + (beatmap.current || 0)) / 1000) + 5).toString();
          if (player == game.me) return;
          var str = get.translation(player) + '正在演奏《' + beatmap.name + '》...<br>';
          ui.create.dialog(str).videoId = id;
          if (ui.backgroundMusic) ui.backgroundMusic.pause();
          if (lib.config.background_audio) {
            if (beatmap.filename.indexOf('ext:') == 0) game.playAudio('..', 'extension', beatmap.filename.slice(4), beatmap.name);
            else game.playAudio('effect', beatmap.filename);
          }
        }, player, event.videoId, event.beatmap);
        'step 1'
        var beatmap = event.beatmap;
        if (event.isMine()) {
          var timeleap = beatmap.timeleap.slice(0);
          var current = beatmap.current;
          //获取两个音符的时间间隔
          var getTimeout = function () {
            var time = timeleap.shift();
            var out = time - current;
            current = time;
            return out;
          };
          //初始化一堆变量
          var score = 0;
          var added = timeleap.length;
          var abs = 1;
          var node_pos = 0;
          var combo = 0;
          var max_combo = 0;
          var nodes = [];
          var roundmenu = false;
          //隐藏菜单按钮
          if (ui.roundmenu && ui.roundmenu.display != 'none') {
            roundmenu = true;
            ui.roundmenu.style.display = 'none';
          }
          if (ui.backgroundMusic) ui.backgroundMusic.pause();
          var event = _status.event;
          event.settleed = false;
          //建个框框
          var dialog = ui.create.dialog('forcebutton', 'hidden');
          event.dialog = dialog;
          event.dialog.textPrompt = event.dialog.add('<div class="text center">' + (beatmap.prompt || '在音符滑条和底部判定区重合时点击屏幕！') + '</div>');
          event.switchToAuto = function () { };
          event.dialog.classList.add('fixed');
          event.dialog.classList.add('scroll1');
          event.dialog.classList.add('scroll2');
          event.dialog.classList.add('fullwidth');
          event.dialog.classList.add('fullheight');
          event.dialog.classList.add('noupdate');
          event.dialog.style.overflow = 'hidden';
          //结束后操作
          event.settle = function () {
            if (event.settleed) return;
            event.settleed = true;
            //评分
            var acc = Math.floor(score / (added * 5) * 100);
            var rank;
            if (acc == 100) rank = ['SS', 'metal'];
            else if (acc >= 94) rank = ['S', 'orange'];
            else if (acc >= 87) rank = ['A', 'wood'];
            else if (acc >= 80) rank = ['B', 'water'];
            else if (acc >= 65) rank = ['C', 'thunder'];
            else rank = ['D', 'fire'];
            event.dialog.textPrompt.innerHTML = '<div class="text center">演奏结束！<br>最大连击数：' + max_combo + '  精准度：' + acc + '%</div>';
            game.me.$fullscreenpop('<span style="font-family:xinwei">演奏评级：<span data-nature="' + rank[1] + '">' + rank[0] + '</span></span>', null, null, false);
            //返回结果并继续游戏
            setTimeout(function () {
              event._result = {
                bool: true,
                accuracy: acc,
                rank: rank,
              };
              event.dialog.close();
              game.resume();
              _status.imchoosing = false;
              if (roundmenu) ui.roundmenu.style.display = '';
              if (ui.backgroundMusic) ui.backgroundMusic.play();
            }, 1000);
          };
          event.dialog.open();
          //操作容差
          var height = event.dialog.offsetHeight;
          var width = event.dialog.offsetWidth;
          var range1 = (beatmap.range1 || [90, 110]);
          var range2 = (beatmap.range2 || [93, 107]);
          var range3 = (beatmap.range3 || [96, 104]);
          var speed = (beatmap.speed || 25);
          //初始化底部的条子
          var judger = ui.create.div('');
          judger.style["background-image"] = (beatmap.judgebar_color || 'linear-gradient(rgba(240, 235, 3, 1), rgba(230, 225, 5, 1))');
          judger.style["border-radius"] = '3px';
          judger.style.position = 'absolute';
          judger.style.opacity = '0.3';
          var heightj = Math.ceil(height * (beatmap.judgebar_height || 0.1));
          judger.style.height = heightj + 'px';
          judger.style.width = width + 'px';
          judger.style.left = '0px';
          judger.style.top = (height - heightj) + 'px';
          event.dialog.appendChild(judger);
          //生成每个音符
          var addNode = function () {
            var node = ui.create.div('');
            nodes.push(node);
            node.style["background-image"] = (beatmap.node_color || 'linear-gradient(rgba(120, 120, 240, 1), rgba(100, 100, 230, 1))');
            node.style["border-radius"] = '3px';
            node.style.position = 'absolute';
            node.style.height = Math.ceil(height / 10) + 'px';
            node.style.width = Math.ceil(width / 6) - 10 + 'px';
            node._position = get.utc();
            event.dialog.appendChild(node);

            node.style.left = Math.ceil(width * node_pos / 6 + 5) + 'px';
            node.style.top = '-' + (Math.ceil(height / 10)) + 'px';
            ui.refresh(node);
            node.style.transition = 'all ' + speed * 110 + 'ms linear';
            node.style.transform = 'translateY(' + Math.ceil(height * 1.1) + 'px)';
            node.timeout = setTimeout(function () {
              if (nodes.contains(node)) {
                nodes.remove(node);
                player.popup('Miss', 'fire', false);
                if (player.damagepopups.length) player.$damagepop();
                combo = 0;
              }
            }, speed * 110);

            node_pos += abs;
            if (node_pos > 5) {
              abs = -1;
              node_pos = 4;
            }
            else if (node_pos < 0) {
              abs = 1;
              node_pos = 1;
            }
            if (timeleap.length) {
              setTimeout(function () {
                addNode();
              }, getTimeout());
            }
            else {
              setTimeout(function () {
                event.settle();
              }, speed * 110 + 100)
            }
          }
          //点击时的判断操作
          var click = function () {
            if (!nodes.length) return;
            for (var node of nodes) {
              //用生成到点击的时间差来判断距离
              var time = get.utc();
              var top = (time - node._position) / speed;
              if (top > range1[1]) continue;
              else if (top < range1[0]) return;
              nodes.remove(node);
              clearTimeout(node.timeout);
              node.style.transform = '';
              node.style.transition = 'all 0s';
              node.style.top = (height * ((top - 10) / 100)) + 'px';
              ui.refresh(node);
              node.style.transition = 'all 0.5s';
              node.style.transform = 'scale(1.2)';
              node.delete();
              if (top >= range3[0] && top < range3[1]) {
                score += 5;
                player.popup('Perfect', 'orange', false);
              }
              else if (top >= range2[0] && top < range2[1]) {
                score += 3;
                player.popup('Great', 'wood', false);
              }
              else {
                score += 1;
                player.popup('Good', 'soil', false);
              }
              if (player.damagepopups.length) player.$damagepop();
              combo++;
              max_combo = Math.max(combo, max_combo);
              break;
            }
          };
          document.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', click);

          game.pause();
          game.countChoose();
          setTimeout(function () {
            if (lib.config.background_audio) {
              if (beatmap.filename.indexOf('ext:') == 0) game.playAudio('..', 'extension', beatmap.filename.slice(4), beatmap.name);
              else game.playAudio('effect', beatmap.filename);
            }
          }, Math.floor(speed * 100 * (0.9 + beatmap.judgebar_height)) + beatmap.current);
          setTimeout(function () {
            addNode();
          }, getTimeout());
        }
        else if (event.isOnline()) {
          event.send();
        }
        else {
          game.pause();
          game.countChoose();
          setTimeout(function () {
            _status.imchoosing = false;
            var acc = get.rand.apply(get, beatmap.aiAcc || [70, 100]);
            var rank;
            if (acc == 100) rank = ['SS', 'metal'];
            else if (acc >= 94) rank = ['S', 'orange'];
            else if (acc >= 87) rank = ['A', 'green'];
            else if (acc >= 80) rank = ['B', 'water'];
            else if (acc >= 65) rank = ['C', 'thunder'];
            else rank = ['D', 'fire'];
            event._result = {
              bool: true,
              accuracy: acc,
              rank: rank,
            };
            if (event.dialog) event.dialog.close();
            if (event.control) event.control.close();
            game.resume();
          }, beatmap.timeleap[beatmap.timeleap.length - 1] + beatmap.speed * 100 + 1000 + (beatmap.current || 0));
        }
        'step 2'
        game.broadcastAll(function (id, time) {
          if (_status.connectMode) lib.configOL.choose_timeout = time;
          var dialog = get.idDialog(id);
          if (dialog) {
            dialog.close();
          }
          if (ui.backgroundMusic) ui.backgroundMusic.play();
        }, event.videoId, event.time);
        var result = event.result || result;
        event.result = result;
      },
      chooseToMove: [() => {
        if (event.chooseTime && _status.connectMode && !game.online) {
          event.time = lib.configOL.choose_timeout;
          game.broadcastAll(function (time) {
            lib.configOL.choose_timeout = time;
          }, event.chooseTime);
        }
        if (event.isMine()) {
          delete ui.selected.guanxing_button;
          var list = event.list, filterMove = event.filterMove, filterOk = event.filterOk;
          _status.imchoosing = true;
          var event = _status.event;
          event.settleed = false;
          event.dialog = ui.create.dialog(event.prompt || '请选择要操作的牌', 'hidden', 'forcebutton');
          event.switchToAuto = function () {
            if (!filterOk(event.moved)) {
              if (!event.forced) event._result = { bool: false };
              else event._result = 'ai';
            }
            else {
              event._result = {
                bool: true,
                moved: event.moved,
              };
            }
            event.dialog.close();
            if (ui.confirm) ui.confirm.close();
            game.resume();
            _status.imchoosing = false;
          };
          event.dialog.classList.add('scroll1');
          event.dialog.classList.add('scroll2');
          event.dialog.classList.add('fullwidth');

          event.moved = [];
          var buttonss = [];
          event.buttonss = buttonss;
          var updateButtons = function () {
            for (var i of buttonss) {
              event.moved[i._link] = get.links(Array.from(i.childNodes));
              if (i.textPrompt) i.previousSibling.innerHTML = ('<div class="text center">' + i.textPrompt(event.moved[i._link]) + '</div>');
            }
            if (filterOk(event.moved)) {
              ui.create.confirm('o');
            }
            else {
              if (!event.forced) ui.create.confirm('c');
              else if (ui.confirm) ui.confirm.close();
            }
          };
          var clickButtons = function () {
            if (!ui.selected.guanxing_button) return;
            if (ui.selected.guanxing_button.parentNode == this) return;
            if (!filterMove(ui.selected.guanxing_button, this._link, event.moved)) return;
            ui.selected.guanxing_button.classList.remove('glow2');
            this.appendChild(ui.selected.guanxing_button);
            delete ui.selected.guanxing_button;
            updateButtons();
          };

          for (var i = 0; i < list.length; i++) {
            event.dialog.add('<div class="text center">' + list[i][0] + '</div>');
            var buttons = ui.create.div('.buttons', event.dialog.content, clickButtons);
            buttonss.push(buttons);
            buttons.classList.add('popup');
            buttons.classList.add('guanxing');
            buttons._link = i;
            if (list[i][1]) {
              ui.create.buttons(list[i][1], 'card', buttons);
            }
            if (list[i][2]) buttons.textPrompt = list[i][2];
          }
          event.dialog.open();
          updateButtons();

          event.custom.replace.button = function (button) {
            if (!ui.selected.guanxing_button) {
              ui.selected.guanxing_button = button;
              button.classList.add('glow2');
              return;
            }
            if (ui.selected.guanxing_button == button) {
              button.classList.remove('glow2');
              delete ui.selected.guanxing_button;
              return;
            }
            if (!filterMove(button, ui.selected.guanxing_button, event.moved)) return;
            var par1 = ui.selected.guanxing_button.parentNode, ind1 = ui.selected.guanxing_button.nextSibling, par2 = button.parentNode, ind2 = button.nextSibling;
            ui.selected.guanxing_button.classList.remove('glow2');
            par1.insertBefore(button, ind1);
            par2.insertBefore(ui.selected.guanxing_button, ind2);
            delete ui.selected.guanxing_button;
            updateButtons();
          }
          event.custom.replace.confirm = function (bool) {
            if (bool) event._result = {
              bool: true,
              moved: event.moved,
            };
            else event._result = { bool: false };
            event.dialog.close();
            if (ui.confirm) ui.confirm.close();
            game.resume();
            _status.imchoosing = false;
          };

          game.pause();
          game.countChoose();
          event.choosing = true;
        }
        else if (event.isOnline()) {
          event.send();
        }
        else {
          event.result = 'ai';
        }
      }, () => {
        if (event.time) game.broadcastAll(function (time) {
          lib.configOL.choose_timeout = time;
        }, event.time);
        var result = event.result || result;
        if ((!result || result == 'ai' || (event.forced && !result.bool)) && event.processAI) {
          var moved = event.processAI(event.list);
          if (moved) result = {
            bool: true,
            moved: moved,
          }
          else result = { bool: false };
        }
        event.result = result;
      }],
      showCharacter: [function () {
        Evt.trigger('showCharacterEnd');
      }, function () {
        Evt.trigger('showCharacterAfter');
        if (get.mode() == 'identity' && player.isZhu) Evt.trigger('zhuUpdate');
      }],
      removeCharacter: function () {
        player.$removeCharacter(Evt.num);
      },
      chooseUseTarget: [function () {
        if (get.is.object(card) && !Evt.viewAs) card.isCard = true;
        if (cards && get.itemtype(card) != 'card') {
          card = get.copy(card);
          card.cards = cards.slice(0);
          Evt.card = card;
        }
        if (!lib.filter.cardEnabled(card, player) || (Evt.addCount !== false && !lib.filter.cardUsable(card, player))) {
          Evt.result = { bool: false };
          Evt.finish();
          return;
        }
        let info = get.info(card);
        let range;
        if (!info.notarget) {
          let select = get.copy(info.selectTarget);
          if (select == undefined) {
            range = [1, 1];
          }
          else if (typeof select == 'number') range = [select, select];
          else if (get.itemtype(select) == 'select') range = select;
          else if (typeof select == 'function') range = select(card, player);
          game.checkMod(card, player, range, 'selectTarget', player);
        }
        if (info.notarget || range[1] == -1) {
          if (!info.notarget && range[1] == -1) {
            for (let i = 0; i < targets.length; i++) {
              if (!player.canUse(card, targets[i], Evt.nodistance ? false : null, Evt.addCount === false ? null : true)) {
                targets.splice(i--, 1);
              }
            }
            if (targets.length) {
              Evt.targets2 = targets;
            }
            else {
              Evt.finish();
              return;
            }
          }
          else Evt.targets2 = [];
          if (Evt.forced) {
            Evt._result = { bool: true };
          }
          else {
            let next = player.chooseBool();
            next.set('prompt', Evt.prompt || ('是否' + (Evt.targets2.length ? '对' : '') + get.translation(Evt.targets2) + '使用' + get.translation(card) + '?'));
            if (Evt.hsskill) next.setHiddenSkill(Evt.hsskill);
            if (Evt.prompt2) next.set('prompt2', Evt.prompt2);
            next.ai = function () {
              let eff = 0;
              for (let i of Evt.targets2) {
                eff += get.effect(i, card, player, player);
              }
              return eff > 0;
            };
          }
        }
        else {
          let next = player.chooseTarget();
          next.set('_get_card', card);
          next.set('filterTarget', function (card, player, target) {
            if (!_status.event.targets.contains(target)) return false;
            if (!_status.event.nodistance && !lib.filter.targetInRange(card, player, target)) return false;
            return lib.filter.targetEnabledx(card, player, target);
          });
          next.set('ai', Evt.ai || get.effect_use);
          next.set('selectTarget', Evt.selectTarget || lib.filter.selectTarget);
          if (Evt.nodistance) next.set('nodistance', true);
          if (Evt.forced) next.set('forced', true);
          if (Evt.addCount !== false) next.set('addCount_extra', true);
          next.set('targets', targets);
          next.set('prompt', Evt.prompt || ('选择' + get.translation(card) + '的目标'));
          if (Evt.prompt2) next.set('prompt2', Evt.prompt2);
          if (Evt.hsskill) next.setHiddenSkill(Evt.hsskill);
        }
      }, function () {
        if (result.bool) {
          Evt.result = {
            bool: true,
            targets: Evt.targets2 || result.targets,
          };
          let next = player.useCard(card, Evt.targets2 || result.targets);
          next.oncard = Evt.oncard;
          if (cards) next.cards = cards.slice(0);
          if (Evt.nopopup) next.nopopup = true;
          if (Evt.animate === false) next.animate = false;
          if (Evt.throw === false) next.throw = false;
          if (Evt.addCount === false) next.addCount = false;
          if (Evt.noTargetDelay) next.targetDelay = false;
          if (Evt.nodelayx) next.delayx = false;
          if (Evt.logSkill) {
            if (typeof Evt.logSkill == 'string') {
              next.skill = Evt.logSkill;
            }
            else if (Array.isArray(Evt.logSkill)) {
              player.logSkill.apply(player, Evt.logSkill);
            }
          }
        }
        else Evt.result = { bool: false };
      }],
      chooseToDuiben: [function () {
        game.log(player, '对', target, '发起了', '#y对策');
        if (_status.connectMode) {
          player.chooseButtonOL([
            [player, ['对策：请选择一种防御对策', [[['', '', 'db_def2'], ['', '', 'db_def1']], 'vcard']], true],
            [target, ['对策：请选择一种进攻之策', [[['', '', 'db_atk1'], ['', '', 'db_atk2']], 'vcard']], true]
          ], function () { }, function () { return 1 + Math.random() }).set('switchToAuto', function () {
            _status.event.result = 'ai';
          }).set('processAI', function () {
            let buttons = _status.event.dialog.buttons;
            return {
              bool: true,
              links: [buttons.randomGet().link],
            }
          });
        }
      }, function () {
        if (_status.connectMode) {
          Evt.mes = result[player.playerid].links[0][2];
          Evt.tes = result[target.playerid].links[0][2];
          Evt.goto(4);
        }
        else {
          player.chooseButton(['对策：请选择一种防御对策', [[['', '', 'db_def2'], ['', '', 'db_def1']], 'vcard']], true).ai = function () { return 1 + Math.random() };
        }
      }, function () {
        Evt.mes = result.links[0][2];
        target.chooseButton(['对策：请选择一种进攻之策', [[['', '', 'db_atk1'], ['', '', 'db_atk2']], 'vcard']], true).ai = function () { return 1 + Math.random() };
      }, function () {
        Evt.tes = result.links[0][2];
      }, function () {
        game.broadcast(function () {
          ui.arena.classList.add('thrownhighlight');
        });
        ui.arena.classList.add('thrownhighlight');
        game.addVideo('thrownhighlight1');
        target.$compare(game.createCard(Evt.tes, '', ''), player, game.createCard(Evt.mes, '', ''));
        game.log(target, '选择的进攻之策为', '#g' + get.translation(Evt.tes));
        game.log(player, '选择的防御对策为', '#g' + get.translation(Evt.mes));
        game.delay(0, 1500);
      }, function () {
        let mes = Evt.mes.slice(6);
        let tes = Evt.tes.slice(6);
        let str;
        if (mes == tes) {
          str = get.translation(player) + '对策成功';
          player.popup('胜', 'wood');
          target.popup('负', 'fire');
          game.log(player, '#g胜');
          Evt.result = { bool: true };
        }
        else {
          str = get.translation(player) + '对策失败';
          target.popup('胜', 'wood');
          player.popup('负', 'fire');
          game.log(target, '#g胜');
          Evt.result = { bool: false };
        }
        game.broadcastAll(function (str) {
          let dialog = ui.create.dialog(str);
          dialog.classList.add('center');
          setTimeout(() => {
            dialog.close();
          }, 1000);
        }, str);
        game.delay(2);
      }, function () {
        game.broadcastAll(function () {
          ui.arena.classList.remove('thrownhighlight');
        });
        game.addVideo('thrownhighlight2');
        if (Evt.clear !== false) {
          game.broadcastAll(ui.clear);
        }
      }],
      chooseToPSS: [function () {
        game.log(player, '对', target, '发起了猜拳');
        if (_status.connectMode) {
          player.chooseButtonOL([
            [player, ['猜拳：请选择一种手势', [[['', '', 'pss_stone'], ['', '', 'pss_scissor'], ['', '', 'pss_paper']], 'vcard']], true],
            [target, ['猜拳：请选择一种手势', [[['', '', 'pss_stone'], ['', '', 'pss_scissor'], ['', '', 'pss_paper']], 'vcard']], true]
          ], function () { }, function () { return 1 + Math.random() }).set('switchToAuto', function () {
            _status.event.result = 'ai';
          }).set('processAI', () => {
            let buttons = _status.event.dialog.buttons;
            return {
              bool: true,
              links: [buttons.randomGet().link],
            };
          });
        }
      }, function () {
        if (_status.connectMode) {
          Evt.mes = result[player.playerid].links[0][2];
          Evt.tes = result[target.playerid].links[0][2];
          Evt.goto(4);
        }
        else {
          player.chooseButton(['猜拳：请选择一种手势', [[['', '', 'pss_stone'], ['', '', 'pss_scissor'], ['', '', 'pss_paper']], 'vcard']], true).ai = function () { return 1 + Math.random() };
        }
      }, function () {
        Evt.mes = result.links[0][2];
        target.chooseButton(['猜拳：请选择一种手势', [[['', '', 'pss_stone'], ['', '', 'pss_scissor'], ['', '', 'pss_paper']], 'vcard']], true).ai = function () { return 1 + Math.random() };
      }, function () {
        Evt.tes = result.links[0][2];
      }, function () {
        game.broadcast(function () {
          ui.arena.classList.add('thrownhighlight');
        });
        ui.arena.classList.add('thrownhighlight');
        game.addVideo('thrownhighlight1');
        player.$compare(game.createCard(Evt.mes, '', ''), target, game.createCard(Evt.tes, '', ''));
        game.log(player, '选择的手势为', '#g' + get.translation(Evt.mes));
        game.log(target, '选择的手势为', '#g' + get.translation(Evt.tes));
        game.delay(0, 1500);
      }, function () {
        let mes = Evt.mes.slice(4);
        let tes = Evt.tes.slice(4);
        let str;
        if (mes == tes) {
          str = '二人平局';
          player.popup('平', 'metal');
          target.popup('平', 'metal');
          game.log('猜拳的结果为', '#g平局');
          Evt.result = { tie: true };
        }
        else {
          if ({ paper: 'stone', scissor: 'paper', stone: 'scissor' }[mes] == tes) {
            str = get.translation(player) + '胜利';
            player.popup('胜', 'wood');
            target.popup('负', 'fire');
            game.log(player, '#g胜');
            Evt.result = { bool: true, winner: mes };
          }
          else {
            str = get.translation(target) + '胜利';
            target.popup('胜', 'wood');
            player.popup('负', 'fire');
            game.log(target, '#g胜');
            Evt.result = { bool: false, winner: tes };
          }
        }
        game.broadcastAll(function (str) {
          let dialog = ui.create.dialog(str);
          dialog.classList.add('center');
          setTimeout(function () {
            dialog.close();
          }, 1000);
        }, str);
        game.delay(2);
      }, function () {
        game.broadcastAll(function () {
          ui.arena.classList.remove('thrownhighlight');
        });
        game.addVideo('thrownhighlight2');
        if (Evt.clear !== false) {
          game.broadcastAll(ui.clear);
        }
      }],
      cardsDiscard: function () {
        game.getGlobalHistory().cardMove.push(Evt);
        for (let i of cards) {
          i.discard();
        }
      },
      orderingDiscard: function () {
        let cards = Evt.relatedEvent.orderingCards;
        for (let i = 0; i < cards.length; i++) {
          if (get.position(cards[i], true) != 'o') cards.splice(i--, 1);
        }
        if (cards.length) game.cardsDiscard(cards);
      },
      cardsGotoOrdering: function () {
        game.getGlobalHistory().cardMove.push(Evt);
        for (let i of cards) {
          i.fix();
          ui.ordering.appendChild(i);
        }
        let evt = Evt.relatedEvent || Evt.getParent();
        if (!evt.orderingCards) evt.orderingCards = [];
        if (!Evt.noOrdering && !Evt.cardsOrdered) {
          Evt.cardsOrdered = true;
          let next = game.createEvent('orderingDiscard', false, evt.getParent());
          next.relatedEvent = evt;
          next.setContent('orderingDiscard');
        }
        if (!Evt.noOrdering) evt.orderingCards.addArray(cards);
      },
      cardsGotoSpecial: function () {
        game.getGlobalHistory().cardMove.push(Evt);
        for (let i of cards) {
          i.fix();
          ui.special.appendChild(i);
        }
        if (Evt.notrigger !== true) Evt.trigger('addCardToStorage');
      },
      chooseToEnable: [function () {
        let list = [];
        for (let i = 1; i < 6; i++) {
          if (!player.isDisabled(i)) continue;
          list.push('equip' + i);
        }
        if (!list.length) Evt.finish();
        else {
          Evt.list = list;
          let next = player.chooseControl(list);
          next.set('prompt', '请选择恢复一个装备栏');
          if (!Evt.ai) Evt.ai = function (Evt, player, list) {
            return list.randomGet();
          }
          Evt.ai = Evt.ai(Evt.getParent(), player, list);
          next.ai = function () {
            return Evt.ai;
          };
        }
      }, function () {
        Evt.result = { control: result.control };
        player.enableEquip(result.control);
      }],
      chooseToDisable: [function () {
        let list = [];
        for (let i = 1; i < 7; i++) {
          if ((i == 3 || i == 4) && Evt.horse) continue;
          if (i == 6 && !Evt.horse) continue;
          if (player.isDisabled(i)) continue;
          list.push('equip' + i);
        }
        if (!list.length) Evt.finish();
        else {
          Evt.list = list;
          let next = player.chooseControl(list);
          next.set('prompt', '请选择废除一个装备栏');
          if (!Evt.ai) Evt.ai = function (Evt, player, list) {
            return list.randomGet();
          }
          Evt.ai = Evt.ai(Evt.getParent(), player, list);
          next.ai = function () {
            return Evt.ai;
          };
        }
      }, function () {
        Evt.result = { control: result.control };
        if (result.control == 'equip6') {
          player.disableEquip(3);
          player.disableEquip(4);
        }
        else player.disableEquip(result.control);
      }],
      swapEquip: [() => {
        game.log(player, '和', target, '交换了装备区中的牌')
        let e1 = player.getCards('e');
        let todis1 = [];
        for (let i of e1) {
          if (target.isDisabled(get.subtype(i))) todis1.push(i);
        }
        player.discard(todis1);
        let e2 = target.getCards('e');
        let todis2 = [];
        for (let i of e2) {
          if (player.isDisabled(get.subtype(i))) todis2.push(i);
        }
        target.discard(todis2);
      }, () => {
        Evt.cards = [player.getCards('e'), target.getCards('e')];
        player.lose(Evt.cards[0], ui.ordering, 'visible');
        target.lose(Evt.cards[1], ui.ordering, 'visible');
        if (Evt.cards[0].length) player.$give(Evt.cards[0], target, false);
        if (Evt.cards[1].length) target.$give(Evt.cards[1], player, false);
      }, () => {
        for (let i = 0; i < Evt.cards[1].length; i++) {
          player.equip(Evt.cards[1][i]);
        }
        for (let i = 0; i < Evt.cards[0].length; i++) {
          target.equip(Evt.cards[0][i]);
        }
      }],
      disableEquip: function () {
        if (!player.isDisabled(Evt.pos)) {
          let cards = player.getCards('e', (card) => {
            let subtype = get.subtype(card);
            if (subtype == Evt.pos)
              return true;
            if (subtype == 'equip6' && ['equip3', 'equip4'].contains(Evt.pos))
              return true;
            return false;
          });
          if (cards.length) player.discard(cards).delay = false;
          game.log(player, '废除了', get.translation(Evt.pos), '栏');
          player.$disableEquip(Evt.pos);
        }
      },
      enableEquip: function () {
        if (player.isDisabled(Evt.pos)) {
          player.syncStorage('_disableEquip');
          game.log(player, '恢复了', get.translation(Evt.pos), '栏');
          player.$enableEquip(Evt.pos);
        };
      },
      disableJudge: [function () {
        game.log(player, '废除了判定区');
        let js = player.getCards('j');
        if (js.length) player.discard(js);
        player.$._disableJudge = true;
        //player.markSkill('_disableJudge');},function(){
        game.broadcastAll(function (player, card) {
          player.$disableJudge();
        }, player);
      }],
      enableJudge: function () {
        if (!player.$._disableJudge) return;
        game.log(player, '恢复了判定区');
        game.broadcastAll(function (player) {
          player.$enableJudge();
        }, player);
      },
      /*----分界线----*/
      phasing: [function () {
        while (ui.dialogs.length) {
          ui.dialogs[0].close();
        }
        if (!player.noPhaseDelay && lib.config.show_phase_prompt) {
          player.popup('回合开始');
        }
        if (lib.config.glow_phase) {
          if (_status.currentPhase) {
            _status.currentPhase.classList.remove('glow_phase');
            game.broadcast(function (player) {
              player.classList.remove('glow_phase');
            }, _status.currentPhase);
          }
          player.classList.add('glow_phase');
          game.broadcast(function (player) {
            player.classList.add('glow_phase');
          }, player);
        }
        _status.currentPhase = player;
        _status.discarded = [];
        game.phaseNumber++;
        player.phaseNumber++;
        game.syncState();
        game.addVideo('phaseChange', player);
        if (game.phaseNumber == 1 && lib.configOL.observe) {
          lib.configOL.observeReady = true;
          game.send('server', 'config', lib.configOL);
        }
        game.log();
        game.log(player, '的回合开始');
        player._noVibrate = true;
        if (get.config('identity_mode') != 'zhong' && get.config('identity_mode') != 'purple' && !_status.connectMode) {
          let num;
          switch (get.config('auto_identity')) {
            case 'one': num = 1; break;
            case 'two': num = 2; break;
            case 'three': num = 3; break;
            case 'always': num = -1; break;
            default: num = 0; break;
          }
          if (num && !_status.identityShown && game.phaseNumber > game.players.length * num && game.showIdentity) {
            if (!_status.video) player.popup('显示身份');
            _status.identityShown = true;
            game.showIdentity(false);
          }
        }
        player.ai.tempIgnore = [];
        _status.globalHistory.push({
          cardMove: [],
          custom: [],
        });
        game.countPlayer2(function (current) {
          current.actionHistory.push(JSON.parse(JSON.stringify({ ...lib.historyRecorder })));
          current.stat.push({ card: {}, skill: {} });
          if (Evt.parent._roundStart) {
            current.getHistory().isRound = true;
            current.getStat().isRound = true;
          }
        });
        player.getHistory().isMe = true;
        player.getStat().isMe = true;
        if (Evt.parent._roundStart) {
          game.getGlobalHistory().isRound = true;
        }
        if (ui.land && ui.land.player == player) {
          game.addVideo('destroyLand');
          ui.land.destroy();
        }
      }, function () {
        Evt.trigger('phaseBeginStart');
      }],
      /**
       * 更换随从
       * @name content.toggleSubPlayer
       * @type {GameCores.Bases.StateMachine}
       */
      toggleSubPlayer: [function () {
        let list = Evt.list || player.$.subplayer.skills.slice(0);
        list.remove(player.$.subplayer.name2);
        Evt.list = list;
        if (!Evt.directresult) {
          if (list.length > 1) {
            let dialog = ui.create.dialog('更换一个随从', 'hidden');
            dialog.add([list, 'character']);
            player.chooseButton(dialog, true);
          }
          else if (list.length == 1) {
            Evt.directresult = list[0];
          }
          else {
            Evt.finish();
          }
        }
        else {
          if (!list.contains(Evt.directresult)) {
            Evt.finish();
          }
        }
      }, function () {
        if (!Evt.directresult) {
          if (result && result.bool && result.links[0]) {
            Evt.directresult = result.links[0];
          }
          else {
            Evt.finish();
            return;
          }
        }
        if (player.$.subplayer) {
          let current = player.$.subplayer.name2;
          if (Evt.directresult == current) {
            Evt.finish();
            return;
          }
          player.storage[current].hp = player.hp;
          player.storage[current].maxHp = player.maxHp;
          player.storage[current].hs = player.getCards('h');
          player.storage[current].es = player.getCards('e');
          player.lose(player.getCards('he'), ui.special)._triggered = null;

          let cfg = player.storage[Evt.directresult];
          player.$.subplayer.name2 = Evt.directresult;
          player.reinit(current, Evt.directresult, [
            cfg.hp,
            cfg.maxHp
          ]);
          if (cfg.hs.length) player.directgain(cfg.hs);
          if (cfg.es.length) player.directequip(cfg.es);
        }
      }],
      /**
       * 结束调遣随从
       * @name content.callSubPlayer
       * @type {GameCores.Bases.StateMachine}
       */
      exitSubPlayer: [function () {
        if (player.$.subplayer) {
          let current = player.$.subplayer.name2;
          if (Evt.remove) {
            player.lose(player.getCards('he'), ui.discardPile)._triggered = null;
          }
          else {
            player.storage[current].hp = player.hp;
            player.storage[current].maxHp = player.maxHp;
            player.storage[current].hs = player.getCards('h');
            player.storage[current].es = player.getCards('e');
            player.lose(player.getCards('he'), ui.special)._triggered = null;
          }
          player.reinit(current, player.$.subplayer.name, [
            player.$.subplayer.hp,
            player.$.subplayer.maxHp
          ]);
          player.update();
          if (Evt.remove) {
            if (player.storage[current].onremove) {
              player.storage[current].onremove(player);
            }
            delete player.storage[current];
            player.$.subplayer.skills.remove(current);
            game.log(player, '牺牲了随从', '#g' + current);
          }
          else {
            game.log(player, '收回了随从', '#g' + current);
          }
          player.addSkill(player.$.subplayer.skills);
        }
      }, function () {
        if (player.$.subplayer) {
          player.directgain(player.$.subplayer.hs);
          player.directequip(player.$.subplayer.es);
        }
        player.removeSkill('subplayer');
      }, function () {
        if (Evt.remove) {
          Evt.trigger('subPlayerDie');
        }
      }],
      /**
       * 调遣随从
       * @name content.callSubPlayer
       * @type {GameCores.Bases.StateMachine}
       */
      callSubPlayer: [function () {
        let list = player.getSubPlayers(Evt.tag);
        Evt.list = list;
        if (!Evt.directresult) {
          if (list.length > 1) {
            let dialog = ui.create.dialog('调遣一个随从', 'hidden');
            dialog.add([list, 'character']);
            player.chooseButton(dialog, true);
          }
          else if (list.length == 1) {
            Evt.directresult = list[0];
          }
          else {
            Evt.finish();
          }
        }
        else {
          if (!list.contains(Evt.directresult)) {
            Evt.finish();
          }
        }
      }, function () {
        if (!Evt.directresult) {
          if (result && result.bool && result.links[0]) {
            Evt.directresult = result.links[0];
          }
          else {
            Evt.finish();
            return;
          }
        }
        if (Evt.directresult) {
          let cfg = player.storage[Evt.directresult];
          let source = cfg.source || player.name;
          let name = Evt.directresult;
          game.log(player, '调遣了随从', '#g' + name);
          player.$.subplayer = {
            name: source,
            name2: Evt.directresult,
            hp: player.hp,
            maxHp: player.maxHp,
            skills: Evt.list.slice(0),
            hs: player.getCards('h'),
            es: player.getCards('e'),
            intro2: cfg.intro2
          }
          player.removeSkill(Evt.list);
          player.reinit(source, name, [cfg.hp, cfg.maxHp]);
          player.addSkill('subplayer');
          player.lose(player.getCards('he'), ui.special)._triggered = null;
          if (cfg.hs.length) player.directgain(cfg.hs);
          if (cfg.es.length) player.directequip(cfg.es);
        }
      }, function () {
        game.delay();
      }],
      /**
       * 反转结算顺序
       * @name content.reverseOrder
       * @type {GameCores.Bases.StateMachine}
       */
      reverseOrder: [() => {
        game.delay();
      }, () => {
        let choice;
        if (get.tag(card, 'multineg')) {
          choice = (player.previous.side == player.side) ? '逆时针' : '顺时针';
        }
        else {
          choice = (player.next.side == player.side) ? '逆时针' : '顺时针';
        }
        player.chooseControl('顺时针', '逆时针', function (Evt, player) {
          return _status.event.choice || '逆时针';
        }).set('prompt', '选择' + get.translation(card) + '的结算方向').set('choice', choice).set('forceDie', true);
      }, () => {
        if (result && result.control == '顺时针') {
          let evt = Evt.getParent();
          evt.fixedSeat = true;
          evt.targets.sortBySeat();
          evt.targets.reverse();
          if (evt.targets[evt.targets.length - 1] == player) {
            evt.targets.unshift(evt.targets.pop());
          }
        }
      }],
      /**
       * 使用判定牌
       * @name content.addJudgeCard
       * @type {GameCores.Bases.StateMachine}
       */
      addJudgeCard: function () {
        if (lib.filter.judge(card, player, target) && cards.length && get.position(cards[0], true) == 'o') target.addJudge(card, cards);
      },
      /**
       * 使用装备牌
       * @name content.equipCard
       * @type {GameCores.Bases.StateMachine}
       */
      equipCard: function () {
        if (cards.length && get.position(cards[0], true) == 'o') target.equip(card, cards[0]);
      },
      /**
       * 游戏开始前分牌
       * @name content.gameDraw
       * @type {GameCores.Bases.StateMachine}
       */
      gameDraw: [() => {
        if (_status.brawl && _status.brawl.noGameDraw) {
          Evt.finish();
          return;
        }
        let end = player;
        let numx = num;
        do {
          if (typeof num == 'function') {
            numx = num(player);
          }
          if (player.getTopCards) player.directgain(player.getTopCards(numx));
          else player.directgain(get.cards(numx));
          if (player.singleHp === true && get.mode() != 'guozhan' && (lib.config.mode != 'doudizhu' || _status.mode != 'online')) {
            player.doubleDraw();
          }
          player = player.next;
        }
        while (player != end);
        Evt.changeCard = get.config('change_card');
        if (_status.connectMode || (lib.config.mode == 'doudizhu' && _status.mode == 'online') || lib.config.mode != 'identity' && lib.config.mode != 'guozhan' && lib.config.mode != 'doudizhu' && lib.config.mode != 'longlaoguan') {
          Evt.changeCard = 'disabled';
        }
      }, () => {
        if (Evt.changeCard != 'disabled' && !_status.auto) {
          Evt.dialog = ui.create.dialog('是否使用手气卡？');
          ui.create.confirm('oc');
          Evt.custom.replace.confirm = function (bool) {
            _status.event.bool = bool;
            game.resume();
          }
        }
        else {
          Evt.finish();
        }
      }, () => {
        if (Evt.changeCard == 'once') {
          Evt.changeCard = 'disabled';
        }
        else if (Evt.changeCard == 'twice') {
          Evt.changeCard = 'once';
        }
        else if (Evt.changeCard == 'disabled') {
          Evt.bool = false;
          return;
        }
        _status.imchoosing = true;
        Evt.switchToAuto = function () {
          _status.event.bool = false;
          game.resume();
        }
        game.pause();
      }, () => {
        _status.imchoosing = false;
        if (Evt.bool) {
          if (game.changeCoin) {
            game.changeCoin(-3);
          }
          let hs = game.me.getCards('h');
          game.addVideo('lose', game.me, [get.cardsInfo(hs), [], [], []]);
          for (let i of hs) {
            i.discard(false);
          }
          game.me.directgain(get.cards(hs.length));
          let ss = game.me.getCards('s');
          game.addVideo('lose', game.me, [get.cardsInfo(ss), [], [], []]);
          for (let i of ss) {
            i.discard(false);
          }
          game.me.directgains(get.cards(ss.length));
          Evt.goto(2);
        }
        else {
          if (Evt.dialog) Evt.dialog.close();
          if (ui.confirm) ui.confirm.close();
          Evt.finish();
        }
      }],
      /**
       * 阶段循环
       * @name content.phaseLoop
       * @type {GameCores.Bases.StateMachine}
       */
      phaseLoop: [() => {
        for (var i = 0; i < lib.onphase.length; i++) {
          lib.onphase[i]();
        }
        player.phase();
      }, () => {
        if (!game.players.contains(Evt.player.next)) {
          Evt.player = game.findNext(Evt.player.next);
        }
        else {
          Evt.player = Evt.player.next;
        }
        Evt.goto(0);
      }],
      /**
       * 加载包
       * @name content.loadPackage
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Array<Object>} Evt.packages 包名数组，用于加载
       * @property {string} Evt.packages[].0 包目录，相对`lib.assetURL`路径
       * @property {string} Evt.packages[].1 包名
       */
      loadPackage: [function () {
        if (Evt.packages.length) {
          window.game = game;
          var pack = Evt.packages.shift().split('/');
          lib.init.js(lib.assetURL + pack[0], pack[1], game.resume);
          game.pause();
        }
        else {
          Evt.finish();
        }
      }, function () {
        if (!lib.config.dev) delete window.game;
        var character = lib.imported.character;
        var card = lib.imported.card;
        var i, j, k;
        for (i in character) {
          if (character[i].character) {
            lib.characterPack[i] = character[i].character;
          }
          if (character[i].forbid && character[i].forbid.contains(lib.config.mode)) continue;
          if (character[i].mode && character[i].mode.contains(lib.config.mode) == false) continue;

          if (Array.isArray(lib[j]) && Array.isArray(character[i][j])) {
            lib[j].addArray(character[i][j]);
            continue;
          }
          for (j in character[i]) {
            if (j == 'mode' || j == 'forbid' || j == 'characterSort') continue;
            for (k in character[i][j]) {
              if (j == 'character') {
                if (!character[i][j][k][4]) {
                  character[i][j][k][4] = [];
                }
                if (character[i][j][k][4].contains('boss') ||
                  character[i][j][k][4].contains('hiddenboss')) {
                  lib.config.forbidai.add(k);
                }
                if (lib.config.forbidai_user && lib.config.forbidai_user.contains(k)) {
                  lib.config.forbidai.add(k);
                }
                for (var l = 0; l < character[i][j][k][3].length; l++) {
                  lib.skilllist.add(character[i][j][k][3][l]);
                }
              }
              if (j == 'translate' && k == i) {
                lib[j][k + '_character_config'] = character[i][j][k];
              }
              else {
                if (lib[j][k] == undefined) {
                  lib[j][k] = character[i][j][k];
                }
                else if (Array.isArray(lib[j][k]) && Array.isArray(character[i][j][k])) {
                  lib[j][k].addArray(character[i][j][k]);
                }
                else {
                  console.log('dublicate ' + j + ' in character ' + i + ':\n' + k + '\n' + ': ' + lib[j][k] + '\n' + character[i][j][k]);
                }
              }
            }
          }
        }
        for (i in card) {
          lib.cardPack[i] = [];
          if (card[i].card) {
            for (var j in card[i].card) {
              if (!card[i].card[j].hidden && card[i].translate[j + '_info']) {
                lib.cardPack[i].push(j);
              }
            }
          }
          for (j in card[i]) {
            if (j == 'mode' || j == 'forbid') continue;
            if (j == 'list') continue;
            for (k in card[i][j]) {
              if (j == 'skill' && k[0] == '_' && !lib.config.cards.contains(i)) {
                continue;
              }
              if (j == 'translate' && k == i) {
                lib[j][k + '_card_config'] = card[i][j][k];
              }
              else {
                if (lib[j][k] == undefined) lib[j][k] = card[i][j][k];
                else console.log('dublicate ' + j + ' in card ' + i + ':\n' + k + '\n' + lib[j][k] + '\n' + card[i][j][k]);
              }
            }
          }
        }
        Evt.goto(0);
      }],
      /**
       * 加载模组
       * @name content.loadMode
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!string} Evt.mode 要加载的mode名
       * @property {?Object} Evt.result 如果加载成功返回加载的模组，如果失败则返回未指定(undefined)结果
       */
      loadMode: [function () {
        window.game = game;
        lib.init.js(lib.assetURL + 'mode', Evt.mode, game.resume);
        game.pause();
      }, function () {
        if (!lib.config.dev) delete window.game;
        Evt.result = lib.imported.mode[Evt.mode];
        delete lib.imported.mode[Evt.mode];
      }],
      /**
       * 强制结束
       * @name content.forceOver
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {?string} Evt.bool 是否调用{@link game.over}，如果为'noover'，则不调用
       * @property {?function():void} [Evt.callback] 回调函数，在事件结束前调用
       */
      forceOver: [function () {
        while (ui.controls.length) {
          ui.controls[0].close();
        }
        while (ui.dialogs.length) {
          ui.dialogs[0].close();
        }
      }, function () {
        if (Evt.bool != 'noover') {
          game.over(Evt.bool);
        }
        if (Evt.callback) {
          Evt.callback();
        }
      }],
      /**
       * 事件触发调度状态机
       * @name content.arrangeTrigger
       * @type {GameCores.Bases.StateMachine}
       */
      arrangeTrigger: [function () {
        Evt.filter1 = function (info) {
          if (info[1].isDead() && !lib.skill[info[0]].forceDie) return false;
          return lib.filter.filterTrigger(trigger, info[1], Evt.triggername, info[0]);
        }
        Evt.filter2 = function (info2) {
          var info = lib.skill[info2[0]];
          if (!lib.translate[info2[0]] || info.silent) return false;
          return true;
        }
        Evt.filter3 = function (info, info2) {
          return Evt.filter2(info2) && Evt.filter1(info2) && info2[1] == info[1] && info[2] == info2[2] && (lib.skill.global.contains(info2[0]) || info[1].hasSkill(info2[0], true));
        }
      }, function () {
        if (trigger.filterStop && trigger.filterStop()) {
          Evt.finish();
        }
        else if (Evt.list.length) {
          var info = Evt.list.shift();
          game.createTrigger(Evt.triggername, info[0], info[1], trigger);
          Evt.redo();
        }
      }, function () {
        if (!Evt.map.length) {
          if (Evt.list2.length) {
            var info = Evt.list2.shift();
            game.createTrigger(Evt.triggername, info[0], info[1], trigger);
            Evt.redo();
          }
          else {
            if (trigger._triggering == this) {
              delete trigger._triggering;
            }
            Evt.finish();
            return;
          }
        };
        Evt.doing = Evt.map.shift();
      }, function () {
        Evt.num = 0;
        var bool = false;
        var list = Evt.doing.list;
        for (var i = 0; i < list.length; i++) {
          if (Evt.filter1(list[i])) {
            Evt.num = i;
            bool = true;
            break;
          }
        }
        if (!bool) { Evt.goto(2); return; }
        var priority = list[Evt.num][2];
        for (var i = 0; i < Evt.num; i++) {
          if (Evt.doing.list[i][2] > priority) {
            Evt.doing.list.splice(i--, 1);
            Evt.num--;
          }
        }
        Evt.choice = [];
        if (Evt.num < Evt.doing.list.length - 1 && Evt.filter2(Evt.doing.list[Evt.num])) {
          var current = Evt.doing.list[Evt.num];
          Evt.choice.push(current);
          for (var i = Evt.num + 1; i < Evt.doing.list.length; i++) {
            if (Evt.filter3(current, Evt.doing.list[i])) Evt.choice.push(Evt.doing.list[i]);
          }
        }
        if (Evt.choice.length < 2) Evt.goto(6);
      }, function () {
        var controls = [];
        Evt.current = Evt.choice[0][1]
        for (var i = 0; i < Evt.choice.length; i++) {
          controls.push(Evt.choice[i][0]);
        }
        Evt.current.chooseControl(controls).set('prompt', '选择下一个触发的技能').set('forceDie', true).set('arrangeSkill', true);
      }, function () {
        if (result.control) {
          for (var i = 0; i < Evt.doing.list.length; i++) {
            if (Evt.doing.list[i][0] == result.control && Evt.doing.list[i][1] == Evt.current) {
              Evt.num = i; break;
            }
          }
        }
      }, function () {
        var info = Evt.doing.list[Evt.num];
        if (info) {
          Evt.doing.list2.push(info);
          Evt.doing.list.splice(Evt.num, 1);
          game.createTrigger(Evt.triggername, info[0], info[1], trigger);
        }
      }, function () {
        if (trigger.filterStop && trigger.filterStop()) {
          Evt.finish();
        }
        else Evt.goto(Evt.doing.list.length ? 3 : 2);
      }],
      /**
       * 检测时机并让玩家选择是否发动触发类技能
       * 创建触发器
       * @name content.createTrigger
       * @type {GameCores.Bases.StateMachine}
       */
      createTrigger: [() => {
        if (lib.filter.filterTrigger(trigger, player, Evt.triggername, Evt.skill)) {
          var fullskills = game.expandSkills(player.getSkills().concat(lib.skill.global));
          if (!fullskills.contains(Evt.skill)) {
            var info = get.info(Evt.skill);
            var hidden = player.hiddenSkills.slice(0);
            game.expandSkills(hidden);
            if (hidden.contains(Evt.skill)) {
              if (!info.silent && player.hasSkillTag('nomingzhi', false, null, true)) {
                Evt.finish();
              }
              else if (!info.direct) {
                Evt.trigger('triggerHidden');
              }
              else {
                Evt.skillHidden = true;
              }
            }
            else {
              var keep = false;
              for (var i in player.additionalSkills) {
                if (i.indexOf('hidden:') == 0 && game.expandSkills(player.additionalSkills[i]).contains(Evt.skill)) {
                  keep = true; break;
                }
              }
              if (!keep) {
                Evt.finish();
              }
            }
          }
        }
        else {
          Evt.finish();
        }
      }, () => {
        if (Evt.cancelled) {
          Evt.finish();
          return;
        }
        var info = get.info(Evt.skill);
        if (!Evt.revealed && !info.forced) {
          var checkFrequent = function (info) {
            if (player.hasSkillTag('nofrequent', false, Evt.skill)) return false;
            if (typeof info.frequent == 'boolean') return info.frequent;
            if (typeof info.frequent == 'function') return info.frequent(trigger, player);
            if (info.frequent == 'check' && typeof info.check == 'function') return info.check(trigger, player);
            return false;
          }
          if (info.direct && player.isUnderControl()) {
            game.swapPlayerAuto(player);
            Evt._result = { bool: true };
            Evt._direct = true;
          }
          else if (info.direct) {
            Evt._result = { bool: true };
            Evt._direct = true;
          }
          else if (info.direct && player.isOnline()) {
            Evt._result = { bool: true };
            Evt._direct = true;
          }
          else {
            if (checkFrequent(info)) {
              Evt.frequentSkill = true;
            }
            var str;
            var check = info.check;
            if (info.prompt) str = info.prompt;
            else {
              if (typeof info.logTarget == 'string') {
                str = get.prompt(Evt.skill, trigger[info.logTarget], player);
              }
              else if (typeof info.logTarget == 'function') {
                str = get.prompt(Evt.skill, info.logTarget(trigger, player), player);
              }
              else {
                str = get.prompt(Evt.skill, null, player);
              }
            }
            if (typeof str == 'function') { str = str(trigger, player) }
            var next = player.chooseBool(str);
            if (Evt.frequentSkill) next.set('frequentSkill', Evt.skill);
            next.set('forceDie', true);
            next.ai = function () {
              return !check || check(trigger, player);
            };
            if (typeof info.prompt2 == 'function') {
              next.set('prompt2', info.prompt2(trigger, player));
            }
            else if (typeof info.prompt2 == 'string') {
              next.set('prompt2', info.prompt2);
            }
            else if (info.prompt2 != false) {
              if (lib.dynamicTranslate[Evt.skill] || lib.translate[Evt.skill + '_info'])
                next.set('prompt2', get.skillInfoTranslation(Evt.skill, player));
            }
            if (trigger.skillwarn) {
              if (next.prompt2) {
                next.set('prompt2', '<span class="thundertext">' + trigger.skillwarn + '。</span>' + next.prompt2);
              }
              else {
                next.set('prompt2', trigger.skillwarn);
              }
            }

            if (info.addDialog) {
              var createDialog = [str, 'small'];
              if (next.prompt2) createDialog.push(next.prompt2);
              createDialog.push(info.addDialog(trigger, player));
              next.set('createDialog', createDialog);
            }
          }
        }
      }, () => {
        var info = get.info(Evt.skill);
        if (result && result.bool != false) {
          var autodelay = info.autodelay;
          if (typeof autodelay == 'function') {
            autodelay = autodelay(trigger, player);
          }
          if (autodelay && (info.forced || !Evt.isMine())) {
            if (typeof autodelay == 'number') {
              game.delayx(autodelay);
            }
            else {
              game.delayx();
            }
          }
        }
      }, () => {
        var info = get.info(Evt.skill);
        if (result && result.bool == false) {
          if (info.oncancel) info.oncancel(trigger, player);
          Evt.finish();
          return;
        }
        var next = game.createEvent(Evt.skill);
        if (typeof info.usable == 'number') {
          player.addSkill('counttrigger');
          if (!player.$.counttrigger) {
            player.$.counttrigger = {};
          }
          if (!player.$.counttrigger[Evt.skill]) {
            player.$.counttrigger[Evt.skill] = 1;
          }
          else {
            player.$.counttrigger[Evt.skill]++;
          }
        }
        next.player = player;
        next._trigger = trigger;
        next.triggername = Evt.triggername;
        next.setContent(info.content);
        next.skillHidden = Evt.skillHidden;
        if (info.forceDie) next.forceDie = true;
        if (info.popup != false && !info.direct) {
          if (info.popup) {
            player.popup(info.popup);
            game.log(player, '发动了', '#p『' + get.skillTranslation(Evt.skill, player) + '』');
          }
          else {
            if (info.logTarget && info.logLine !== false) {
              if (typeof info.logTarget == 'string') {
                player.logSkill(Evt.skill, trigger[info.logTarget], info.line);
              }
              else if (typeof info.logTarget == 'function') {
                player.logSkill(Evt.skill, info.logTarget(trigger, player), info.line);
              }
            }
            else {
              player.logSkill(Evt.skill, false, info.line);
            }
          }
        }
      }, () => {
        if (player._hookTrigger) {
          for (var i = 0; i < player._hookTrigger.length; i++) {
            var info = lib.skill[player._hookTrigger[i]].hookTrigger;
            if (info) {
              if (info.after && info.after(Evt, player, Evt.triggername)) {
                Evt.trigger('triggerAfter');
                break;
              }
            }
          }
        }
      }],
      /**
       * Play video
       * @name content.playVideoContent
       * @type {GameCores.Bases.StateMachine}
       */
      playVideoContent: [function () {
        game.delay(0, 500);
      }, function () {
        if (!game.chess) {
          ui.control.innerHTML = '';
          var nodes = [];
          for (var i = 0; i < ui.arena.childNodes.length; i++) {
            nodes.push(ui.arena.childNodes[i]);
          }
          for (var i = 0; i < nodes.length; i++) {
            if (nodes[i] == ui.canvas) continue;
            if (nodes[i] == ui.control) continue;
            if (nodes[i] == ui.mebg) continue;
            if (nodes[i] == ui.me) continue;
            if (nodes[i] == ui.roundmenu) continue;
            nodes[i].remove();
          }
          ui.sidebar.innerHTML = '';
          ui.cardPile.innerHTML = '';
          ui.discardPile.innerHTML = '';
          ui.special.innerHTML = '';
          ui.ordering.innerHTML = '';
        }
        ui.system.firstChild.innerHTML = '';
        ui.system.lastChild.innerHTML = '';
        ui.system.firstChild.appendChild(ui.config2);
        if (ui.updateVideoMenu) {
          ui.updateVideoMenu();
        }
        _status.videoDuration = 1;
        ui.create.system('返回', function () {
          var mode = localStorage.getItem(lib.configprefix + 'playbackmode');
          if (mode) {
            game.saveConfig('mode', mode);
          }
          game.reload();
        });
        ui.create.system('重播', function () {
          _status.replayvideo = true;
          game.playVideo(_status.playback, lib.config.mode);
        });
        ui.create.system('暂停', ui.click.pause, true).id = 'pausebutton';
        var slow = ui.create.system('减速', function () {
          _status.videoDuration *= 1.5;
          updateDuration();
        }, true);
        var fast = ui.create.system('加速', function () {
          _status.videoDuration /= 1.5;
          updateDuration();
        }, true);
        var updateDuration = function () {
          if (_status.videoDuration > 1) {
            slow.classList.add('glow');
          }
          else {
            slow.classList.remove('glow');
          }
          if (_status.videoDuration < 1) {
            fast.classList.add('glow');
          }
          else {
            fast.classList.remove('glow');
          }
        }
        ui.system.style.display = '';
        ui.refresh(ui.system);
        ui.system.show();
        ui.window.show();
        if (lib.config.mode != 'versus' && lib.config.mode != 'boss') {
          ui.arena.style.display = '';
          ui.refresh(ui.arena);
          ui.arena.show();
        }
        if (!game.chess) {
          game.playerMap = {};
        }
        game.finishCards();
      }, function () {
        if (Evt.video.length) {
          var content = Evt.video.shift();
          // console.log(content);
          if (content.type == 'delay') {
            game.delay(content.content);
          }
          else if (content.type == 'play') {
            window.play = {};
            if (!Evt.playtoload) {
              Evt.playtoload = 1;
            }
            else {
              Evt.playtoload++;
            }
            var script = lib.init.js(lib.assetURL + 'play', content.name);
            script.addEventListener('load', function () {
              var play = window.play[content.name]
              if (play && play.video) {
                play.video(content.init);
              }
              Evt.playtoload--;
              if (Evt.playtoload == 0) {
                delete window.play;
              }
            });
          }
          else if (typeof content.player == 'string' && game.playerMap[content.player] &&
            game.playerMap[content.player].classList &&
            !game.playerMap[content.player].classList.contains('obstacle')) {
            game.videoContent[content.type](game.playerMap[content.player], content.content);
          }
          else {
            game.videoContent[content.type](content.content);
          }
          if (Evt.video.length) {
            game.delay(0, _status.videoDuration * Math.min(2000, Evt.video[0].delay));
          }
          Evt.redo();
        }
        else {
          _status.over = true;
          ui.system.lastChild.hide();
          setTimeout(function () {
            ui.system.lastChild.innerHTML = '';
          }, 500);
        }
      }],
      /**
       * wait for player
       * @name content.waitForPlayer
       * @type {GameCores.Bases.StateMachine}
       */
      waitForPlayer: [function () {
        ui.auto.hide();
        ui.pause.hide();

        game.createServer();
        if (!lib.translate.zhu) {
          lib.translate.zhu = '主';
        }
        if (Evt.func) {
          Evt.func();
        }
        if (!lib.configOL.number) {
          lib.configOL.number = parseInt(lib.configOL.player_number);
        }
        if (game.onlineroom) {
          game.send('server', 'config', lib.configOL);
        }

        ui.create.connectPlayers(game.ip);
        if (!window.isNonameServer) {
          var me = game.connectPlayers[0];
          me.setIdentity('zhu');
          me.initOL(get.connectNickname(), lib.config.connect_avatar);
          me.playerid = '1';
          game.onlinezhu = '1';
        }
        _status.waitingForPlayer = true;
        if (window.isNonameServer) {
          document.querySelector('#server_status').innerHTML = '等待中';
        }
        game.pause();
      }, function () {
        _status.waitingForPlayer = false;
        lib.configOL.gameStarted = true;
        if (window.isNonameServer) {
          document.querySelector('#server_status').innerHTML = '游戏中';
        }
        if (game.onlineroom) {
          game.send('server', 'config', lib.configOL);
        }
        for (var i = 0; i < game.connectPlayers.length; i++) {
          game.connectPlayers[i].delete();
        }
        delete game.connectPlayers;
        if (ui.roomInfo) {
          ui.roomInfo.remove();
          delete ui.roomInfo;
        }
        if (ui.exitroom) {
          ui.exitroom.remove();
          delete ui.exitroom;
        }
        game.broadcast('gameStart');
        game.delay(2);
        ui.auto.show();
        ui.pause.show();
        if (lib.config.show_cardpile) {
          ui.cardPileButton.style.display = '';
        }
      }],
      /**
       * 置换手牌(单机)
       * @name content.replaceHandcards
       * @type {GameCores.Bases.StateMachine}
       */
      replaceHandcards: [function () {
        if (Evt.players.contains(game.me)) {
          game.me.chooseBool('是否置换手牌？');
        }
        else {
          Evt.finish();
        }
      }, function () {
        if (result && result.bool) {
          var hs = game.me.getCards('h')
          for (var i = 0; i < hs.length; i++) {
            hs[i].discard(false);
          }
          game.me.directgain(get.cards(hs.length));
        }
      }],
      /**
       * 置换手牌[support online]
       * @name content.replaceHandcards
       * @type {GameCores.Bases.StateMachine}
       */
      replaceHandcardsOL: [function () {
        var send = function () {
          game.me.chooseBool('是否置换手牌？');
          game.resume();
        };
        var sendback = function (result, player) {
          if (result && result.bool) {
            var hs = player.getCards('h')
            game.broadcastAll(function (player, hs) {
              game.addVideo('lose', player, [get.cardsInfo(hs), [], [], []]);
              for (var i = 0; i < hs.length; i++) {
                hs[i].discard(false);
              }
            }, player, hs);
            player.directgain(get.cards(hs.length));
          }
        };
        for (var i = 0; i < Evt.players.length; i++) {
          if (Evt.players[i].isOnline()) {
            Evt.withol = true;
            Evt.players[i].send(send);
            Evt.players[i].wait(sendback);
          }
          else if (Evt.players[i] == game.me) {
            Evt.withme = true;
            game.me.chooseBool('是否置换手牌？');
            game.me.wait(sendback);
          }
        }
      }, function () {
        if (Evt.withme) {
          game.me.unwait(result);
        }
      }, function () {
        if (Evt.withol && !Evt.resultOL) {
          game.pause();
        }
      }],
      /**
       * 一个完整的回合
       * @name content.phase
       * @type {GameCores.Bases.StateMachine}
       */
      phase: [() => {
        if (!Evt.stageList || !Evt.stageList.length) Evt.stageList = lib.phaseName;
        Evt.stepNum = 0;
      }, () => {
        if (typeof player[Evt.stageList[Evt.stepNum]] == 'function') player[Evt.stageList[Evt.stepNum]]();
      }, () => {
        if (Evt.stageList[Evt.stepNum] == 'phaseDraw') {
          if (!player.noPhaseDelay) {
            if (player == game.me) {
              game.delay();
            }
            else {
              game.delayx();
            }
          }
        }
        if (Evt.stageList[Evt.stepNum] == 'phaseUse') {
          game.broadcastAll(function () {
            if (ui.tempnowuxie) {
              ui.tempnowuxie.close();
              delete ui.tempnowuxie;
            }
          });
        }
        if (Evt.stageList[Evt.stepNum] == 'phaseDiscard') {
          if (!player.noPhaseDelay) game.delayx();
          delete player._noSkill;
        }
      }, () => {
        Evt.trigger('phaseNext');
        if (Evt.stageList[++Evt.stepNum]) {
          Evt.trigger('stepNext');

          Evt.goto(1);
        }
      }],
      /**
       * 判定阶段
       * @name content.phaseJudge
       * @type {GameCores.Bases.StateMachine}
       */
      phaseJudge: [() => {
        Evt.cards = player.getCards('j');
        if (!Evt.cards.length) Evt.finish();
      }, () => {
        if (cards.length && player.getCards('j').contains(cards[0])) {
          Evt.card = cards.shift();
          if (Evt.card.classList.contains('removing')) {
            Evt.card.remove();
            delete Evt.card;
            Evt.redo();
          }
          else if (Evt.card.classList.contains('feichu')) {
            Evt.finish();
            return;
          }
          else {
            player.lose(Evt.card, 'visible', ui.ordering);
            player.$phaseJudge(Evt.card);
            Evt.cancelled = false;
            Evt.trigger('phaseJudge');
            var name = Evt.card.viewAs || Evt.card.name;
            player.popup(name, 'thunder');
            if (!lib.card[name].effect) {
              game.delay();
              Evt.redo();
            }
            else if (!lib.card[name].judge) {
              game.delay();
              Evt.nojudge = true;
            }
          }
        }
        else Evt.finish();
      }, () => {
        if (!Evt.cancelled && !Evt.nojudge) player.judge(Evt.card).set('type', 'phase');
      }, () => {
        var name = Evt.card.viewAs || Evt.card.name;
        if (Evt.cancelled && !Evt.direct) {
          if (lib.card[name].cancel) {
            var next = game.createEvent(name + 'Cancel');
            next.setContent(lib.card[name].cancel);
            next.card = Evt.card;
            next.cards = [Evt.card];
            next.player = player;
          }
        }
        else {
          var next = game.createEvent(name);
          next.setContent(lib.card[name].effect);
          next._result = result;
          next.card = Evt.card;
          next.cards = [Evt.card];
          next.player = player;
        }
        ui.clear();
        Evt.goto(1);
      }],
      /**
       * 摸牌阶段
       * @name content.phaseDraw
       * @type {GameCores.Bases.StateMachine}
       */
      phaseDraw: [() => {
        Evt.trigger("phaseDrawBegin1");
      }, () => {
        Evt.trigger("phaseDrawBegin2");
      }, () => {
        if (game.modPhaseDraw) {
          game.modPhaseDraw(player, Evt.num);
        }
        else {
          if (Evt.num > 0) {
            var num = Evt.num;
            if (Evt.attachDraw) {
              for (var i = 0; i < Evt.attachDraw.length; i++) {
                ui.cardPile.insertBefore(Evt.attachDraw[i], ui.cardPile.firstChild);
              }
              num += Evt.attachDraw.length;
            }
            var next = player.draw(num);
            if (Evt.attachDraw) {
              next.minnum = Evt.attachDraw.length;
            }
          }
        }
      }, () => {
        if (Array.isArray(result)) {
          Evt.cards = result;
        }
      }],
      /**
       * 出牌阶段
       * @name content.phaseUse
       * @type {GameCores.Bases.StateMachine}
       */
      phaseUse: [() => {
        ;
        var next = player.chooseToUse();
        if (!lib.config.show_phaseuse_prompt) {
          next.set('prompt', false);
        }
        next.set('type', 'phase');
      }, () => {
        if (result.bool && !Evt.skipped) {
          Evt.goto(0);
        }
        game.broadcastAll(function () {
          if (ui.tempnowuxie) {
            ui.tempnowuxie.close();
            delete ui.tempnowuxie;
          }
        });
      }, () => {
        var stat = player.getStat();
        for (var i in stat.skill) {
          var bool = false;
          var info = lib.skill[i];
          if (!info) continue;
          if (info.enable != undefined) {
            if (typeof info.enable == 'string' && info.enable == 'phaseUse') bool = true;
            else if (typeof info.enable == 'object' && info.enable.contains('phaseUse')) bool = true;
          }
          if (bool) stat.skill[i] = 0;
        }
        for (var i in stat.card) {
          var bool = false;
          var info = lib.card[i];
          if (!info) continue;
          if (info.updateUsable == 'phaseUse') stat.card[i] = 0;
        }
      }],
      /**
       * 弃牌阶段
       * @name content.phaseDiscard
       * @type {GameCores.Bases.StateMachine}
       */
      phaseDiscard: [() => {
        if (!Evt.num) Evt.num = player.needsToDiscard();
        if (Evt.num <= 0) Evt.finish();
        else {
          if (lib.config.show_phase_prompt) {
            player.popup('弃牌阶段');
          }
        }
        Evt.trigger('phaseDiscard');
      }, () => {
        player.chooseToDiscard(num, true);
      }, () => {
        Evt.cards = result.cards;
      }],
      /**
       * 选择以使用(牌|技能)
       * @name content.chooseToUse
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      chooseToUse: [() => {
        if (Evt.responded) return;
        if (game.modeSwapPlayer && !_status.auto && player.isUnderControl() && !lib.filter.wuxieSwap(Evt)) {
          game.modeSwapPlayer(player);
        }
        var skills = player.getSkills(true);
        game.expandSkills(skills);
        for (var i = 0; i < skills.length; i++) {
          var info = lib.skill[skills[i]];
          if (info && info.onChooseToUse) {
            info.onChooseToUse(Evt);
          }
        }
        _status.noclearcountdown = true;
        if (Evt.type == 'phase') {
          if (Evt.isMine()) {
            if (lib.config.mode == 'richer' && lib.skill._chessmove.filter(true, player) && player.getStat().skill && !player.getStat().skill._chessmove) {
              Evt.endButton = ui.create.control('请进行移动', 'stayleft', function () { });
            }
            else {
              Evt.endButton = ui.create.control('结束回合', 'stayleft', function () {
                if (_status.event.skill) {
                  ui.click.cancel();
                }
                ui.click.cancel();
              });
            }
            Evt.fakeforce = true;
          }
          else {
            if (Evt.endButton) {
              Evt.endButton.close();
              delete Evt.endButton;
            }
            Evt.fakeforce = false;
          }
        }
        if (Evt.player.isUnderControl() && !_status.auto) {
          Evt.result = {
            bool: false
          }
          return;
        }
        else if (Evt.isMine()) {
          if (Evt.hsskill && !Evt.forced && _status.prehidden_skills.contains(Evt.hsskill)) {
            ui.click.cancel();
            return;
          }
          if (Evt.type == 'wuxie') {
            if (ui.tempnowuxie) {
              var triggerevent = Evt.getTrigger();
              if (triggerevent && triggerevent.targets && triggerevent.num == triggerevent.targets.length - 1) {
                ui.tempnowuxie.close();
              }
            }
            if (lib.filter.wuxieSwap(Evt)) {
              Evt.result = {
                bool: false
              }
              return;
            }
          }
          var ok = game.check();
          if (!ok || !lib.config.auto_confirm) {
            game.pause();
            if (lib.config.enable_vibrate && player._noVibrate) {
              delete player._noVibrate;
              game.vibrate();
            }
            if (typeof Evt.prompt == 'string') {
              if (Evt.openskilldialog) {
                Evt.skillDialog = ui.create.dialog(Evt.openskilldialog);
                delete Evt.openskilldialog;
                Evt.dialog = Evt.prompt;
              }
              else {
                Evt.dialog = ui.create.dialog(Evt.prompt);
                if (Evt.prompt2) {
                  Evt.dialog.addText(Evt.prompt2);
                }
              }
            }
            else if (Evt.prompt == 'function') {
              Evt.dialog = ui.create.dialog(Evt.prompt(Evt));
            }
            else if (Evt.prompt == undefined) {
              var str;
              if (typeof Evt.filterCard == 'object') {
                var filter = Evt.filterCard;
                str = '请使用' + get.cnNumber(Evt.selectCard[0]) + '张'
                if (filter.name) {
                  str += get.translation(filter.name);
                }
                else {
                  str += '牌';
                }
              }
              else {
                str = '请选择要使用的牌';
              }
              if (Evt.openskilldialog) {
                Evt.skillDialog = ui.create.dialog(Evt.openskilldialog);
                delete Evt.openskilldialog;
                Evt.dialog = str;
              }
              else if (typeof Evt.skillDialog != 'string') {
                Evt.dialog = ui.create.dialog(str);
              }
              else {
                Evt.dialog = str;
              }
            }
          }
        }
        else if (Evt.isOnline()) {
          Evt.send();
        }
        else {
          Evt.result = 'ai';
        }
      }, () => {
        if (Evt.result == 'ai') {
          var ok = game.check();
          if (ok) {
            ui.click.ok();
          }
          else if (ai.basic.chooseCard(Evt.ai1)) {
            if (ai.basic.chooseTarget(Evt.ai2)) {
              ui.click.ok();
              Evt._aiexcludeclear = true;
            }
            else {
              if (!Evt.norestore) {
                if (Evt.skill) {
                  var skill = Evt.skill;
                  ui.click.cancel();
                  Evt._aiexclude.add(skill);
                  var info = get.info(skill);
                  if (info.sourceSkill) {
                    Evt._aiexclude.add(info.sourceSkill);
                  }
                }
                else {
                  get.card(true).aiexclude();
                  game.uncheck();
                }
                Evt.redo();
                game.resume();
              }
              else {
                ui.click.cancel();
              }
            }
          }
          else if (Evt.skill && !Evt.norestore) {
            var skill = Evt.skill;
            ui.click.cancel();
            Evt._aiexclude.add(skill);
            var info = get.info(skill);
            if (info.sourceSkill) {
              Evt._aiexclude.add(info.sourceSkill);
            }
            Evt.redo();
            game.resume();
          }
          else {
            ui.click.cancel();
          }
          if (Evt.aidelay && Evt.result && Evt.result.bool) {
            game.delayx();
          }
        }
      }, () => {
        if (Evt.endButton) {
          Evt.endButton.close();
          delete Evt.endButton;
        }
        Evt.resume();
        if (Evt.result) {
          if (Evt.result.skill) {
            var info = get.info(Evt.result.skill);
            if (info && info.chooseButton) {
              if (Evt.dialog && typeof Evt.dialog == 'object') Evt.dialog.close();
              var dialog = info.chooseButton.dialog(Evt, player);
              if (info.chooseButton.chooseControl) {
                var next = player.chooseControl(info.chooseButton.chooseControl(Evt, player));
                next.dialog = dialog;
                next.set('ai', info.chooseButton.check || function () { return 0; });
              }
              else {
                var next = player.chooseButton(dialog);
                next.set('ai', info.chooseButton.check || function () { return 1; });
                next.set('filterButton', info.chooseButton.filter || function () { return true; });
                next.set('selectButton', info.chooseButton.select || 1);
              }
              Evt.buttoned = Evt.result.skill;
            }
            else if (info && info.precontent && !game.online && !Evt.nouse) {
              var next = game.createEvent('pre_' + Evt.result.skill);
              next.setContent(info.precontent);
              next.set('result', Evt.result);
              next.set('player', player);
            }
          }
        }
      }, () => {
        if (Evt.buttoned) {
          if (result.bool || result.control && result.control != 'cancel2') {
            var info = get.info(Evt.buttoned).chooseButton;
            lib.skill[Evt.buttoned + '_backup'] = info.backup(info.chooseControl ? result : result.links, player);
            lib.skill[Evt.buttoned + '_backup'].sourceSkill = Evt.buttoned;
            if (game.online) {
              Evt._sendskill = [Evt.buttoned + '_backup', lib.skill[Evt.buttoned + '_backup']];
            }
            Evt.backup(Evt.buttoned + '_backup');
            if (info.prompt) {
              Evt.openskilldialog = info.prompt(info.chooseControl ? result : result.links, player);
            }
          }
          else {
            ui.control.animate('nozoom', 100);
            Evt._aiexclude.add(Evt.buttoned);
          }
          Evt.goto(0);
          delete Evt.buttoned;
        }
      }, () => {
        if (Evt._aiexcludeclear) {
          delete Evt._aiexcludeclear;
          Evt._aiexclude.length = 0;
        }
        delete _status.noclearcountdown;
        if (Evt.skillDialog && get.objtype(Evt.skillDialog) == 'div') {
          Evt.skillDialog.close();
        }
        if (Evt.result && Evt.result.bool && !game.online && !Evt.nouse) {
          player.useResult(Evt.result, Evt);
        }
        else if (Evt._sendskill) {
          Evt.result._sendskill = Evt._sendskill;
        }
        if (Evt.dialog && typeof Evt.dialog == 'object') Evt.dialog.close();
        if (!_status.noclearcountdown) {
          game.stopCountChoose();
        }
      }, () => {
        if (Evt._result && Evt.result) {
          Evt.result.result = Evt._result;
        }
      }],
      /**
       * 选择以响应(牌|技能)
       * @name content.chooseToUse
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      chooseToRespond: [() => {
        if (Evt.responded) {
          delete Evt.dialog;
          return;
        }
        var skills = player.getSkills(true);
        game.expandSkills(skills);
        for (var i = 0; i < skills.length; i++) {
          var info = lib.skill[skills[i]];
          if (info && info.onChooseToRespond) {
            info.onChooseToRespond(Evt);
          }
        }
        _status.noclearcountdown = true;
        if (!_status.connectMode && lib.config.skip_shan && Evt.autochoose && Evt.autochoose()) {
          Evt.result = { bool: false };
        }
        else {
          if (game.modeSwapPlayer && !_status.auto && player.isUnderControl()) {
            game.modeSwapPlayer(player);
          }
          if (Evt.isMine()) {
            if (Evt.hsskill && !Evt.forced && _status.prehidden_skills.contains(Evt.hsskill)) {
              ui.click.cancel();
              return;
            }
            var ok = game.check();
            if (!ok || !lib.config.auto_confirm) {
              game.pause();
              if (Evt.openskilldialog) {
                Evt.skillDialog = ui.create.dialog(Evt.openskilldialog);
                delete Evt.openskilldialog;
                Evt.dialog = Evt.prompt;
              }
              else {
                if (Evt.prompt) Evt.dialog = ui.create.dialog(Evt.prompt);
                if (Evt.prompt2) Evt.dialog.addText(Evt.prompt2);
              }
            }
          }
          else if (Evt.isOnline()) {
            Evt.send();
          }
          else {
            Evt.result = 'ai';
          }
        }
      }, () => {
        if (Evt.result == 'ai') {
          var ok = game.check();
          if (ok) {
            ui.click.ok();
          }
          else if (ai.basic.chooseCard(Evt.ai)) {
            ui.click.ok();
            Evt._aiexcludeclear = true;
          }
          else if (Evt.skill && !Evt.norestore) {
            var skill = Evt.skill;
            ui.click.cancel();
            Evt._aiexclude.add(skill);
            var info = get.info(skill);
            if (info.sourceSkill) {
              Evt._aiexclude.add(info.sourceSkill);
            }
            Evt.redo();
            game.resume();
          }
          else {
            ui.click.cancel();
          }
          if (Evt.aidelay && Evt.result && Evt.result.bool) {
            game.delayx();
          }
        }
      }, () => {
        Evt.resume();
        if (Evt.result) {
          if (Evt.result.skill) {
            var info = get.info(Evt.result.skill);
            if (info && info.chooseButton) {
              if (Evt.dialog && typeof Evt.dialog == 'object') Evt.dialog.close();
              var dialog = info.chooseButton.dialog(Evt, player);
              if (info.chooseButton.chooseControl) {
                var next = player.chooseControl(info.chooseButton.chooseControl(Evt, player));
                next.dialog = dialog;
                next.set('ai', info.chooseButton.check || function () { return 0; });
              }
              else {
                var next = player.chooseButton(dialog);
                next.set('ai', info.chooseButton.check || function () { return 1; });
                next.set('filterButton', info.chooseButton.filter || function () { return true; });
                next.set('selectButton', info.chooseButton.select || 1);
              }
              Evt.buttoned = Evt.result.skill;
            }
            else if (info && info.precontent && !game.online) {
              var next = game.createEvent('pre_' + Evt.result.skill);
              next.setContent(info.precontent);
              next.set('result', Evt.result);
              next.set('player', player);
            }
          }
        }
      }, () => {
        if (Evt.buttoned) {
          if (result.bool || result.control && result.control != 'cancel2') {
            var info = get.info(Evt.buttoned).chooseButton;
            lib.skill[Evt.buttoned + '_backup'] = info.backup(info.chooseControl ? result : result.links, player);
            lib.skill[Evt.buttoned + '_backup'].sourceSkill = Evt.buttoned;
            if (game.online) {
              Evt._sendskill = [Evt.buttoned + '_backup', lib.skill[Evt.buttoned + '_backup']];
            }
            Evt.backup(Evt.buttoned + '_backup');
            if (info.prompt) {
              Evt.openskilldialog = info.prompt(info.chooseControl ? result : result.links, player);
            }
          }
          else {
            ui.control.animate('nozoom', 100);
            Evt._aiexclude.add(Evt.buttoned);
          }
          Evt.goto(0);
          delete Evt.buttoned;
        }
      }, () => {
        delete _status.noclearcountdown;
        if (Evt.skillDialog && get.objtype(Evt.skillDialog) == 'div') {
          Evt.skillDialog.close();
        }
        if (Evt.result.bool && !game.online) {
          if (Evt.result._sendskill) {
            lib.skill[Evt.result._sendskill[0]] = Evt.result._sendskill[1];
          }
          var info = get.info(Evt.result.skill);
          if (Evt.onresult) {
            Evt.onresult(Evt.result);
          }
          if (Evt.result.skill) {
            if (info.direct && !info.clearTime) {
              _status.noclearcountdown = true;
            }
          }
          if (Evt.logSkill) {
            if (typeof Evt.logSkill == 'string') {
              player.logSkill(Evt.logSkill);
            }
            else if (Array.isArray(Evt.logSkill)) {
              player.logSkill.apply(player, Evt.logSkill);
            }
          }
          if (!Evt.result.card && Evt.result.skill) {
            Evt.result.used = Evt.result.skill;
            player.useSkill(Evt.result.skill, Evt.result.cards, Evt.result.targets);
          }
          else {
            if (info && info.prerespond) {
              info.prerespond(Evt.result, player);
            }
            var next = player.respond(Evt.result.cards, Evt.result.card, Evt.animate, Evt.result.skill, Evt.source);
            if (Evt.result.noanimate) next.animate = false;
            if (Evt.parent.card && Evt.parent.type == 'card') {
              next.set('respondTo', [Evt.parent.player, Evt.parent.card]);
            }
            if (Evt.noOrdering) next.noOrdering = true;
          }
        }
        else if (Evt._sendskill) {
          Evt.result._sendskill = Evt._sendskill;
        }
        if (Evt.dialog && Evt.dialog.close) Evt.dialog.close();
        if (!_status.noclearcountdown) {
          game.stopCountChoose();
        }
      }],
      /**
       * 选择以弃置牌
       * @name content.chooseToDiscard
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      chooseToDiscard: [() => {
        if (Evt.autochoose()) {
          Evt.result = {
            bool: true,
            autochoose: true,
            cards: player.getCards(Evt.position),
            rawcards: player.getCards(Evt.position),
          }
          for (var i = 0; i < Evt.result.cards.length; i++) {
            if (!lib.filter.cardDiscardable(Evt.result.cards[i], player, Evt)) {
              Evt.result.cards.splice(i--, 1);
            }
          }
        }
        else {
          // &&!lib.filter.wuxieSwap(trigger)
          if (game.modeSwapPlayer && !_status.auto && player.isUnderControl()) {
            game.modeSwapPlayer(player);
          }
          Evt.rangecards = player.getCards(Evt.position);
          for (var i = 0; i < Evt.rangecards.length; i++) {
            if (lib.filter.cardDiscardable(Evt.rangecards[i], player, Evt)) {
              Evt.rangecards.splice(i--, 1);
            }
            else {
              Evt.rangecards[i].uncheck('chooseToDiscard');
            }
          }
          var range = get.select(Evt.selectCard);
          game.check();
          if (Evt.isMine()) {
            if (Evt.hsskill && !Evt.forced && _status.prehidden_skills.contains(Evt.hsskill)) {
              ui.click.cancel();
              return;
            }
            game.pause();
            if (range[1] > 1 && typeof Evt.selectCard != 'function') {
              Evt.promptdiscard = ui.create.control('AI代选', function () {
                ai.basic.chooseCard(Evt.ai);
                if (_status.event.custom && _status.event.custom.add.card) {
                  _status.event.custom.add.card();
                }
                for (var i = 0; i < ui.selected.cards.length; i++) {
                  ui.selected.cards[i].updateTransform(true);
                }
              });
            }
            if (Array.isArray(Evt.dialog)) {
              Evt.dialog = ui.create.dialog.apply(this, Evt.dialog);
              Evt.dialog.open();
              Evt.dialog.classList.add('noselect');
            }
            else if (Evt.prompt != false) {
              var str;
              if (typeof (Evt.prompt) == 'string') str = Evt.prompt;
              else {
                str = '请弃置';
                if (range[0] == range[1]) str += get.cnNumber(range[0]);
                else if (range[1] == Infinity) str += '至少' + get.cnNumber(range[0]);
                else str += get.cnNumber(range[0]) + '至' + get.cnNumber(range[1]);
                str += '张';
                if (Evt.position == 'h' || Evt.position == undefined) str += '手';
                if (Evt.position == 'e') str += '装备';
                str += '牌';
              }
              Evt.dialog = ui.create.dialog(str);
              if (Evt.prompt2) {
                Evt.dialog.addText(Evt.prompt2, Evt.prompt2.length <= 20);
              }
              if (Array.isArray(Evt.selectCard)) {
                Evt.promptbar = Evt.dialog.add('0/' + get.numStr(Evt.selectCard[1], 'card'));
                Evt.custom.add.card = function () {
                  _status.event.promptbar.innerHTML =
                    ui.selected.cards.length + '/' + get.numStr(_status.event.selectCard[1], 'card');
                }
              }
            }
            else if (get.itemtype(Evt.dialog) == 'dialog') {
              Evt.dialog.style.display = '';
              Evt.dialog.open();
            }
          }
          else if (Evt.isOnline()) {
            Evt.send();
          }
          else {
            Evt.result = 'ai';
          }
        }
      }, () => {
        if (Evt.result == 'ai') {
          game.check();
          if (ai.basic.chooseCard(Evt.ai) || forced) {
            ui.click.ok();
          }
          else if (Evt.skill) {
            var skill = Evt.skill;
            ui.click.cancel();
            Evt._aiexclude.add(skill);
            Evt.redo();
            game.resume();
          }
          else {
            ui.click.cancel();
          }
        }
        if (Evt.rangecards) {
          for (var i = 0; i < Evt.rangecards.length; i++) {
            Evt.rangecards[i].recheck('chooseToDiscard');
          }
        }
      }, () => {
        Evt.resume();
        if (Evt.promptdiscard) {
          Evt.promptdiscard.close();
        }
      }, () => {
        if (Evt.result.bool && Evt.result.cards && Evt.result.cards.length &&
          !game.online && Evt.autodelay && !Evt.isMine()) {
          if (typeof Evt.autodelay == 'number') {
            game.delayx(Evt.autodelay);
          }
          else {
            game.delayx();
          }
        }
      }, () => {
        if (Evt.logSkill && Evt.result.bool && !game.online) {
          if (typeof Evt.logSkill == 'string') {
            player.logSkill(Evt.logSkill);
          }
          else if (Array.isArray(Evt.logSkill)) {
            player.logSkill.apply(player, Evt.logSkill);
          }
        }
        if (!game.online) {
          if (typeof Evt.delay == 'boolean') {
            Evt.done = player.discard(Evt.result.cards).set('delay', Evt.delay);
          }
          else {
            Evt.done = player.discard(Evt.result.cards);
          }
        }
        if (Evt.dialog && Evt.dialog.close) Evt.dialog.close();
      }],
      /**
       * 拼点失败
       * @name content.chooseToCompareLose
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      chooseToCompareLose: function () {
        for (var i = 0; i < Evt.lose_list.length; i++) {
          var next = Evt.lose_list[i][0].lose(Evt.lose_list[i][1], ui.ordering);
          next.relatedEvent = Evt.getParent();
          next.getlx = false;
        }
      },
      /**
       * 多人拼点
       * @name content.chooseToCompareMultiple
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      chooseToCompareMultiple: [() => {
        if (player.countCards('h') == 0) {
          Evt.result = { cancelled: true, bool: false }
          Evt.finish();
          return;
        }
        for (var i = 0; i < targets.length; i++) {
          if (targets[i].countCards('h') == 0) {
            Evt.result = { cancelled: true, bool: false }
            Evt.finish();
            return;
          }
        }
        if (!Evt.multitarget) {
          targets.sort(lib.sort.seat);
        }
        game.log(player, '对', targets, '发起拼点');
      }, () => {
        Evt._result = [];
        Evt.list = targets.filter(function (current) {
          return !Evt.fixedResult || !Evt.fixedResult[current.playerid];
        });
        if (Evt.list.length || !Evt.fixedResult || !Evt.fixedResult[player.playerid]) {
          if (!Evt.fixedResult || !Evt.fixedResult[player.playerid]) Evt.list.unshift(player);
          player.chooseCardOL(Evt.list, '请选择拼点牌', true).set('type', 'compare').set('ai', Evt.ai).set('source', player).aiCard = function (target) {
            var hs = target.getCards('h');
            var Evt = _status.event;
            Evt.player = target;
            hs.sort(function (a, b) {
              return Evt.ai(b) - Evt.ai(a);
            });
            delete Evt.player;
            return { bool: true, cards: [hs[0]] };
          };
        }
      }, () => {
        var cards = [];
        var lose_list = [];
        if (Evt.fixedResult && Evt.fixedResult[player.playerid]) {
          Evt.list.unshift(player);
          result.unshift({ bool: true, cards: [Evt.fixedResult[player.playerid]] });
          lose_list.push([player, [Evt.fixedResult[player.playerid]]]);
        }
        else {
          if (result[0].skill && lib.skill[result[0].skill] && lib.skill[result[0].skill].onCompare) {
            player.logSkill(result[0].skill);
            result[0].cards = lib.skill[result[0].skill].onCompare(player)
          }
          else lose_list.push([player, result[0].cards]);
        };
        for (var j = 0; j < targets.length; j++) {
          if (Evt.list.contains(targets[j])) {
            var i = Evt.list.indexOf(targets[j]);
            if (result[i].skill && lib.skill[result[i].skill] && lib.skill[result[i].skill].onCompare) {
              Evt.list[i].logSkill(result[i].skill);
              result[i].cards = lib.skill[result[i].skill].onCompare(Evt.list[i]);
            }
            else lose_list.push([targets[j], result[i].cards]);
            cards.push(result[i].cards[0]);
          }
          else if (Evt.fixedResult && Evt.fixedResult[targets[j].playerid]) {
            cards.push(Evt.fixedResult[targets[j].playerid]);
            lose_list.push([targets[j], [Evt.fixedResult[targets[j].playerid]]]);
          }
        }
        if (lose_list.length) {
          game.loseAsync({
            lose_list: lose_list,
          }).setContent('chooseToCompareLose');
        }
        Evt.cardlist = cards;
        Evt.cards = cards;
        Evt.card1 = result[0].cards[0];
        Evt.num1 = Evt.card1.number;
        Evt.iwhile = 0;
        Evt.result = {
          player: Evt.card1,
          targets: Evt.cardlist.slice(0),
          num1: [],
          num2: [],
        };
        game.log(player, '的拼点牌为', Evt.card1);
      }, () => {
        if (Evt.iwhile < targets.length) {
          Evt.target = targets[Evt.iwhile];
          Evt.target.animate('target');
          player.animate('target');
          Evt.card2 = Evt.cardlist[Evt.iwhile];
          Evt.num2 = Evt.card2.number;
          game.log(Evt.target, '的拼点牌为', Evt.card2);
          player.line(Evt.target);
          player.$compare(Evt.card1, Evt.target, Evt.card2);
          Evt.trigger('compare');
          game.delay(0, 1500);
        }
        else {
          Evt.goto(7);
        }
      }, () => {
        Evt.result.num1[Evt.iwhile] = Evt.num1;
        Evt.result.num2[Evt.iwhile] = Evt.num2;
        var str;
        if (Evt.num1 > Evt.num2) {
          Evt.result.winner = player;
          Evt.result.loser = target;
          str = get.translation(player) + '拼点成功';
          player.popup('胜');
          target.popup('负');
        }
        else {
          str = get.translation(player) + '拼点失败';
          if (Evt.num1 == Evt.num2) {
            Evt.result.tie = true;
            player.popup('平');
            target.popup('平');
          }
          else {
            Evt.result.winner = target;
            Evt.result.loser = player;
            player.popup('负');
            target.popup('胜');
          }
        }
        game.broadcastAll(function (str) {
          var dialog = ui.create.dialog(str);
          dialog.classList.add('center');
          setTimeout(function () {
            dialog.close();
          }, 1000);
        }, str);
        game.delay(2);
      }, () => {
        if (Evt.callback) {
          game.broadcastAll(function (card1, card2) {
            if (card1.clone) card1.clone.style.opacity = 0.5;
            if (card2.clone) card2.clone.style.opacity = 0.5;
          }, Evt.card1, Evt.card2);
          var next = game.createEvent('compareMultiple');
          next.player = player;
          next.target = Evt.target;
          next.card1 = Evt.card1;
          next.card2 = Evt.card2;
          next.num1 = Evt.num1;
          next.num2 = Evt.num2;
          next.winner = Evt.result.winner;
          next.setContent(Evt.callback);
        }
      }, () => {
        game.broadcastAll(ui.clear);
        Evt.iwhile++;
        Evt.goto(3);
      }, () => {
        Evt.cards.add(Evt.card1);
      }],
      /**
       * 两人拼点
       * @name content.chooseToCompare
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      chooseToCompare: [() => {
        if (player.countCards('h') == 0 || target.countCards('h') == 0) {
          Evt.result = { cancelled: true, bool: false }
          Evt.finish();
          return;
        }
        game.log(player, '对', target, '发起拼点');
        Evt.lose_list = [];
      }, () => {
        var sendback = function () {
          if (_status.event != Evt) {
            return function () {
              Evt.resultOL = _status.event.resultOL;
            };
          }
        };
        if (Evt.fixedResult && Evt.fixedResult[player.playerid]) {
          Evt.card1 = Evt.fixedResult[player.playerid];
          Evt.lose_list.push([player, Evt.card1]);
        }
        else if (player.isOnline()) {
          player.wait(sendback);
          Evt.ol = true;
          player.send(function (ai) {
            game.me.chooseCard('请选择拼点牌', true).set('type', 'compare').set('glow_result', true).ai = ai;
            game.resume();
          }, Evt.ai);
        }
        else {
          Evt.localPlayer = true;
          player.chooseCard('请选择拼点牌', true).set('type', 'compare').set('glow_result', true).ai = Evt.ai;
        }
        if (Evt.fixedResult && Evt.fixedResult[target.playerid]) {
          Evt.card2 = Evt.fixedResult[target.playerid];
          Evt.lose_list.push([target, Evt.card2]);
        }
        else if (target.isOnline()) {
          target.wait(sendback);
          Evt.ol = true;
          target.send(function (ai) {
            game.me.chooseCard('请选择拼点牌', true).set('type', 'compare').set('glow_result', true).ai = ai;
            game.resume();
          }, Evt.ai);
        }
        else {
          Evt.localTarget = true;
        }
      }, () => {
        if (Evt.localPlayer) {
          if (result.skill && lib.skill[result.skill] && lib.skill[result.skill].onCompare) {
            result.cards = lib.skill[result.skill].onCompare(player);
            player.logSkill(result.skill);
          }
          else Evt.lose_list.push([player, result.cards[0]]);
          Evt.card1 = result.cards[0];
        }
        if (Evt.localTarget) {
          target.chooseCard('请选择拼点牌', true).set('type', 'compare').set('glow_result', true).ai = Evt.ai;
        }
      }, () => {
        if (Evt.localTarget) {
          if (result.skill && lib.skill[result.skill] && lib.skill[result.skill].onCompare) {
            target.logSkill(result.skill);
            result.cards = lib.skill[result.skill].onCompare(target);
          }
          else Evt.lose_list.push([target, result.cards[0]]);
          Evt.card2 = result.cards[0];
        }
        if (!Evt.resultOL && Evt.ol) {
          game.pause();
        }
      }, () => {
        try {
          if (!Evt.card1) {
            if (Evt.resultOL[player.playerid].skill && lib.skill[Evt.resultOL[player.playerid].skill] && lib.skill[Evt.resultOL[player.playerid].skill].onCompare) {
              player.logSkill(Evt.resultOL[player.playerid].skill);
              Evt.resultOL[player.playerid].cards = lib.skill[Evt.resultOL[player.playerid].skill].onCompare(player);
            }
            else Evt.lose_list.push([player, Evt.resultOL[player.playerid].cards[0]]);
            Evt.card1 = Evt.resultOL[player.playerid].cards[0];
          };
          if (!Evt.card2) {
            if (Evt.resultOL[target.playerid].skill && lib.skill[Evt.resultOL[target.playerid].skill] && lib.skill[Evt.resultOL[target.playerid].skill].onCompare) {
              target.logSkill(Evt.resultOL[target.playerid].skill);
              Evt.resultOL[target.playerid].cards = lib.skill[Evt.resultOL[target.playerid].skill].onCompare(player);
            }
            else Evt.lose_list.push([target, Evt.resultOL[target.playerid].cards[0]]);
            Evt.card2 = Evt.resultOL[target.playerid].cards[0];
          }
          if (!Evt.card1 || !Evt.card2) {
            throw ('err');
          }
        }
        catch (e) {
          console.log(e);
          game.print(e);
          Evt.finish();
          return;
        }
        if (Evt.card2.number >= 10 || Evt.card2.number <= 4) {
          if (target.countCards('h') > 2) {
            Evt.addToAI = true;
          }
        }
        if (Evt.lose_list.length) {
          game.loseAsync({
            lose_list: Evt.lose_list,
          }).setContent('chooseToCompareLose');
        }
      }, () => {
        game.broadcast(function () {
          ui.arena.classList.add('thrownhighlight');
        });
        ui.arena.classList.add('thrownhighlight');
        game.addVideo('thrownhighlight1');
        player.$compare(Evt.card1, target, Evt.card2);
        game.log(player, '的拼点牌为', Evt.card1);
        game.log(target, '的拼点牌为', Evt.card2);
        Evt.num1 = Evt.card1.number;
        Evt.num2 = Evt.card2.number;
        Evt.trigger('compare');
        game.delay(0, 1500);
      }, () => {
        Evt.result = {
          player: Evt.card1,
          target: Evt.card2,
          num1: Evt.num1,
          num2: Evt.num2
        }
        var str;
        if (Evt.num1 > Evt.num2) {
          Evt.result.bool = true;
          Evt.result.winner = player;
          Evt.result.loser = target;
          str = get.translation(player) + '拼点成功';
          player.popup('胜');
          target.popup('负');
        }
        else {
          Evt.result.bool = false;
          str = get.translation(player) + '拼点失败';
          if (Evt.num1 == Evt.num2) {
            Evt.result.tie = true;
            player.popup('平');
            target.popup('平');
          }
          else {
            Evt.result.winner = target;
            Evt.result.loser = player;
            player.popup('负');
            target.popup('胜');
          }
        }
        game.broadcastAll(function (str) {
          var dialog = ui.create.dialog(str);
          dialog.classList.add('center');
          setTimeout(function () {
            dialog.close();
          }, 1000);
        }, str);
        game.delay(2);
      }, () => {
        if (typeof Evt.target.ai.shown == 'number' && Evt.target.ai.shown <= 0.85 && Evt.addToAI) {
          Evt.target.ai.shown += 0.1;
        }
        game.broadcastAll(function () {
          ui.arena.classList.remove('thrownhighlight');
        });
        game.addVideo('thrownhighlight2');
        if (Evt.clear !== false) {
          game.broadcastAll(ui.clear);
        }
        if (typeof Evt.preserve == 'function') {
          Evt.preserve = Evt.preserve(Evt.result);
        }
        else if (Evt.preserve == 'win') {
          Evt.preserve = Evt.result.bool;
        }
        else if (Evt.preserve == 'lose') {
          Evt.preserve = !Evt.result.bool;
        }
      }],
      /**
       * 选择以获得一项技能
       * @name content.discoverSkill
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      discoverSkill: [function () {
        var num = Evt.num || 3;
        var choice;
        if (typeof Evt.list == 'string' || typeof Evt.list == 'function') {
          choice = get.gainableSkills(Evt.list).randomGets(num);
        }
        else if (Array.isArray(Evt.list)) {
          choice = Evt.list.randomGets(num);
        }
        else {
          choice = Array.from(Evt.list).randomGets(num);
        }
        if (!choice.length) {
          Evt.finish();
          Evt.result = { bool: false };
          return;
        }
        Evt.skillai = Evt.ai || function (list) {
          return get.max(list, get.skillRank, 'item');
        };
        if (_status.connectMode) {
          if (choice.length == 1) Evt._result = { control: list[0] };
          else player.chooseControl(choice).set('prompt', '选择获得一个技能').set('forceDie', true).set('ai', function () {
            return Evt.skillai(choice);
          });
        }
        else if (Evt.isMine()) {
          game.check();
          game.pause();
          Evt.dialog = ui.create.dialog('forcebutton');
          Evt.dialog.add(Evt.prompt || '选择获得一项技能');
          var clickItem = function () {
            _status.event._result = this.link;
            game.resume();
          };
          for (i = 0; i < choice.length; i++) {
            if (lib.translate[choice[i] + '_info']) {
              var translation = get.translation(choice[i]);
              if (translation[0] == '新' && translation.length == 3) {
                translation = translation.slice(1, 3);
              }
              else {
                translation = translation.slice(0, 2);
              }
              var item = Evt.dialog.add('<div class="popup pointerdiv" style="width:80%;display:inline-block"><div class="skill">' +
                translation + '</div><div>' + lib.translate[choice[i] + '_info'] + '</div></div>');
              item.firstChild.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', clickItem);
              item.firstChild.link = choice[i];
            }
          }
          Evt.dialog.add(ui.create.div('.placeholder'));
          Evt.switchToAuto = function () {
            Evt._result = Evt.skillai(Evt.choice);
            game.resume();
          };
          if (Evt.isMine() || Evt.dialogdisplay) {
            Evt.dialog.style.display = '';
            Evt.dialog.open();
          }
          game.countChoose();
          Evt.choosing = true;
        }
        else if (Evt.isOnline()) {
          Evt.send();
        }
        else {
          Evt._result = Evt.skillai(choice);
        }
      }, function () {
        if (_status.connectMode) {
          Evt.result = { bool: true, skill: result.control };
        } else {
          if (Evt.dialog) {
            Evt.dialog.close();
          }
          Evt.choosing = false;
          Evt.result = { bool: true, skill: result };
        }
      }],
      /**
       * 选择以获得一项技能
       * @name content.chooseSkill
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      chooseSkill: [function () {
        var list;
        if (typeof Evt.target == 'string') {
          list = get.gainableSkillsName(Evt.target, Evt.func);
        }
        else {
          list = Evt.target.getGainableSkills(Evt.func);
        }
        if (!list.length) {
          Evt.finish();
          Evt.result = { bool: false };
          return;
        }
        Evt.skillai = function (list) {
          return get.max(list, get.skillRank, 'item');
        };
        if (Evt.isMine()) {
          var dialog = ui.create.dialog('forcebutton');
          dialog.add(Evt.prompt || '选择获得一项技能');
          _status.event.list = list;
          var clickItem = function () {
            _status.event._result = this.link;
            game.resume();
          };
          for (i = 0; i < list.length; i++) {
            if (lib.translate[list[i] + '_info']) {
              var translation = get.translation(list[i]);
              if (translation[0] == '新' && translation.length == 3) {
                translation = translation.slice(1, 3);
              }
              else {
                translation = translation.slice(0, 2);
              }
              var item = dialog.add('<div class="popup pointerdiv" style="width:80%;display:inline-block"><div class="skill">' +
                translation + '</div><div>' + lib.translate[list[i] + '_info'] + '</div></div>');
              item.firstChild.addEventListener('click', clickItem);
              item.firstChild.link = list[i];
            }
          }
          dialog.add(ui.create.div('.placeholder'));
          Evt.dialog = dialog;
          Evt.switchToAuto = function () {
            Evt._result = Evt.skillai(Evt.list);
            game.resume();
          };
          _status.imchoosing = true;
          game.pause();
        }
        else {
          Evt._result = Evt.skillai(list);
        }
      }, function () {
        _status.imchoosing = false;
        if (Evt.dialog) {
          Evt.dialog.close();
        }
        Evt.result = { bool: true, skill: result };
      }],
      /**
       * 选择以(获得|使用)牌
       * @name content.chooseSkill
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      discoverCard: [function () {
        var num = Evt.num || 3;
        var choice;
        if (typeof Evt.list == 'string' || typeof Evt.list == 'function') {
          choice = get.inpile(Evt.list).randomGets(num);
        }
        else if (Array.isArray(Evt.list)) {
          choice = Evt.list.randomGets(num);
        }
        else {
          choice = Array.from(Evt.list).randomGets(num);
        }
        if (choice.length) {
          var prompt = Evt.prompt;
          if (!prompt) {
            prompt = '选择一张牌';
            if (Evt.use) {
              prompt += '使用之';
            }
            else if (!Evt.nogain) {
              prompt += '获得之';
            }
          }
          if (typeof choice[0] === 'string') {
            var next = player.chooseVCardButton(choice, prompt, Evt.forced);
            if (Evt.ai) {
              next.set('ai', Evt.ai);
            }
          }
          else if (get.itemtype(choice[0]) == 'card') {
            var next = player.chooseCardButton(choice, prompt, Evt.forced);
            if (Evt.ai) {
              next.set('ai', Evt.ai);
            }
          }
          else {
            Evt.finish();
          }
        }
        else {
          Evt.finish();
        }
      }, function () {
        Evt.result = {
          bool: result.bool,
          card: null,
          choice: null
        };
        if (result.bool && result.links.length) {
          var link = result.links[0];
          var togain = null;
          if (get.itemtype(link) == 'card') {
            Evt.result.card = link;
            togain = link;
          }
          else if (Array.isArray(link)) {
            Evt.result.choice = link[2];
            togain = game.createCard(link[2]);
          }
          if (togain) {
            if (Evt.use) {
              player.chooseUseTarget(togain);
            }
            else if (!Evt.nogain) {
              player.gain(togain, 'draw');
              game.log(player, '获得了一张牌');
            }
          }
        }
      }],
      /**
       * 选择项(按钮)
       * @name content.chooseButton
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      chooseButton: [() => {
        if (typeof Evt.dialog == 'number') {
          Evt.dialog = get.idDialog(Evt.dialog);
        }
        if (Evt.createDialog && !Evt.dialog) {
          if (Array.isArray(Evt.createDialog)) {
            Evt.createDialog.add('hidden');
            Evt.dialog = ui.create.dialog.apply(this, Evt.createDialog);
          }
          Evt.closeDialog = true;
        }
        if (Evt.dialog == undefined) Evt.dialog = ui.dialog;
        if (Evt.isMine() || Evt.dialogdisplay) {
          Evt.dialog.style.display = '';
          Evt.dialog.open();
        }
        game.check();
        if (Evt.isMine()) {
          if (Evt.hsskill && !Evt.forced && _status.prehidden_skills.contains(Evt.hsskill)) {
            ui.click.cancel();
            return;
          }
          game.pause();
        }
        else if (Evt.isOnline()) {
          Evt.send();
          delete Evt.callback;
        }
        else {
          Evt.result = 'ai';
        }
        if (Evt.onfree) {
          lib.init.onfree();
        }
      }, () => {
        if (Evt.result == 'ai') {
          if (Evt.processAI) {
            Evt.result = Evt.processAI();
          }
          else {
            game.check();
            if (ai.basic.chooseButton(Evt.ai) || forced) ui.click.ok();
            else ui.click.cancel();
          }
        }
        if (Evt.closeDialog) {
          Evt.dialog.close();
        }
        if (Evt.callback) {
          Evt.callback(Evt.player, Evt.result);
        }
        Evt.resume();
      }],
      /**
       * 多人选择牌
       * @name content.chooseCardOL
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      chooseCardOL: [function () {
        Evt.targets = Evt.list.slice(0);
        if (!_status.connectMode) {
          Evt.result = [];
          Evt.goto(7);
        }
        else {
          for (var i = 0; i < Evt.list.length; i++) {
            var target = Evt.list[i];
            target.wait();
            if (target.isOnline()) {
              target.send(function (args, set) {
                game.me.chooseCard.apply(game.me, args).set(set);
                game.resume();
              }, Evt._args, Evt._set);
              Evt.list.splice(i--, 1);
            }
            else if (target == game.me) {
              Evt.withme = true;
              Evt.list.splice(i--, 1);
            }
          }
        }
      }, function () {
        if (Evt.list.length) {
          Evt.target = Evt.list.shift();
          Evt.target.chooseCard.apply(Evt.target, Evt._args).set(Evt._set);
        }
        else {
          Evt.goto(3);
        }
      }, function () {
        Evt.target.unwait(result);
        Evt.goto(1);
      }, function () {
        if (Evt.withme) {
          game.me.chooseCard.apply(game.me, Evt._args).set(Evt._set);
        }
        else {
          Evt.goto(5);
        }
      }, function () {
        game.me.unwait(result);
      }, function () {
        if (!Evt.resultOL) {
          game.pause();
        }
      }, function () {
        Evt.result = [];
        for (var i = 0; i < Evt.targets.length; i++) {
          Evt.result[i] = Evt.resultOL[Evt.targets[i].playerid] || {};
          if (Evt.result[i] == 'ai' && Evt.aiCard) {
            Evt.result[i] = Evt.aiCard(Evt.targets[i]);
          }
        }
        Evt.finish();
      }, function () {
        if (Evt.list.length) {
          Evt.target = Evt.list.shift();
          Evt.target.chooseCard.apply(Evt.target, Evt._args).set(Evt._set);
        }
        else {
          for (var i = 0; i < Evt.targets.length; i++) {
            if (!Evt.result[i]) {
              Evt.result[i] = {};
            }
          }
          Evt.finish();
        }
      }, function () {
        Evt.result[Evt.targets.indexOf(Evt.target)] = result;
        Evt.goto(7);
      }],
      /**
       * 多人选择项(按钮)
       * @name content.chooseButtonOL
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      chooseButtonOL: [function () {
        ui.arena.classList.add('markhidden');
        for (var i = 0; i < Evt.list.length; i++) {
          var current = Evt.list[i];
          current[0].wait();
          if (current[0].isOnline()) {
            var target = current.shift();
            target.send(function (args, callback, switchToAuto, processAI) {
              ui.arena.classList.add('markhidden');
              var next = game.me.chooseButton.apply(game.me, args);
              next.callback = callback;
              next.switchToAuto = switchToAuto;
              next.processAI = processAI;
              next.complexSelect = true;
              game.resume();
            }, current, Evt.callback, Evt.switchToAuto, Evt.processAI);
            target._choose_button_ol = current;
            Evt.list.splice(i--, 1);
          }
          else if (current[0] == game.me) {
            Evt.last = current;
            Evt.last.shift();
            Evt.list.splice(i--, 1);
          }
        }
      }, function () {
        if (Evt.list.length) {
          var current = Evt.list.shift();
          if (current.length)
            Evt.target = current.shift();
          else {
            Evt.target = current;
            current = null;
          }
          var next = Evt.target.chooseButton.apply(Evt.target, current);
          next.callback = Evt.callback;
          next.switchToAuto = Evt.switchToAuto;
          next.processAI = Evt.processAI;
        }
        else {
          Evt.goto(3);
        }
      }, function () {
        Evt.target.unwait(result);
        Evt.goto(1);
      }, function () {
        if (Evt.last) {
          var next = game.me.chooseButton.apply(game.me, Evt.last);
          next.callback = Evt.callback;
          next.switchToAuto = Evt.switchToAuto;
          next.processAI = Evt.processAI;
        }
        else {
          Evt.goto(5);
        }
      }, function () {
        game.me.unwait(result);
      }, function () {
        if (!Evt.resultOL) {
          game.pause();
        }
      }, function () {
        game.broadcastAll(function () {
          ui.arena.classList.remove('markhidden');
        });
        Evt.result = Evt.resultOL;
      }],
      /**
       * 选择牌
       * @name content.chooseCard
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      chooseCard: [() => {
        if (Evt.directresult) {
          Evt.result = {
            buttons: [],
            cards: Evt.directresult.slice(0),
            targets: [],
            confirm: 'ok',
            bool: true,
            links: []
          };
        }
        else {
          game.check();
          if (Evt.isMine()) {
            game.pause();
            if (Evt.hsskill && !Evt.forced && _status.prehidden_skills.contains(Evt.hsskill)) {
              ui.click.cancel();
              return;
            }
            if (Evt.prompt != false) {
              var str;
              if (typeof Evt.prompt == 'string') str = Evt.prompt;
              else {
                str = '请选择'
                var range = get.select(Evt.selectCard);
                if (range[0] == range[1]) str += get.cnNumber(range[0]);
                else if (range[1] == Infinity) str += '至少' + get.cnNumber(range[0]);
                else str += get.cnNumber(range[0]) + '至' + get.cnNumber(range[1]);
                str += '张';
                if (Evt.position == 'h' || Evt.position == undefined) str += '手';
                if (Evt.position == 'e') str += '装备';
                str += '牌';
              }
              Evt.dialog = ui.create.dialog(str);
              if (Evt.prompt2) {
                Evt.dialog.addText(Evt.prompt2, Evt.prompt2.length <= 20);
              }
              if (Array.isArray(Evt.promptx)) {
                for (var i = 0; i < Evt.promptx.length; i++) {
                  Evt.dialog.add(Evt.promptx[i]);
                }
              }
              if (Array.isArray(Evt.selectCard)) {
                Evt.promptbar = Evt.dialog.add('0/' + get.numStr(Evt.selectCard[1], 'card'));
                Evt.custom.add.card = function () {
                  _status.event.promptbar.innerHTML =
                    ui.selected.cards.length + '/' + get.numStr(_status.event.selectCard[1], 'card');
                }
              }
            }
          }
          else if (Evt.isOnline()) {
            Evt.send();
          }
          else {
            Evt.result = 'ai';
          }
        }
      }, () => {
        if (Evt.result == 'ai') {
          game.check();
          if (ai.basic.chooseCard(Evt.ai) || forced) {
            ui.click.ok();
          }
          else if (Evt.skill) {
            var skill = Evt.skill;
            ui.click.cancel();
            Evt._aiexclude.add(skill);
            Evt.redo();
            game.resume();
          }
          else {
            ui.click.cancel();
          }
        }
      }, () => {
        Evt.resume();
        if (Evt.glow_result && Evt.result.cards && !Evt.directresult) {
          for (var i = 0; i < Evt.result.cards.length; i++) {
            Evt.result.cards[i].classList.add('glow');
          }
        }
        if (Evt.dialog) Evt.dialog.close();
      }],
      /**
       * 选择角色对象
       * @name content.chooseTarget
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      chooseTarget: [() => {
        if (Evt.isMine()) {
          if (Evt.hsskill && !Evt.forced && _status.prehidden_skills.contains(Evt.hsskill)) {
            ui.click.cancel();
            return;
          }
          game.check();
          game.pause();
          if (Evt.createDialog && !Evt.dialog && Array.isArray(Evt.createDialog)) {
            Evt.dialog = ui.create.dialog.apply(this, Evt.createDialog);
          }
          else if (Evt.prompt != false) {
            var str;
            if (typeof Evt.prompt == 'string') str = Evt.prompt;
            else {
              str = '请选择'
              var range = get.select(Evt.selectTarget);
              if (range[0] == range[1]) str += get.cnNumber(range[0]);
              else if (range[1] == Infinity) str += '至少' + get.cnNumber(range[0]);
              else str += get.cnNumber(range[0]) + '至' + get.cnNumber(range[1]);
              str += '个目标';
            }
            Evt.dialog = ui.create.dialog(str);
            if (Evt.prompt2) {
              Evt.dialog.addText(Evt.prompt2, Evt.prompt2.length <= 20);
            }
            if (Evt.promptbar != 'none') {
              Evt.promptbar = Evt.dialog.add('0/' + get.numStr(get.select(Evt.selectTarget)[1], 'target'));
              Evt.custom.add.target = function () {
                _status.event.promptbar.innerHTML =
                  ui.selected.targets.length + '/' + get.numStr(get.select(Evt.selectTarget)[1], 'target');
              }
            }
          }
          else if (get.itemtype(Evt.dialog) == 'dialog') {
            Evt.dialog.open();
          }
        }
        else if (Evt.isOnline()) {
          Evt.send();
        }
        else {
          Evt.result = 'ai';
        }
      }, () => {
        if (Evt.result == 'ai') {
          game.check();
          if (ai.basic.chooseTarget(Evt.ai) || forced) {
            ui.click.ok();
          }
          else {
            ui.click.cancel();
          }
        }
        if (Evt.result.bool && Evt.animate !== false) {//play anim
          for (var i = 0; i < Evt.result.targets.length; i++) {
            Evt.result.targets[i].animate('target');
          }
        }
        if (Evt.dialog) Evt.dialog.close();
        Evt.resume();
      }, () => {
        if (Evt.onresult) {
          Evt.onresult(Evt.result);
        }
        if (Evt.result.bool && Evt.autodelay && !Evt.isMine()) {
          if (typeof Evt.autodelay == 'number') {
            game.delayx(Evt.autodelay);
          }
          else {
            game.delayx();
          }
        }
      }],
      /**
       * 选择卡牌和目标角色
       * @name content.chooseCardTarget
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      chooseCardTarget: [() => {
        if (Evt.isMine()) {
          if (Evt.hsskill && !Evt.forced && _status.prehidden_skills.contains(Evt.hsskill)) {
            ui.click.cancel();
            return;
          }
          game.check();
          game.pause();
          if (Evt.prompt != false) {
            Evt.dialog = ui.create.dialog(Evt.prompt || '请选择卡牌和目标');
            if (Evt.prompt2) {
              Evt.dialog.addText(Evt.prompt2, Evt.prompt2.length <= 20);
            }
          }
        }
        else if (Evt.isOnline()) {
          Evt.send();
        }
        else {
          Evt.result = 'ai';
        }
      }, () => {
        if (Evt.result == 'ai') {
          game.check();
          if (ai.basic.chooseCard(Evt.ai1)) {
            if (ai.basic.chooseTarget(Evt.ai2)) {
              ui.click.ok();
              _status.event._aiexclude.length = 0;
            }
            else {
              get.card(true).aiexclude();
              game.uncheck();
              Evt.redo();
              game.resume();
            }
          }
          else {
            ui.click.cancel();
          }
        }
      }, () => {
        Evt.resume();
        if (Evt.result.bool && Evt.animate !== false) {
          for (var i = 0; i < Evt.result.targets.length; i++) {
            Evt.result.targets[i].animate('target');
          }
        }
        if (Evt.dialog) Evt.dialog.close();
      }],
      /**
       * 选择项(列表项)
       * @name content.chooseControl
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      chooseControl: [() => {
        if (Evt.controls.length == 0) {
          if (Evt.sortcard) {
            var sortnum = 2;
            if (Evt.sorttop) {
              sortnum = 1;
            }
            for (var i = 0; i < Evt.sortcard.length + sortnum; i++) {
              Evt.controls.push(get.cnNumber(i, true));
            }
          }
          else if (Evt.choiceList) {
            for (var i = 0; i < Evt.choiceList.length; i++) {
              Evt.controls.push('选项' + get.cnNumber(i + 1, true));
            }
          }
          else {
            Evt.finish();
            return;
          }
        }
        else if (Evt.choiceList && Evt.controls.length == 1 && Evt.controls[0] == 'cancel2') {
          Evt.controls.shift();
          for (var i = 0; i < Evt.choiceList.length; i++) {
            Evt.controls.push('选项' + get.cnNumber(i + 1, true));
          }
          Evt.controls.push('cancel2');
        }
        if (Evt.isMine()) {
          if (Evt.arrangeSkill) {
            var hidden = player.hiddenSkills.slice(0);
            game.expandSkills(hidden);
            if (hidden.length) {
              for (var i of Evt.controls) {
                if (_status.prehidden_skills.contains(i) && hidden.contains(i)) {
                  Evt.result = {
                    bool: true,
                    control: i,
                  }
                  return;
                }
              }
            }
          }
          else if (Evt.hsskill && _status.prehidden_skills.contains(Evt.hsskill) && Evt.controls.contains('cancel2')) {
            Evt.result = {
              bool: true,
              control: 'cancel2',
            }
            return;
          }
          if (Evt.sortcard) {
            var prompt = Evt.prompt || '选择一个位置';
            if (Evt.tosort) {
              prompt += '放置' + get.translation(Evt.tosort);
            }
            Evt.dialog = ui.create.dialog(prompt, 'hidden');
            if (Evt.sortcard && Evt.sortcard.length) {
              Evt.dialog.addSmall(Evt.sortcard);
            }
            else {
              Evt.dialog.buttons = [];
              Evt.dialog.add(ui.create.div('.buttons'));
            }
            var buttons = Evt.dialog.content.lastChild;
            var sortnum = 2;
            if (Evt.sorttop) {
              sortnum = 1;
            }
            for (var i = 0; i < Evt.dialog.buttons.length + sortnum; i++) {
              var item = ui.create.div('.button.card.pointerdiv.mebg');
              item.style.width = '50px';
              buttons.insertBefore(item, Evt.dialog.buttons[i]);
              item.innerHTML = '<div style="font-family: xinwei;font-size: 25px;height: 75px;line-height: 25px;top: 8px;left: 10px;width: 30px;">第' + get.cnNumber(i + 1, true) + '张</div>';
              if (i == Evt.dialog.buttons.length + 1) {
                item.firstChild.innerHTML = '牌堆底';
              }
              item.link = get.cnNumber(i, true);
              item.listen(ui.click.dialogcontrol);
            }

            Evt.dialog.forcebutton = true;
            Evt.dialog.classList.add('forcebutton');
            Evt.dialog.open();
          }
          else if (Evt.dialogcontrol) {
            Evt.dialog = ui.create.dialog(Evt.prompt || '选择一项', 'hidden');
            for (var i = 0; i < Evt.controls.length; i++) {
              var item = Evt.dialog.add('<div class="popup text pointerdiv" style="width:calc(100% - 10px);display:inline-block">' + Evt.controls[i] + '</div>');
              item.firstChild.listen(ui.click.dialogcontrol);
              item.firstChild.link = Evt.controls[i];
            }
            Evt.dialog.forcebutton = true;
            Evt.dialog.classList.add('forcebutton');
            if (Evt.addDialog) {
              for (var i = 0; i < Evt.addDialog.length; i++) {
                if (get.itemtype(Evt.addDialog[i]) == 'cards') {
                  Evt.dialog.addSmall(Evt.addDialog[i]);
                }
                else {
                  Evt.dialog.add(Evt.addDialog[i]);
                }
              }
              Evt.dialog.add(ui.create.div('.placeholder.slim'));
            }
            Evt.dialog.open();
          }
          else {
            if (Evt.seperate || lib.config.seperate_control) {
              Evt.controlbars = [];
              for (var i = 0; i < Evt.controls.length; i++) {
                Evt.controlbars.push(ui.create.control([Evt.controls[i]]));
              }
            }
            else {
              Evt.controlbar = ui.create.control(Evt.controls);
            }
            if (Evt.dialog) {
              if (Array.isArray(Evt.dialog)) {
                Evt.dialog = ui.create.dialog.apply(this, Evt.dialog);
              }
              Evt.dialog.open();
            }
            else if (Evt.choiceList) {
              Evt.dialog = ui.create.dialog(Evt.prompt || '选择一项', 'hidden');
              Evt.dialog.forcebutton = true;
              Evt.dialog.open();
              for (var i = 0; i < Evt.choiceList.length; i++) {
                Evt.dialog.add('<div class="popup text" style="width:calc(100% - 10px);display:inline-block">选项' +
                  get.cnNumber(i + 1, true) + '：' + Evt.choiceList[i] + '</div>');
              }
            }
            else if (Evt.prompt) {
              Evt.dialog = ui.create.dialog(Evt.prompt);
              if (Evt.prompt2) {
                Evt.dialog.addText(Evt.prompt2, Evt.prompt2.length <= 20 || Evt.centerprompt2);
              }
            }
          }
          game.pause();
          game.countChoose();
          Evt.choosing = true;
        }
        else if (Evt.isOnline()) {
          Evt.send();
        }
        else {
          Evt.result = 'ai';
        }
      }, () => {
        if (Evt.result == 'ai') {
          Evt.result = {};
          if (Evt.ai) {
            var result = Evt.ai(Evt.getParent(), player);
            if (typeof result == 'number') Evt.result.control = Evt.controls[result];
            else Evt.result.control = result;
          }
          else Evt.result.control = Evt.controls[Evt.choice];
        }
        Evt.result.index = Evt.controls.indexOf(Evt.result.control);
        Evt.choosing = false;
        _status.imchoosing = false;
        if (Evt.dialog && Evt.dialog.close) Evt.dialog.close();
        if (Evt.controlbar) Evt.controlbar.close();
        if (Evt.controlbars) {
          for (var i = 0; i < Evt.controlbars.length; i++) {
            Evt.controlbars[i].close();
          }
        }
        Evt.resume();
      }],
      /**
       * 确认项(确认|取消)
       * @name content.chooseBool
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      chooseBool: [() => {
        if (Evt.isMine()) {
          if (Evt.frequentSkill && !lib.config.autoskilllist.contains(Evt.frequentSkill)) {
            ui.click.ok();
            return;
          }
          else if (Evt.hsskill && _status.prehidden_skills.contains(Evt.hsskill)) {
            ui.click.cancel();
            return;
          }
          ui.create.confirm('oc');
          if (Evt.createDialog && !Evt.dialog) {
            if (Array.isArray(Evt.createDialog)) {
              Evt.dialog = ui.create.dialog.apply(this, Evt.createDialog);
              if (Evt.dialogselectx) {
                for (var i = 0; i < Evt.dialog.buttons.length; i++) {
                  Evt.dialog.buttons[i].classList.add('selectedx');
                }
              }
            }
          }
          if (Evt.dialog) {
            Evt.dialog.open();
          }
          else if (Evt.prompt) {
            Evt.dialog = ui.create.dialog(Evt.prompt);
            if (Evt.prompt2) {
              Evt.dialog.addText(Evt.prompt2, Evt.prompt2.length <= 20);
            }
          }
          game.pause();
          game.countChoose();
          Evt.choosing = true;
        }
        else if (Evt.isOnline()) {
          Evt.send();
        }
        else {
          Evt.result = 'ai';
        }
      }, () => {
        if (Evt.result == 'ai') {
          if (Evt.ai) {
            Evt.choice = Evt.ai(Evt.getParent(), player);
          }
          Evt.result = { bool: Evt.choice };
        }
        _status.imchoosing = false;
        Evt.choosing = false;
        if (Evt.dialog) Evt.dialog.close();
        Evt.resume();
      }],
      /**
       * 选择(摸牌|回血)
       * @name content.chooseDrawRecover
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      chooseDrawRecover: [function () {
        if (player.isHealthy() && Evt.forced) {
          player.draw(Evt.num1);
          Evt.finish();
          return;
        }
        var controls = ['draw_card'];
        if (player.isDamaged()) {
          Evt.num2 = Math.min(Evt.num2, player.maxHp - player.hp);
          controls.push('recover_hp');
        }
        if (!Evt.forced) {
          controls.push('cancel2');
        }
        var prompt = Evt.prompt;
        if (!prompt) {
          if (player.isHealthy()) {
            prompt = '是否摸' + get.cnNumber(Evt.num1) + '张牌？';
          }
          else {
            prompt = '摸' + get.cnNumber(Evt.num1) + '张牌或回复' + get.cnNumber(Evt.num2) + '点' + get.translation('hp');
          }
        }
        var next = player.chooseControl(controls);
        next.set('prompt', prompt);
        if (Evt.hsskill) next.setHiddenSkill(Evt.hsskill);
        if (Evt.ai) {
          next.set('ai', Evt.ai);
        }
        else {
          var choice;
          if (player.isDamaged() && get.recoverEffect(player) > 0 && (
            player.hp == 1 || player.needsToDiscard() ||
            player.hasSkillTag('maixie_hp') || Evt.num2 > Evt.num1 ||
            (Evt.num2 == Evt.num1 && player.needsToDiscard(1))
          )) {
            choice = 'recover_hp';
          }
          else {
            choice = 'draw_card';
          }
          next.set('ai', function () {
            return _status.event.choice;
          });
          next.set('choice', choice);
        }
      }, function () {
        if (result.control != 'cancel2') {
          if (Evt.logSkill) {
            if (typeof Evt.logSkill == 'string') {
              player.logSkill(Evt.logSkill);
            }
            else if (Array.isArray(Evt.logSkill)) {
              player.logSkill.apply(player, Evt.logSkill);
            }
          }
          if (result.control == 'draw_card') {
            player.draw(Evt.num1);
          }
          else {
            player.recover(Evt.num2);
          }
        }
        Evt.result = result;
      }],
      /**
       * 从目标角色选择牌
       * @name content.choosePlayerCard
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      choosePlayerCard: [() => {
        if (!Evt.dialog) Evt.dialog = ui.create.dialog('hidden');
        else if (!Evt.isMine) {
          Evt.dialog.style.display = 'none';
        }
        if (Evt.prompt) {
          Evt.dialog.add(Evt.prompt);
        }
        else {
          Evt.dialog.add('选择' + get.translation(target) + '的一张牌');
        }
        if (Evt.prompt2) {
          Evt.dialog.addText(Evt.prompt2);
        }
        var directh = (!lib.config.unauto_choose && !Evt.complexSelect);
        directh = game.showPlayerCard(Evt, target, directh, null);
        if (Evt.dialog.buttons.length == 0) {
          Evt.finish();
          return;
        }
        var cs = target.getCards(Evt.position);
        var select = get.select(Evt.selectButton);
        if (Evt.forced && select[0] >= cs.length) {
          Evt.result = {
            bool: true,
            buttons: Evt.dialog.buttons,
            links: cs
          }
        }
        else if (Evt.forced && directh && !Evt.isOnline() && select[0] == select[1]) {
          Evt.result = {
            bool: true,
            buttons: Evt.dialog.buttons.randomGets(select[0]),
            links: []
          }
          for (var i = 0; i < Evt.result.buttons.length; i++) {
            Evt.result.links[i] = Evt.result.buttons[i].link;
          }
        }
        else {
          if (Evt.isMine()) {
            if (Evt.hsskill && !Evt.forced && _status.prehidden_skills.contains(Evt.hsskill)) {
              ui.click.cancel();
              return;
            }
            Evt.dialog.open();
            game.check();
            game.pause();
          }
          else if (Evt.isOnline()) {
            Evt.send();
          }
          else {
            Evt.result = 'ai';
          }
        }
      }, () => {
        if (Evt.result == 'ai') {
          game.check();
          if (ai.basic.chooseButton(Evt.ai) || forced) ui.click.ok();
          else ui.click.cancel();
        }
        Evt.dialog.close();
        if (Evt.result.links) {
          Evt.result.cards = Evt.result.links.slice(0);
        }
        Evt.resume();
      }],
      /**
       * 从目标角色选择牌弃置
       * @name content.discardPlayerCard
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      discardPlayerCard: [() => {
        if (Evt.directresult) {
          Evt.result = {
            buttons: [],
            cards: Evt.directresult.slice(0),
            links: Evt.directresult.slice(0),
            targets: [],
            confirm: 'ok',
            bool: true
          };
          Evt.cards = Evt.directresult.slice(0);
          Evt.goto(2);
          return;
        }
        if (!Evt.dialog) Evt.dialog = ui.create.dialog('hidden');
        else if (!Evt.isMine) {
          Evt.dialog.style.display = 'none';
        }
        if (Evt.prompt == undefined) {
          var str = '弃置' + get.translation(target);
          var range = get.select(Evt.selectButton);
          if (range[0] == range[1]) str += get.cnNumber(range[0]);
          else if (range[1] == Infinity) str += '至少' + get.cnNumber(range[0]);
          else str += get.cnNumber(range[0]) + '至' + get.cnNumber(range[1]);
          str += '张';
          if (Evt.position == 'h' || Evt.position == undefined) str += '手';
          if (Evt.position == 'e') str += '装备';
          str += '牌';
          Evt.prompt = str;
        }
        if (Evt.prompt) {
          Evt.dialog.add(Evt.prompt);
        }
        if (Evt.prompt2) {
          Evt.dialog.addText(Evt.prompt2);
        }
        var directh = (!lib.config.unauto_choose && !Evt.complexSelect);
        directh = game.showPlayerCard(Evt, target, directh, 'canBeDiscarded');
        if (Evt.dialog.buttons.length == 0) {
          Evt.finish();
          return;
        }
        var cs = target.getCards(Evt.position);
        var select = get.select(Evt.selectButton);
        if (Evt.forced && select[0] >= cs.length) {
          Evt.result = {
            bool: true,
            buttons: Evt.dialog.buttons,
            links: cs
          }
        }
        else if (Evt.forced && directh && !Evt.isOnline() && select[0] == select[1]) {
          Evt.result = {
            bool: true,
            buttons: Evt.dialog.buttons.randomGets(select[0]),
            links: []
          }
          for (var i = 0; i < Evt.result.buttons.length; i++) {
            Evt.result.links[i] = Evt.result.buttons[i].link;
          }
        }
        else {
          if (Evt.isMine()) {
            Evt.dialog.open();
            game.check();
            game.pause();
          }
          else if (Evt.isOnline()) {
            Evt.send();
          }
          else {
            Evt.result = 'ai';
          }
        }
      }, () => {
        if (Evt.result == 'ai') {
          game.check();
          if (ai.basic.chooseButton(Evt.ai) || forced) ui.click.ok();
          else ui.click.cancel();
        }
        Evt.dialog.close();
      }, () => {
        Evt.resume();
        if (Evt.result.bool && Evt.result.links && !game.online) {
          if (Evt.logSkill) {
            if (typeof Evt.logSkill == 'string') {
              player.logSkill(Evt.logSkill);
            }
            else if (Array.isArray(Evt.logSkill)) {
              player.logSkill.apply(player, Evt.logSkill);
            }
          }
          var cards = [];
          for (var i = 0; i < Evt.result.links.length; i++) {
            cards.push(Evt.result.links[i]);
          }
          Evt.result.cards = Evt.result.links.slice(0);
          Evt.cards = cards;
          Evt.trigger("rewriteDiscardResult");
        }
      }, () => {
        if (Evt.boolline) {
          player.line(target, 'green');
        }
        if (!Evt.chooseonly) {
          var next = target.discard(Evt.cards);
          if (player != target) next.notBySelf = true;
          Evt.done = next;
          if (Evt.delay === false) {
            next.set('delay', false);
          }
        }
      }],
      /**
       * 从目标角色选择牌获得
       * @name content.gainPlayerCard
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      gainPlayerCard: [() => {
        if (Evt.directresult) {
          Evt.result = {
            buttons: [],
            cards: Evt.directresult.slice(0),
            links: Evt.directresult.slice(0),
            targets: [],
            confirm: 'ok',
            bool: true
          };
          Evt.cards = Evt.directresult.slice(0);
          Evt.goto(2);
          return;
        }
        if (!Evt.dialog) Evt.dialog = ui.create.dialog('hidden');
        else if (!Evt.isMine) {
          Evt.dialog.style.display = 'none';
        }
        if (Evt.prompt == undefined) {
          var str = '获得' + get.translation(target);
          var range = get.select(Evt.selectButton);
          if (range[0] == range[1]) str += get.cnNumber(range[0]);
          else if (range[1] == Infinity) str += '至少' + get.cnNumber(range[0]);
          else str += get.cnNumber(range[0]) + '至' + get.cnNumber(range[1]);
          str += '张';
          if (Evt.position == 'h' || Evt.position == undefined) str += '手';
          if (Evt.position == 'e') str += '装备';
          str += '牌';
          Evt.prompt = str;
        }
        if (Evt.prompt) {
          Evt.dialog.add(Evt.prompt);
        }
        if (Evt.prompt2) {
          Evt.dialog.addText(Evt.prompt2);
        }
        var directh = (!lib.config.unauto_choose && !Evt.complexSelect);
        directh = game.showPlayerCard(Evt, target, directh, 'canBeGained');
        if (Evt.dialog.buttons.length == 0) {
          Evt.dialog.close();
          Evt.finish();
          return;
        }
        var cs = target.getCards(Evt.position);
        var select = get.select(Evt.selectButton);
        if (Evt.forced && select[0] >= cs.length) {
          Evt.result = {
            bool: true,
            buttons: Evt.dialog.buttons,
            links: cs
          }
        }
        else if (Evt.forced && directh && !Evt.isOnline() && select[0] == select[1]) {
          Evt.result = {
            bool: true,
            buttons: Evt.dialog.buttons.randomGets(select[0]),
            links: []
          }
          for (var i = 0; i < Evt.result.buttons.length; i++) {
            Evt.result.links[i] = Evt.result.buttons[i].link;
          }
        }
        else {
          if (Evt.isMine()) {
            Evt.dialog.open();
            game.check();
            game.pause();
          }
          else if (Evt.isOnline()) {
            Evt.send();
          }
          else {
            Evt.result = 'ai';
          }
        }
      }, () => {
        if (Evt.result == 'ai') {
          game.check();
          if (ai.basic.chooseButton(Evt.ai) || forced) ui.click.ok();
          else ui.click.cancel();
        }
        Evt.dialog.close();
      }, () => {
        Evt.resume();
        if (game.online || !Evt.result.bool) {
          Evt.finish();
        }
      }, () => {
        if (Evt.logSkill && Evt.result.bool && !game.online) {
          if (typeof Evt.logSkill == 'string') {
            player.logSkill(Evt.logSkill);
          }
          else if (Array.isArray(Evt.logSkill)) {
            player.logSkill.apply(player, Evt.logSkill);
          }
        }
        var cards = [];
        for (var i = 0; i < Evt.result.links.length; i++) {
          cards.push(Evt.result.links[i]);
        }
        Evt.result.cards = Evt.result.links.slice(0);
        Evt.cards = cards;
        Evt.trigger("rewriteGainResult");
      }, () => {
        if (Evt.boolline) {
          player.line(target, 'green');
        }
        if (!Evt.chooseonly) {
          if (Evt.delay !== false) {
            var next = player.gain(Evt.cards, target, Evt.visibleMove ? 'give' : 'giveAuto', 'bySelf');
            Evt.done = next;
          }
          else {
            var next = player.gain(Evt.cards, target, 'bySelf');
            Evt.done = next;
            target[Evt.visibleMove ? '$give' : '$giveAuto'](cards, player);
            if (Evt.visibleMove) next.visible = true;
          }
        }
        else target[Evt.visibleMove ? '$give' : '$giveAuto'](cards, player);
      }],
      /**
       * 展示角色手牌
       * @name content.showHandcards
       * @type {GameCores.Bases.StateMachine}
       */
      showHandcards: [() => {
        if (player.countCards('h') == 0) {
          Evt.finish();
          return;
        }
        var cards = player.getCards('h');
        var str = get.translation(player.name) + '的手牌';
        if (typeof Evt.prompt == 'string') {
          str = Evt.prompt;
        }
        Evt.dialog = ui.create.dialog(str, cards);
        Evt.dialogid = lib.status.videoId++;
        Evt.dialog.videoId = Evt.dialogid;
        game.broadcast(function (str, cards, id) {
          ui.create.dialog(str, cards).videoId = id;
        }, str, cards, Evt.dialogid);
        game.log(player, '展示了', cards);
        game.addVideo('showCards', player, [str, get.cardsInfo(cards)]);
        game.delayx(2);
      }, () => {
        game.broadcast('closeDialog', Evt.dialogid);
        Evt.dialog.close();
      }],
      /**
       * 展示角色的牌
       * @name content.showHandcards
       * @type {GameCores.Bases.StateMachine}
       */
      showCards: [() => {
        if (get.itemtype(cards) != 'cards') {
          Evt.finish();
          return;
        }
        if (!Evt.str) {
          Evt.str = get.translation(player.name) + '展示的牌';
        }
        Evt.dialog = ui.create.dialog(Evt.str, cards);
        Evt.dialogid = lib.status.videoId++;
        Evt.dialog.videoId = Evt.dialogid;

        if (Evt.hiddencards) {
          for (var i = 0; i < Evt.dialog.buttons.length; i++) {
            if (Evt.hiddencards.contains(Evt.dialog.buttons[i].link)) {
              Evt.dialog.buttons[i].className = 'button card';
              Evt.dialog.buttons[i].innerHTML = '';
            }
          }
        }
        game.broadcast(function (str, cards, cards2, id) {
          var dialog = ui.create.dialog(str, cards);
          dialog.forcebutton = true;
          dialog.videoId = id;
          if (cards2) {
            for (var i = 0; i < dialog.buttons.length; i++) {
              if (cards2.contains(dialog.buttons[i].link)) {
                dialog.buttons[i].className = 'button card';
                dialog.buttons[i].innerHTML = '';
              }
            }
          }
        }, Evt.str, cards, Evt.hiddencards, Evt.dialogid);
        if (Evt.hiddencards) {
          var cards2 = cards.slice(0);
          for (var i = 0; i < Evt.hiddencards.length; i++) {
            cards2.remove(Evt.hiddencards[i]);
          }
          game.log(player, '展示了', cards2);
        }
        else {
          game.log(player, '展示了', cards);
        }
        game.delayx(2);
        game.addVideo('showCards', player, [Evt.str, get.cardsInfo(cards)]);
      }, () => {
        game.broadcast('closeDialog', Evt.dialogid);
        Evt.dialog.close();
      }],
      /**
       * 查看牌
       * @name content.showHandcards
       * @type {GameCores.Bases.StateMachine}
       */
      viewCards: [() => {
        if (player == game.me) {
          Evt.dialog = ui.create.dialog(Evt.str, Evt.cards);
          if (Evt.isMine()) {
            game.pause();
            ui.create.confirm('o');
            game.countChoose();
            Evt.choosing = true;
          }
          else {
            Evt.finish();
            Evt.result = 'viewed';
            setTimeout(function () {
              Evt.dialog.close();
            }, 2 * lib.config.duration);
            game.delayx(2);
          }
        }
        else if (Evt.isOnline()) {
          Evt.send();
        }
        else {
          Evt.finish();
        }
      }, () => {
        Evt.result = 'viewed';
        _status.imchoosing = false;
        Evt.choosing = false;
        if (Evt.dialog) Evt.dialog.close();
      }],
      /**
       * 移动牌位置
       * @name content.moveCard
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Object} Evt.result 返回选择结果给父事件
       */
      moveCard: [function () {
        if (!player.canMoveCard(null, Evt.nojudge, Evt.moveHandcard)) {
          Evt.finish();
          return;
        }
        var next = player.chooseTarget(2, function (card, player, target) {
          if (_status.event.sourceFilterTarget && typeof _status.event.sourceFilterTarget == 'function') {
            if (!_status.event.sourceFilterTarget(card, player, target)) return false;
          }
          if (ui.selected.targets.length) {
            var from = ui.selected.targets[0];
            if (_status.event.moveHandcard && from.countCards('h') > 0) return true;
            var js = from.getCards('j');
            for (var i = 0; i < js.length; i++) {
              if (_status.event.nojudge) break;
              if (target.canAddJudge(js[i])) return true;
            }
            if (target.isMin()) return false;
            var es = from.getCards('e');
            for (var i = 0; i < es.length; i++) {
              if (target.isEmpty(get.subtype(es[i]))) return true;
            }
            return false;
          }
          else {
            var range = 'ej';
            if (_status.event.nojudge) range = 'e';
            if (_status.event.moveHandcard) range = 'h' + range;
            return target.countCards(range) > 0;
          }
        });
        next.set('nojudge', Evt.nojudge || false);
        next.set('moveHandcard', Evt.moveHandcard || false);
        next.set('sourceFilterTarget', Evt.sourceFilterTarget || false);
        next.set('ai', Evt.ai || function (target) {
          var player = _status.event.player;
          var att = get.attitude(player, target);
          var sgnatt = get.sgn(att);
          if (ui.selected.targets.length == 0) {
            if (att > 0) {
              if (!_status.event.nojudge && target.countCards('j', function (card) {
                return game.hasPlayer(function (current) {
                  return current != target && current.canAddJudge(card) && get.attitude(player, current) < 0;
                })
              })) return 14;
              if (target.countCards('e', function (card) {
                return get.value(card, target) < 0 && game.hasPlayer(function (current) {
                  return current != target && get.attitude(player, current) < 0 && current.isEmpty(get.subtype(card)) && get.effect(target, card, player, player) < 0;
                });
              }) > 0) return 9;
            }
            else if (att < 0) {
              if (game.hasPlayer(function (current) {
                if (current != target && get.attitude(player, current) > 0) {
                  var es = target.getCards('e');
                  for (var i = 0; i < es.length; i++) {
                    if (get.value(es[i], target) > 0 && current.isEmpty(get.subtype(es[i])) && get.effect(current, es[i], player, player) > 0) return true;
                  }
                }
              })) {
                return -att;
              }
            }
            return 0;
          }
          var es = ui.selected.targets[0].getCards('e');
          var i;
          var att2 = get.sgn(get.attitude(player, ui.selected.targets[0]));
          for (i = 0; i < es.length; i++) {
            if (sgnatt != 0 && att2 != 0 && sgnatt != att2 &&
              get.sgn(get.value(es[i], ui.selected.targets[0])) == -att2 &&
              get.sgn(get.effect(target, es[i], player, target)) == sgnatt &&
              target.isEmpty(get.subtype(es[i]))) {
              return Math.abs(att);
            }
          }
          if (i == es.length && (_status.event.nojudge || !ui.selected.targets[0].countCards('j', function (card) {
            return target.canAddJudge(card);
          }) || att2 <= 0)) {
            return 0;
          }
          return -att * att2;
        });
        next.set('multitarget', true);
        next.set('targetprompt', _status.event.targetprompt || ['被移走', '移动目标']);
        next.set('prompt', Evt.prompt || '移动场上的一张牌');
        if (Evt.prompt2) next.set('prompt2', Evt.prompt2);
        if (Evt.forced) next.set('forced', true);
      }, function () {
        Evt.result = result;
        if (result.bool) {
          player.line2(result.targets, 'green');
          Evt.targets = result.targets;
        }
        else {
          Evt.finish();
        }
      }, function () {
        game.delay();
      }, function () {
        if (targets.length == 2) {
          player.choosePlayerCard('hej', true, function (button) {
            var player = _status.event.player;
            var targets0 = _status.event.targets0;
            var targets1 = _status.event.targets1;
            if (get.attitude(player, targets0) > 0 && get.attitude(player, targets1) < 0) {
              if (get.position(button.link) == 'j') return 12;
              if (get.value(button.link, targets0) < 0 && get.effect(targets1, button.link, player, targets1) > 0) return 10;
              return 0;
            }
            else {
              if (get.position(button.link) == 'j') return -10;
              return get.value(button.link) * get.effect(targets1, button.link, player, targets1);
            }
          }, targets[0]).set('nojudge', Evt.nojudge || false).set('targets0', targets[0]).set('targets1', targets[1]).set('filterButton', function (button) {
            var targets1 = _status.event.targets1;
            if (get.position(button.link) == 'h') {
              if (!_status.event.moveHandcard) return false;
              return true;
            }
            if (get.position(button.link) == 'j') {
              if (_status.event.nojudge) return false;
              return targets1.canAddJudge(button.link);
            }
            else {
              return targets1.isEmpty(get.subtype(button.link));
            }
          }).set('moveHandcard', Evt.moveHandcard || false);
        }
        else {
          Evt.finish();
        }
      }, function () {
        if (result.bool && result.links.length) {
          var link = result.links[0];
          if (get.position(link) == 'e') {
            Evt.targets[1].equip(link);
          }
          else if (get.position(link) == 'h') {
            Evt.targets[0].give(link, Evt.targets[1], 'giveAuto');
          }
          else if (link.viewAs) {
            Evt.targets[1].addJudge({ name: link.viewAs }, [link]);
          }
          else {
            Evt.targets[1].addJudge(link);
          }
          if (get.position(link) != 'h') {
            Evt.targets[0].$give(link, Evt.targets[1], false);
            game.log(Evt.targets[0], '的', link, '被移动给了', Evt.targets[1]);
          }
          Evt.result.card = link;
          Evt.result.position = get.position(link);
          game.delay();
        }
      }],
      /**
       * 角色使用牌
       * @name content.useCard
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {?Object} Evt.result 返回选择使用结果(如果有)给父事件
       */
      useCard: [() => {
        if (!card) {
          console.log('err: no card', get.translation(Evt.player));
          Evt.finish();
          return;
        }
        if (!get.info(card, false).noForceDie) Evt.forceDie = true;
        var next = player.lose(cards, 'visible', ui.ordering).set('type', 'use');
        var directDiscard = [];
        for (var i = 0; i < cards.length; i++) {
          if (!next.cards.contains(cards[i])) {
            directDiscard.push(cards[i]);
          }
        }
        if (directDiscard.length) game.cardsGotoOrdering(directDiscard);
        //player.using=cards;
        var cardaudio = true;
        if (Evt.skill) {
          if (lib.skill[Evt.skill].audio) {
            cardaudio = false;
          }
          if (lib.skill[Evt.skill].log != false) {
            player.logSkill(Evt.skill);
          }
          if (get.info(Evt.skill).popname) {
            player.tryCardAnimate(card, Evt.card.name, 'metal', true);
          }
        }
        else if (!Evt.nopopup) {
          if (lib.translate[Evt.card.name + '_pop']) {
            player.tryCardAnimate(card, lib.translate[Evt.card.name + '_pop'], 'metal');
          }
          else {
            player.tryCardAnimate(card, Evt.card.name, 'metal');
          }
        }
        if (Evt.audio === false) {
          cardaudio = false;
        }
        if (cardaudio) {
          game.broadcastAll(function (player, card) {
            if (lib.config.background_audio) {
              if (get.type(card) == 'equip' && !lib.config.equip_audio) return;
              var sex = player.sex == 'female' ? 'female' : 'male';
              var audioinfo = lib.card[card.name].audio;
              // if(audioinfo||true){
              if (card.name == 'sha' && (card.nature == 'fire' || card.nature == 'thunder' || card.nature == 'ice' || card.nature == 'ocean')) {
                game.playAudio('card', sex, card.name + '_' + card.nature);
              }
              else {
                if (typeof audioinfo == 'string') {
                  if (audioinfo.indexOf('ext:') == 0) game.playAudio('..', 'extension', audioinfo.slice(4), card.name + '_' + sex);
                  else game.playAudio('card', sex, audioinfo);
                }
                else {
                  game.playAudio('card', sex, card.name);
                }
              }
              // }
              // else if(get.type(card)!='equip'){
              //     game.playAudio('card/default');
              // }
            }
          }, player, card);
        }
        if (Evt.animate != false && Evt.line != false) {
          if ((card.name == 'wuxie' || card.name == 'youdishenru') && Evt.getParent().source) {
            var lining = Evt.getParent().sourcex || Evt.getParent().source2 || Evt.getParent().source;
            if (lining == player && Evt.getParent().sourcex2) {
              lining = Evt.getParent().sourcex2;
            }
            if (Array.isArray(lining) && Evt.getTrigger().name == 'jiedao') {
              player.line(lining[0], 'green');
            }
            else {
              player.line(lining, 'green');
            }
          }
          else {
            var config = {};
            if (card.nature == 'fire' ||
              (card.classList && card.classList.contains('fire'))) {
              config.color = 'fire';
            }
            else if (card.nature == 'thunder' ||
              (card.classList && card.classList.contains('thunder'))) {
              config.color = 'thunder';
            }
            else if (card.nature == 'ocean' ||
              (card.classList && card.classList.contains('ocean'))) {
              config.color = 'ocean';
            }
            else if (card.nature == 'yami' ||
              (card.classList && card.classList.contains('yami'))) {
              config.color = 'yami';
            }
            if (Evt.addedTarget) {
              player.line2(targets.concat(Evt.addedTargets), config);
            }
            else if (get.info(card, false).multitarget && targets.length > 1 && !get.info(card, false).multiline) {
              player.line2(targets, config);
            }
            else {
              player.line(targets, config);
            }
          }
          if (Evt.throw !== false) player.$throw(cards);
          if (lib.config.sync_speed && cards[0] && cards[0].clone) {
            var waitingForTransition = get.time();
            Evt.waitingForTransition = waitingForTransition;
            cards[0].clone.listenTransition(function () {
              if (_status.waitingForTransition == waitingForTransition && _status.paused) {
                game.resume();
              }
              delete Evt.waitingForTransition;
            });
          }
        }
        Evt.id = get.id();
        Evt.excluded = [];
        Evt.directHit = [];
        Evt.customArgs = { default: {} };
        if (typeof Evt.baseDamage != 'number') Evt.baseDamage = get.info(card, false).baseDamage || 1;
        if (typeof Evt.baseNumber != 'number') Evt.baseNumber = get.info(card, false).baseNumber || 1;
        if (Evt.oncard) {
          Evt.oncard(Evt.card, Evt.player);
        }
        player.actionHistory[player.actionHistory.length - 1].useCard.push(Evt);
        if (Evt.addCount !== false) {
          if (player.stat[player.stat.length - 1].card[card.name] == undefined) {
            player.stat[player.stat.length - 1].card[card.name] = 1;
          }
          else {
            player.stat[player.stat.length - 1].card[card.name]++;
          }
          if (Evt.skill) {
            if (player.stat[player.stat.length - 1].skill[Evt.skill] == undefined) {
              player.stat[player.stat.length - 1].skill[Evt.skill] = 1;
            }
            else {
              player.stat[player.stat.length - 1].skill[Evt.skill]++;
            }
            var sourceSkill = get.info(Evt.skill).sourceSkill;
            if (sourceSkill) {
              if (player.stat[player.stat.length - 1].skill[sourceSkill] == undefined) {
                player.stat[player.stat.length - 1].skill[sourceSkill] = 1;
              }
              else {
                player.stat[player.stat.length - 1].skill[sourceSkill]++;
              }
            }
          }
        }
        if (targets.length) {
          var str = (targets.length == 1 && targets[0] == player) ? '#b自己' : targets;
          if (cards.length && !card.isCard) {
            if (Evt.addedTarget) {
              game.log(player, '对', str, '使用了', card, '（', cards, '，指向', Evt.addedTargets, '）');
            }
            else {
              game.log(player, '对', str, '使用了', card, '（', cards, '）');
            }
          }
          else {
            if (Evt.addedTarget) {
              game.log(player, '对', str, '使用了', card, '（指向', Evt.addedTargets, '）');
            }
            else {
              game.log(player, '对', str, '使用了', card);
            }
          }
        }
        else {
          if (cards.length && !card.isCard) {
            if (Evt.addedTarget) {
              game.log(player, '使用了', card, '（', cards, '，指向', Evt.addedTargets, '）');
            }
            else {
              game.log(player, '使用了', card, '（', cards, '）');
            }
          }
          else {
            if (Evt.addedTarget) {
              game.log(player, '使用了', card, '（指向', Evt.addedTargets, '）');
            }
            else {
              game.log(player, '使用了', card);
            }
          }
        }
        if (card.name == 'wuxie') {
          game.logv(player, [card, cards], [Evt.getTrigger().card]);
        }
        else {
          game.logv(player, [card, cards], targets);
        }
        Evt.trigger('useCard1');
      }, () => {
        Evt.trigger('useCard2');
      }, () => {
        Evt.trigger('useCard');
        Evt._oncancel = function () {
          game.broadcastAll(function (id) {
            if (ui.tempnowuxie && ui.tempnowuxie._origin == id) {
              ui.tempnowuxie.close();
              delete ui.tempnowuxie;
            }
          }, Evt.id);
        };
      }, () => {
        Evt.sortTarget = function (animate, sort) {
          var info = get.info(card, false);
          if (num == 0 && targets.length > 1) {
            if (!info.multitarget) {
              if (!Evt.fixedSeat && !sort) {
                targets.sortBySeat(player);
              }
              if (animate) for (var i = 0; i < targets.length; i++) {
                targets[i].animate('target');
              }
            }
            else if (animate) {
              for (var i = 0; i < targets.length; i++) {
                targets[i].animate('target');
              }
            }
          }
        }
        Evt.sortTarget();
        Evt.getTriggerTarget = function (list1, list2) {
          var listx = list1.slice(0).sortBySeat();
          for (var i = 0; i < listx.length; i++) {
            if (list2.numOf(listx[i]) < listx.numOf(listx[i])) return listx[i];
          }
          return null;
        }
      }, () => {
        if (Evt.all_excluded) return;
        if (!Evt.triggeredTargets1) Evt.triggeredTargets1 = [];
        var target = Evt.getTriggerTarget(targets, Evt.triggeredTargets1);
        if (target) {
          Evt.triggeredTargets1.push(target);
          var next = game.createEvent('useCardToPlayer', false);
          if (Evt.triggeredTargets1.length == 1) next.isFirstTarget = true;
          next.setContent('emptyEvent');
          next.targets = targets;
          next.target = target;
          next.card = card;
          next.cards = cards;
          next.player = player;
          next.excluded = Evt.excluded;
          next.directHit = Evt.directHit;
          next.customArgs = Evt.customArgs;
          if (Evt.forceDie) next.forceDie = true;
          Evt.redo();
        }
      }, () => {
        if (Evt.all_excluded) return;
        if (!Evt.triggeredTargets2) Evt.triggeredTargets2 = [];
        var target = Evt.getTriggerTarget(targets, Evt.triggeredTargets2);
        if (target) {
          Evt.triggeredTargets2.push(target);
          var next = game.createEvent('useCardToTarget', false);
          if (Evt.triggeredTargets2.length == 1) next.isFirstTarget = true;
          next.setContent('emptyEvent');
          next.targets = targets;
          next.target = target;
          next.card = card;
          next.cards = cards;
          next.player = player;
          next.excluded = Evt.excluded;
          next.directHit = Evt.directHit;
          next.customArgs = Evt.customArgs;
          if (Evt.forceDie) next.forceDie = true;
          Evt.redo();
        }
      }, () => {
        if (Evt.all_excluded) return;
        if (!Evt.triggeredTargets3) Evt.triggeredTargets3 = [];
        var target = Evt.getTriggerTarget(targets, Evt.triggeredTargets3);
        if (target) {
          Evt.triggeredTargets3.push(target);
          var next = game.createEvent('useCardToPlayered', false);
          if (Evt.triggeredTargets3.length == 1) next.isFirstTarget = true;
          next.setContent('emptyEvent');
          next.targets = targets;
          next.target = target;
          next.card = card;
          next.cards = cards;
          next.player = player;
          next.excluded = Evt.excluded;
          next.directHit = Evt.directHit;
          next.customArgs = Evt.customArgs;
          if (Evt.forceDie) next.forceDie = true;
          Evt.redo();
        }
      }, () => {
        var info = get.info(card, false);
        if (!info.nodelay && Evt.animate != false) {
          if (Evt.delayx !== false) {
            if (Evt.waitingForTransition) {
              _status.waitingForTransition = Evt.waitingForTransition;
              game.pause();
            }
            else {
              game.delayx();
            }
          }
        }
      }, () => {
        if (Evt.all_excluded) return;
        if (!Evt.triggeredTargets4) Evt.triggeredTargets4 = [];
        var target = Evt.getTriggerTarget(targets, Evt.triggeredTargets4);
        if (target) {
          Evt.triggeredTargets4.push(target);
          var next = game.createEvent('useCardToTargeted', false);
          if (Evt.triggeredTargets4.length == 1) next.isFirstTarget = true;
          next.setContent('emptyEvent');
          next.targets = targets;
          next.target = target;
          next.card = card;
          next.cards = cards;
          next.player = player;
          next.excluded = Evt.excluded;
          next.directHit = Evt.directHit;
          next.customArgs = Evt.customArgs;
          if (Evt.forceDie) next.forceDie = true;
          if (targets.length == Evt.triggeredTargets4.length) {
            Evt.sortTarget();
          }
          Evt.redo();
        }
      }, () => {
        var info = get.info(card, false);
        if (info.contentBefore) {
          var next = game.createEvent(card.name + 'ContentBefore');
          next.setContent(info.contentBefore);
          next.targets = targets;
          next.card = card;
          next.cards = cards;
          next.player = player;
          next.type = 'precard';
          if (Evt.forceDie) next.forceDie = true;
        }
        else if (info.reverseOrder && get.is.versus() && targets.length > 1) {
          var next = game.createEvent(card.name + 'ContentBefore');
          next.setContent('reverseOrder');
          next.targets = targets;
          next.card = card;
          next.cards = cards;
          next.player = player;
          next.type = 'precard';
          if (Evt.forceDie) next.forceDie = true;
        }
      }, () => {
        if (Evt.all_excluded) return;
        var info = get.info(card, false);
        if (num == 0 && targets.length > 1) {
          Evt.sortTarget(true, true);
        }
        if (targets[num] && targets[num].isDead()) return;
        if (targets[num] && targets[num].isOut()) return;
        if (targets[num] && targets[num].removed) return;
        if (targets[num] && info.ignoreTarget && info.ignoreTarget(card, player, targets[num])) return;
        if (targets.length == 0 && !info.notarget) return;
        if (targets[num] && Evt.excluded.contains(targets[num])) {
          var next = game.createEvent('useCardToExcluded', false);
          next.setContent('emptyEvent');
          next.targets = targets;
          next.target = targets[num];
          next.num = num;
          next.card = card;
          next.cards = cards;
          next.player = player;
          return;
        };
        var next = game.createEvent(card.name);
        next.setContent(info.content);
        next.targets = targets;
        next.card = card;
        next.cards = cards;
        next.player = player;
        next.num = num;
        next.type = 'card';
        next.skill = Evt.skill;
        next.multitarget = info.multitarget;
        next.preResult = Evt.preResult;
        next.baseDamage = Evt.baseDamage;
        next.baseNumber = Evt.baseNumber;
        if (Evt.forceDie) next.forceDie = true;
        if (Evt.addedTargets) {
          next.addedTargets = Evt.addedTargets;
          next.addedTarget = Evt.addedTarget;
          next._targets = Evt._targets;
        }
        if (info.targetDelay === false) {
          Evt.targetDelay = false;
        }
        next.target = targets[num];
        for (var i in Evt.customArgs.default) next[i] = Evt.customArgs.default[i];
        if (next.target && Evt.customArgs[next.target.playerid]) {
          var customArgs = Evt.customArgs[next.target.playerid];
          for (var i in customArgs) next[i] = customArgs[i];
        }
        if (next.target && Evt.directHit.contains(next.target)) next.directHit = true;
        if (next.target && !info.multitarget) {
          if (num == 0 && targets.length > 1) {
            // var ttt=next.target;
            // setTimeout(function(){ttt.animate('target');},0.5*lib.config.duration);
          }
          else {
            next.target.animate('target');
          }
        }
        if (!info.nodelay && num > 0) {
          if (Evt.targetDelay !== false) {
            game.delayx(0.5);
          }
        }
      }, () => {
        if (Evt.all_excluded) return;
        if (!get.info(Evt.card, false).multitarget && num < targets.length - 1 && !Evt.cancelled) {
          Evt.num++;
          Evt.goto(10)
        }
      }, () => {
        if (get.info(card, false).contentAfter) {
          var next = game.createEvent(card.name + 'ContentAfter');
          next.setContent(get.info(card, false).contentAfter);
          next.targets = targets;
          next.card = card;
          next.cards = cards;
          next.player = player;
          next.preResult = Evt.preResult;
          next.type = 'postcard';
          if (Evt.forceDie) next.forceDie = true;
        }
      }, () => {
        if (Evt.postAi) {
          Evt.player.logAi(Evt.targets, Evt.card);
        }
        if (Evt._result) {
          Evt.result = Evt._result;
        }
        //delete player.using;
        if (document.getElementsByClassName('thrown').length) {
          if (Evt.delayx !== false) game.delayx();
        }
        else {
          Evt.finish();
        }
      }, () => {
        Evt._oncancel();
      }],
      /**
       * 角色使用技能
       * @name content.useSkill
       * @type {GameCores.Bases.StateMachine}
       */
      useSkill: [() => {
        var info = get.info(Evt.skill);
        if (!info.noForceDie) Evt.forceDie = true;
        Evt._skill = Evt.skill;
        game.trySkillAudio(Evt.skill, player);
        var checkShow = player.checkShow(Evt.skill);
        if (info.discard != false && info.lose != false && !info.viewAs) {
          player.discard(cards).delay = false;
          if (lib.config.low_performance) {
            Evt.discardTransition = true;
          }
        }
        else {
          if (info.lose != false) {
            if (info.losetrigger == false) {
              var losecard = player.lose(cards, ui.special)._triggered = null;
            }
            else {
              var losecard = player.lose(cards, ui.special);
              if (info.visible) losecard.visible = true;
              if (info.loseTo) losecard.position = ui[info.loseTo];
              if (info.insert) losecard.insert_card = true;
              if (losecard.position == ui.special && info.toStorage) losecard.toStorage = true;
            }
          }
          if (!info.prepare && info.viewAs) {
            player.$throw(cards);
            if (losecard) losecard.visible = true;
            if (lib.config.sync_speed && cards[0] && cards[0].clone) {
              var waitingForTransition = get.time();
              Evt.waitingForTransition = waitingForTransition;
              cards[0].clone.listenTransition(function () {
                if (_status.waitingForTransition == waitingForTransition && _status.paused) {
                  game.resume();
                }
                delete Evt.waitingForTransition;
              });
            }
          }
        }
        if (info.line != false && targets.length) {
          var config = {};
          if (get.is.object(info.line)) config = info.line;
          else if (info.line == 'fire') {
            config.color = 'fire';
          }
          else if (info.line == 'thunder') {
            config.color = 'thunder';
          }
          else if (info.line == 'ocean') {
            config.color = 'ocean';
          }
          else if (info.line === undefined || info.line == 'green') {
            config.color = 'green';
          }
          if (info.multitarget && !info.multiline && targets.length > 1) {
            player.line2(targets, config);
          }
          else {
            player.line(targets, config);
          }
        }
        var str = '';
        if (targets && targets.length && info.log != 'notarget') {
          str += '对<span class="bluetext">' + (targets[0] == player ? '自己' : get.translation(targets[0]));
          for (var i = 1; i < targets.length; i++) {
            str += '、' + (targets[i] == player ? '自己' : get.translation(targets[i]));
          }
          str += '</span>'
        }
        str += '发动了';
        if (!info.direct) {
          game.log(player, str, '#p『' + get.skillTranslation(skill, player) + '』');
          if (info.logv !== false) game.logv(player, skill, targets);
          player.trySkillAnimate(skill, skill, checkShow);
        }
        if (Evt.addCount != false) {
          if (player.stat[player.stat.length - 1].skill[skill] == undefined) {
            player.stat[player.stat.length - 1].skill[skill] = 1;
          }
          else {
            player.stat[player.stat.length - 1].skill[skill]++;
          }
          var sourceSkill = get.info(skill).sourceSkill;
          if (sourceSkill) {
            if (player.stat[player.stat.length - 1].skill[sourceSkill] == undefined) {
              player.stat[player.stat.length - 1].skill[sourceSkill] = 1;
            }
            else {
              player.stat[player.stat.length - 1].skill[sourceSkill]++;
            }
          }
        }
        if (player.stat[player.stat.length - 1].allSkills == undefined) {
          player.stat[player.stat.length - 1].allSkills = 1;
        }
        else {
          player.stat[player.stat.length - 1].allSkills++;
        }
        if (info.prepare) {
          switch (info.prepare) {
            case 'give': if (losecard) losecard.visible = true; player.$give(cards, targets[0]); break;
            case 'give2': player.$give(cards.length, targets[0]); break;
            case 'throw': if (losecard) losecard.visible = true; player.$throw(cards); break;
            case 'throw2': player.$throw(cards.length); break;
            default: info.prepare(cards, player, targets);
          }
        }
        if (info.round) {
          var roundname = skill + '_roundcount';
          player.storage[roundname] = info.round;
          if (!player.hasSkill(roundname)) player.addSkill(roundname)
          // player.storage[roundname] = game.roundNumber;
          player.syncStorage(roundname);
          player.markSkill(roundname);
        }
      }, () => {
        var info = get.info(Evt.skill);
        if (info && info.contentBefore) {
          var next = game.createEvent(Evt.skill + 'ContentBefore');
          next.setContent(info.contentBefore);
          next.targets = targets;
          next.cards = cards;
          next.player = player;
          if (Evt.forceDie) next.forceDie = true;
        }
      }, () => {
        if (!Evt.skill) {
          console.log('error: no skill', get.translation(Evt.player), Evt.player.getSkills());
          if (Evt._skill) {
            Evt.skill = Evt._skill;
            console.log(Evt._skill);
          }
          else {
            Evt.finish();
            return;
          }
        }
        var info = get.info(Evt.skill);
        if (targets[num] && targets[num].isDead() ||
          targets[num] && targets[num].isOut() ||
          targets[num] && targets[num].removed) {
          if (!info.multitarget && num < targets.length - 1) {
            Evt.num++;
            Evt.redo();
          }
          return;
        }
        var next = game.createEvent(Evt.skill);
        next.setContent(info.content);
        next.targets = targets;
        next.cards = cards;
        next.player = player;
        next.num = num;
        next.multitarget = info.multitarget;
        if (num == 0 && next.targets.length > 1) {
          if (!info.multitarget) {
            lib.tempSortSeat = player;
            targets.sort(lib.sort.seat);
            delete lib.tempSortSeat;
          }
          for (var i = 0; i < targets.length; i++) {
            targets[i].animate('target');
          }
        }
        next.target = targets[num];
        if (Evt.forceDie) next.forceDie = true;
        if (next.target && !info.multitarget) {
          if (num == 0 && targets.length > 1) {
            // var ttt=next.target;
            // setTimeout(function(){ttt.animate('target');},0.5*lib.config.duration);
          }
          else {
            next.target.animate('target');
          }
        }
        if (num == 0) {
          if (typeof info.delay == 'number') game.delay(info.delay);
          else if (info.delay !== false && info.delay !== 0) {
            if (Evt.waitingForTransition) {
              _status.waitingForTransition = Evt.waitingForTransition;
              game.pause();
            }
            else {
              game.delayx()
            }
          }
        }
        else game.delayx(0.5);
        if (!info.multitarget && num < targets.length - 1) {
          Evt.num++;
          Evt.redo();
        }
      }, () => {
        var info = get.info(Evt.skill);
        if (info && info.contentAfter) {
          var next = game.createEvent(Evt.skill + 'ContentAfter');
          next.setContent(info.contentAfter);
          next.targets = targets;
          next.cards = cards;
          next.player = player;
          if (Evt.forceDie) next.forceDie = true;
        }
      }, () => {
        if (player.getStat().allSkills > 200) {
          player._noSkill = true;
          console.log(player.name, Evt.skill);
        }
        if (document.getElementsByClassName('thrown').length) {
          if (Evt.skill && get.info(Evt.skill).delay !== false && get.info(Evt.skill).delay !== 0) game.delayx();
        }
        else {
          Evt.finish();
        }
      }, () => {
        ui.clear();
      }],
      /**
       * 从(牌库|牌堆顶|牌堆底)摸牌
       * @name content.useCard
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 当前事件
       * @property {!Array<GameCores.GameObjects.Card>} Evt.result 返回摸到的牌数组
       */
      draw: function () {
        // if(lib.config.background_audio){
        //     game.playAudio('effect','draw');
        // }
        // game.broadcast(function(){
        //     if(lib.config.background_audio){
        //         game.playAudio('effect','draw');
        //     }
        // });
        if (typeof Evt.minnum == 'number' && num < Evt.minnum) {
          num = Evt.minnum;
        }
        if (Evt.drawDeck) {
          if (Evt.drawDeck > num) {
            Evt.drawDeck = num;
          }
          num -= Evt.drawDeck;
        }
        if (Evt.log != false) {
          if (num > 0) {
            if (Evt.bottom) game.log(player, '从牌堆底摸了' + get.cnNumber(num) + '张牌');
            else game.log(player, '摸了' + get.cnNumber(num) + '张牌');
          }
          if (Evt.drawDeck) {
            game.log(player, '从牌库中获得了' + get.cnNumber(Evt.drawDeck) + '张牌');
          }
        }
        var cards;
        if (num > 0) {
          if (Evt.bottom) cards = get.bottomCards(num);
          else if (player.getTopCards) cards = player.getTopCards(num);
          else cards = get.cards(num);
        }
        else {
          cards = [];
        }
        if (Evt.drawDeck) {
          cards = cards.concat(player.getDeckCards(Evt.drawDeck));
        }
        if (Evt.animate != false) {
          if (Evt.visible) {
            var next = player.gain(cards, 'gain2');
            if (Evt.bottom) game.log(player, '从牌堆底摸了' + get.cnNumber(num) + '张牌（', cards, '）');
            else game.log(player, '摸了' + get.cnNumber(num) + '张牌（', cards, '）');
          }
          else {
            var next = player.gain(cards, 'draw');
          }
        }
        else {
          var next = player.gain(cards);
          if (Evt.$draw) {
            player.$draw(cards.length);
          }
        }
        if (Evt.gaintag) next.gaintag.addArray(Evt.gaintag);
        Evt.result = cards;
      },
      /**
       * 从(手牌区|装备区|武将牌上|判定区)弃置牌
       * @name content.discard
       * @type {GameCores.Bases.StateMachine}
       */
      discard: [() => {
        game.log(player, '弃置了', cards);
        event.done = player.lose(cards, event.position, 'visible');
        event.done.type = 'discard';
      }, () => {
        Evt.trigger('discard');
      }],
      /**
       * 角色打出牌
       * @name content.respond
       * @type {GameCores.Bases.StateMachine}
       */
      respond: [function () {
        var cardaudio = true;
        if (Evt.skill) {
          if (lib.skill[Evt.skill].audio) {
            cardaudio = false;
          }
          player.logSkill(Evt.skill);
          player.checkShow(Evt.skill, true);
          if (lib.skill[Evt.skill].onrespond && !game.online) {
            lib.skill[Evt.skill].onrespond(Evt, player);
          }
        }
        else if (!Evt.nopopup) player.tryCardAnimate(card, card.name, 'wood');
        if (cardaudio && Evt.getParent(3).name == 'useCard') {
          game.broadcastAll(function (player, card) {
            if (lib.config.background_audio) {
              var sex = player.sex == 'female' ? 'female' : 'male';
              var audioinfo = lib.card[card.name].audio;
              // if(audioinfo||true){
              if (typeof audioinfo == 'string' && audioinfo.indexOf('ext:') == 0) {
                game.playAudio('..', 'extension', audioinfo.slice(4), card.name + '_' + sex);
              }
              else {
                game.playAudio('card', sex, card.name);
              }
              // }
              // else{
              //     game.playAudio('card/default');
              // }
            }
          }, player, card);
        }
        if (cards.length && (cards.length > 1 || cards[0].name != card.name)) {
          game.log(player, '打出了', card, '（', cards, '）');
        }
        else {
          game.log(player, '打出了', card);
        }
        player.actionHistory[player.actionHistory.length - 1].respond.push(Evt);
        var cards2 = cards.slice(0);
        if (cards2.length) {
          var next = player.lose(cards2, ui.ordering, 'visible');
          if (Evt.noOrdering) next.noOrdering = true;
          cards2.removeArray(next.cards);
          if (cards2.length) {
            var next2 = game.cardsGotoOrdering(cards2);
            if (Evt.noOrdering) next2.noOrdering = true;
          }
        }
        if (Evt.animate != false && Evt.throw !== false) {
          for (var i = 0; i < cards.length; i++) {
            player.$throw(cards[i]);
            if (Evt.highlight) {
              cards[i].clone.classList.add('thrownhighlight');
              game.addVideo('highlightnode', player, get.cardInfo(cards[i]));
            }
          }
          if (Evt.highlight) {
            game.broadcast(function (cards) {
              for (var i = 0; i < cards.length; i++) {
                if (cards[i].clone) {
                  cards[i].clone.classList.add('thrownhighlight');
                }
              }
            }, cards);
          }
        }
        Evt.trigger('respond');
      }, function () {
        game.delayx(0.5);
      }],
      /**
       * 角色和目标交换(手)牌
       * @name content.swapHandcards
       * @type {GameCores.Bases.StateMachine}
       */
      swapHandcards: [function () {
        Evt.cards1 = Evt.cards1 || player.getCards('h');
        Evt.cards2 = Evt.cards2 || target.getCards('h');
        game.loseAsync({
          player: player,
          target: target,
          cards1: Evt.cards1,
          cards2: Evt.cards2,
        }).setContent('swapHandcardsx');
      }, function () {
        player.gain(Evt.cards2);
        target.gain(Evt.cards1);
      }],
      swapHandcardsx: [function () {
        player.$giveAuto(Evt.cards1, target);
        target.$giveAuto(Evt.cards2, player);
      }, function () {
        Evt.cards = Evt.cards1;
        var next = player.lose(Evt.cards, ui.ordering).getlx = false;
        next.relatedEvent = Evt.getParent();
        if (player == game.me) {
          Evt.delayed = true;
        }
        else {
          next.delay = false;
        }
      }, function () {
        Evt.cards = Evt.cards2;
        var next = target.lose(Evt.cards, ui.ordering).getlx = false;
        next.relatedEvent = Evt.getParent();
        if (target == game.me) {
          Evt.delayed = true;
        }
        else {
          next.delay = false;
        }
      }, function () {
        if (!Evt.delayed) game.delay();
      }],
      /**
       * 角色从每个目标获得一张牌
       * @name content.gainMultiple
       * @type {GameCores.Bases.StateMachine}
       */
      gainMultiple: [function () {
        Evt.delayed = false;
        Evt.num = 0;
        Evt.cards = [];
      }, function () {
        player.gainPlayerCard(targets[num], Evt.position, true).set('boolline', false).set('delay', num == targets.length - 1);
      }, function () {
        if (result.bool) {
          Evt.cards.addArray(result.cards);
          if (num == targets.length - 1) Evt.delayed = true;
        }
        Evt.num++;
        if (Evt.num < targets.length) {
          Evt.goto(1);
        }
      }, function () {
        if (!Evt.delayed) game.delay();
      }],
      /**
       * 角色获得牌
       * @name content.lose
       * @type {GameCores.Bases.StateMachine}
       */
      gain: [() => {
        if (cards) {
          var map = {};
          for (var i of cards) {
            var owner = get.owner(i, 'judge');
            if (owner && (owner != player || get.position(i) != 'h')) {
              var id = owner.playerid;
              if (!map[id]) map[id] = [];
              map[id].push(i);
            }
          }
          for (var i in map) {
            var owner = (_status.connectMode ? lib.playerOL : game.playerMap)[i];
            var next = owner.lose(map[i], ui.special).set('type', 'gain').set('forceDie', true).set('getlx', false);
            if (Evt.animate == 'give' || Evt.visible == true) next.visible = true;
            Evt.relatedLose = next;
          }
        }
        else {
          Evt.finish();
        }
      }, () => {
        for (var i = 0; i < cards.length; i++) {
          if (cards[i].destroyed) {
            if (player.hasSkill(cards[i].destroyed)) {
              delete cards[i].destroyed;
            }
            else {
              cards.splice(i--, 1);
            }
          }
        }
        if (cards.length == 0) {
          Evt.finish();
          return;
        }
        player.getHistory('gain').push(Evt);
        //if(Evt.source&&Evt.delay!==false) game.delayx();}, () => {
        if (player.getStat().gain == undefined) {
          player.getStat().gain = cards.length;
        }
        else {
          player.getStat().gain += cards.length;
        }
      }, () => {
        var sort;
        var frag1 = document.createDocumentFragment();
        var frag2 = document.createDocumentFragment();
        var hs = player.getCards('hs');
        for (var i = 0; i < cards.length; i++) {
          if (hs.contains(cards[i])) {
            cards.splice(i--, 1);
          }
        }
        for (var num = 0; num < cards.length; num++) {
          sort = lib.config.sort_card(cards[num]);
          if (lib.config.reverse_sort) sort = -sort;
          cards[num].fix();
          cards[num].style.transform = '';
          cards[num].addGaintag(Evt.gaintag);
          if (_status.discarded) {
            _status.discarded.remove(cards[num]);
          }
          // cards[num].vanishtag.length=0;
          for (var num2 = 0; num2 < cards[num].vanishtag.length; num2++) {
            if (cards[num].vanishtag[num2][0] != '_') {
              cards[num].vanishtag.splice(num2--, 1);
            }
          }
          if (player == game.me) {
            cards[num].classList.add('drawinghidden');
          }
          if (get.is.singleHandcard() || sort > 1) frag1.appendChild(cards[num]);
          else frag2.appendChild(cards[num]);
        }
        var addv = function () {
          if (player == game.me) {
            game.addVideo('gain12', player, [get.cardsInfo(frag1.childNodes), get.cardsInfo(frag2.childNodes), Evt.gaintag]);
          }
        };
        var broadcast = function () {
          game.broadcast(function (player, cards, num, gaintag) {
            player.directgain(cards, null, gaintag);
            _status.cardPileNum = num;
          }, player, cards, ui.cardPile.childNodes.length, Evt.gaintag);
        };
        if (Evt.animate == 'draw') {
          player.$draw(cards.length);
          game.pause();
          setTimeout(function () {
            addv();
            player.node.handcards1.insertBefore(frag1, player.node.handcards1.firstChild);
            player.node.handcards2.insertBefore(frag2, player.node.handcards2.firstChild);
            player.update();
            if (player == game.me) ui.updatehl();
            broadcast();
            game.resume();
          }, get.delayx(500, 500));
        }
        else if (Evt.animate == 'gain') {
          player.$gain(cards);
          game.pause();
          setTimeout(function () {
            addv();
            player.node.handcards1.insertBefore(frag1, player.node.handcards1.firstChild);
            player.node.handcards2.insertBefore(frag2, player.node.handcards2.firstChild);
            player.update();
            if (player == game.me) ui.updatehl();
            broadcast();
            game.resume();
          }, get.delayx(700, 700));
        }
        else if (Evt.animate == 'gain2' || Evt.animate == 'draw2') {
          var gain2t = 300;
          if (player.$gain2(cards) && player == game.me) {
            gain2t = 500;
          }
          game.pause();
          setTimeout(function () {
            addv();
            player.node.handcards1.insertBefore(frag1, player.node.handcards1.firstChild);
            player.node.handcards2.insertBefore(frag2, player.node.handcards2.firstChild);
            player.update();
            if (player == game.me) ui.updatehl();
            broadcast();
            game.resume();
          }, get.delayx(gain2t, gain2t));
        }
        else if (Evt.source && (Evt.animate == 'give' || Evt.animate == 'giveAuto')) {
          if (Evt.animate == 'give') Evt.source['$' + Evt.animate](cards, player);
          else {
            var givemap = { hs: [], ots: [] };
            for (var i = 0; i < cards.length; i++) {
              givemap[Evt.relatedLose && Evt.relatedLose.hs && Evt.relatedLose.hs.contains(cards[i]) ? 'hs' : 'ots'].push(cards[i]);
            }
            if (givemap.hs.length) Evt.source.$giveAuto(givemap.hs, player);
            if (givemap.ots.length) Evt.source.$give(givemap.ots, player);
          }
          game.pause();
          setTimeout(function () {
            addv();
            player.node.handcards1.insertBefore(frag1, player.node.handcards1.firstChild);
            player.node.handcards2.insertBefore(frag2, player.node.handcards2.firstChild);
            player.update();
            if (player == game.me) ui.updatehl();
            broadcast();
            game.resume();
          }, get.delayx(500, 500));
        }
        else {
          addv();
          player.node.handcards1.insertBefore(frag1, player.node.handcards1.firstChild);
          player.node.handcards2.insertBefore(frag2, player.node.handcards2.firstChild);
          player.update();
          if (player == game.me) ui.updatehl();
          broadcast();
          Evt.finish();
        }
        if (Evt.log) {
          game.log(player, '获得了', cards);
        }
      }, () => {
        game.delayx();
      }],
      /**
       * 失去牌至(弃牌堆|牌堆)，或将牌移动至武将牌上(special arena)
       * @name content.lose
       * @type {GameCores.Bases.StateMachine}
       */
      lose: [() => {
        var evt = Evt.getParent();
        if (evt.name != 'discard' && Evt.type != 'discard') {
          Evt.delay = false;
          return;
        }
        if (evt.delay === false) Evt.delay = false;
        if (evt.animate != false) {
          evt.discardid = lib.status.videoId++;
          game.broadcastAll(function (player, cards, id) {
            player.$throw(cards, null, 'nobroadcast');
            var cardnodes = [];
            cardnodes._discardtime = get.time();
            for (var i = 0; i < cards.length; i++) {
              if (cards[i].clone) {
                cardnodes.push(cards[i].clone);
              }
            }
            ui.todiscard[id] = cardnodes;
          }, player, cards, evt.discardid);
          if (lib.config.sync_speed && cards[0] && cards[0].clone) {
            if (evt.delay != false) {
              var waitingForTransition = get.time();
              evt.waitingForTransition = waitingForTransition;
              cards[0].clone.listenTransition(function () {
                if (_status.waitingForTransition == waitingForTransition && _status.paused) {
                  game.resume();
                }
                delete evt.waitingForTransition;
              });
            }
            else if (evt.getParent().discardTransition) {
              delete evt.getParent().discardTransition;
              var waitingForTransition = get.time();
              evt.getParent().waitingForTransition = waitingForTransition;
              cards[0].clone.listenTransition(function () {
                if (_status.waitingForTransition == waitingForTransition && _status.paused) {
                  game.resume();
                }
                delete evt.getParent().waitingForTransition;
              });
            }
          }
        }
      }, () => {
        Evt.gaintag_map = {};
        var hs = [], es = [], js = [], ss = [];
        if (Evt.insert_card && Evt.position == ui.cardPile) Evt.cards.reverse();
        var hej = player.getCards('hejs');
        Evt.stockcards = cards.slice(0);
        for (var i = 0; i < cards.length; i++) {
          if (cards[i].gaintag && cards[i].gaintag.length) {
            Evt.gaintag_map[cards[i].cardid] = cards[i].gaintag.slice(0);
            if (cards[i].hasGaintag('ming_')) Evt.gaintag_map[cards[i].cardid].push('ming_');
            if (cards[i].hasGaintag('an_')) Evt.gaintag_map[cards[i].cardid].push('an_');
            cards[i].removeGaintag(true);
          }
          if (!hej.contains(cards[i])) {
            cards.splice(i--, 1);
            continue;
          }
          else if (cards[i].parentNode) {
            if (cards[i].parentNode.classList.contains('equips')) {
              cards[i].original = 'e';
              es.push(cards[i]);
            }
            else if (cards[i].parentNode.classList.contains('judges')) {
              cards[i].original = 'j';
              js.push(cards[i]);
            }
            else if (cards[i].parentNode.classList.contains('handcards')) {
              if (cards[i].classList.contains('glows')) {
                cards[i].original = 's';
                ss.push(cards[i]);
              }
              else {
                cards[i].original = 'h';
                hs.push(cards[i]);
              }
            }
            else {
              cards[i].original = null;
            }
          }

          cards[i].style.transform += ' scale(0.2)';
          cards[i].classList.remove('glow');
          cards[i].classList.remove('glows');
          cards[i].recheck();

          var info = lib.card[cards[i].name];
          if (info.destroy || cards[i]._destroy) {
            cards[i].delete();
            cards[i].destroyed = info.destroy || cards[i]._destroy;
          }
          else if (Evt.position) {
            if (_status.discarded) {
              if (Evt.position == ui.discardPile) {
                _status.discarded.add(cards[i]);
              }
              else {
                _status.discarded.remove(cards[i]);
              }
            }
            if (Evt.insert_index) {
              Evt.position.insertBefore(cards[i], Evt.insert_index(Evt, cards[i]));
              cards[i].fix();
            }
            else if (Evt.insert_card) {
              Evt.position.insertBefore(cards[i], Evt.position.firstChild);
              cards[i].fix();
            }
            else if (Evt.position == ui.cardPile) {
              Evt.position.appendChild(cards[i]);
              cards[i].fix();
            }
            else cards[i].goto(Evt.position);
          }
          else {
            cards[i].remove();
          }
          //if(ss.contains(cards[i])) cards.splice(i--,1);
        }
        if (player == game.me) ui.updatehl();
        ui.updatej(player);
        game.broadcast(function (player, cards, num) {
          for (var i = 0; i < cards.length; i++) {
            cards[i].classList.remove('glow');
            cards[i].classList.remove('glows');
            cards[i].fix();
            cards[i].remove();
          }
          if (player == game.me) {
            ui.updatehl();
          }
          ui.updatej(player);
          _status.cardPileNum = num;
        }, player, cards, ui.cardPile.childNodes.length);
        game.addVideo('lose', player, [get.cardsInfo(hs), get.cardsInfo(es), get.cardsInfo(js), get.cardsInfo(ss)]);
        Evt.cards2 = hs.concat(es);
        player.getHistory('lose').push(Evt);
        game.getGlobalHistory().cardMove.push(Evt);
        player.update();
        game.addVideo('loseAfter', player);
        Evt.num = 0;
        if (Evt.position == ui.ordering) {
          var evt = Evt.relatedEvent || Evt.getParent();
          if (!evt.orderingCards) evt.orderingCards = [];
          if (!Evt.noOrdering && !Evt.cardsOrdered) {
            Evt.cardsOrdered = true;
            var next = game.createEvent('orderingDiscard', false, evt.getParent());
            next.relatedEvent = evt;
            next.setContent('orderingDiscard');
          }
          if (!Evt.noOrdering) {
            evt.orderingCards.addArray(cards);
            evt.orderingCards.addArray(ss);
          }
        }
        else if (Evt.position == ui.cardPile) {
          game.updateRoundNumber();
        }
        Evt.hs = hs;
        Evt.es = es;
        Evt.js = js;
        Evt.ss = ss;
      }, () => {
        if (num < cards.length) {
          let evt = Evt.getParent();
          if (Evt.es.contains(cards[num])) {
            Evt.moveEquip = false;
            if ((evt.name == 'equip' && evt.cards.contains(cards[num]))
              || (Evt.getParent() && Evt.getParent().name != 'swapEquip')) Evt.moveEquip = true;
            Evt.loseEquip = true;
            player.removeEquipTrigger(cards[num], Evt.moveEquip);
            var info = get.info(cards[num]);
            if (info.onLose && (!info.filterLose || info.filterLose(cards[num], player))) {
              Evt.goto(3);
              return;
            }
          }
          Evt.num++;
          Evt.redo();
        }
        else {
          if (Evt.loseEquip) {
            player.addEquipTrigger();
          }
          Evt.goto(4);
        }
      }, () => {
        var info = get.info(cards[num]);
        if (info.loseDelay != false && (player.isAlive() || info.forceDie)) {
          player.popup(cards[num].name);
          game.delayx();
        }
        if (Array.isArray(info.onLose)) {
          for (var i = 0; i < info.onLose.length; i++) {
            var next = game.createEvent('lose_' + cards[num].name);
            next.setContent(info.onLose[i]);
            if (info.forceDie) next.forceDie = true;
            next.player = player;
            next.card = cards[num];
          }
        }
        else {
          var next = game.createEvent('lose_' + cards[num].name);
          next.setContent(info.onLose);
          next.player = player;
          if (info.forceDie) next.forceDie = true;
          next.card = cards[num];
        }
        Evt.num++;
        Evt.goto(2);
      }, () => {
        var evt = Evt.getParent();
        if (evt.name != 'discard' && Evt.type != 'discard') return;
        if (evt.delay != false) {
          if (evt.waitingForTransition) {
            _status.waitingForTransition = evt.waitingForTransition;
            game.pause();
          }
          else {
            game.delayx();
          }
        }
      }],
      /**
       * 令角色受到伤害
       * @name content.damage
       * @type {GameCores.Bases.StateMachine}
       */
      damage: [() => {
        Evt.forceDie = true;
        Evt.trigger('damageBegin1');
      }, () => {
        Evt.trigger('damageBegin2');
      }, () => {
        Evt.trigger('damageBegin3');
      }, () => {
        Evt.trigger('damageBegin4');
      }, () => {
        if (num > 0 && player.hujia && !player.hasSkillTag('nohujia') && !(source && source.hasSkillTag('overHujia', true, {
          name: Evt.card ? Evt.card.name : null,
          target: player,
          card: Evt.card
        }))) {
          if (num >= player.hujia) {
            Evt.hujia = player.hujia;
            num -= player.hujia;
          }
          else {
            Evt.hujia = num;
            num = 0;
          }
          player.changeHujia(-Evt.hujia).type = 'damage';
        }
        Evt.num = num;
        if (num <= 0) {
          Evt.trigger('damageZero');
          delete Evt.filterStop;
          Evt.finish();
          Evt._triggered = null;
        }
        if (num > 0) {
          Evt.trigger('damageHit');
        }
      }, () => {
        if (lib.config.background_audio) {
          game.playAudio('effect', 'damage' + (num > 1 ? '2' : ''));
        }
        game.broadcast(function (num) {
          if (lib.config.background_audio) {
            game.playAudio('effect', 'damage' + (num > 1 ? '2' : ''));
          }
        }, num);
        var str = '受到了';
        if (source) str += '来自<span class="bluetext">' + (source == player ? '自己' : get.translation(source)) + '</span>的';
        str += get.cnNumber(num) + '点';
        if (Evt.nature) str += get.translation(Evt.nature) + '属性';
        str += '伤害';
        game.log(player, str);
        if (player.stat[player.stat.length - 1].damaged == undefined) {
          player.stat[player.stat.length - 1].damaged = num;
        }
        else {
          player.stat[player.stat.length - 1].damaged += num;
        }
        if (source) {
          source.getHistory('sourceDamage').push(Evt);
          if (source.stat[source.stat.length - 1].damage == undefined) {
            source.stat[source.stat.length - 1].damage = num;
          }
          else {
            source.stat[source.stat.length - 1].damage += num;
          }
        }
        player.getHistory('damage').push(Evt);
        if (Evt.notrigger) {
          player.changeHp(-num, false)._triggered = null;
        }
        else {
          player.changeHp(-num, false);
        }
        if (Evt.animate !== false) {
          player.$damage(source);
          game.broadcastAll(function (nature, player) {
            if (lib.config.animation && !lib.config.low_performance) {
              if (nature == 'fire') {
                player.$fire();
              }
              else if (nature == 'thunder') {
                player.$thunder();
              }
            }
          }, Evt.nature, player);
          player.$damagepop(-num, Evt.nature);
        }
        if (!Evt.notrigger) {
          if (num == 0) {
            Evt.trigger('damageZero');
            Evt._triggered = null;
          }
          else {
            Evt.trigger('damage');
          }
        }
      }, () => {
        if (player.hp <= 0 && player.isAlive()) {
          game.delayx();
          player.dying(Evt);
        }
        if (source && lib.config.border_style == 'auto') {
          var dnum = 0;
          for (var j = 0; j < source.stat.length; j++) {
            if (source.stat[j].damage != undefined) dnum += source.stat[j].damage;
          }
          if (dnum >= 2) {
            if (lib.config.autoborder_start == 'silver') {
              dnum += 4;
            }
            else if (lib.config.autoborder_start == 'gold') {
              dnum += 8;
            }
          }
          if (lib.config.autoborder_count == 'damage') {
            source.node.framebg.dataset.decoration = '';
            if (dnum >= 10) {
              source.node.framebg.dataset.auto = 'gold';
              if (dnum >= 12) source.node.framebg.dataset.decoration = 'gold';
            }
            else if (dnum >= 6) {
              source.node.framebg.dataset.auto = 'silver';
              if (dnum >= 8) source.node.framebg.dataset.decoration = 'silver';
            }
            else if (dnum >= 2) {
              source.node.framebg.dataset.auto = 'bronze';
              if (dnum >= 4) source.node.framebg.dataset.decoration = 'bronze';
            }
            if (dnum >= 2) {
              source.classList.add('topcount');
            }
          }
          else if (lib.config.autoborder_count == 'mix') {
            source.node.framebg.dataset.decoration = '';
            switch (source.node.framebg.dataset.auto) {
              case 'bronze': if (dnum >= 4) source.node.framebg.dataset.decoration = 'bronze'; break;
              case 'silver': if (dnum >= 8) source.node.framebg.dataset.decoration = 'silver'; break;
              case 'gold': if (dnum >= 12) source.node.framebg.dataset.decoration = 'gold'; break;
            }
          }
        }
      }, () => {
        if (!Evt.notrigger) Evt.trigger('damageSource');
      }],
      /**
       * 角色回复血量
       * @name content.recover
       * @type {GameCores.Bases.StateMachine}
       */
      recover: function () {
        if (lib.config.background_audio) {
          game.playAudio('effect', 'recover');
        }
        game.broadcast(function () {
          if (lib.config.background_audio) {
            game.playAudio('effect', 'recover');
          }
        });
        if (num > player.maxHp - player.hp) {
          num = player.maxHp - player.hp;
          Evt.num = num;
        }
        if (num > 0) {
          player.changeHp(num, false);
          game.broadcastAll(function (player) {
            if (lib.config.animation && !lib.config.low_performance) {
              player.$recover();
            }
          }, player);
          player.$damagepop(num, 'wood');
          game.log(player, '回复了' + get.cnNumber(num) + '点' + get.translation('hp'));
          Evt.result = num;
        }
        player.getHistory('recover').push(Evt);
      },
      /**
       * 令角色失去血量
       * @name content.loseHp
       * @type {GameCores.Bases.StateMachine}
       */
      loseHp: [() => {
        if (lib.config.background_audio) {
          game.playAudio('effect', 'loseHp');
        }
        game.broadcast(function () {
          if (lib.config.background_audio) {
            game.playAudio('effect', 'loseHp');
          }
        });
        game.log(player, '失去了' + get.cnNumber(num) + '点' + get.translation('hp'))
        player.changeHp(-num);
      }, () => {
        if (player.hp <= 0) {
          game.delayx();
          player.dying(Evt);
        }
      }],
      /**
       * 双将模式下，如果“双将体力设置”选择为“平均值”，因此向下取整体力的角色可以摸一张牌
       * @name content.doubleDraw
       * @type {GameCores.Bases.StateMachine}
       */
      doubleDraw: [() => {
        player.chooseBool('你的主副将体力上限之和是奇数，是否摸一张牌？');
      }, () => {
        if (result.bool) {
          player.draw();
        }
      }],
      /**
       * 令角色减少血量上限
       * @name content.loseMaxHp
       * @type {GameCores.Bases.StateMachine}
       */
      loseMaxHp: [() => {
        game.log(player, '减少了' + get.cnNumber(num) + '点' + get.translation('hp') + '上限');
        player.maxHp -= num;
        Evt.loseHp = Math.max(0, player.hp - player.maxHp);
        player.update();
      }, () => {
        if (player.maxHp <= 0) {
          player.die(Evt);
        }
      }],
      /**
       * 令角色增加血量上限
       * @name content.gainMaxHp
       * @type {GameCores.Bases.StateMachine}
       */
      gainMaxHp: [() => {
        game.log(player, '增加了' + get.cnNumber(num) + '点' + get.translation('hp') + '上限');
        player.maxHp += num;
        player.update();
      }],
      /**
       * 令角色改变血量(不能超过上限)
       * @name content.changeHp
       * @type {GameCores.Bases.StateMachine}
       */
      changeHp: [() => {
        Evt.trigger('changeHpBegin');
      }, () => {
        player.hp += num;
        if (isNaN(player.hp))
          player.hp = 0;
        if (player.hp > player.maxHp)
          player.hp = player.maxHp;
        player.update();
        if (Evt.popup !== false) {
          player.$damagepop(num, 'water');
        }
        //改变体力后立即刷新濒死列表
        if (_status.dying.contains(player) && player.hp > 0) {
          _status.dying.remove(player);
          game.broadcast(function (list) {
            _status.dying = list;
          }, _status.dying);
          var evt = Evt.getParent('_save');
          if (evt && evt.finish)
            evt.finish();
          evt = Evt.getParent('dying');
          if (evt && evt.finish)
            evt.finish();
        }
        Evt.trigger('changeHp');
      }],
      /**
       * 令角色获得/失去护甲
       * @name content.changeHujia
       * @type {GameCores.Bases.StateMachine}
       */
      changeHujia: () => {
        if (lib.config.background_audio) {
          game.playAudio('effect', 'hujia');
        }
        game.broadcast(function () {
          if (lib.config.background_audio) {
            game.playAudio('effect', 'hujia');
          }
        });
        player.hujia += num;
        player.$damagepop((num > 0 ? '+' + num : num), 'gray');
        if (num > 0) {
          game.log(player, '获得了' + get.cnNumber(num) + '点护甲');
        } else if (num < 0) {
          if (Evt.type == 'damage')
            game.log(player, '的护甲抵挡了' + get.cnNumber(-num) + '点伤害');
          else
            game.log(player, '失去了' + get.cnNumber(-num) + '点护甲');
        }
        if (player.hujia < 0) {
          player.hujia = 0;
        }
        player.update();
        player.getHistory('changeHujia').push(Evt);
      },
      /**
       * 角色濒死事件
       * @name content.dying
       * @type {GameCores.Bases.StateMachine}
       */
      dying: [() => {
        Evt.forceDie = true;
        if (player.isDying() || player.hp > 0) {
          Evt.finish();
          return;
        }
        _status.dying.unshift(player);
        game.broadcast(function (list) {
          _status.dying = list;
        }, _status.dying);
        Evt.trigger('dying');
        game.log(player, '濒死');
      }, () => {
        delete Evt.filterStop;
        if (player.hp > 0) {
          _status.dying.remove(player);
          game.broadcast(function (list) {
            _status.dying = list;
          }, _status.dying);
          Evt.finish();
        }
        else if (!Evt.skipTao) {
          var next = game.createEvent('_save');
          var start = false;
          var starts = [_status.currentPhase, Evt.source, Evt.player, game.me, game.players[0]];
          for (var i = 0; i < starts.length; i++) {
            if (get.itemtype(starts[i]) == 'player') {
              start = starts[i]; break;
            }
          }
          next.player = start;
          next._trigger = Evt;
          next.triggername = '_save';
          next.forceDie = true;
          next.setContent(lib.skill._save.content);
        }
      }, () => {
        _status.dying.remove(player);
        game.broadcast(function (list) {
          _status.dying = list;
        }, _status.dying);
        if (player.hp <= 0 && !player.nodying && !(Evt.reason && Evt.reason.nofatal)) player.die(Evt.reason);
      }],
      /**
       * 角色死亡事件
       * @name content.die
       * @type {GameCores.Bases.StateMachine}
       */
      die: [() => {
        Evt.forceDie = true;
        if (_status.roundStart == player) {
          _status.roundStart = player.next || player.getNext() || game.players[0];
        }
        if (ui.land && ui.land.player == player) {
          game.addVideo('destroyLand');
          ui.land.destroy();
        }
        var unseen = false;
        if (player.classList.contains('unseen')) {
          player.classList.remove('unseen');
          unseen = true;
        }
        var logvid = game.logv(player, 'die', source);
        Evt.logvid = logvid;
        if (unseen) {
          player.classList.add('unseen');
        }
        if (source) {
          game.log(player, '被', source, '杀害');
          if (source.stat[source.stat.length - 1].kill == undefined) {
            source.stat[source.stat.length - 1].kill = 1;
          }
          else {
            source.stat[source.stat.length - 1].kill++;
          }
        }
        else {
          game.log(player, '阵亡')
        }


        // player.removeEquipTrigger();

        // for(var i in lib.skill.globalmap){
        //     if(lib.skill.globalmap[i].contains(player)){
        //                  lib.skill.globalmap[i].remove(player);
        //                  if(lib.skill.globalmap[i].length==0&&!lib.skill[i].globalFixed){
        //                               game.removeGlobalSkill(i);
        //                  }
        //     }
        // }

        game.broadcastAll(function (player) {
          player.classList.add('dead');
          player.removeLink();
          player.classList.remove('turnedover');
          player.classList.remove('out');
          player.node.count.innerHTML = '0';
          player.node.hp.hide();
          player.node.equips.hide();
          player.node.count.hide();
          player.previous.next = player.next;
          player.next.previous = player.previous;
          game.players.remove(player);
          game.dead.push(player);
          _status.dying.remove(player);

          if (lib.config.background_speak) {
            if (lib.character[player.name] && lib.character[player.name][4].contains('die_audio')) {
              game.playAudio('die', player.name);
            }
            // else if(true){
            else {
              game.playAudio('die', player.name, function () {
                game.playAudio('die', player.name.slice(player.name.indexOf('_') + 1));
              });
            }
          }
        }, player);

        game.addVideo('diex', player);
        if (Evt.animate !== false) {
          player.$die(source);
        }
        if (player.hp != 0) {
          player.changeHp(0 - player.hp, false).forceDie = true;
        }
      }, () => {
        if (player.dieAfter) player.dieAfter(source);
      }, () => {
        Evt.trigger('die');
      }, () => {
        if (player.isDead()) {
          if (!game.reserveDead) {
            for (var mark in player.marks) {
              player.unmarkSkill(mark);
            }
            while (player.node.marks.childNodes.length > 1) {
              player.node.marks.lastChild.remove();
            }
            game.broadcast(function (player) {
              while (player.node.marks.childNodes.length > 1) {
                player.node.marks.lastChild.remove();
              }
            }, player);
          }
          for (var i in player.tempSkills) {
            player.removeSkill(i);
          }
          var skills = player.getSkills();
          for (var i = 0; i < skills.length; i++) {
            if (lib.skill[skills[i]].temp) {
              player.removeSkill(skills[i]);
            }
          }
          if (_status.characterlist) {
            if (lib.character[player.name]) _status.characterlist.add(player.name);
            if (lib.character[player.name1]) _status.characterlist.add(player.name1);
            if (lib.character[player.name2]) _status.characterlist.add(player.name2);
          }
          Evt.cards = player.getCards('hejs');
          if (Evt.cards.length) {
            player.discard(Evt.cards).forceDie = true;
            //player.$throw(Evt.cards,1000);
          }
        }
      }, () => {
        if (player.dieAfter2) player.dieAfter2(source);
      }, () => {
        game.broadcastAll(function (player) {
          if (game.online && player == game.me && !_status.over && !game.controlOver && !ui.exit) {
            if (lib.mode[lib.configOL.mode].config.dierestart) {
              ui.create.exit();
            }
          }
        }, player);
        if (!_status.connectMode && player == game.me && !_status.over && !game.controlOver) {
          ui.control.show();
          if (get.config('revive') && lib.mode[lib.config.mode].config.revive && !ui.revive) {
            ui.revive = ui.create.control('revive', ui.click.dierevive);
          }
          if (get.config('continue_game') && !ui.continue_game && lib.mode[lib.config.mode].config.continue_game && !_status.brawl && !game.no_continue_game) {
            ui.continue_game = ui.create.control('再战', game.reloadCurrent);
          }
          if (get.config('dierestart') && lib.mode[lib.config.mode].config.dierestart && !ui.restart) {
            ui.restart = ui.create.control('restart', game.reload);
          }
        }

        if (!_status.connectMode && player == game.me && !game.modeSwapPlayer) {
          // _status.auto=false;
          if (ui.auto) {
            // ui.auto.classList.remove('glow');
            ui.auto.hide();
          }
          if (ui.wuxie) ui.wuxie.hide();
        }

        if (typeof _status.coin == 'number' && source && !_status.auto) {
          if (source == game.me || source.isUnderControl()) {
            _status.coin += 10;
          }
        }
        if (source && lib.config.border_style == 'auto' && (lib.config.autoborder_count == 'kill' || lib.config.autoborder_count == 'mix')) {
          switch (source.node.framebg.dataset.auto) {
            case 'gold': case 'silver': source.node.framebg.dataset.auto = 'gold'; break;
            case 'bronze': source.node.framebg.dataset.auto = 'silver'; break;
            default: source.node.framebg.dataset.auto = lib.config.autoborder_start || 'bronze';
          }
          if (lib.config.autoborder_count == 'kill') {
            source.node.framebg.dataset.decoration = source.node.framebg.dataset.auto;
          }
          else {
            var dnum = 0;
            for (var j = 0; j < source.stat.length; j++) {
              if (source.stat[j].damage != undefined) dnum += source.stat[j].damage;
            }
            source.node.framebg.dataset.decoration = '';
            switch (source.node.framebg.dataset.auto) {
              case 'bronze': if (dnum >= 4) source.node.framebg.dataset.decoration = 'bronze'; break;
              case 'silver': if (dnum >= 8) source.node.framebg.dataset.decoration = 'silver'; break;
              case 'gold': if (dnum >= 12) source.node.framebg.dataset.decoration = 'gold'; break;
            }
          }
          source.classList.add('topcount');
        }
      }],
      /**
       * 角色使用装备牌
       * @name content.equip
       * @type {GameCores.Bases.StateMachine}
       */
      equip: [() => {
        console.log(card, cards)
        if (cards) {
          var owner = get.owner(cards[0]);
          if (owner) owner.lose(card, ui.special, 'visible').set('type', 'equip').set('getlx', false);
        }
      }, () => {
        if (Evt.cancelled) {
          Evt.finish();
          return;
        }
        if (cards[0].destroyed) {
          if (player.hasSkill(cards[0].destroyed)) {
            delete cards[0].destroyed;
          }
          else {
            Evt.finish();
            return;
          }
        }
        if (Evt.draw) {
          game.delay(0, 300);
          player.$draw(cards);
        }
        var viewAs = typeof card == 'string' ? card : card.name;
        Evt.viewAs = viewAs;
        if (!lib.card[viewAs]) {
          cards[0].fix();
          cards[0].style.transform = '';
          cards[0].classList.remove('drawinghidden');
          delete cards[0]._transform;
          game.cardsDiscard(cards[0]);
          Evt.finish();
        }
      }, () => {
        game.broadcast(function (player, card, viewAs) {
          if (card.clone && (card.clone.parentNode == player.parentNode || card.clone.parentNode == ui.arena)) {
            card.clone.moveDelete(player);
            game.addVideo('gain2', player, get.cardsInfo([card]));
          }
        }, player, cards[0], Evt.viewAs);
        if (cards[0].clone && (cards[0].clone.parentNode == player.parentNode || cards[0].clone.parentNode == ui.arena)) {
          cards[0].clone.moveDelete(player);
          game.addVideo('gain2', player, get.cardsInfo(cards));
        }
        player.equiping = true;
      }, () => {
        var info = get.info(card, false);
        var current = player.getCards('e', function (card) {
          if (info.customSwap) return info.customSwap(card);
          return get.subtype(card, false) == info.subtype;
        });
        if (current.length) {
          player.lose(current, false, 'visible').set('type', 'equip').set('getlx', false);
          if (info.loseThrow) {
            player.$throw(current);
          }
          Evt.swapped = true;
          Evt.redo();
        }
        if (get.itemtype(card) != 'card') {
          if (typeof card == 'string') cards[0].viewAs = card;
          else cards[0].viewAs = card.name;
        }
        else {
          delete cards[0].viewAs;
        }
      }, () => {
        if (player.isMin() || player.countCards('e', { subtype: get.subtype(Evt.viewAs) })) {
          Evt.finish();
          game.cardsDiscard(cards[0]);
          delete player.equiping;
          return;
        }
        if (lib.config.background_audio) {
          game.playAudio('effect', get.subtype(Evt.viewAs));
        }
        game.broadcast(function (type) {
          if (lib.config.background_audio) {
            game.playAudio('effect', type);
          }
        }, get.subtype(cards[0].viewAs));
        if (cards[0].viewAs && cards[0].viewAs != cards[0].name) {
          player.$equip(cards[0], cards[0].viewAs);
          game.addVideo('equip', player, get.cardInfo(cards[0].viewAs));
          game.log(player, '装备了<span class="yellowtext">' + get.translation(cards[0].viewAs) + '</span>（', cards[0], '）');
        }
        else if (cards[0].originalName && cards[0].originalName != cards[0].name) {
          player.$equip(cards[0]);
          game.addVideo('equip', player, get.cardInfo(cards[0]));
          game.log(player, '装备了', cards[0], '（【' + get.translation(cards[0].originalName) + '】）');
        }
        else {
          player.$equip(cards[0]);
          game.addVideo('equip', player, get.cardInfo(card));
          game.log(player, '装备了', card);
        }
      }, () => {
        var info = get.info(card, false);
        if (info.onEquip && (!info.filterEquip || info.filterEquip(card, player))) {
          if (Array.isArray(info.onEquip)) {
            for (var i = 0; i < info.onEquip.length; i++) {
              var next = game.createEvent('equip_' + card.name);
              next.setContent(info.onEquip[i]);
              next.player = player;
              next.card = card;
            }
          }
          else {
            var next = game.createEvent('equip_' + card.name);
            next.setContent(info.onEquip);
            next.player = player;
            next.card = card;
          }
          if (info.equipDelay != 'false') game.delayx();
        }
        delete player.equiping;
        if (Evt.delay) {
          game.delayx();
        }
      }],
      /**
       * 角色添加判定牌
       * @name content.addJudge
       * @type {GameCores.Bases.StateMachine}
       */
      addJudge: [() => {
        if (cards) {
          var owner = get.owner(cards[0]);
          if (owner) {
            Evt.relatedLose = owner.lose(cards, 'visible').set('getlx', false);
          }
        }
      }, () => {
        if (cards[0].destroyed) {
          if (player.hasSkill(cards[0].destroyed)) {
            delete cards[0].destroyed;
          }
          else {
            Evt.finish();
            return;
          }
        }
        cards[0].fix();
        cards[0].style.transform = '';
        cards[0].classList.remove('drawinghidden');
        delete cards[0]._transform;
        var viewAs = typeof card == 'string' ? card : card.name;
        if (!lib.card[viewAs] || !lib.card[viewAs].effect) {
          game.cardsDiscard(cards[0]);
        }
        else {
          cards[0].style.transform = '';
          cards[0].classList.add('drawinghidden');
          player.node.judges.insertBefore(cards[0], player.node.judges.firstChild);
          if (_status.discarded) {
            _status.discarded.remove(cards[0]);
          }
          ui.updatej(player);
          game.broadcast(function (player, card, viewAs) {
            card.fix();
            card.style.transform = '';
            card.classList.add('drawinghidden');
            card.viewAs = viewAs;
            if (viewAs && viewAs != card.name && (card.classList.contains('fullskin') || card.classList.contains('fullborder'))) {
              card.classList.add('fakejudge');
              card.node.background.innerHTML = lib.translate[viewAs + '_bg'] || get.translation(viewAs)[0]
            }
            else {
              card.classList.remove('fakejudge');
            }
            player.node.judges.insertBefore(card, player.node.judges.firstChild);
            ui.updatej(player);
            if (card.clone && (card.clone.parentNode == player.parentNode || card.clone.parentNode == ui.arena)) {
              card.clone.moveDelete(player);
              game.addVideo('gain2', player, get.cardsInfo([card]));
            }
          }, player, cards[0], viewAs);
          if (cards[0].clone && (cards[0].clone.parentNode == player.parentNode || cards[0].clone.parentNode == ui.arena)) {
            cards[0].clone.moveDelete(player);
            game.addVideo('gain2', player, get.cardsInfo(cards));
          }
          // player.$gain2(cards);
          if (get.itemtype(card) != 'card') {
            if (typeof card == 'string') cards[0].viewAs = card;
            else cards[0].viewAs = card.name;
          }
          else {
            delete cards[0].viewAs;
          }
          if (cards[0].viewAs && cards[0].viewAs != cards[0].name) {
            if (cards[0].classList.contains('fullskin') || cards[0].classList.contains('fullborder')) {
              cards[0].classList.add('fakejudge');
              cards[0].node.background.innerHTML = lib.translate[cards[0].viewAs + '_bg'] || get.translation(cards[0].viewAs)[0];
            }
            //姑且改成了取单牌的形式，以后需要叠多张牌的时候再改回来
            game.log(player, '被贴上了<span class="yellowtext">' + get.translation(cards[0].viewAs) + '</span>（', cards[0], '）');
          }
          else {
            cards[0].classList.remove('fakejudge');
            game.log(player, '被贴上了', cards);
          }
          game.addVideo('addJudge', player, [get.cardInfo(cards[0]), cards[0].viewAs]);
        }
      }],
      /**
       * 角色进行判定
       * @name content.judge
       * @type {GameCores.Bases.StateMachine}
       * @property {!Object} Evt 本事件
       * @property {!Object} Evt.result 将判定牌信息返回给父事件
       */
      judge: [() => {
        var judgestr = get.translation(player) + '的' + Evt.judgestr + '判定';
        Evt.videoId = lib.status.videoId++;
        var cardj = Evt.directresult;
        if (!cardj) {
          if (player.getTopCards) cardj = player.getTopCards()[0];
          else cardj = get.cards()[0];
        }
        var nextj = game.cardsGotoOrdering(cardj);
        if (Evt.position != ui.discardPile) nextj.noOrdering = true;
        player.judging.unshift(cardj);
        game.addVideo('judge1', player, [get.cardInfo(player.judging[0]), judgestr, Evt.videoId]);
        game.broadcastAll(function (player, card, str, id, cardid) {
          var Evt;
          if (game.online) {
            Evt = {};
          }
          else {
            Evt = _status.event;
          }
          if (game.chess) {
            Evt.node = card.copy('thrown', 'center', ui.arena).animate('start');
          }
          else {
            Evt.node = player.$throwordered(card.copy(), true);
          }
          if (lib.cardOL) lib.cardOL[cardid] = Evt.node;
          Evt.node.cardid = cardid;
          Evt.node.classList.add('thrownhighlight');
          ui.arena.classList.add('thrownhighlight');
          Evt.dialog = ui.create.dialog(str);
          Evt.dialog.classList.add('center');
          Evt.dialog.videoId = id;
        }, player, player.judging[0], judgestr, Evt.videoId, get.id());

        game.log(player, '进行' + Evt.judgestr + '判定，亮出的判定牌为', player.judging[0]);
        game.delay(2);
        if (!Evt.noJudgeTrigger) Evt.trigger('judge');
      }, () => {
        Evt.result = {
          card: player.judging[0],
          name: player.judging[0].name,
          number: get.number(player.judging[0]),
          suit: get.suit(player.judging[0]),
          color: get.color(player.judging[0]),
          node: Evt.node,
        };
        if (Evt.fixedResult) {
          for (var i in Evt.fixedResult) {
            Evt.result[i] = Evt.fixedResult[i];
          }
        }
        Evt.result.judge = Evt.judge(Evt.result);
        if (Evt.result.judge > 0) Evt.result.bool = true;
        else if (Evt.result.judge < 0) Evt.result.bool = false;
        else Evt.result.bool = null;
        player.judging.shift();
        game.checkMod(player, Evt.result, 'judge', player);
        if (Evt.result.bool == true) {
          player.popup('洗具');
        }
        else if (Evt.result.bool == false) {
          player.popup('杯具');
        }
        if (Evt.clearArena != false) {
          game.broadcastAll(ui.clear);
        }
        game.broadcast(function (id) {
          var dialog = get.idDialog(id);
          if (dialog) {
            dialog.close();
          }
          ui.arena.classList.remove('thrownhighlight');
        }, Evt.videoId);
        Evt.dialog.close();
        game.addVideo('judge2', null, Evt.videoId);
        ui.arena.classList.remove('thrownhighlight');
        game.log(player, '的判定结果为', Evt.result.card);
        if (Evt.callback) {
          var next = game.createEvent('judgeCallback', false);
          next.player = player;
          next.card = Evt.result.card;
          next.judgeResult = get.copy(Evt.result);
          next.setContent(Evt.callback);
        }
        else {
          if (!get.owner(Evt.result.card)) {
            if (Evt.position != ui.discardPile) Evt.position.appendChild(Evt.result.card);
          }
        }
        player.getHistory('judge').push(Evt);
      }],
      /**
       * 角色武将牌翻面
       * @name content.turnOver
       * @type {GameCores.Bases.StateMachine}
       */
      turnOver: function () {
        game.log(player, '翻面');
        player.classList.toggle('turnedover');
        game.broadcast(function (player) {
          player.classList.toggle('turnedover');
        }, player);
        game.addVideo('turnOver', player, player.classList.contains('turnedover'));
      },
      /**
       * 角色连环/解除连环
       * @name content.link
       * @type {GameCores.Bases.StateMachine}
       */
      link: function () {
        if (player.isLinked()) {
          game.log(player, '解除连环');
        }
        else {
          game.log(player, '被连环');
        }
        if (lib.config.background_audio) {
          game.playAudio('effect', 'link');
        }
        game.broadcast(function () {
          if (lib.config.background_audio) {
            game.playAudio('effect', 'link');
          }
        });
        player.classList.remove('target');
        if (get.is.linked2(player)) {
          player.classList.toggle('linked2');
        }
        else {
          player.classList.toggle('linked');
        }
        ui.updatej(player);
        ui.updatem(player);
        game.broadcast(function (player, linked) {
          player.classList.remove('target');
          if (get.is.linked2(player)) {
            if (linked) {
              player.classList.add('linked2');
            }
            else {
              player.classList.remove('linked2');
            }
          }
          else {
            if (linked) {
              player.classList.add('linked');
            }
            else {
              player.classList.remove('linked');
            }
          }
          ui.updatej(player);
          ui.updatem(player);
        }, player, player.isLinked());
        game.addVideo('link', player, player.isLinked());
      },
      chooseToGuanxing: [() => {
        var cards = get.cards(num);
        game.cardsGotoOrdering(cards);
        var next = player.chooseToMove();
        next.set('list', [
          ['牌堆顶', cards],
          ['牌堆底'],
        ]);
        next.set('prompt', '点击将牌移动到牌堆顶或牌堆底');
        next.processAI = event.processAI || function (list) {
          var cards = list[0][1], player = _status.event.player;
          var top = [];
          var bottom;
          cards.sort(function (a, b) {
            return get.value(b, player) - get.value(a, player);
          });
          while (cards.length) {
            if (get.value(cards[0], player) <= 5) break;
            top.unshift(cards.shift());
          }
          bottom = cards;
          return [top, bottom];
        }
      }, () => {
        var top = result.moved[0];
        var bottom = result.moved[1];
        top.reverse();
        for (var i = 0; i < top.length; i++) {
          ui.cardPile.insertBefore(top[i], ui.cardPile.firstChild);
        }
        for (i = 0; i < bottom.length; i++) {
          ui.cardPile.appendChild(bottom[i]);
        }
        player.popup(get.cnNumber(top.length) + '上' + get.cnNumber(bottom.length) + '下');
        game.log(player, '将' + get.cnNumber(top.length) + '张牌置于牌堆顶');
        game.updateRoundNumber();
        game.delayx();
      }],
    },
    /**
     * 玩家方法，.player节点共用的方法（比如展示牌【showCard】）
     * 角色
     * @namespace
     * @mixin
     */
    player: {
      /**
       * 检测本角色武将牌周围是否有牌
       */
      hasCardAround: function () {
        let cards = [];
        let skills = this.getSkills(true, false, false);
        game.expandSkills(skills);
        for (let i of skills) {
          if (lib.skill[i] && lib.skill[i].cardAround) {
            let key = [];
            let storage = this.getStorage(i);
            let method = lib.skill[i].cardAround;
            if (Array.isArray(method)) {
              for (let j of method) key = key.concat(storage[j]);
            }
            else if (typeof method == 'function') {
              key = key.concat(method(this));
            }
            else if (Array.isArray(storage)) key = key.concat(storage);
            else key.push(storage);
            cards.addArray(key);
          }
        }
        if (cards.length) return cards;
        return false;
      },
      isYingV: function () {
        var info = lib.character[this.name || this.name1];
        if (info && info[4]) {
          if (info[4].contains('yingV')) return true;
        }
      },
      isGuoV: function () {
        var info = lib.character[this.name || this.name1];
        if (info && info[4]) {
          if (info[4].contains('guoV')) return true;
        }
      },
      /**
       * 将一张牌置入本角色的判定区
       */
      addToJudge: function (card, source) {
        let cards = (get.itemtype(card) == 'card') ? [card] : card;
        if (source) source.$give(cards, this, false);
        if (get.type(cards[0]) == 'delay') this.addJudge(cards[0]);
        else if (get.color(cards[0]) == 'red' && this.canAddJudge('lebu')) this.addJudge({ name: 'lebu' }, cards);
        else if (get.color(cards[0]) == 'black' && this.canAddJudge('bingliang')) this.addJudge({ name: 'bingliang' }, cards);
      },
      /**
       * 判断一张牌能否本角色的判定区
       */
      canAddToJudge: function (card) {
        if (get.type(card) == 'delay') return this.canAddJudge(card);
        if (this.canAddJudge('lebu') && get.color(card) == 'red') return true
        if (this.canAddJudge('bingliang') && get.color(card) == 'black') return true
        return false;
      },
      //自创函数(升阶相关)
      choosePromotion: function (...args) {
        let next = game.createEvent('choosePromotion');
        next.player = this;
        for (let i of args) {
          if (get.itemtype(i) == 'cards') next.materials = i;
          else if (typeof i == 'boolean') next.forced = i;
          else if (typeof i == 'string') next.prompt = i;
          else if (get.itemtype(i) == 'select' || typeof i == 'number') next.select = i;
          else if (typeof i == 'function') next.filterProduct = i;
          else if (typeof i == 'function') next.filterMaterial = i;
        }
        if (!this.canPromotion.apply(this, arguments)) return;
        if (next.prompt == undefined) next.prompt = '「普通升阶」（每个出牌阶段限一次）<br>请选择升阶获得的卡牌';
        if (next.select == undefined) next.select = [1, Infinity];
        next.setContent('choosePromotion');
        return next;
      },
      canPromotion: function (...args) {
        if (lib.configOL.protect_beginner) return false;
        let list = [];
        if (!lib.cardPack.mode_derivation || !lib.cardPack.mode_derivation.length) return false;
        for (var i = 0; i < lib.cardPack.mode_derivation.length; i++) {
          var info = lib.card[lib.cardPack.mode_derivation[i]];
          if (info && info.materials && (typeof info.materials == 'function' || Array.isArray(info.materials))) list.push(lib.cardPack.mode_derivation[i]);
        }
        let materials, select, filterProduct, bool = false;
        for (let i of args) {
          if (get.itemtype(i) == 'cards') materials = i;
          else if (get.itemtype(i) == 'select' || typeof i == 'number') select = i;
          else if (typeof i == 'function') filterProduct = i;
        }
        if (filterProduct) list = list.filter(filterProduct);
        if (!materials || !list.length) return false;
        if (select == undefined) select = [1, Infinity];
        let materialList = [];
        let cards = materials.slice(0);
        let l = cards.length;
        let all = Math.pow(l, 2);
        for (let i = 1; i < all; i++) {
          let array = [];
          for (let j = 0; j < l; j++) {
            if (Math.floor((i % Math.pow(2, j + 1)) / Math.pow(2, j)) > 0) array.push(cards[j])
          }
          if ((get.itemtype(select) == 'select' && array.length >= select[0] && array.length <= select[1])
            || (typeof select == 'number' && array.length == select)) materialList.push(array);
        }
        for (let j of materialList) {
          for (let k of list) {
            let filter = get.info({ name: k }).materials;
            if (Array.isArray(filter) && filter.length == j.length) {
              let mate = filter.slice(0);
              for (let l = 0; l < mate.length; l++) {
                for (let card of j) {
                  if (get.is.filterCardBy(card, mate[l])) {
                    mate.splice(l--, 1);
                  }
                }
              }
              if (mate.length == 0) {
                bool = true;
              }
            }
            if (typeof filter == 'function') {
              bool = filter(j);
            }
          }
        }
        return bool;
      },
      //新函数
      /**
       * 将技能移入本角色的封锁列表
       */
      addSkillBlocker: function (skill) {
        if (!this.storage.skill_blocker) this.storage.skill_blocker = [];
        this.storage.skill_blocker.push(skill);
      },
      /**
       * 将技能移出本角色的封锁列表
       */
      removeSkillBlocker: function (skill) {
        if (this.storage.skill_blocker) {
          this.storage.skill_blocker.remove(skill);
          if (!this.storage.skill_blocker.length) delete this.storage.skill_blocker;
        }
      },
      /**
       * 将本角色的卡牌移入(目标角色)特殊区
       */
      loseToSpecial: function (cards, tag, target) {
        var next = game.loseAsync({
          player: this,
          cards: cards,
          tag: tag,
          toStorage: true,
          target: target || this,
        });
        next.setContent([() => {
          player.lose(cards, ui.special).set('getlx', false);
        }, () => {
          target.directgains(cards, null, Evt.tag)
        }]);
        return next;
      },
      /**
       * 为本角色的手牌添加标签
       */
      addGaintag: function (cards, tag) {
        if (get.itemtype(cards) == 'card') cards = [cards];
        game.addVideo('addGaintag', this, [get.cardsInfo(cards), tag]);
        game.broadcastAll(function (player, cards, tag) {
          var hs = player.getCards('h');
          for (var i of cards) {
            if (hs.contains(i)) i.addGaintag(tag);
          }
        }, this, cards, tag);
      },
      /**
       * 为本角色手牌移除标签
       */
      removeGaintag: function (tag, cards) {
        game.addVideo('removeGaintag', this, tag);
        game.broadcastAll(function (player, tag, cards) {
          cards = cards || player.getCards('h');
          for (var i of cards) i.removeGaintag(tag);
        }, this, tag, cards);
      },
      /**
       * 判断本角色能否在濒死求桃事件中救治目标角色
       * @param {string} target 目标角色
       * @returns {!boolean} 可以救治返回`true`，不可以返回`false`
       */
      canSave: function (target) {
        var player = this;
        if (player.hasSkillTag('save', true, target, true)) return true;
        var name = {}, hs = player.getCards('hs');
        for (var i of hs) name[get.name(i)] = true;
        for (var i in lib.card) {
          if (lib.card[i].savable && (lib.inpile.contains(i) || name[i])) {
            if (lib.filter.cardSavable({ name: i }, player, target) && (_status.connectMode || player.hasUsableCard(i))) return true;
          }
        }
        return false;
      },
      /**
       * 展示本角色
       * @param {(0|1|2)} num 0:展示主将; 1: 展示副将; 2: 全部展示
       * @param {?boolean} [log] 如果为true或未指定，输出日志；如果为false，不输出日志
       * @returns {GameCores.Bases.Event}
       */
      showCharacter: function (num, log) {
        var toShow = [];
        if ((num == 0 || num == 2) && this.isUnseen(0)) toShow.add(this.name1);
        if ((num == 1 || num == 2) && this.isUnseen(1)) toShow.add(this.name2);
        if (!toShow.length) return;
        lib.element.player.$showCharacter.apply(this, arguments);
        var next = game.createEvent('showCharacter', false);
        next.player = this;
        next.num = num;
        next.toShow = toShow;
        next._args = arguments;
        next.setContent('showCharacter');
        return next;
      },
      /**
       * 展示本角色(无事件)
       * @param {(0|1|2)} num 0:展示主将; 1: 展示副将; 2: 全部展示
       * @param {?boolean} [log] 如果为true或未指定，输出日志；如果为false，不输出日志
       */
      $showCharacter: function (num, log) {
        if (num == 0 && !this.isUnseen(0)) {
          return;
        }
        if (num == 1 && (!this.name2 || !this.isUnseen(1))) {
          return;
        }
        if (!this.isUnseen(2)) {
          return;
        }
        game.addVideo('showCharacter', this, num);
        var skills;
        switch (num) {
          case 0:
            if (log !== false) game.log(this, '展示了主将', '#b' + this.name1);
            this.name = this.name1;
            skills = lib.character[this.name][3] || [];
            this.sex = lib.character[this.name][0];
            if (this.group == 'unknown') this.group = lib.character[this.name][1];
            this.classList.remove('unseen');
            break;
          case 1:
            if (log !== false) game.log(this, '展示了副将', '#b' + this.name2);
            skills = lib.character[this.name2][3] || [];
            if (this.sex == 'unknown') this.sex = lib.character[this.name2][0];
            if (this.name.indexOf('unknown') == 0) this.name = this.name2;
            this.classList.remove('unseen2');
            break;
          case 2:
            if (log !== false) {
              if (this.name2) game.log(this, '展示了主将', '#b' + this.name1, '、副将', '#b' + this.name2);
              else game.log(this, '展示了主将', '#b' + this.name1);
            }
            this.name = this.name1;
            var skills = (lib.character[this.name][3] || []);
            if (this.name2) skills = skills.concat(lib.character[this.name2][3] || []);
            this.sex = lib.character[this.name][0];
            if (this.group == 'unknown') this.group = lib.character[this.name][1];
            this.classList.remove('unseen');
            this.classList.remove('unseen2');
            break;
        }
        if (!this.isUnseen(2)) {
          delete this.storage.nohp;
          this.hp = this.storage.rawHp + this.maxHp - 1;
          this.maxHp = this.storage.rawMaxHp + this.maxHp - 1;
          this.node.hp.show();
          this.update();
        }
        game.broadcast(function (player, name, sex, num, group) {
          player.group = group;
          player.name = name;
          player.sex = sex;
          switch (num) {
            case 0: player.classList.remove('unseen'); break;
            case 1: player.classList.remove('unseen2'); break;
            case 2: player.classList.remove('unseen'); player.classList.remove('unseen2'); break;
          }
          if (!player.isUnseen(2)) {
            delete player.$.nohp;
            player.node.hp.show();
            player.update();
          }
        }, this, this.name, this.sex, num, this.group);
        for (var i = 0; i < skills.length; i++) {
          if (this.hiddenSkills.contains(skills[i])) {
            this.hiddenSkills.remove(skills[i]);
            this.addSkill(skills[i]);
          }
        }
        this.checkConflict();
      },
      /**
       * 演奏音符
       * 本角色演奏音符
       * @returns {GameCores.Bases.Event}
       */
      chooseToPlayBeatmap: function (beatmap) {
        var next = game.createEvent('chooseToPlayBeatmap');
        next.player = this;
        next.beatmap = beatmap;
        next._args = Array.from(arguments);
        next.setContent('chooseToPlayBeatmap');
        return next;
      },
      /**
       * 移动牌
       * 本角色牌堆顶、牌堆底、各区域之间移动牌
       * @returns {GameCores.Bases.Event}
       */
      chooseToMove: function () {
        var next = game.createEvent('chooseToMove');
        next.player = this;
        for (var i = 0; i < arguments.length; i++) {
          if (typeof arguments[i] == 'boolean') {
            next.forced = arguments[i];
          }
          else if (typeof arguments[i] == 'string') {
            next.prompt = arguments[i];
          }
        }
        next.setContent('chooseToMove');
        next.filterOk = function () { return true };
        next.filterMove = function () { return true };
        return next;
      },
      /**
       * 观星
       * 本角色观看牌堆顶的`num`张牌并将其以任意顺序置于牌堆顶或牌堆底
       * @param {number} num
       * @returns {GameCores.Bases.Event}
       */
      chooseToGuanxing: function (num) {
        var next = game.createEvent('chooseToGuanxing');
        next.num = num || 1;
        next.player = this;
        next.setContent('chooseToGuanxing');
        return next;
      },
      /**
       * 向其他角色发送互动表情(本机)
       * @param {!GameCores.GameObjects.Player} 互动的对象
       * @param {!string} emotion 表情
       */
      $throwEmotion: function (target, name) {
        game.addVideo('throwEmotion', this, [target.dataset.position, name]);
        var getLeft = function (player) {
          if (player == game.me && !ui.fakeme && !ui.chess) return player.getLeft() + player.node.avatar.offsetWidth / 2;
          return player.getLeft() + player.offsetWidth / 2;
        }
        var player = this;
        var emotion = ui.create.div('', '<div style="text-align:center"> <img src="' + lib.assetURL + 'image/emotion/throw_emotion/' + name + '1.png"> </div>', game.chess ? ui.chess : ui.window);
        emotion.style.width = '60px';
        emotion.style.height = '60px';
        var width = emotion.offsetWidth / 2;
        var height = emotion.offsetHeight / 2;
        if (game.chess) width += 60;
        var left = getLeft(player) - width;
        var top = player.getTop() + player.offsetHeight / 3 - height;
        emotion.style.left = left + 'px';
        emotion.style.top = top + 'px';
        var left2 = getLeft(target) - width;
        var top2 = target.getTop() + target.offsetHeight / 3 - height;
        emotion.style['z-index'] = 10;
        emotion.style.transform = 'translateY(' + (top2 - top) + 'px) translateX(' + (left2 - left) + 'px)';
        if (lib.config.background_audio) game.playAudio('effect', 'throw_' + name + get.rand(1, 2));
        setTimeout(function () {
          emotion.innerHTML = ('<div style="text-align:center"> <img src="' + lib.assetURL + 'image/emotion/throw_emotion/' + name + '2.png"> </div>');
          setTimeout(function () {
            emotion.delete();
          }, 1200);
        }, 600);
      },
      /**
       * 本角色尝试播放一个技能动画[support online]
       * @param {string} name 技能名
       * @param {string} popname 弹出的名称，如果`popname`等于`name`，使用`get.skillTranslation(name, this)`作为弹出的名称
       * @param {?boolean} [checkShow]
       */
      trySkillAnimate: function (name, popname, checkShow) {
        if (!game.online && lib.config.skill_animation_type != 'off' && lib.skill[name] && lib.skill[name].skillAnimation) {
          if (lib.config.skill_animation_type == 'default') {
            checkShow = checkShow || 'main';
          }
          else {
            checkShow = false;
          }
          if (lib.skill[name].textAnimation) {
            checkShow = false;
          }
          this.$skill(lib.skill[name].animationStr || lib.translate[name], lib.skill[name].skillAnimation, lib.skill[name].animationColor, checkShow);
          return;
        }
        var player = this;
        game.broadcast(function (player, name, popname) {
          player.trySkillAnimate(name, popname);
        }, player, name, popname);
        if (lib.animate.skill[name]) lib.animate.skill[name].apply(this, arguments);
        else {
          if (popname != name) this.popup(popname, 'water', false);
          else this.popup(get.skillTranslation(name, this), 'water', false);
        }
      },
      /**
       * 本角色尝试播放一个游戏牌动画[support online]
       * @param {!GameCores.GameObjects.Card} card
       * @param {string} name 游戏牌名
       * @param {string} nature 属性
       * @param {?string} [popname] 弹出的名称，如果未指定，使用`name`作为弹出的名称
       */
      tryCardAnimate: function (card, name, nature, popname) {
        var player = this;
        game.broadcast(function (player, card, name, nature, popname) {
          player.tryCardAnimate(card, name, nature, popname);
        }, player, card, name, nature, popname);
        if (lib.animate.card[card.name]) lib.animate.card[card.name].apply(this, arguments);
        else {
          if (!lib.config.show_card_prompt) return;
          if (get.type(card) == 'equip' && lib.config.hide_card_prompt_equip) return;
          if (get.type(card) == 'basic' && lib.config.hide_card_prompt_basic) return;
          if (popname) player.popup({ name: card.name, nature: card.nature }, nature, false);
          else player.popup(name, nature, false);
        }
      },
      hasUsableCard: function (name) {
        var player = this;
        if (player.countCards('hs', name)) return true;
        var skills = player.getSkills(true).concat(lib.skill.global);
        game.expandSkills(skills);
        for (var i = 0; i < skills.length; i++) {
          var ifo = get.info(skills[i]);
          if (ifo.viewAs && typeof ifo.viewAs != 'function' && ifo.viewAs.name == name) {
            if (!ifo.viewAsFilter || ifo.viewAsFilter(player)) {
              return true;
            }
          }
          else {
            var hiddenCard = get.info(skills[i]).hiddenCard;
            if (typeof hiddenCard == 'function' && hiddenCard(player, name)) {
              return true;
            }
          }
        }
      },
      /**
       * 判断目标角色是否在本角色的攻击范围内
       * @param {string} to 目标角色
       * @returns {!boolean} 在范围内返回`true`，在范围外返回`false`
       */
      inRange: function (to) {
        var from = this;
        if (from == to || from.hasSkill('undist') || to.hasSkill('undist')) return false;
        if (!game.players.contains(from) && !game.dead.contains(from)) return false;
        if (!game.players.contains(to) && !game.dead.contains(to)) return false;
        var mod1 = game.checkMod(from, to, 'unchanged', 'inRange', from);
        if (mod1 != 'unchanged') return mod1;
        var mod2 = game.checkMod(from, to, 'unchanged', 'inRangeOf', to);
        if (mod2 != 'unchanged') return mod2;
        if (from.getAttackRange() < 1) return false;
        var player = from, m, n = 1, i;
        var fxy, txy;
        if (game.chess) {
          fxy = from.getXY();
          txy = to.getXY();
          n = Math.abs(fxy[0] - txy[0]) + Math.abs(fxy[1] - txy[1]);
        }
        else if (to.isMin(true) || from.isMin(true)) { }
        else {
          var length = game.players.length;
          var totalPopulation = game.players.length + game.dead.length + 1;
          for (var iwhile = 0; iwhile < totalPopulation; iwhile++) {
            if (player.nextSeat != to) {
              player = player.nextSeat;
              if (player.isAlive() && !player.isOut() && !player.hasSkill('undist') && !player.isMin(true)) n++;
            }
            else {
              break;
            }
          }
          for (i = 0; i < game.players.length; i++) {
            if (game.players[i].isOut() || game.players[i].hasSkill('undist') || game.players[i].isMin(true)) length--;
          }
          if (from.isDead()) length++;
          if (to.isDead()) length++;
          var left = from.hasSkillTag('left_hand');
          var right = from.hasSkillTag('right_hand');
          if (left === right) n = Math.min(n, length - n);
          else if (left == true) n = length - n;
        }
        n = game.checkMod(from, to, n, 'globalFrom', from);
        n = game.checkMod(from, to, n, 'globalTo', to);
        m = n;
        m = game.checkMod(from, to, m, 'attackFrom', from);
        m = game.checkMod(from, to, m, 'attackTo', to);
        var equips1 = from.getCards('e', function (card) {
          return !ui.selected.cards || !ui.selected.cards.contains(card);
        }), equips2 = to.getCards('e', function (card) {
          return !ui.selected.cards || !ui.selected.cards.contains(card);
        });
        for (i = 0; i < equips1.length; i++) {
          var info = get.info(equips1[i]).distance;
          if (!info) continue;
          if (info.globalFrom) {
            m += info.globalFrom;
            n += info.globalFrom;
          }
          if (info.attackFrom) {
            m += info.attackFrom;
          }
        }
        for (i = 0; i < equips2.length; i++) {
          var info = get.info(equips2[i]).distance;
          if (!info) continue;
          if (info.globalTo) {
            m += info.globalTo;
            n += info.globalTo;
          }
          if (info.attaclTo) {
            m += info.attaclTo;
          }
        }
        return m <= 1;
      },
      /**
       * 判断本角色是否在目标角色的攻击范围内
       * @param {string} source 目标角色
       * @returns {!boolean} 在范围内返回`true`，在范围外返回`false`
       */
      inRangeOf: function (source) {
        return source.inRange(this);
      },
      /**
       * 获得本角色已损失的体力值
       * @returns {!number} this.maxHp - Math.max(0, this.hp)
       */
      getDamagedHp: function () {
        return this.maxHp - Math.max(0, this.hp);
      },
      changeGroup: function (group, log, broadcast) {
        var player = this;
        if (broadcast !== false) {
          game.broadcast(function (player, group) {
            player.group = group;
            player.node.name.dataset.nature = get.groupnature(group);
          }, player, group);
        }
        player.group = group;
        player.node.name.dataset.nature = get.groupnature(group);
        if (log !== false) game.log(this, '将势力变为了', '#y' + get.translation(group + 2));
      },
      chooseToDuiben: function (target) {
        var next = game.createEvent('chooseToDuiben');
        next.player = this;
        next.target = target;
        next.setContent('chooseToDuiben');
        return next;
      },
      chooseToPSS: function (target) {
        var next = game.createEvent('chooseToPSS');
        next.player = this;
        next.target = target;
        next.setContent('chooseToPSS');
        return next;
      },
      chooseToEnable: function () {
        var next = game.createEvent('chooseToEnable');
        next.player = this;
        next.setContent('chooseToEnable');
        return next;
      },
      chooseToDisable: function (horse) {
        var next = game.createEvent('chooseToDisable');
        next.player = this;
        if (horse) next.horse = true;
        next.setContent('chooseToDisable');
        return next;
      },
      countDisabled: function () {
        if (!this.storage.disableEquip) return 0;
        return this.storage.disableEquip.length;
      },
      isPhaseUsing: function (notmeisok) {
        if (!notmeisok && _status.currentPhase != this) return false;
        return _status.event.name == 'phaseUse' || _status.event.getParent('phaseUse').name == 'phaseUse';
      },
      swapEquip: function (target, subtype) {
        var next = game.createEvent('swapEquip');
        next.player = this;
        next.target = target;
        next.subtype = subtype;
        next.setContent('swapEquip');
        return next;
      },
      canCompare: function (target) {
        if (this == target) return false;
        if (!this.countCards('h') || !target.countCards('h')) return false;
        if (this.hasSkillTag('noCompareSource') || target.hasSkillTag('noCompareTarget')) return false;
        return true;
      },
      disableEquip: function (pos) {
        if (typeof pos == 'number') pos = 'equip' + pos;
        var next = game.createEvent('disableEquip');
        next.player = this;
        next.pos = pos;
        next.source = _status.event.player;
        next.setContent('disableEquip');
        return next;
      },
      $disableEquip: function (skill) {
        game.broadcast(function (player, skill) {
          player.$disableEquip(skill);
        }, this, skill);
        var player = this;
        if (!player.$.disableEquip) player.$.disableEquip = [];
        player.$.disableEquip.add(skill);
        player.$.disableEquip.sort();
        var pos = { equip1: '武器栏', equip2: '防具栏', equip3: '+1马栏', equip4: '-1马栏', equip5: '宝物栏' }[skill];
        if (!pos) return;
        var card = game.createCard('feichu_' + skill, pos, '');
        card.fix();
        card.style.transform = '';
        card.classList.remove('drawinghidden');
        card.classList.add('feichu');
        delete card._transform;
        var equipNum = get.equipNum(card);
        var equipped = false;
        for (var i = 0; i < player.node.equips.childNodes.length; i++) {
          if (get.equipNum(player.node.equips.childNodes[i]) >= equipNum) {
            player.node.equips.insertBefore(card, player.node.equips.childNodes[i]);
            equipped = true;
            break;
          }
        }
        if (!equipped) {
          player.node.equips.appendChild(card);
          if (_status.discarded) {
            _status.discarded.remove(card);
          }
        }
        return player;
      },
      enableEquip: function (pos) {
        if (typeof pos == 'number') pos = 'equip' + pos;
        var next = game.createEvent('enableEquip');
        next.player = this;
        next.pos = pos;
        next.source = _status.event.player;
        next.setContent('enableEquip');
        return next;
      },
      $enableEquip: function (skill) {
        game.broadcast(function (player, skill) {
          player.$enableEquip(skill);
        }, this, skill);
        var player = this;
        if (player.$.disableEquip) player.$.disableEquip.remove(skill);
        for (var i = 0; i < player.node.equips.childNodes.length; i++) {
          if (player.node.equips.childNodes[i].name == 'feichu_' + skill) {
            player.node.equips.removeChild(player.node.equips.childNodes[i]);
            break;
          }
        }
        return player;
      },
      isDisabled: function (arg) {
        if (typeof arg == 'number') arg = 'equip' + arg;
        if (arg == 'equip6' && this.storage.disableEquip && (this.storage.disableEquip.contains('equip3') || this.storage.disableEquip.contains('equip4'))) return true;
        if (this.storage.disableEquip && this.storage.disableEquip.contains(arg)) return true;
        return false;
      },
      isEmpty: function (num) {
        if (num == 6 || num == 'equip6') {
          if (!this.isEmpty(3) || !this.isEmpty(4)) return false;
        }
        else if ([3, 4, 'equip3', 'equip4'].contains(num)) {
          if (this.getEquip(6)) return false;
        }
        return !this.isDisabled(num) && !this.getEquip(num);
      },
      $disableJudge: function () {
        var player = this;
        var card = game.createCard('disable_judge', '', '');
        player.$._disableJudge = true;
        card.fix();
        card.classList.add('feichu');
        card.style.transform = '';
        card.classList.add('drawinghidden');
        player.node.judges.insertBefore(card, player.node.judges.firstChild);
        ui.updatej(player);
      },
      $enableJudge: function () {
        var player = this;
        player.$._disableJudge = false;
        for (var i = 0; i < player.node.judges.childNodes.length; i++) {
          if (player.node.judges.childNodes[i].name == 'disable_judge') {
            player.node.judges.removeChild(player.node.judges.childNodes[i]);
            break;
          }
        }
      },
      disableJudge: function () {
        var next = game.createEvent('disableJudge');
        next.player = this;
        next.source = _status.event.player;
        next.setContent('disableJudge');
        return next;
      },
      enableJudge: function () {
        var next = game.createEvent('enableJudge');
        next.player = this;
        next.source = _status.event.player;
        next.setContent('enableJudge');
        return next;
      },
      //原有函数
      /**
       * 角色初始化
       * @param {?string} character 角色名，如果未指定，函数直接返回undefined
       * @param {(string|false)} character2 如果为角色名，创建双将角色；如果为false，创建单将
       * @param {!boolean} skill 如果为true，添加技能；如果为false，不添加角色技能；该参数在`character2`参数为false时无效
       * @returns {GameCores.GameObjects.Card} 角色对象
       */
      init: function (character, character2, skill) {
        if (typeof character == 'string' && !lib.character[character]) {
          lib.character[character] = get.character(character);
        }
        if (typeof character2 == 'string' && !lib.character[character2]) {
          lib.character[character2] = get.character(character2);
        }
        if (!lib.character[character]) return;
        if (get.is.jun(character2)) {
          var tmp = character;
          character = character2;
          character2 = tmp;
        }
        if (character2 == false) {
          skill = false;
          character2 = null;
        }
        var info = lib.character[character];
        if (!info) {
          info = ['', '', 1, [], []];
        }
        if (!info[4]) {
          info[4] = [];
        }
        var skills = info[3].slice(0);
        this.clearSkills(true);
        this.classList.add('fullskin');
        if (!game.minskin && get.is.newLayout() && !info[4].contains('minskin')) {
          this.classList.remove('minskin');
          this.node.avatar.setBackground(character, 'character');
        }
        else {
          this.node.avatar.setBackground(character, 'character');
          if (info[4].contains('minskin')) {
            this.classList.add('minskin');
          }
          else if (game.minskin) {
            this.classList.add('minskin');
          }
          else {
            this.classList.remove('minskin');
          }
        }

        var hp1 = get.infoHp(info[2]);
        var maxHp1 = get.infoMaxHp(info[2]);

        this.node.avatar.show();
        this.node.count.show();
        this.node.equips.show();
        this.name = character;
        this.name1 = character;
        this.sex = info[0];
        this.group = info[1];
        this.hp = hp1;
        this.maxHp = maxHp1;
        this.hujia = 0;
        this.node.intro.innerHTML = lib.config.intro;
        this.node.name.dataset.nature = get.groupnature(this.group);
        lib.setIntro(this);
        this.node.name.innerHTML = get[get.slimName2 ? 'slimName2' : 'slimName'](character);
        if (this.classList.contains('minskin') && this.node.name.querySelectorAll('br').length >= 4) {
          this.node.name.classList.add('long');
        }
        if (info[4].contains('hiddenSkill') && !this.noclick) {
          if (!this.hiddenSkills) this.hiddenSkills = [];
          this.hiddenSkills.addArray(skills);
          skills = [];
          this.classList.add(_status.video ? 'unseen_v' : 'unseen');
          this.name = 'unknown';
          if (!this.node.name_seat && !_status.video) {
            this.node.name_seat = ui.create.div('.name.name_seat', get.verticalStr(get.translation(this.name)), this);
            this.node.name_seat.dataset.nature = get.groupnature(this.group);
          }
          this.sex = 'male';
          //this.group='unknown';
          this.storage.nohp = true;
          skills.add('g_hidden_ai');
        }
        if (character2 && lib.character[character2]) {
          var info2 = lib.character[character2];
          if (!info2) {
            info2 = ['', '', 1, [], []];
          }
          if (!info2[4]) {
            info2[4] = [];
          }
          this.classList.add('fullskin2');
          this.node.avatar2.setBackground(character2, 'character');

          this.node.avatar2.show();
          this.name2 = character2;
          var hp2 = get.infoHp(info2[2]);
          var maxHp2 = get.infoMaxHp(info2[2]);
          var double_hp;
          if (_status.connectMode || get.mode() == 'single') {
            double_hp = 'pingjun';
          }
          else {
            double_hp = get.config('double_hp');
          }
          switch (double_hp) {
            case 'pingjun': {
              this.maxHp = Math.floor((maxHp1 + maxHp2) / 2);
              this.hp = Math.floor((hp1 + hp2) / 2);
              this.singleHp = ((maxHp1 + maxHp2) % 2 === 1);
              break;
            }
            case 'zuidazhi': {
              this.maxHp = Math.max(maxHp1, maxHp2);
              this.hp = Math.max(hp1, hp2);
              break;
            }
            case 'zuixiaozhi': {
              this.maxHp = Math.min(maxHp1, maxHp2);
              this.hp = Math.min(hp1, hp2);
              break;
            }
            case 'zonghe': {
              this.maxHp = maxHp1 + maxHp2;
              this.hp = hp1 + hp2;
              break;
            }
            default: {
              this.maxHp = maxHp1 + maxHp2 - 3;
              this.hp = hp1 + hp2 - 3;
            };
          }
          this.node.count.classList.add('p2');
          if (info2[4].contains('hiddenSkill') && !this.noclick) {
            if (!this.hiddenSkills) this.hiddenSkills = [];
            this.hiddenSkills.addArray(info2[3]);
            this.classList.add(_status.video ? 'unseen2_v' : 'unseen2');
            this.storage.nohp = true;
            skills.add('g_hidden_ai');
          }
          else skills = skills.concat(info2[3]);

          this.node.name2.innerHTML = get.slimName(character2);
        }
        if (this.storage.nohp) {
          this.storage.rawHp = this.hp;
          this.storage.rawMaxHp = this.maxHp;
          this.hp = 1;
          this.maxHp = 1;
          this.node.hp.hide();
        }
        if (skill != false) {
          for (var i = 0; i < skills.length; i++) {
            this.addSkill(skills[i]);
          }
          this.checkConflict();
        }
        if(this.group){
          lib.group.add(this.group);
        }
        if (this.inits) {
          for (var i = 0; i < lib.element.player.inits.length; i++) {
            lib.element.player.inits[i](this);
          }
        }
        if (this._inits) {
          for (var i = 0; i < this._inits.length; i++) {
            this._inits[i](this);
          }
        }
        this.update();
        return this;
      },
      /**
       * 角色初始化[support online]
       * @param {string} name 玩家名
       * @param {string} character 角色名
       */
      initOL: function (name, character) {
        this.node.avatar.setBackground(character, 'character');
        this.node.avatar.show();
        this.node.name.innerHTML = get.verticalStr(name);
        this.nickname = name;
        this.avatar = character;
        this.node.nameol.innerHTML = '';
        if (lib.character[character]) this.sex = lib.character[character][0];
      },
      /**
       * 在角色销毁时调用[support online]
       */
      uninitOL: function () {
        this.node.avatar.hide();
        this.node.name.innerHTML = '';
        this.node.identity.firstChild.innerHTML = '';
        delete this.nickname;
        delete this.avatar;
        delete this.sex;
      },
      /**
       * 初始化房间
       * @returns {GameCores.GameObjects.Player} this self
       * @param {Array} info 房间信息
       */
      initRoom: function (info, info2) {
        var str = '';
        this.serving = false;
        if (!info || info == 'server') {
          this.roomempty = true;
          str = '空房间';
          this.roomfull = false;
          this.roomgaming = false;
          this.version = null;
          if (info == 'server') {
            this.serving = true;
          }
        }
        else {
          var config = info[2];
          this.key = info[4];
          this.roomempty = false;
          str += get.modetrans(config);
          str += ' 模式　';
          for (var i = str.length; i < 11; i++) str += '　';
          this.version = config.version;
          if (config.gameStarted) {
            str += '<span class="firetext">游戏中</span>　';
            if (config.observe && config.observeReady && this.version == lib.versionOL) {
              this.classList.remove('exclude');
            }
            else {
              this.classList.add('exclude');
            }
          }
          else {
            str += '<span class="greentext">等待中</span>　';
            if (this.version != lib.versionOL) {
              this.classList.add('exclude');
            }
            else {
              this.classList.remove('exclude');
            }
          }
          this.maxHp = parseInt(config.number);
          this.hp = Math.min(this.maxHp, info[3]);
          if (this.hp < this.maxHp || config.gameStarted) str += ('人数：' + this.hp + '/' + this.maxHp);
          else str += ('人数：<span class="firetext">' + this.hp + '/' + this.maxHp + '</span>');

          str += ('　(' + info[0].slice(0, 12) + ' 的房间)');
          this.config = config;
          if (this.hp == this.maxHp && !config.gameStarted) {
            this.roomfull = true;
          }
          else {
            this.roomfull = false;
          }
          if (config.gameStarted && (!config.observe || !config.observeReady)) {
            this.roomgaming = true;
          }
          else {
            this.roomgaming = false;
          }
        }
        this.firstChild.innerHTML = str;
        return this;
      },
      /**
       * TODO - 重新初始化
       * @param {*} from
       * @param {*} to
       * @param {*} maxHp
       * @param {*} online
       * @returns {(undefined|GameCores.GameObjects.Player)}
       */
      reinit: function (from, to, maxHp, online) {
        var info1 = lib.character[from];
        var info2 = lib.character[to];
        var smooth = true;
        if (maxHp == 'nosmooth') {
          smooth = false;
          maxHp = null;
        }
        if (this.name2 == from) {
          this.name2 = to;
          if (this.isUnseen(0) && !this.isUnseen(1)) {
            this.sex = info2[0];
            this.name = to;
          }
          if (smooth) this.smoothAvatar(true);
          this.node.avatar2.setBackground(to, 'character');
          this.node.name2.innerHTML = get.slimName(to);
        }
        else if (this.name == from || this.name1 == from) {
          if (this.name1 == from) {
            this.name1 = to;
          }
          if (!this.classList.contains('unseen2')) {
            this.name = to;
            this.sex = info2[0];
          }
          if (smooth) this.smoothAvatar(false);
          this.node.avatar.setBackground(to, 'character');
          this.node.name.innerHTML = get.slimName(to);

          if (this == game.me && ui.fakeme) {
            ui.fakeme.style.backgroundImage = this.node.avatar.style.backgroundImage;
          }
        }
        else {
          return this;
        }
        if (online) {
          return;
        }
        for (var i = 0; i < info1[3].length; i++) {
          this.removeSkill(info1[3][i]);
        }
        for (var i = 0; i < info2[3].length; i++) {
          this.addSkill(info2[3][i]);
        }
        if (Array.isArray(maxHp)) {
          this.maxHp = maxHp[1];
          this.hp = maxHp[0];
        }
        else {
          var num;
          if (maxHp === false) {
            num = 0;
          }
          else {
            if (typeof maxHp != 'number') {
              maxHp = get.infoMaxHp(info2[2]);
            }
            num = maxHp - get.infoMaxHp(info1[2]);
          }
          if (typeof this.singleHp == 'boolean') {
            if (num % 2 != 0) {
              if (this.singleHp) {
                this.maxHp += (num + 1) / 2;
                this.singleHp = false;
              }
              else {
                this.maxHp += (num - 1) / 2;
                this.singleHp = true;
                if (!game.online) {
                  this.doubleDraw();
                }
              }
            }
            else {
              this.maxHp += num / 2;
            }
          }
          else {
            this.maxHp += num;
          }
        }
        game.broadcast(function (player, from, to, skills) {
          player.reinit(from, to, null, true);
          player.applySkills(skills);
        }, this, from, to, get.skillState(this));
        game.addVideo('reinit3', this, {
          from: from,
          to: to,
          hp: this.maxHp,
          avatar2: this.name2 == to
        });
        this.update();
      },
      /**
       * 在角色销毁时调用
       * @returns {!GameCores.GameObjects.Player} this self
       */
      uninit: function () {
        for (var i = 1; i < 6; i++) {
          if (this.isDisabled(i)) this.$enableEquip('equip' + i);
        }
        if (this.storage._disableJudge) {
          game.broadcastAll(function (player) {
            player.$._disableJudge = false;
            for (var i = 0; i < player.node.judges.childNodes.length; i++) {
              if (player.node.judges.childNodes[i].name == 'disable_judge') {
                player.node.judges.removeChild(player.node.judges.childNodes[i]);
                break;
              }
            }
          }, this);
        }
        this.node.avatar.hide();
        this.node.count.hide();
        if (this.node.wuxing) {
          this.node.wuxing.hide();
        }
        if (this.node.name_seat) {
          this.node.name_seat.remove();
          delete this.node.name_seat;
        }
        if (this.storage.nohp) this.node.hp.show();
        this.classList.remove('unseen');
        this.classList.remove('unseen2');
        delete this.name;
        delete this.name1;
        delete this.sex;
        delete this.group;
        delete this.hp;
        delete this.maxHp;
        delete this.hujia;
        this.clearSkills(true);
        this.node.identity.style.backgroundColor = '';
        this.node.intro.innerHTML = '';
        this.node.name.innerHTML = '';
        this.node.hp.innerHTML = '';
        this.node.count.innerHTML = '0';
        if (this.name2) {
          delete this.singleHp;
          this.node.avatar2.hide();
          this.node.name2.innerHTML = '';
          this.classList.remove('fullskin2')
          delete this.name2;
          this.node.count.classList.remove('p2');
        }
        for (var mark in this.marks) {
          this.marks[mark].remove();
        }
        ui.updatem(this);

        this.skipList = [];
        this.skills = this.skills.contains('cangji_yozuru') ? ['cangji_yozuru'] : [];
        this.initedSkills = [];
        this.additionalSkills = {};
        this.disabledSkills = {};
        this.hiddenSkills = [];
        this.awakenedSkills = [];
        this.forbiddenSkills = {};
        this.phaseNumber = 0;
        this.stat = [{ card: {}, skill: {} }];
        this.tempSkills = {};
        let storage = {}
        this.$ = this.storage = storage;
        this.marks = {};
        this.ai = { friend: [], enemy: [], neutral: [] };

        return this;
      },
      /**
       * 返回`this.offsetLeft`
       * @returns {!number}
       */
      getLeft: function () {
        return this.offsetLeft;
      },
      /**
       * 返回`this.offsetTop`
       * @returns {!number}
       */
      getTop: function () {
        return this.offsetTop;
      },
      /**
       * @param {?boolean} [vice] 是否使用副将头像，如果为true则使用副将头像；如果为false或未指定，使用(主将)头像
       * @param {?boolean} [video] 如果为true或未指定，添加动画；如果为false，不添加动画
       */
      smoothAvatar: function (vice, video) {
        var div = ui.create.div('.fullsize');
        if (vice) {
          div.style.background = getComputedStyle(this.node.avatar2).background;
          this.node.avatar2.appendChild(div);
        }
        else {
          div.style.background = getComputedStyle(this.node.avatar).background;
          this.node.avatar.appendChild(div);
        }
        ui.refresh(div);
        div.style.transition = 'all 1s';
        setTimeout(function () {
          div.classList.add('removing');
          setTimeout(function () {
            div.remove();
          }, 2000);
        }, 100);
        if (video != false) {
          game.addVideo('smoothAvatar', this, vice);
        }
      },
      /**
       * 强制改变本角色座次，即使目标座次已经有角色存在
       * @param {number} position
       * @param {boolean} [video] 如果为true或未指定，添加动画；如果为false，不添加动画
       */
      changeSeat: function (position, video) {
        var player = this;
        if (video !== false) game.addVideo('changeSeat', player, position);
        var rect1 = player.getBoundingClientRect();
        player.style.transition = 'all 0s';
        ui.refresh(player);
        player.dataset.position = position;
        var rect2 = player.getBoundingClientRect();
        var dx = rect1.left - rect2.left;
        var dy = rect1.top - rect2.top;
        if ((game.chess || (player.dataset.position != 0 && position != 0)) && player.classList.contains('linked')) {
          player.style.transform = 'rotate(-90deg) translate(' + (-dy) + 'px,' + (dx) + 'px)';
        }
        else {
          player.style.transform = 'translate(' + (dx) + 'px,' + (dy) + 'px)';
        }
        setTimeout(function () {
          player.style.transition = '';
          ui.refresh(player);
          player.style.transform = '';
        }, 100);
      },
      /**
       * 将数据(参数)传输至服务器
       * @returns {!GameCores.GameObjects.Player} this self
       */
      send: function () {
        if (!this.ws || this.ws.closed) return this;
        this.ws.send.apply(this.ws, arguments);
        return this;
      },
      /**
       * 为本角色生成并注册ID，如果本角色的ID已经存在就重新生成；如果是在(联机|播放录播)的情况下，该函数不做操作
       * @returns {!GameCores.GameObjects.Player} this self
       */
      getId: function () {
        if (_status.video || _status.connectMode) return this;
        if (this.playerid) {
          delete game.playerMap[this.playerid];
        }
        this.playerid = get.id();
        game.playerMap[this.playerid] = this;
        return this;
      },
      /**
       * 向其他角色发送互动表情[support online]
       * @param {!GameCores.GameObjects.Player} 互动的对象
       * @param {!string} emotion 表情
       */
      throwEmotion: function (target, emotion) {
        game.broadcastAll(function (player, target, emotion) {
          player.$throwEmotion(target, emotion);
        }, this, target, emotion);
      },
      /**
       * 本角色发送聊天表情
       * @param {string} emotionPack 表情包
       * @param {number} emotionID 表情ID
       */
      emotion: function (pack, id) {
        var str = '<img src="##assetURL##image/emotion/' + pack + '/' + id + '.gif" width="50" height="50">';
        lib.element.player.say.call(this, str);
        game.broadcast(function (id, str) {
          if (lib.playerOL[id]) {
            lib.playerOL[id].say(str);
          }
          else if (game.connectPlayers) {
            for (var i = 0; i < game.connectPlayers.length; i++) {
              if (game.connectPlayers[i].playerid == id) {
                lib.element.player.say.call(game.connectPlayers[i], str);
                return;
              }
            }
          }
        }, this.playerid, str);
      },
      /**
       * 本角色发送聊天消息[support online]
       * @param {!string} str 聊天消息
       */
      chat: function (str) {
        if (get.is.banWords(str)) return;
        lib.element.player.say.call(this, str);
        game.broadcast(function (id, str) {
          if (lib.playerOL[id]) {
            lib.playerOL[id].say(str);
          }
          else if (game.connectPlayers) {
            for (var i = 0; i < game.connectPlayers.length; i++) {
              if (game.connectPlayers[i].playerid == id) {
                lib.element.player.say.call(game.connectPlayers[i], str);
                return;
              }
            }
          }
        }, this.playerid, str);
      },
      /**
       * 本角色发送聊天消息(单机)
       * @param {!string} str 聊天消息
       */
      say: function (str) {
        str = str.replace(/##assetURL##/g, lib.assetURL);
        var dialog = ui.create.dialog('hidden');
        dialog.classList.add('static');
        dialog.add('<div class="text" style="word-break:break-all;display:inline">' + str + '</div>');
        dialog.classList.add('popped');
        ui.window.appendChild(dialog);
        var width = dialog.content.firstChild.firstChild.offsetWidth;
        if (width < 190) {
          dialog._mod_height = -16;
        }
        else {
          dialog.content.firstChild.style.textAlign = 'left';
        }
        dialog.style.width = (width + 16) + 'px';
        var refnode;
        if (this.node && this.node.avatar && this.parentNode == ui.arena) {
          refnode = this.node.avatar;
        }
        if (refnode) {
          lib.placePoppedDialog(dialog, {
            clientX: (ui.arena.offsetLeft + this.getLeft() + refnode.offsetLeft + refnode.offsetWidth / 2) * game.documentZoom,
            clientY: (ui.arena.offsetTop + this.getTop() + refnode.offsetTop + refnode.offsetHeight / 4) * game.documentZoom
          });
        }
        else {
          lib.placePoppedDialog(dialog, {
            clientX: (this.getLeft() + this.offsetWidth / 2) * game.documentZoom,
            clientY: (this.getTop() + this.offsetHeight / 4) * game.documentZoom
          });
        }
        if (dialog._mod_height) {
          dialog.content.firstChild.style.padding = 0;
        }
        setTimeout(function () {
          dialog.delete();
        }, lib.quickVoice.indexOf(str) != -1 ? 3800 : 2000);
        var name = get.translation(this.name);
        var info = [name ? (name + '[' + this.nickname + ']') : this.nickname, str];
        lib.chatHistory.push(info);
        if (_status.addChatEntry) {
          if (_status.addChatEntry._origin.parentNode) {
            _status.addChatEntry(info, false);
          }
          else {
            delete _status.addChatEntry;
          }
        }
        if (lib.config.background_speak && lib.quickVoice.indexOf(str) != -1) {
          game.playAudio('voice', (this.sex == 'female' ? 'female' : 'male'), lib.quickVoice.indexOf(str));
        }
      },
      /**
       * 显示投降按钮
       */
      showGiveup: function () {
        this._giveUp = true;
        if (this == game.me) {
          ui.create.giveup();
        }
        else if (this.isOnline2()) {
          this.send(ui.create.giveup);
        }
      },
      /**
       * 同步技能信息[support online]
       * @param {Object} skills 要同步的技能信息
       * @param {?Array<string>} skills.global 全局技能的信息
       * @param {?Object} skills.skillinfo 技能模板信息
       * @param {?Object} skills.stat 本角色的技能状态信息
       * @param {?Object} skills."['playerid']" 角色的技能信息
       */
      applySkills: function (skills) {
        for (var i in skills) {
          if (i == 'global') {
            lib.skill.global = skills[i];
          }
          else if (i == 'skillinfo') {
            for (var j in skills[i]) {
              if (!lib.skill[j]) {
                lib.skill[j] = {};
              }
              lib.skill[j].chooseButton = skills[i][j];
            }
          }
          else if (i == 'stat') {
            this.stat = [skills.stat];
          }
          else if (lib.playerOL[i]) {
            for (var j in skills[i]) {
              lib.playerOL[i][j] = skills[i][j];
            }
          }
        }
      },
      /**
       * 返回本角色状态信息
       * @returns {GameCores.GameObjects.Player~State}
       */
      getState: function () {
        /**
         * @name GameCores.GameObjects.Player~State
         * @property {number} hp 当前血量
         * @property {number} maxHp 最大血量
         * @property {string} nickname 玩家昵称
         * @property {string} sex 角色性别
         * @property {string} group 角色势力
         * @property {string} name 角色姓名
         * @property {string} name1 角色(主将)姓名
         * @property {string} name2 角色(副将)姓名
         * @property {Array<GameCores.GameObjects.Card>} handcards 角色手牌
         * @property {Array<string>} gaintag gaintag标签数组
         * @property {Array<GameCores.GameObjects.Card>} equips 角色装备区的牌
         * @property {Array<GameCores.GameObjects.Card>} judges 角色判定区的牌
         * @property {Array<GameCores.GameObjects.Card>} specials 角色武将牌上的牌
         * @property {Array<string>} disableJudge 对角色无效的判定数组
         * @property {Array<(string|number)>} disableEquip 角色废除的装备(类型)数组
         * @property {Array<(string|undefined)>} views 角色判定区牌的视为名数组，即使判定牌的视为名为空也会添加到该数组中，`views`与`judges`一一对应
         * @property {number} position 角色位置(座次)
         * @property {number} hujia 角色护甲
         * @property {(boolean|undefined)} side 角色所属的一侧，如果`p1.side == p2.side`则认为p1与p2为同侧(友方)，否则为异侧(敌方)；该值仅在部分模式(vs等)中使用，在其他模式中默认为undefined
         * @property {boolean} identityShown 是否显示身份
         * @property {Array} identityNode [this.node.identity.innerHTML, this.node.identity.dataset.color] 
         * @property {string} identity 角色身份
         * @property {boolean} dead 角色是否已死亡
         * @property {boolean} linked 角色是否被链接
         * @property {boolean} turnedover 角色是否翻面
         * @property {number} phaseNumber 此时的回合计数
         * @property {boolean} unseen
         * @property {boolean} unseen2 
         * @property {string} mode 当前的模式
         */
        var state = {
          hp: this.hp,
          maxHp: this.maxHp,
          nickname: this.nickname,
          sex: this.sex,
          group: this.group,
          name: this.name,
          name1: this.name1,
          name2: this.name2,
          handcards: this.getCards('hs'),
          gaintag: [],
          equips: this.getCards('e'),
          judges: this.getCards('j'),
          specials: this.getCards('s'),
          disableJudge: this.storage._disableJudge,
          disableEquip: this.storage.disableEquip,
          views: [],
          position: parseInt(this.dataset.position),
          hujia: this.hujia,
          side: this.side,
          identityShown: this.identityShown,
          identityNode: [this.node.identity.innerHTML, this.node.identity.dataset.color],
          identity: this.identity,
          dead: this.isDead(),
          linked: this.isLinked(),
          turnedover: this.isTurnedOver(),
          phaseNumber: this.phaseNumber,
          unseen: this.isUnseen(0),
          unseen2: this.isUnseen(1),
        }
        for (var i = 0; i < state.judges.length; i++) {
          state.views[i] = state.judges[i].viewAs;
        }
        for (var i = 0; i < state.handcards.length; i++) {
          state.gaintag[i] = state.handcards[i].gaintag;
        }
        if (this.getModeState) {
          state.mode = this.getModeState();
        }
        return state;
      },
      /**
       * 设置玩家昵称
       * @param {string} [str] 玩家昵称，如果未指定或为空字符串，使用`this.nickname`。如果`this.nickname`的值也未指定，使用空字符串
       * @returns {GameCores.GameObjects.Player} this self
       */
      setNickname: function (str) {
        this.node.nameol.innerHTML = (str || this.nickname || '').slice(0, 12);
        return this;
      },
      /**
       * 设置头像[support online]
       * @param {!string} name 武将名，如果是角色副将，则设置副将的头像；如果是主将，则设置主将的头像
       * @param {!string} name2 新图片名(角色名)，用于设置背景；{@link HTMLDivElement#setBackground}
       * @param {?boolean} [video] 如果为true或未指定，添加动画；如果为false，不添加动画
       * @param {?boolean} [fakeme] 如果为true或未指定，设置{@link ui.fakeme}的背景图为头像图；如果为false，不设置
       */
      setAvatar: function (name, name2, video, fakeme) {
        var node;
        if (this.name2 == name) {
          node = this.node.avatar2;
          this.smoothAvatar(true, video);
        }
        else if (this.name == name) {
          node = this.node.avatar;
          this.smoothAvatar(false, video);
        }
        if (node) {
          node.setBackground(name2, 'character');
          if (this == game.me && ui.fakeme && fakeme !== false) {
            ui.fakeme.style.backgroundImage = node.style.backgroundImage;
          }
          if (video != false) {
            game.addVideo('setAvatar', this, [name, name2]);
          }
        }
        game.broadcast(function (player, name, name2) {
          player.setAvatar(name, name2, false);
        }, this, name, name2);
      },
      /**
       * 设置头像更新数组，每张头像更新后停留1s，全部更新完成后，还原头像
       * @param {!string} name 武将名，如果是角色副将，则设置副将的头像；如果是主将，则设置主将的头像
       * @param {Array<string>} list 头像名(角色名)数组
       * @see {@link lib.element.player.setAvatar}
       */
      setAvatarQueue: function (name, list) {
        var node;
        var player = this;
        if (player.name2 == name) {
          node = player.node.avatar2;
        }
        else {
          node = player.node.avatar;
        }
        if (node._avatarqueue) {
          for (var i = 0; i < list.length; i++) {
            node._avatarqueue.push(list[i]);
          }
        }
        else {
          var func = function () {
            if (node._avatarqueue.length) {
              player.setAvatar(name, node._avatarqueue.shift(), false, false);
            }
            else {
              clearInterval(node._avatarqueueinterval);
              delete node._avatarqueue;
              delete node._avatarqueueinterval;
              player.setAvatar(name, name, false, false);
            }
          };
          node._avatarqueue = list.slice(0);
          node._avatarqueueinterval = setInterval(func, 1000);
          func();
        }
        game.addVideo('setAvatarQueue', this, [name, list]);
      },
      /**
       * 本角色闪烁头像
       * @param {!string} skill 技能名，如果技能属于角色副将，则设置副将的头像，否则设置主将的头像
       * @param {!string} name (角色|技能)名，如果是角色名，闪烁此角色的头像；如果是技能名，使用此技能所属角色的角色名
       */
      flashAvatar: function (skill, name) {
        if (lib.skill[name] && !lib.character[name]) {
          var stop = false;
          var list = lib.config.all.characters.slice(0);
          for (var i in lib.characterPack) {
            list.add(i);
          }
          for (var i = 0; i < list.length; i++) {
            for (var j in lib.characterPack[list[i]]) {
              if (lib.characterPack[list[i]][j][3].contains(name)) {
                name = j;
                stop = true;
                break;
              }
            }
            if (stop) {
              break;
            }
          }
        }
        if (lib.character[this.name2] && lib.character[this.name2][3].contains(skill)) {
          this.setAvatarQueue(this.name2, [name]);
        }
        else {
          this.setAvatarQueue(this.name, [name]);
        }
      },
      /**
       * 本角色头像下绘制图像
       * @param {!string} buff 技能名，如果技能属于角色副将，则设置副将的头像，否则设置主将的头像
       * @param {!string} skill 技能名，如果技能属于角色副将，则设置副将的头像，否则设置主将的头像
       * @param {!string} name (角色|技能)名，如果是角色名，闪烁此角色的头像；如果是技能名，使用此技能所属角色的角色名
       */
      buffAvatar: function (buff, skill, name) {
        if (lib.skill[name] && !lib.character[name]) {
          var stop = false;
          var list = lib.config.all.characters.slice(0);
          for (var i in lib.characterPack) {
            list.add(i);
          }
          for (var i = 0; i < list.length; i++) {
            for (var j in lib.characterPack[list[i]]) {
              if (lib.characterPack[list[i]][j][3].contains(name)) {
                name = j;
                stop = true;
                break;
              }
            }
            if (stop) {
              break;
            }
          }
        }
        if (lib.character[this.name2] && lib.character[this.name2][3].contains(skill)) {
          this.setAvatarQueue(this.name2, [name]);
        }
        else {
          this.setAvatarQueue(this.name, [name]);
        }
      },
      /**
       * 同步本角色数据(联网)
       * @returns {?GameCores.GameObjects.Player} this self；如果是回放模式且该函数被无参调用，返回空值(undefined)
       */
      update: function () {
        if (_status.video && arguments.length == 0) return;
        if (this.hp >= this.maxHp) this.hp = this.maxHp;
        var hp = this.node.hp;
        hp.style.transition = 'none';
        game.broadcast(function (player, hp, maxHp, hujia) {
          player.hp = hp;
          player.maxHp = maxHp;
          player.hujia = hujia;
          player.update();
        }, this, this.hp, this.maxHp, this.hujia);
        if (!_status.video) {
          if (this.hujia) {
            this.markSkill('ghujia');
          }
          else {
            this.unmarkSkill('ghujia');
          }
        }
        if (!this.storage.nohp) {
          var libHp = lib.character[(this.name && this.name.indexOf('unknown') == 0) ? this.name1 : this.name];
          if (this.maxHp == Infinity) {
            hp.innerHTML = '∞';
          }
          else if (libHp && libHp[2] && get.infoHp(libHp[2]) < 0) {
            hp.innerHTML = this.hp + '/' + this.maxHp;
            hp.classList.add('text');
          }
          else if (game.layout == 'default' && this.maxHp > 14) {
            hp.innerHTML = this.hp + '/' + this.maxHp;
            hp.classList.add('text');
          }
          else if (get.is.newLayout() &&
            (
              this.maxHp > 9 ||
              (this.maxHp > 5 && this.classList.contains('minskin')) ||
              ((game.layout == 'mobile' || game.layout == 'long') && this.dataset.position == 0 && this.maxHp > 7)
            )) {
            hp.innerHTML = this.hp + '<br>/<br>' + this.maxHp + '<div></div>';
            if (this.hp == 0) {
              hp.lastChild.classList.add('lost');
            }
            hp.classList.add('textstyle');
            // hp.classList.remove('long');
          }
          else {
            hp.innerHTML = '';
            hp.classList.remove('text');
            hp.classList.remove('textstyle');
            while (this.maxHp > hp.childNodes.length) {
              ui.create.div(hp);
            }
            while (Math.max(0, this.maxHp) < hp.childNodes.length) {
              hp.removeChild(hp.lastChild);
            }
            for (var i = 0; i < this.maxHp; i++) {
              var index = i;
              if (get.is.newLayout()) {
                index = this.maxHp - i - 1;
              }
              if (i < this.hp) {
                hp.childNodes[index].classList.remove('lost');
              }
              else {
                hp.childNodes[index].classList.add('lost');
              }
            }
            // if(this.maxHp==9){
            //     hp.classList.add('long');
            // }
            // else{
            //     hp.classList.remove('long');
            // }
          }
          if (hp.classList.contains('room')) {
            hp.dataset.condition = 'high';
          }
          else if (this.hp == 0) {
            hp.dataset.condition = '';
          }
          else if (this.hp > Math.round(this.maxHp / 2) || this.hp === this.maxHp) {
            hp.dataset.condition = 'high';
          }
          else if (this.hp > Math.floor(this.maxHp / 3)) {
            hp.dataset.condition = 'mid';
          }
          else {
            hp.dataset.condition = 'low';
          }

          setTimeout(function () {
            hp.style.transition = '';
          });
        }
        var numh = this.countCards('h');
        if (_status.video) {
          numh = arguments[0];
        }
        if (numh >= 10) {
          numh = numh.toString();
          this.node.count.dataset.condition = 'low';
          this.node.count.innerHTML = numh[0] + '<br>' + numh[1];
        }
        else {
          if (numh > 5) {
            this.node.count.dataset.condition = 'higher';
          }
          else if (numh > 2) {
            this.node.count.dataset.condition = 'high';
          }
          else if (numh > 0) {
            this.node.count.dataset.condition = 'mid';
          }
          else {
            this.node.count.dataset.condition = 'none';
          }
          this.node.count.innerHTML = numh;
        }
        if (this.updates) {
          for (var i = 0; i < lib.element.player.updates.length; i++) {
            lib.element.player.updates[i](this);
          }
        }
        if (!_status.video) {
          game.addVideo('update', this, [this.countCards('h'), this.hp, this.maxHp, this.hujia]);
        }
        this.updateMarks();
        return this;
      },
      /**
       * 本角色的一个技能标记移除指定数量，如果这个技能当前(没有标记|标记数为0)，返回`undefined`；
       * 此函数仅支持数值类型的标记，如果是非数值类型的标记，不做任何移除操作，返回`undefined`；
       * 数值类型仅支持整数
       * @param {!string} i 技能名，此函数会调用`this.storage[i]`获取该技能的标记数量
       * @param {?number} [num] 正整数，标记要移除的数量；如果值为0或未指定，则使用数量 **1** 作为要移除的数量
       * @param {?boolean} [log] 是否输出日志，如果为true或未指定，输出日志；如果为false，不输出日志
       */
      removeMark: function (i, num, log) {
        if (typeof num != 'number' || !num) num = 1;
        if (typeof this.storage[i] != 'number' || !this.storage[i]) return;
        if (num > this.storage[i]) num = this.storage[i];
        this.storage[i] -= num;
        if (log !== false) {
          var str = false;
          var info = get.info(i);
          if (info && info.intro && (info.intro.name || info.intro.name2)) str = info.intro.name2 || info.intro.name;
          else str = lib.translate[i];
          if (str) game.log(this, '移去了', get.cnNumber(num), '个', '#g【' + str + '】');
        }
        this.syncStorage(i);
        this[this.storage[i] ? 'markSkill' : 'unmarkSkill'](i);
      },
      /**
       * 本角色的一个技能标记添加指定数量；
       * 此函数支持任意类型的标记，但不建议使用非数值类型的标记，因为对非数值类型的标记，会首先使用 0 值覆盖原值；
       * 数值类型不支持浮点数
       * @param {!string} i 技能名，此函数会调用`this.storage[i]`获取该技能的标记数量
       * @param {?number} [num] 正整数，标记要添加的数量；如果值为0或未指定，则使用数量 **1** 作为要添加的数量
       * @param {?boolean} [log] 是否输出日志，如果为true或未指定，输出日志；如果为false，不输出日志
       */
      addMark: function (i, num, log) {
        if (typeof num != 'number' || !num) num = 1;
        if (typeof this.storage[i] != 'number') this.storage[i] = 0;
        this.storage[i] += num;
        if (log !== false) {
          var str = false;
          var info = get.info(i);
          if (info && info.intro && (info.intro.name || info.intro.name2)) str = info.intro.name2 || info.intro.name;
          else str = lib.translate[i];
          if (str) game.log(this, '获得了', get.cnNumber(num), '个', '#g【' + str + '】');
        }
        this.syncStorage(i);
        this.markSkill(i);
      },
      /**
       * 返回本角色一个技能的标记数
       * @param {?string} [i] 技能名，如果是数值型标记，返回此技能的标记数；如果是数组型标记，返回数组的长度值；否则，返回0值
       * @returns {!number}
       */
      countMark: function (i) {
        if (this.storage[i] == undefined) return 0;
        if (typeof this.storage[i] == 'number') return this.storage[i];
        if (Array.isArray(this.storage[i])) return this.storage[i].length;
        return 0;
      },
      /**
       * 返回此角色是否有一个技能的标记
       * 此函数仅支持数值型标记，对于非数值型标记，此函数总返回false
       * @param {!string} i 技能名，此函数会调用`this.storage[i]`获取该技能的标记数量
       * @returns {!boolean}
       */
      hasMark: function (i) {
        return this.countMark(i) > 0;
      },
      /**
       * 同步本角色一个技能标记的显示数值，如果是非数值类型的标记，不做同步操作，返回`this`
       * @param {!string} i 技能名
       * @param {?boolean} [storage] 是否同步标记数据，如果为true，同步标记(联网)；如果为false或未指定，不同步
       */
      updateMark: function (i, storage) {
        if (!this.marks[i]) {
          if (lib.skill[i] && lib.skill[i].intro && (this.storage[i] || lib.skill[i].intro.markcount)) {
            this.markSkill(i);
            if (!this.marks[i]) return this;
          }
          else {
            return this;
          }
        }
        if (storage && this.storage[i]) {
          this.syncStorage(i);
        }
        if (i == 'ghujia' || ((!this.marks[i].querySelector('.image') || this.storage[i + '_markcount']) &&
          lib.skill[i] && lib.skill[i].intro && !lib.skill[i].intro.nocount &&
          (this.storage[i] || lib.skill[i].intro.markcount))) {
          this.marks[i].classList.add('overflowmark')
          var num = 0;
          if (typeof lib.skill[i].intro.markcount == 'function') {
            num = lib.skill[i].intro.markcount(this.storage[i], this);
          }
          else if (typeof this.storage[i + '_markcount'] == 'number') {
            num = this.storage[i + '_markcount'];
          }
          else if (i == 'ghujia') {
            num = this.hujia;
          }
          else if (typeof this.storage[i] == 'number') {
            num = this.storage[i];
          }
          else if (Array.isArray(this.storage[i])) {
            num = this.storage[i].length;
          }
          if (num) {
            if (!this.marks[i].markcount) {
              this.marks[i].markcount = ui.create.div('.markcount.menubutton', this.marks[i]);
            }
            this.marks[i].markcount.innerHTML = num;
          }
          else if (this.marks[i].markcount) {
            this.marks[i].markcount.delete();
            delete this.marks[i].markcount;
          }
        }
        else {
          if (this.marks[i].markcount) {
            this.marks[i].markcount.delete();
            delete this.marks[i].markcount;
          }
          if (lib.skill[i].mark == 'auto') {
            this.unmarkSkill(i);
          }
        }
        return this;
      },
      /**
       * 更新本角色全部数值型技能标记信息，不处理非数值标记
       * @param {?string} [skillname] 技能名，同步本角色的一个技能标记数据然后同步更新(联网)；如果未指定，则不进行同步，仅在本机更新
       */
      updateMarks: function (connect) {
        if (typeof connect == 'string' && _status.connectMode && !game.online) {
          game.broadcast(function (player, storage, skill) {
            player.$[skill] = storage;
            player.updateMarks();
          }, this, this.$[connect], connect);
        }
        for (var i in this.marks) {
          this.updateMark(i);
        }
      },
      num: function (arg1, arg2, arg3) {
        if (get.itemtype(arg1) == 'position') {
          return this.get(arg1, arg2, arg3).length;
        }
        else if (arg1 == 's') {
          if (typeof arg2 == 'boolean') {
            return game.expandSkills(this.getSkills(arg2).concat(lib.skill.global)).contains(arg3);
          }
          else {
            return game.expandSkills(this.getSkills().concat(lib.skill.global)).contains(arg2);
          }
        }
      },
      line: function (target, config) {
        if (get.itemtype(target) == 'players') {
          for (var i = 0; i < target.length; i++) {
            this.line(target[i], config);
          }
        }
        else if (get.itemtype(target) == 'player') {
          if (target == this) return;
          game.broadcast(function (player, target, config) {
            player.line(target, config);
          }, this, target, config);
          game.addVideo('line', this, [target.dataset.position, config]);
          game.linexy([
            this.getLeft() + this.offsetWidth / 2,
            this.getTop() + this.offsetHeight / 2,
            target.getLeft() + target.offsetWidth / 2,
            target.getTop() + target.offsetHeight / 2
          ], config, true);
        }
      },
      line2: function (targets, config) {
        this.line(targets[0], config);
        targets = targets.slice(0);
        for (var i = 1; i < targets.length; i++) {
          (function (j) {
            setTimeout(function () {
              targets[j - 1].line(targets[j], config);
            }, lib.config.duration * i);
          }(i));
        }
      },
      getNext: function () {
        if (this.hasSkill('undist')) return null;
        var target = this;
        for (var i = 0; i < game.players.length - 1; i++) {
          target = target.next;
          if (!target.hasSkill('undist')) {
            return target;
          }
        }
        return null;
      },
      getPrevious: function () {
        if (this.hasSkill('undist')) return null;
        var target = this;
        for (var i = 0; i < game.players.length - 1; i++) {
          target = target.previous;
          if (!target.hasSkill('undist')) {
            return target;
          }
        }
        return null;
      },
      countUsed: function (card, type) {
        if (type === true) {
          var num = 0;
          var history = this.getHistory('useCard');
          for (var i = 0; i < history.length; i++) {
            if (!card) num++;
            else if (typeof card == 'string' && history[i].card && card == history[i].card.name) num++;
            else if (typeof card == 'object' && history[i].card && card.name == history[i].card.name) num++;
          }
          return num;
        }
        var num;
        var stat = this.getStat('card');
        if (!card) {
          num = 0;
          for (var i in stat) {
            if (typeof stat[i] == 'number') {
              console.log(i, stat[i])
              num += stat[i];
            }
          }
          return num;
        }
        if (typeof card == 'object') {
          card = card.name;
        }
        num = stat[card];
        if (typeof num != 'number') return 0;
        return num;
      },
      countSkill: function (skill) {
        var num = this.getStat('skill')[skill];
        if (num == undefined) return 0;
        return num;
      },
      getStockSkills: function (unowned, unique, hidden) {
        var list = [];
        if (lib.character[this.name] && (hidden || !this.isUnseen(0))) {
          list.addArray(lib.character[this.name][3]);
        }
        if (lib.character[this.name1] && (hidden || !this.isUnseen(0))) {
          list.addArray(lib.character[this.name1][3]);
        }
        if (lib.character[this.name2] && (hidden || !this.isUnseen(1))) {
          list.addArray(lib.character[this.name2][3]);
        }
        if (!unowned) {
          for (var i = 0; i < list.length; i++) {
            if (!this.hasSkill(list[i])) {
              list.splice(i--, 1);
            }
          }
        }
        if (!unique) {
          for (var i = 0; i < list.length; i++) {
            var info = lib.skill[list[i]];
            if (!info || info.unique || info.temp || info.sub || info.charlotte) {
              list.splice(i--, 1);
            }
          }
        }
        return list;
      },
      /**
       * 返回本角色(手牌|装备区|判定区|武将牌上)或任意位置组合的游戏牌
       * @function lib.element.player.getCards
       * @param {string} [position='h'] 游戏牌位置组合: [hesj]+
       * @returns {!Array<GameCores.GameObjects.Card>}
       */
      /**
       * 返回本角色所有牌中等于指定名称或手牌轴被视为指定名称的游戏牌
       * @function lib.element.player.getCards
       * @variation 2
       * @param {string} [position='h'] 游戏牌位置: [hesj]+
       * @param {!string} [name] 游戏牌名，返回所有名称等于该牌名，或者手牌中被视为此牌名的牌
       * @returns {!Array<GameCores.GameObjects.Card>}
       */
      /**
       * 返回本角色所有牌中满足特定条件的游戏牌
       * @function lib.element.player.getCards
       * @variation 3
       * @param {string} [position='h'] 游戏牌位置: [hesj]+
       * @param {?Object} [cond] 条件对象，每个属性对应一个匹配条件(游戏牌对象必须有该属性，否则该条件会被跳过，不会生效)，只要有一次匹配失败就将牌从结果数组中移除；如果未指定则跳过匹配过程
       * @param {...(Array<(Object|string)>|string)} cond.'[keyname]' 匹配条件，如果`cond[keyname] == card[keyname] || cond[keyname].contains(card[keyname])`成立，则匹配成功
       * @returns {!Array<GameCores.GameObjects.Card>}
       */
      /**
       * getCards筛选函数
       * @callback lib.element.player.getCards~filterCard
       * @param {!GameCores.GameObjects.Card} card 游戏牌对象
       * @returns {?boolean} true表示保留此游戏牌，false或未指定表示不保留
       * @see {@link lib.element.player.getCards(4)}
       */
      /**
       * 返回本角色所有牌中通过筛选函数的游戏牌
       * @function lib.element.player.getCards
       * @variation 4
       * @param {string} [position='h'] 游戏牌位置: [hesj]+
       * @param {?lib.element.player.getCards~filterCard} [filter] 筛选函数，如果未指定则跳过筛选过程
       * @returns {!Array<GameCores.GameObjects.Card>}
       */
      getCards: function (arg1, arg2) {
        if (typeof arg1 != 'string') {
          arg1 = 'h';
        }
        var cards = [], cards1 = [];
        var i, j;
        for (i = 0; i < arg1.length; i++) {
          if (arg1[i] == 'h') {
            for (j = 0; j < this.node.handcards1.childElementCount; j++) {
              if (!this.node.handcards1.childNodes[j].classList.contains('removing') && !this.node.handcards1.childNodes[j].classList.contains('glows')) {
                cards.push(this.node.handcards1.childNodes[j]);
              }
            }
            for (j = 0; j < this.node.handcards2.childElementCount; j++) {
              if (!this.node.handcards2.childNodes[j].classList.contains('removing') && !this.node.handcards2.childNodes[j].classList.contains('glows')) {
                cards.push(this.node.handcards2.childNodes[j]);
              }
            }
          }
          else if (arg1[i] == 's') {
            for (j = 0; j < this.node.handcards1.childElementCount; j++) {
              if (!this.node.handcards1.childNodes[j].classList.contains('removing') && this.node.handcards1.childNodes[j].classList.contains('glows')) {
                cards.push(this.node.handcards1.childNodes[j]);
              }
            }
            for (j = 0; j < this.node.handcards2.childElementCount; j++) {
              if (!this.node.handcards2.childNodes[j].classList.contains('removing') && this.node.handcards2.childNodes[j].classList.contains('glows')) {
                cards.push(this.node.handcards2.childNodes[j]);
              }
            }
          }
          else if (arg1[i] == 'e') {
            for (j = 0; j < this.node.equips.childElementCount; j++) {
              if (!this.node.equips.childNodes[j].classList.contains('removing') && !this.node.equips.childNodes[j].classList.contains('feichu')) {
                cards.push(this.node.equips.childNodes[j]);
              }
            }
          }
          else if (arg1[i] == 'j') {
            for (j = 0; j < this.node.judges.childElementCount; j++) {
              if (!this.node.judges.childNodes[j].classList.contains('removing') && !this.node.judges.childNodes[j].classList.contains('feichu')) {
                cards.push(this.node.judges.childNodes[j]);
                if (this.node.judges.childNodes[j].viewAs && arguments.length > 1) {
                  this.node.judges.childNodes[j].tempJudge = this.node.judges.childNodes[j].name;
                  this.node.judges.childNodes[j].name = this.node.judges.childNodes[j].viewAs;
                  cards1.push(this.node.judges.childNodes[j]);
                }
              }
            }
          }
        }
        if (arguments.length == 1) {
          return cards;
        }
        if (arg2) {
          for (i = 0; i < cards.length; i++) {
            if (!get.is.filterCardBy(cards[i], arg2)) {
              cards.splice(i--, 1);
            }
          }
        }
        for (i = 0; i < cards1.length; i++) {
          if (cards1[i].tempJudge) {
            cards1[i].name = cards1[i].tempJudge;
            delete cards1[i].tempJudge;
          }
        }
        return cards;
      },
      getDiscardableCards: function (player, arg1, arg2) {
        var cards = this.getCards(arg1, arg2);
        for (var i = 0; i < cards.length; i++) {
          if (!lib.filter.canBeDiscarded(cards[i], player, this)) {
            cards.splice(i--, 1);
          }
        }
        return cards;
      },
      getGainableCards: function (player, arg1, arg2) {
        var cards = this.getCards(arg1, arg2);
        for (var i = 0; i < cards.length; i++) {
          if (!lib.filter.canBeGained(cards[i], player, this)) {
            cards.splice(i--, 1);
          }
        }
        return cards;
      },
      getGainableSkills: function (func) {
        var list = [];
        var names = [this.name, this.name1, this.name2];
        for (var i = 0; i < names.length; i++) {
          list.addArray(get.gainableSkillsName(names[i], func));
        }
        return list;
      },
      countCards: function (arg1, arg2) {
        return this.getCards(arg1, arg2).length;
      },
      countDiscardableCards: function (player, arg1, arg2) {
        return this.getDiscardableCards(player, arg1, arg2).length;
      },
      countGainableCards: function (player, arg1, arg2) {
        return this.getGainableCards(player, arg1, arg2).length;
      },
      getOriginalSkills: function () {
        var skills = [];
        if (lib.character[this.name] && !this.isUnseen(0)) {
          skills.addArray(lib.character[this.name][3]);
        }
        if (this.name2 && lib.character[this.name2] && !this.isUnseen(1)) {
          skills.addArray(lib.character[this.name2][3]);
        }
        return skills;
      },
      /**
       * 返回本角色的技能组；
       * 该技能组不包括子技能；
       * @param {!string} skill 技能名
       * @param {*} arg2 为真时表示计入隐藏的技能、为'e'时表示仅返回装备技能
       * @param {*} arg3 为false时表示不计入装备技能
       * @param {*} arg4 为false时表示计入失效的技能
       * @returns {!Array<string>}
       */
      getSkills: function (arg2, arg3, arg4) {
        var skills = this.skills.slice(0);
        var es = [];
        var i, j;
        if (arg3 !== false) {
          for (i = 0; i < this.node.equips.childElementCount; i++) {
            if (!this.node.equips.childNodes[i].classList.contains('removing')) {
              var equipskills = get.info(this.node.equips.childNodes[i], false).skills;
              if (equipskills) {
                es.addArray(equipskills);
              }
            }
          }
          if (arg2 == 'e') {
            return es;
          }
        }
        for (var i in this.additionalSkills) {
          if (Array.isArray(this.additionalSkills[i]) && (arg2 || i.indexOf('hidden:') !== 0)) {
            for (j = 0; j < this.additionalSkills[i].length; j++) {
              if (this.additionalSkills[i][j]) {
                skills.add(this.additionalSkills[i][j]);
              }
            }
          }
          else if (this.additionalSkills[i] && typeof this.additionalSkills[i] == 'string') {
            skills.add(this.additionalSkills[i]);
          }
        }
        for (var i in this.tempSkills) {
          skills.add(i);
        }
        if (arg2) skills.addArray(this.hiddenSkills);
        if (arg3 !== false) skills.addArray(es);
        for (var i in this.forbiddenSkills) {
          skills.remove(i);
        }
        if (arg4 !== false) {
          skills = game.filterSkills(skills, this, es);
        }
        return skills;
      },
      /**
       * 角色的游戏牌区域(手牌|装备区|判定区)组合
       * Regex: [hej]|he|hj|ej|hej
       * @typedef {string} GameCores.PlayerCardPosition
       * @see {@link GameCores.CardPosition}
       */
      /**
       * 返回本角色(武将牌上|手牌|装备区|判定区)的游戏牌 TODO
       * @param {('s'|GameCores.PlayerCardPosition)} position 角色的游戏牌区域或者角色的武将牌上区域
       * @param {*} arg2
       * @param {*} arg3
       * @param {*} arg4
       * @returns {Array<GameCores.GameObjects.Card>}
       * @see {@link GameCores.PlayerCardPosition}
       * @example
       * let cards = player.get('he')//手牌和装备区所有未被移除、废除、的牌
       * 
       * 
       */
      get: function (arg1, arg2, arg3, arg4) {
        var i, j;
        if (arg1 == 's') {
          var skills = this.skills.slice(0);
          var es = [];
          if (arg3 !== false) {
            for (i = 0; i < this.node.equips.childElementCount; i++) {
              if (!this.node.equips.childNodes[i].classList.contains('removing') && !this.node.equips.childNodes[i].classList.contains('feichu')) {
                var equipskills = get.info(this.node.equips.childNodes[i]).skills;
                if (equipskills) {
                  es.addArray(equipskills);
                }
              }
            }
            if (arg2 == 'e') {
              return es;
            }
          }
          for (var i in this.additionalSkills) {
            if (Array.isArray(this.additionalSkills[i])) {
              for (j = 0; j < this.additionalSkills[i].length; j++) {
                if (this.additionalSkills[i][j]) {
                  skills.add(this.additionalSkills[i][j]);
                }
              }
            }
            else if (this.additionalSkills[i] && typeof this.additionalSkills[i] == 'string') {
              skills.add(this.additionalSkills[i]);
            }
          }
          for (var i in this.tempSkills) {
            skills.add(i);
          }
          if (arg2) skills.addArray(this.hiddenSkills);
          if (arg3 !== false) skills.addArray(es);
          for (var i in this.forbiddenSkills) {
            skills.remove(i);
          }
          if (arg4 !== false) {
            skills = game.filterSkills(skills, this, es);
          }
          return skills;
        }
        else if (get.is.pos(arg1)) {
          var cards = [], cards1 = [];
          for (i = 0; i < arg1.length; i++) {
            if (arg1[i] == 'h') {
              for (j = 0; j < this.node.handcards1.childElementCount; j++) {
                if (!this.node.handcards1.childNodes[j].classList.contains('removing') && !this.node.handcards1.childNodes[j].classList.contains('feichu') && !this.node.handcards1.childNodes[j].classList.contains('glows')) {
                  cards.push(this.node.handcards1.childNodes[j]);
                }
              }
              for (j = 0; j < this.node.handcards2.childElementCount; j++) {
                if (!this.node.handcards2.childNodes[j].classList.contains('removing') && !this.node.handcards2.childNodes[j].classList.contains('feichu') && !this.node.handcards2.childNodes[j].classList.contains('glows')) {
                  cards.push(this.node.handcards2.childNodes[j]);
                }
              }
            }
            else if (arg1[i] == 'e') {
              for (j = 0; j < this.node.equips.childElementCount; j++) {
                if (!this.node.equips.childNodes[j].classList.contains('removing') && !this.node.equips.childNodes[j].classList.contains('feichu')) {
                  cards.push(this.node.equips.childNodes[j]);
                }
              }
              if (arguments.length == 2 && typeof arg2 == 'string' && /1|2|3|4|5/.test(arg2)) {
                for (j = 0; j < cards.length; j++) {
                  if (get.subtype(cards[j]) == 'equip' + arg2) return cards[j];
                }
                return;
              }
            }
            else if (arg1[i] == 'j') {
              for (j = 0; j < this.node.judges.childElementCount; j++) {
                if (!this.node.judges.childNodes[j].classList.contains('removing') && !this.node.judges.childNodes[j].classList.contains('feichu')) {
                  cards.push(this.node.judges.childNodes[j]);
                  if (this.node.judges.childNodes[j].viewAs && arguments.length > 1) {
                    this.node.judges.childNodes[j].tempJudge = this.node.judges.childNodes[j].name;
                    this.node.judges.childNodes[j].name = this.node.judges.childNodes[j].viewAs;
                    cards1.push(this.node.judges.childNodes[j]);
                  }
                }
              }
            }
          }
          if (arguments.length == 1) {
            return cards;
          }
          if (arg2 != undefined) {
            if (typeof arg3 == 'function') {
              var cards2 = cards.slice(0);
              cards.sort(function (a, b) {
                return arg3(b, cards2) - arg3(a, cards2);
              });
            }
            if (typeof arg2 == 'string') {
              for (i = 0; i < cards.length; i++) {
                if (cards[i].name != arg2) {
                  cards.splice(i, 1); i--;
                }
              }
            }
            else if (typeof arg2 == 'object') {
              for (i = 0; i < cards.length; i++) {
                for (j in arg2) {
                  if (j == 'type') {
                    if (typeof arg2[j] == 'object') {
                      if (arg2[j].contains(get.type(cards[i])) == false) {
                        cards.splice(i, 1); i--; break;
                      }
                    }
                    else if (typeof arg2[j] == 'string') {
                      if (get.type(cards[i]) != arg2[j]) {
                        cards.splice(i, 1); i--; break;
                      }
                    }
                  }
                  else if (j == 'subtype') {
                    if (typeof arg2[j] == 'object') {
                      if (arg2[j].contains(get.subtype(cards[i])) == false) {
                        cards.splice(i, 1); i--; break;
                      }
                    }
                    else if (typeof arg2[j] == 'string') {
                      if (get.subtype(cards[i]) != arg2[j]) {
                        cards.splice(i, 1); i--; break;
                      }
                    }
                  }
                  else if (j == 'color') {
                    if (typeof arg2[j] == 'object') {
                      if (arg2[j].contains(get.color(cards[i])) == false) {
                        cards.splice(i, 1); i--; break;
                      }
                    }
                    else if (typeof arg2[j] == 'string') {
                      if (get.color(cards[i]) != arg2[j]) {
                        cards.splice(i, 1); i--; break;
                      }
                    }
                  }
                  else if (j == 'suit') {
                    if (typeof arg2[j] == 'object') {
                      if (arg2[j].contains(get.suit(cards[i])) == false) {
                        cards.splice(i, 1); i--; break;
                      }
                    }
                    else if (typeof arg2[j] == 'string') {
                      if (get.suit(cards[i]) != arg2[j]) {
                        cards.splice(i, 1); i--; break;
                      }
                    }
                  }
                  else if (j == 'number') {
                    if (typeof arg2[j] == 'object') {
                      if (arg2[j].contains(get.number(cards[i])) == false) {
                        cards.splice(i, 1); i--; break;
                      }
                    }
                    else if (typeof arg2[j] == 'string') {
                      if (get.number(cards[i]) != arg2[j]) {
                        cards.splice(i, 1); i--; break;
                      }
                    }
                  }
                  else if (typeof arg2[j] == 'object') {
                    if (arg2[j].contains(cards[i][j]) == false) {
                      cards.splice(i, 1); i--; break;
                    }
                  }
                  else if (typeof arg2[j] == 'string') {
                    if (cards[i][j] != arg2[j]) {
                      cards.splice(i, 1); i--; break;
                    }
                  }
                }
              }
            }
            else if (typeof arg2 == 'number' && arg2 > 0) {
              cards.splice(arg2);
            }
            else if (typeof arg2 == 'function') {
              for (i = 0; i < cards.length; i++) {
                if (!arg2(cards[i])) {
                  cards.splice(i, 1); i--;
                }
              }
            }
          }
          for (i = 0; i < cards1.length; i++) {
            if (cards1[i].tempJudge) {
              cards1[i].name = cards1[i].tempJudge;
              delete cards1[i].tempJudge;
            }
          }
          if (arg2 === 0) return cards[0];
          if (typeof arg3 == 'number') {
            if (arg3 == 0) return cards[0];
            cards.splice(arg3);
          }
          if (typeof arg4 == 'number') {
            if (arg4 == 0) return cards[0];
            cards.splice(arg4);
          }
          return cards;
        }
      },
      /**
       * 记录本角色的一个技能当前标记数(回放记录)，并更新全部标记信息({@link lib.element.player.updateMarks})
       * @param {!string} skill 技能名
       */
      syncStorage: function (skill) {
        switch (get.itemtype(this.storage[skill])) {
          case 'cards': game.addVideo('storage', this, [skill, get.cardsInfo(this.storage[skill]), 'cards']); break;
          case 'card': game.addVideo('storage', this, [skill, get.cardInfo(this.storage[skill]), 'card']); break;
          default:
            try {
              game.addVideo('storage', this, [skill, JSON.parse(JSON.stringify(this.storage[skill]))]);
            }
            catch (e) {
              console.log(this.storage[skill]);
            }
        }
      },
      syncSkills: function () {
        game.broadcast(function (player, skills) {
          player.applySkills(skills);
        }, this, get.skillState(this));
      },
      playerfocus: function (time) {
        time = time || 1000;
        this.classList.add('playerfocus');
        ui.arena.classList.add('playerfocus');
        var that = this;
        setTimeout(function () {
          that.classList.remove('playerfocus');
          ui.arena.classList.remove('playerfocus');
        }, time);
        game.addVideo('playerfocus', this, time);
        game.broadcast(function (player, time) {
          player.playerfocus(time);
        }, this, time);
        return this;
      },
      /**
       * 记录本角色的一个技能当前标记数(回放记录)，并更新全部标记信息({@link lib.element.player.updateMarks})
       * @param {!string} skill 技能名
       */
      setIdentity: function (identity) {
        if (!identity) identity = this.identity;
        if (get.is.jun(this)) {
          this.node.identity.firstChild.innerHTML = '君';
        }
        else {
          this.node.identity.firstChild.innerHTML = get.translation(identity);
        }
        this.node.identity.dataset.color = identity;
        return this;
      },
      insertPhase: function (skill, insert) {
        var evt = _status.event.getParent('phase');
        var next;
        if (evt && evt.parent && evt.parent.next) {
          evt = evt.parent;
          next = game.createEvent('phase', null, evt);
        }
        else if (_status.event.parent && _status.event.parent.next) {
          evt = _status.event.parent;
          next = game.createEvent('phase', null, evt);
        }
        else {
          evt = null;
          next = game.createEvent('phase');
        }
        if (evt && insert && evt.next.contains(next)) {
          evt.next.remove(next);
          evt.next.unshift(next);
        }
        next.player = this;
        next.skill = skill || _status.event.name;
        next.setContent('phase');
        return next;
      },
      insertEvent: function (name, content, arg) {
        var evt = _status.event.getParent('phase');
        var next;
        if (evt && evt.parent && evt.parent.next) {
          next = game.createEvent(name, null, evt.parent);
        }
        else {
          next = game.createEvent(name);
        }
        for (var i in arg) {
          next[i] = arg[i];
        }
        next.player = this;
        next.setContent(content);
        return next;
      },
      phase: function (skill, stageList) {
        var next = game.createEvent('phase');
        next.player = this;
        next.setContent('phase');
        if (!_status.roundStart) {
          _status.roundStart = this;
        }
        if (skill) {
          next.skill = skill;
        }
        if (stageList) {
          next.stageList = stageList;
        }
        return next;
      },
      phaseZhunbei: function () {
        var next = game.createEvent('phaseZhunbei');
        next.player = this;
        next.setContent('emptyEvent');
        return next;
      },
      phaseJudge: function () {
        var next = game.createEvent('phaseJudge');
        next.player = this;
        next.setContent('phaseJudge');
        return next;
      },
      phaseDraw: function () {
        var next = game.createEvent('phaseDraw');
        next.player = this;
        next.num = 2;
        if ((get.config('first_less') || _status.connectMode || _status.first_less_forced) && game.phaseNumber == 1 && _status.first_less) {
          next.num--;
        }
        next.setContent('phaseDraw');
        return next;
      },
      phaseUse: function () {
        var next = game.createEvent('phaseUse');
        next.player = this;
        next.setContent('phaseUse');
        return next;
      },
      phaseDiscard: function () {
        var next = game.createEvent('phaseDiscard');
        next.player = this;
        next.setContent('phaseDiscard');
        return next;
      },
      phaseJieshu: function () {
        var next = game.createEvent('phaseJieshu');
        next.player = this;
        next.setContent('emptyEvent');
        return next;
      },
      chooseToUse: function (use) {
        var next = game.createEvent('chooseToUse');
        next.player = this;
        if (arguments.length == 1 && get.objtype(arguments[0]) == 'object') {
          for (var i in use) {
            next[i] = use[i];
          }
        }
        else {
          for (var i = 0; i < arguments.length; i++) {
            if (typeof arguments[i] == 'number' || get.itemtype(arguments[i]) == 'select') {
              next.selectTarget = arguments[i];
            }
            else if ((typeof arguments[i] == 'object' && arguments[i]) || typeof arguments[i] == 'function') {
              if (get.itemtype(arguments[i]) == 'player' || next.filterCard) {
                next.filterTarget = arguments[i];
              }
              else next.filterCard = arguments[i];
            }
            else if (typeof arguments[i] == 'boolean') {
              next.forced = arguments[i];
            }
            else if (typeof arguments[i] == 'string') {
              next.prompt = arguments[i];
            }
          }
        }
        if (typeof next.filterCard == 'object') {
          next.filterCard = get.filter(next.filterCard);
        }
        if (typeof next.filterTarget == 'object') {
          next.filterTarget = get.filter(next.filterTarget, 2);
        }
        if (next.filterCard == undefined) {
          next.filterCard = lib.filter.filterCard;
        }
        if (next.selectCard == undefined) {
          next.selectCard = [1, 1];
        }
        if (next.filterTarget == undefined) {
          next.filterTarget = lib.filter.filterTarget;
        }
        if (next.selectTarget == undefined) {
          next.selectTarget = lib.filter.selectTarget;
        }
        next.position = 'hs';
        if (next.ai1 == undefined) next.ai1 = get.order;
        if (next.ai2 == undefined) next.ai2 = get.effect_use;
        next.setContent('chooseToUse');
        next._args = Array.from(arguments);
        return next;
      },
      chooseToRespond: function () {
        var next = game.createEvent('chooseToRespond');
        next.player = this;
        var filter;
        for (var i = 0; i < arguments.length; i++) {
          if (typeof arguments[i] == 'number') {
            next.selectCard = [arguments[i], arguments[i]];
          }
          else if (get.itemtype(arguments[i]) == 'select') {
            next.selectCard = arguments[i];
          }
          else if (typeof arguments[i] == 'boolean') {
            next.forced = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'position') {
            next.position = arguments[i];
          }
          else if (typeof arguments[i] == 'function') {
            if (next.filterCard) next.ai = arguments[i];
            else next.filterCard = arguments[i];
          }
          else if (typeof arguments[i] == 'object' && arguments[i]) {
            next.filterCard = get.filter(arguments[i]);
            filter = arguments[i];
          }
          else if (arguments[i] == 'nosource') {
            next.nosource = true;
          }
          else if (typeof arguments[i] == 'string') {
            next.prompt = arguments[i];
          }
        }
        if (next.filterCard == undefined) next.filterCard = lib.filter.all;
        if (next.selectCard == undefined) next.selectCard = [1, 1];
        if (next.source == undefined && !next.nosource) next.source = _status.event.player;
        if (next.ai == undefined) next.ai = get.unuseful2;
        if (next.prompt != false) {
          if (typeof next.prompt == 'string') {
            //next.dialog=next.prompt;
          }
          else {
            var str = '请打出' + get.cnNumber(next.selectCard[0]) + '张'
            if (filter) {
              if (filter.name) {
                str += get.translation(filter.name);
              }
              else {
                str += '牌';
              }
            }
            else {
              str += '牌';
            }
            if (_status.event.getParent().name == 'useCard') {
              var cardname = _status.event.name;
              if (lib.card[cardname] && lib.translate[cardname]) {
                str += '响应' + lib.translate[cardname];
              }
            }
            next.prompt = str;
          }
        }
        next.position = 'hs';
        next.setContent('chooseToRespond');
        next._args = Array.from(arguments);
        return next;
      },
      chooseToDiscard: function () {
        var next = game.createEvent('chooseToDiscard');
        next.player = this;
        for (var i = 0; i < arguments.length; i++) {
          if (typeof arguments[i] == 'number') {
            next.selectCard = [arguments[i], arguments[i]];
          }
          else if (get.itemtype(arguments[i]) == 'select') {
            next.selectCard = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'dialog') {
            next.dialog = arguments[i];
            next.prompt = false;
          }
          else if (typeof arguments[i] == 'boolean') {
            next.forced = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'position') {
            next.position = arguments[i];
          }
          else if (typeof arguments[i] == 'function') {
            if (next.filterCard) next.ai = arguments[i];
            else next.filterCard = arguments[i];
          }
          else if (typeof arguments[i] == 'object' && arguments[i]) {
            next.filterCard = get.filter(arguments[i]);
          }
          else if (typeof arguments[i] == 'string') {
            get.evtprompt(next, arguments[i]);
          }
          if (arguments[i] === null) {
            for (var i = 0; i < arguments.length; i++) {
              console.log(arguments[i]);
            }
          }
        }
        if (next.isMine() == false && next.dialog) next.dialog.style.display = 'none';
        if (next.filterCard == undefined) next.filterCard = lib.filter.all;
        if (next.selectCard == undefined) next.selectCard = [1, 1];
        if (next.ai == undefined) next.ai = get.unuseful;
        next.autochoose = function () {
          if (!this.forced) return false;
          if (typeof this.selectCard == 'function') return false;
          var cards = this.player.getCards(this.position);
          var num = cards.length;
          for (var i = 0; i < cards.length; i++) {
            if (!lib.filter.cardDiscardable(cards[i], this.player, this)) num--;
          }
          return get.select(this.selectCard)[0] >= num;
        }
        next.setContent('chooseToDiscard');
        next._args = Array.from(arguments);
        return next;
      },
      chooseToCompare: function (target, check) {
        var next = game.createEvent('chooseToCompare');
        next.player = this;
        if (Array.isArray(target)) {
          next.targets = target;
          if (check) next.ai = check;
          else next.ai = function (card) {
            if (typeof card == 'string' && lib.skill[card]) {
              var ais = lib.skill[card].check || function () { return 0 };
              return ais();
            }
            var addi = (get.value(card) >= 8 && get.type(card) != 'equip') ? -10 : 0;
            if (card.name == 'du') addi += 5;
            var source = _status.event.source;
            var player = _status.event.player;
            var getn = function (card) {
              if (player.hasSkill('tianbian') && get.suit(card) == 'heart') return 13;
              return get.number(card);
            }
            if (source && source != player && get.attitude(player, source) > 1) {
              return -getn(card) - get.value(card) / 2 + addi;
            }
            return getn(card) - get.value(card) / 2 + addi;
          }
          next.setContent('chooseToCompareMultiple');
        }
        else {
          next.target = target;
          if (check) next.ai = check;
          else next.ai = function (card) {
            if (typeof card == 'string' && lib.skill[card]) {
              var ais = lib.skill[card].check || function () { return 0 };
              return ais();
            }
            var player = get.owner(card);
            var getn = function (card) {
              if (player.hasSkill('tianbian') && get.suit(card) == 'heart') return 13;
              return get.number(card);
            }
            var Evt = _status.event.getParent();
            var to = (player == Evt.player ? Evt.target : Evt.player);
            var addi = (get.value(card) >= 8 && get.type(card) != 'equip') ? -10 : 0;
            if (card.name == 'du') addi -= 5;
            if (player == Evt.player) {
              if (get.attitude(player, to) > 0 && Evt.small) {
                return -getn(card) - get.value(card) / 2 + addi;
              }
              return getn(card) - get.value(card) / 2 + addi;
            }
            else {
              if (get.attitude(player, to) > 0 && !Evt.small) {
                return -getn(card) - get.value(card) / 2 + addi;
              }
              return getn(card) - get.value(card) / 2 + addi;
            }
          }
          next.setContent('chooseToCompare');
        }
        next.forceDie = true;
        next._args = Array.from(arguments);
        return next;
      },
      discoverSkill: function (list) {
        var next = game.createEvent('discoverSkill');
        next.player = this;
        next.setContent('discoverSkill');
        next.list = list;
        for (var i = 1; i < arguments.length; i++) {
          if (typeof arguments[i] == 'boolean') {
            next.forced = arguments[i];
          }
          else if (typeof arguments[i] == 'number') {
            next.num = arguments[i];
          }
          else if (typeof arguments[i] == 'string') {
            next.prompt = arguments[i];
          }
          else if (typeof arguments[i] === 'function') {
            next.ai = arguments[i];
          }
        }
      },
      chooseSkill: function (target) {
        var next = game.createEvent('chooseSkill');
        next.player = this;
        next.setContent('chooseSkill');
        next.target = target;
        for (var i = 1; i < arguments.length; i++) {
          if (typeof arguments[i] == 'string') {
            next.prompt = arguments[i];
          }
          else if (typeof arguments[i] == 'function') {
            next.func = arguments[i];
          }
        }
      },
      discoverCard: function (list) {
        var next = game.createEvent('discoverCard');
        next.player = this;
        next.setContent('discoverCard');
        next.list = list || lib.inpile.slice(0);
        next.forced = true;
        for (var i = 1; i < arguments.length; i++) {
          if (typeof arguments[i] == 'boolean') {
            next.forced = arguments[i];
          }
          else if (typeof arguments[i] == 'string') {
            switch (arguments[i]) {
              case 'use': next.use = true; break;
              case 'nogain': next.nogain = true; break;
              default: next.prompt = arguments[i];
            }
          }
          else if (typeof arguments[i] == 'number') {
            next.num = arguments[i];
          }
          else if (typeof arguments[i] === 'function') {
            next.ai = arguments[i];
          }
        }
        return next;
      },
      chooseCardButton: function () {
        var cards, prompt, forced, select;
        for (var i = 0; i < arguments.length; i++) {
          if (get.itemtype(arguments[i]) == 'cards') cards = arguments[i];
          else if (typeof arguments[i] == 'boolean') forced = arguments[i];
          else if (typeof arguments[i] == 'string') prompt = arguments[i];
          else if (get.itemtype(arguments[i]) == 'select' || typeof arguments[i] == 'number') select = arguments[i];
        }
        if (prompt == undefined) prompt = '请选择卡牌';
        return this.chooseButton(forced, select, 'hidden', [prompt, cards, 'hidden']);
      },
      chooseVCardButton: function () {
        var list, prompt, forced, select, notype = false;
        for (var i = 0; i < arguments.length; i++) {
          if (Array.isArray(arguments[i])) {
            list = arguments[i];
          }
          else if (arguments[i] == 'notype') {
            notype = true;
          }
          else if (typeof arguments[i] == 'boolean') forced = arguments[i];
          else if (typeof arguments[i] == 'string') prompt = arguments[i];
          else if (get.itemtype(arguments[i]) == 'select' || typeof arguments[i] == 'number') select = arguments[i];
        }
        for (var i = 0; i < list.length; i++) {
          list[i] = [notype ? '' : (get.subtype(list[i]) || get.type(list[i])), '', list[i]];
        }
        if (prompt == undefined) prompt = '请选择卡牌';
        return this.chooseButton(forced, select, 'hidden', [prompt, [list, 'vcard'], 'hidden']);
      },
      chooseButton: function () {
        var next = game.createEvent('chooseButton');
        for (var i = 0; i < arguments.length; i++) {
          if (typeof arguments[i] == 'boolean') {
            next.forced = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'dialog') {
            next.dialog = arguments[i];
            next.closeDialog = true;
          }
          else if (get.itemtype(arguments[i]) == 'select') {
            next.selectButton = arguments[i];
          }
          else if (typeof arguments[i] == 'number') {
            next.selectButton = [arguments[i], arguments[i]];
          }
          else if (typeof arguments[i] == 'function') {
            if (next.ai) next.filterButton = arguments[i];
            else next.ai = arguments[i];
          }
          else if (Array.isArray(arguments[i])) {
            next.createDialog = arguments[i];
          }
        }
        next.player = this;
        if (typeof next.forced != 'boolean') next.forced = false;
        if (next.isMine() == false && next.dialog) next.dialog.style.display = 'none';
        if (next.filterButton == undefined) next.filterButton = lib.filter.filterButton;
        if (next.selectButton == undefined) next.selectButton = [1, 1];
        if (next.ai == undefined) next.ai = function () { return 1 };
        next.setContent('chooseButton');
        next._args = Array.from(arguments);
        next.forceDie = true;
        return next;
      },
      chooseButtonOL: function (list, callback, ai) {
        var next = game.createEvent('chooseButtonOL');
        next.list = list;
        next.setContent('chooseButtonOL');
        next.ai = ai;
        next.callback = callback;
        next._args = Array.from(arguments);
        return next;
      },
      chooseCardOL: function () {
        var next = game.createEvent('chooseCardOL');
        next._args = [];
        for (var i = 0; i < arguments.length; i++) {
          if (get.itemtype(arguments[i]) == 'players') {
            next.list = arguments[i].slice(0);
          }
          else {
            next._args.push(arguments[i]);
          }
        }
        next.setContent('chooseCardOL');
        next._args.add('glow_result');
        return next;
      },
      chooseCard: function (choose) {
        var next = game.createEvent('chooseCard');
        next.player = this;
        if (arguments.length == 1 && get.is.object(choose)) {
          for (var i in choose) {
            next[i] = choose[i];
          }
        }
        else {
          for (var i = 0; i < arguments.length; i++) {
            if (typeof arguments[i] == 'number') {
              next.selectCard = [arguments[i], arguments[i]];
            }
            else if (get.itemtype(arguments[i]) == 'select') {
              next.selectCard = arguments[i];
            }
            else if (typeof arguments[i] == 'boolean') {
              next.forced = arguments[i];
            }
            else if (get.itemtype(arguments[i]) == 'position') {
              next.position = arguments[i];
            }
            else if (typeof arguments[i] == 'function') {
              if (next.filterCard) next.ai = arguments[i];
              else next.filterCard = arguments[i];
            }
            else if (typeof arguments[i] == 'object' && arguments[i]) {
              next.filterCard = get.filter(arguments[i]);
            }
            else if (arguments[i] == 'glow_result') {
              next.glow_result = true;
            }
            else if (typeof arguments[i] == 'string') {
              get.evtprompt(next, arguments[i]);
            }
          }
        }
        if (next.filterCard == undefined) next.filterCard = lib.filter.all;
        if (next.selectCard == undefined) next.selectCard = [1, 1];
        if (next.ai == undefined) next.ai = get.unuseful3;
        next.setContent('chooseCard');
        next._args = Array.from(arguments);
        return next;
      },
      chooseUseTarget: function () {
        var next = game.createEvent('chooseUseTarget');
        next.player = this;
        for (var i = 0; i < arguments.length; i++) {
          if (get.itemtype(arguments[i]) == 'cards') {
            next.cards = arguments[i].slice(0);
          }
          else if (get.itemtype(arguments[i]) == 'card') {
            next.card = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'players') {
            next.targets = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'player') {
            next.targets = [arguments[i]];
          }
          else if (get.is.object(arguments[i]) && arguments[i].name) {
            next.card = arguments[i];
          }
          else if (typeof arguments[i] == 'string') {
            if (arguments[i] == 'nopopup') {
              next.nopopup = true;
            }
            else if (arguments[i] == 'noanimate') {
              next.animate = false;
            }
            else if (arguments[i] == 'nothrow') {
              next.throw = false;
            }
            else if (arguments[i] == 'nodistance') {
              next.nodistance = true;
            }
            else if (arguments[i] == 'noTargetDelay') {
              next.noTargetDelay = true;
            }
            else if (arguments[i] == 'nodelayx') {
              next.nodelayx = true;
            }
            else if (lib.card[arguments[i]] && !next.card) {
              next.card = { name: arguments[i], isCard: true };
            }
            else get.evtprompt(next, arguments[i]);
          }
          else if (arguments[i] === true) {
            next.forced = true;
          }
          else if (arguments[i] === false) {
            next.addCount = false;
          }
        }
        if (!next.targets) next.targets = game.players.slice(0);
        if (next.cards == undefined) {
          if (get.itemtype(next.card) == 'card') {
            next.cards = [next.card];
          }
          else next.cards = [];
        }
        else if (next.card == undefined) {
          if (next.cards) {
            next.card = next.cards[0];
          }
        }
        next.setContent('chooseUseTarget');
        next._args = Array.from(arguments);
        return next;
        // Fully Online-Ready! Enjoy It!
      },
      chooseTarget: function () {
        var next = game.createEvent('chooseTarget');
        next.player = this;
        for (var i = 0; i < arguments.length; i++) {
          if (typeof arguments[i] == 'number') {
            next.selectTarget = [arguments[i], arguments[i]];
          }
          else if (get.itemtype(arguments[i]) == 'select') {
            next.selectTarget = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'dialog') {
            next.dialog = arguments[i];
            next.prompt = false;
          }
          else if (typeof arguments[i] == 'boolean') {
            next.forced = arguments[i];
          }
          else if (typeof arguments[i] == 'function') {
            if (next.filterTarget) next.ai = arguments[i];
            else next.filterTarget = arguments[i];
          }
          else if (typeof arguments[i] == 'string') {
            get.evtprompt(next, arguments[i]);
          }
        }
        if (next.filterTarget == undefined) next.filterTarget = lib.filter.all;
        if (next.selectTarget == undefined) next.selectTarget = [1, 1];
        if (next.ai == undefined) next.ai = get.attitude2;
        next.setContent('chooseTarget');
        next._args = Array.from(arguments);
        next.forceDie = true;
        return next;
      },
      chooseCardTarget: function (choose) {
        var next = game.createEvent('chooseCardTarget');
        next.player = this;
        if (arguments.length == 1) {
          for (var i in choose) {
            next[i] = choose[i];
          }
        }
        if (typeof next.filterCard == 'object') {
          next.filterCard = get.filter(next.filterCard);
        }
        if (typeof next.filterTarget == 'object') {
          next.filterTarget = get.filter(next.filterTarget, 2);
        }
        if (next.filterCard == undefined || next.filterCard === true) {
          next.filterCard = lib.filter.all;
        }
        if (next.selectCard == undefined) {
          next.selectCard = 1;
        }
        if (next.filterTarget == undefined || next.filterTarget === true) {
          next.filterTarget = lib.filter.all;
        }
        if (next.selectTarget == undefined) {
          next.selectTarget = 1;
        }
        if (next.ai1 == undefined) next.ai1 = get.unuseful2;
        if (next.ai2 == undefined) next.ai2 = get.attitude2;
        next.setContent('chooseCardTarget');
        next._args = Array.from(arguments);
        return next;
      },
      chooseControlList: function () {
        var list = [];
        var prompt = null;
        var forced = 'cancel2';
        var func = null;
        for (var i = 0; i < arguments.length; i++) {
          if (typeof arguments[i] == 'string') {
            if (!prompt) {
              prompt = arguments[i];
            }
            else {
              list.push(arguments[i]);
            }
          }
          else if (Array.isArray(arguments[i])) {
            list = arguments[i];
          }
          else if (arguments[i] === true) {
            forced = null;
          }
          else if (typeof arguments[i] == 'function') {
            func = arguments[i];
          }
        }
        return this.chooseControl(forced, func).set('choiceList', list).set('prompt', prompt);
      },
      chooseControl: function () {
        var next = game.createEvent('chooseControl');
        next.controls = [];
        for (var i = 0; i < arguments.length; i++) {
          if (typeof arguments[i] == 'string') {
            if (arguments[i] == 'dialogcontrol') {
              next.dialogcontrol = true;
            }
            else if (arguments[i] == 'seperate') {
              next.seperate = true;
            }
            else {
              next.controls.push(arguments[i]);
            }
          }
          else if (Array.isArray(arguments[i])) {
            next.controls = next.controls.concat(arguments[i]);
          }
          else if (typeof arguments[i] == 'function') {
            next.ai = arguments[i];
          }
          else if (typeof arguments[i] == 'number') {
            next.choice = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'dialog') {
            next.dialog = arguments[i];
          }
        }
        next.player = this;
        if (next.choice == undefined) next.choice = 0;
        next.setContent('chooseControl');
        next._args = Array.from(arguments);
        next.forceDie = true;
        return next;
      },
      chooseBool: function () {
        var next = game.createEvent('chooseBool');
        for (var i = 0; i < arguments.length; i++) {
          if (typeof arguments[i] == 'boolean') {
            next.choice = arguments[i];
          }
          else if (typeof arguments[i] == 'function') {
            next.ai = arguments[i];
          }
          else if (typeof arguments[i] == 'string') {
            get.evtprompt(next, arguments[i]);
          }
          else if (get.itemtype(arguments[i]) == 'dialog') {
            next.dialog = arguments[i];
          }
          if (next.choice == undefined) next.choice = true;
        }
        next.player = this;
        next.setContent('chooseBool');
        next._args = Array.from(arguments);
        next.forceDie = true;
        return next;
      },
      chooseDrawRecover: function () {
        var next = game.createEvent('chooseDrawRecover', false);
        next.player = this;
        for (var i = 0; i < arguments.length; i++) {
          if (typeof arguments[i] == 'number') {
            if (typeof next.num1 == 'number') {
              next.num2 = arguments[i];
            }
            else {
              next.num1 = arguments[i];
            }
          }
          else if (typeof arguments[i] == 'boolean') {
            next.forced = arguments[i];
          }
          else if (typeof arguments[i] == 'string') {
            next.prompt = arguments[i];
          }
          else if (typeof arguments[i] == 'function') {
            next.ai = arguments[i];
          }
        }
        if (typeof next.num1 != 'number') {
          next.num1 = 1;
        }
        if (typeof next.num2 != 'number') {
          next.num2 = 1;
        }
        next.setContent('chooseDrawRecover');
        return next;
      },
      choosePlayerCard: function () {
        var next = game.createEvent('choosePlayerCard');
        next.player = this;
        for (var i = 0; i < arguments.length; i++) {
          if (get.itemtype(arguments[i]) == 'player') {
            next.target = arguments[i];
          }
          else if (typeof arguments[i] == 'number') {
            next.selectButton = [arguments[i], arguments[i]];
          }
          else if (get.itemtype(arguments[i]) == 'select') {
            next.selectButton = arguments[i];
          }
          else if (typeof arguments[i] == 'boolean') {
            next.forced = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'position') {
            next.position = arguments[i];
          }
          else if (arguments[i] == 'visible') {
            next.visible = true;
          }
          else if (typeof arguments[i] == 'function') {
            if (next.ai) next.filterButton = arguments[i];
            else next.ai = arguments[i];
          }
          else if (typeof arguments[i] == 'object' && arguments[i]) {
            next.filterButton = get.filter(arguments[i]);
          }
          else if (typeof arguments[i] == 'string') {
            next.prompt = arguments[i];
          }
        }
        if (next.filterButton == undefined) next.filterButton = lib.filter.all;
        if (next.position == undefined) next.position = 'he';
        if (next.selectButton == undefined) next.selectButton = [1, 1];
        if (next.ai == undefined) next.ai = function (button) {
          var val = get.buttonValue(button);
          if (get.attitude(_status.event.player, get.owner(button.link)) > 0) return -val;
          return val;
        };
        next.setContent('choosePlayerCard');
        next._args = Array.from(arguments);
        return next;
      },
      discardPlayerCard: function () {
        var next = game.createEvent('discardPlayerCard');
        next.player = this;
        for (var i = 0; i < arguments.length; i++) {
          if (get.itemtype(arguments[i]) == 'player') {
            next.target = arguments[i];
          }
          else if (typeof arguments[i] == 'number') {
            next.selectButton = [arguments[i], arguments[i]];
          }
          else if (get.itemtype(arguments[i]) == 'select') {
            next.selectButton = arguments[i];
          }
          else if (typeof arguments[i] == 'boolean') {
            next.forced = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'position') {
            next.position = arguments[i];
          }
          else if (arguments[i] == 'visible') {
            next.visible = true;
          }
          else if (typeof arguments[i] == 'function') {
            if (next.ai) next.filterButton = arguments[i];
            else next.ai = arguments[i];
          }
          else if (typeof arguments[i] == 'object' && arguments[i]) {
            next.filterButton = get.filter(arguments[i]);
          }
          else if (typeof arguments[i] == 'string') {
            next.prompt = arguments[i];
          }
        }
        if (next.filterButton == undefined) next.filterButton = lib.filter.all;
        if (next.position == undefined) next.position = 'he';
        if (next.selectButton == undefined) next.selectButton = [1, 1];
        if (next.ai == undefined) next.ai = function (button) {
          var val = get.buttonValue(button);
          if (get.attitude(_status.event.player, get.owner(button.link)) > 0) return -val;
          return val;
        };
        next.setContent('discardPlayerCard');
        next._args = Array.from(arguments);
        return next;
      },
      gainPlayerCard: function () {
        var next = game.createEvent('gainPlayerCard');
        next.player = this;
        for (var i = 0; i < arguments.length; i++) {
          if (get.itemtype(arguments[i]) == 'player') {
            next.target = arguments[i];
          }
          else if (typeof arguments[i] == 'number') {
            next.selectButton = [arguments[i], arguments[i]];
          }
          else if (get.itemtype(arguments[i]) == 'select') {
            next.selectButton = arguments[i];
          }
          else if (typeof arguments[i] == 'boolean') {
            next.forced = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'position') {
            next.position = arguments[i];
          }
          else if (arguments[i] == 'visible') {
            next.visible = true;
          }
          else if (arguments[i] == 'visibleMove') {
            next.visibleMove = true;
          }
          else if (typeof arguments[i] == 'function') {
            if (next.ai) next.filterButton = arguments[i];
            else next.ai = arguments[i];
          }
          else if (typeof arguments[i] == 'object' && arguments[i]) {
            next.filterButton = get.filter(arguments[i]);
          }
          else if (typeof arguments[i] == 'string') {
            next.prompt = arguments[i];
          }
        }
        if (next.filterButton == undefined) next.filterButton = lib.filter.all;
        if (next.position == undefined) next.position = 'he';
        if (next.selectButton == undefined) next.selectButton = [1, 1];
        if (next.ai == undefined) next.ai = function (button) {
          var val = get.buttonValue(button);
          if (get.attitude(_status.event.player, get.owner(button.link)) > 0) return -val;
          return val;
        };
        next.setContent('gainPlayerCard');
        next._args = Array.from(arguments);
        return next;
      },
      showHandcards: function (str) {
        var next = game.createEvent('showHandcards');
        next.player = this;
        if (typeof str == 'string') {
          next.prompt = str;
        }
        next.setContent('showHandcards');
        next._args = Array.from(arguments);
        return next;
      },
      showCards: function (cards, str) {
        var next = game.createEvent('showCards');
        next.player = this;
        next.str = str;
        if (typeof cards == 'string') {
          str = cards;
          cards = next.str;
          next.str = str;
        }
        if (get.itemtype(cards) == 'card') next.cards = [cards];
        else if (get.itemtype(cards) == 'cards') next.cards = cards.slice(0);
        else _status.event.next.remove(next);
        next.setContent('showCards');
        next._args = Array.from(arguments);
        return next;
      },
      viewCards: function (str, cards) {
        var next = game.createEvent('viewCards');
        next.player = this;
        next.str = str;
        next.cards = cards.slice(0);
        next.setContent('viewCards');
        next._args = Array.from(arguments);
        return next;
      },
      viewHandcards: function (target) {
        var cards = target.getCards('h');
        if (cards.length) {
          return this.viewCards(get.translation(target) + '的手牌', cards);
        }
        else {
          return false;
        }
      },
      canMoveCard: function (withatt, nojudge, moveHandcard) {
        var player = this;
        return game.hasPlayer(function (current) {
          var att = get.sgn(get.attitude(player, current));
          if (!withatt || att != 0) {
            var es = current.getCards('e');
            for (var i = 0; i < es.length; i++) {
              if (game.hasPlayer(function (current2) {
                if (withatt) {
                  if (get.sgn(get.value(es[i], current)) != -att) return false;
                  var att2 = get.sgn(get.attitude(player, current2));
                  if (att == att2 || att2 != get.sgn(get.effect(current2, es[i], player, current2))) return false;
                }
                return current != current2 && !current2.isMin() && current2.isEmpty(get.subtype(es[i]));
              })) {
                return true;
              }
            }
          }
          if (!nojudge && (!withatt || att > 0)) {
            var js = current.getCards('j');
            for (var i = 0; i < js.length; i++) {
              if (game.hasPlayer(function (current2) {
                if (withatt) {
                  var att2 = get.attitude(player, current2);
                  if (att2 >= 0) return false;
                }
                return current != current2 && current2.canAddJudge(js[i]);
              })) {
                return true;
              }
            }
          }
          if (moveHandcard == true) {
            if (current.countCards('h') > 0) return true;
          }
        });
      },
      /**
       * 移动场上牌
       * 本角色移动场上的牌
       * @returns {GameCores.Bases.Event}
       */
      moveCard: function () {
        var next = game.createEvent('moveCard');
        next.player = this;
        for (var i = 0; i < arguments.length; i++) {
          if (typeof arguments[i] == 'boolean') {
            next.forced = arguments[i];
          }
          else if (typeof arguments[i] == 'string') {
            get.evtprompt(next, arguments[i]);
          }
          else if (typeof arguments[i] == 'function') {
            if (next.sourceFilterTarget) next.ai = arguments[i];
            else next.sourceFilterTarget = arguments[i];
          }
          else if (Array.isArray(arguments[i])) {
            for (var j = 0; j < arguments[i].length; j++) {
              if (typeof arguments[i][j] != 'string') break;
            }
            if (j == arguments[i].length) {
              next.targetprompt = arguments[i];
            }
          }
        }
        next.setContent('moveCard');
        next._args = Array.from(arguments);
        return next;
      },
      /**
       * 本角色使用牌或技能；`chooseToUse`时调用
       * @function
       * @param {*} result `chooseToUse`的结果
       * @param {?GameCores.Bases.Event} [Evt] 父事件，如果不指定，使用当前事件作为父事件
       */
      useResult: function (result, Evt) {
        Evt = Evt || _status.event;
        if (result._sendskill) {
          lib.skill[result._sendskill[0]] = result._sendskill[1];
        }
        if (Evt.onresult) {
          Evt.onresult(result);
        }
        if (result.skill) {
          var info = get.info(result.skill);
          if (info.onuse) {
            info.onuse(result, this);
          }
          if (info.direct && !info.clearTime) {
            _status.noclearcountdown = true;
          }
        }
        if (Evt.logSkill) {
          if (typeof Evt.logSkill == 'string') {
            this.logSkill(Evt.logSkill);
          }
          else if (Array.isArray(Evt.logSkill)) {
            this.logSkill.apply(this, Evt.logSkill);
          }
        }
        if (result.card || !result.skill) {
          result.used = result.card || result.cards[0];
          var next = this.useCard(result.card, result.cards, result.targets, result.skill);
          next.oncard = Evt.oncard;
          next.respondTo = Evt.respondTo;
          if (Evt.addCount === false) {
            next.addCount = false;
          }
          return next;
        }
        else if (result.skill) {
          result.used = result.skill;
          return this.useSkill(result.skill, result.cards, result.targets);
        }
      },
      useCard: function () {
        var next = game.createEvent('useCard');
        next.player = this;
        next.num = 0;
        for (var i = 0; i < arguments.length; i++) {
          if (get.itemtype(arguments[i]) == 'cards') {
            next.cards = arguments[i].slice(0);
          }
          else if (get.itemtype(arguments[i]) == 'players') {
            next.targets = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'player') {
            next.targets = [arguments[i]];
          }
          else if (get.itemtype(arguments[i]) == 'card') {
            next.card = arguments[i];
          }
          else if (typeof arguments[i] == 'object' && arguments[i] && arguments[i].name) {
            next.card = arguments[i];
          }
          else if (typeof arguments[i] == 'string') {
            if (arguments[i] == 'noai') {
              next.noai = true;
            }
            else if (arguments[i] == 'nowuxie') {
              next.nowuxie = true;
            }
            else {
              next.skill = arguments[i];
            }
          }
          else if (typeof arguments[i] == 'boolean') {
            next.addCount = arguments[i];
          }
        }
        if (next.cards == undefined) {
          if (get.itemtype(next.card) == 'card') {
            next.cards = [next.card];
          }
          else next.cards = [];
        }
        else if (next.card == undefined) {
          if (next.cards) {
            next.card = next.cards[0];
          }
        }
        if (!next.targets) {
          next.targets = [];
        }
        if (next.card) {
          next.card = get.autoViewAs(next.card, false, next.player);
          var info = get.info(next.card);
          if (info.changeTarget) {
            info.changeTarget(next.player, next.targets);
          }
          if (info.singleCard) {
            next._targets = next.targets.slice(0);
            next.target = next.targets[0];
            next.addedTargets = next.targets.splice(1);
            if (next.addedTargets.length) {
              next.addedTarget = next.addedTargets[0];
            }
          }
          if (!next.card.isCard && next.cards.length) {
            next.card.cards = next.cards.slice(0);
          }
        }
        for (var i = 0; i < next.targets.length; i++) {
          if (get.attitude(this, next.targets[i]) >= -1 && get.attitude(this, next.targets[i]) < 0) {
            if (!this.ai.tempIgnore) this.ai.tempIgnore = [];
            this.ai.tempIgnore.add(next.targets[i]);
          }
        }
        if (typeof this.logAi == 'function' && !next.noai && !get.info(next.card).noai) {
          var postAi = get.info(next.card).postAi;
          if (postAi && postAi(next.targets)) {
            next.postAi = true;
          }
          else {
            this.logAi(next.targets, next.card);
          }
        }
        next.stocktargets = next.targets.slice(0);
        next.setContent('useCard');
        return next;
      },
      useSkill: function () {
        var next = game.createEvent('useSkill');
        next.player = this;
        next.num = 0;
        for (var i = 0; i < arguments.length; i++) {
          if (get.itemtype(arguments[i]) == 'cards') {
            next.cards = arguments[i].slice(0);
          }
          else if (get.itemtype(arguments[i]) == 'players') {
            next.targets = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'card') {
            next.card = arguments[i];
          }
          else if (typeof arguments[i] == 'string') {
            next.skill = arguments[i];
          }
          else if (typeof arguments[i] == 'boolean') {
            next.addCount = arguments[i];
          }
        }
        if (next.cards == undefined) {
          next.cards = [];
        }
        if (next.skill && get.info(next.skill) && get.info(next.skill).changeTarget) {
          get.info(next.skill).changeTarget(next.player, next.targets);
        }
        if (next.targets) {
          for (var i = 0; i < next.targets.length; i++) {
            if (get.attitude(this, next.targets[i]) >= -1 && get.attitude(this, next.targets[i]) < 0) {
              if (!this.ai.tempIgnore) this.ai.tempIgnore = [];
              this.ai.tempIgnore.add(next.targets[i]);
            }
          }
          if (typeof this.logAi == 'function') {
            this.logAi(next.targets, next.skill);
          }
        }
        else {
          next.targets = [];
        }
        next.setContent('useSkill');
        return next;
      },
      drawTo: function (num, args) {
        var num2 = num - this.countCards('h');
        if (!num2) return;
        var next = this.draw(num2);
        if (Array.isArray(args)) {
          for (var i = 0; i < args.length; i++) {
            if (get.itemtype(args[i]) == 'player') {
              next.source = args[i];
            }
            else if (typeof args[i] == 'boolean') {
              next.animate = args[i];
            }
            else if (args[i] == 'nodelay') {
              next.animate = false;
              next.$draw = true;
            }
            else if (args[i] == 'visible') {
              next.visible = true;
            }
            else if (args[i] == 'bottom') {
              next.bottom = true;
            }
            else if (typeof args[i] == 'object' && args[i] && args[i].drawDeck != undefined) {
              next.drawDeck = args[i].drawDeck;
            }
          }
        }
        return next;
      },
      draw: function () {
        var next = game.createEvent('draw');
        next.player = this;
        for (var i = 0; i < arguments.length; i++) {
          if (get.itemtype(arguments[i]) == 'player') {
            next.source = arguments[i];
          }
          else if (typeof arguments[i] == 'number') {
            next.num = arguments[i];
          }
          else if (typeof arguments[i] == 'boolean') {
            next.animate = arguments[i];
          }
          else if (arguments[i] == 'nodelay') {
            next.animate = false;
            next.$draw = true;
          }
          else if (arguments[i] == 'visible') {
            next.visible = true;
          }
          else if (arguments[i] == 'bottom') {
            next.bottom = true;
          }
          else if (typeof arguments[i] == 'object' && arguments[i] && arguments[i].drawDeck != undefined) {
            next.drawDeck = arguments[i].drawDeck;
          }
        }
        if (next.num == undefined) next.num = 1;
        if (next.num <= 0) _status.event.next.remove(next);
        next.setContent('draw');
        if (lib.config.mode == 'stone' && _status.mode == 'deck' &&
          next.drawDeck == undefined && !next.player.isMin() && next.num > 1) {
          next.drawDeck = 1;
        }
        return next;
      },
      randomDiscard: function () {
        var position = 'he', num = 1, delay = null;
        for (var i = 0; i < arguments.length; i++) {
          if (typeof arguments[i] == 'number') {
            num = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'position') {
            position = arguments[i];
          }
          else if (typeof arguments[i] == 'boolean') {
            delay = arguments[i];
          }
        }
        var cards = this.getCards(position).randomGets(num);
        if (cards.length) {
          var next = this.discard(cards, 'notBySelf');
          if (typeof delay == 'boolean') {
            next.delay = delay;
          }
        }
        return cards;
      },
      randomGain: function () {
        var position = 'he', num = 1, target = null, line = false;
        for (var i = 0; i < arguments.length; i++) {
          if (typeof arguments[i] == 'number') {
            num = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'position') {
            position = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'player') {
            target = arguments[i];
          }
          else if (typeof arguments[i] == 'boolean') {
            line = arguments[i];
          }
        }
        if (target) {
          var cards = target.getCards(position).randomGets(num);
          if (cards.length) {
            if (line) {
              this.line(target, 'green');
            }
            this.gain(cards, target, 'log', 'bySelf');
            target.$giveAuto(cards, this);
          }
          return cards;
        }
        return [];
      },
      discard: function () {
        var next = game.createEvent('discard');
        next.player = this;
        next.num = 0;
        for (var i = 0; i < arguments.length; i++) {
          if (get.itemtype(arguments[i]) == 'player') {
            next.source = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'cards') {
            next.cards = arguments[i].slice(0);
          }
          else if (get.itemtype(arguments[i]) == 'card') {
            next.cards = [arguments[i]];
          }
          else if (typeof arguments[i] == 'boolean') {
            next.animate = arguments[i];
          }
          else if (get.objtype(arguments[i]) == 'div') {
            next.position = arguments[i];
          }
          else if (arguments[i] == 'notBySelf') {
            next.notBySelf = true;
          }
        }
        if (next.cards == undefined) _status.event.next.remove(next);
        next.setContent('discard');
        return next;
      },
      respond: function () {
        var next = game.createEvent('respond');
        next.player = this;
        for (var i = 0; i < arguments.length; i++) {
          if (get.itemtype(arguments[i]) == 'cards') {
            next.cards = arguments[i].slice(0);
          }
          else if (get.itemtype(arguments[i]) == 'card') {
            next.card = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'player') {
            next.source = arguments[i];
          }
          else if (typeof arguments[i] == 'object' && arguments[i] && arguments[i].name) {
            next.card = arguments[i];
          }
          else if (typeof arguments[i] == 'boolean') next.animate = arguments[i];
          else if (arguments[i] == 'highlight') next.highlight = true;
          else if (arguments[i] == 'noOrdering') next.noOrdering = true;
          else if (typeof arguments[i] == 'string') next.skill = arguments[i];
        }
        if (next.cards == undefined) {
          if (get.itemtype(next.card) == 'card') {
            next.cards = [next.card];
          }
          else {
            next.cards = [];
          }
        }
        else if (next.card == undefined) {
          if (next.cards) {
            next.card = next.cards[0];
            if (!next.skill) {
              next.card = get.autoViewAs(next.card, null, next.player);
            }
          }
        }
        next.setContent('respond');
        return next;
      },
      swapHandcards: function (target, cards1, cards2) {
        var next = game.createEvent('swapHandcards', false);
        next.player = this;
        next.target = target;
        if (cards1) next.cards1 = cards1;
        if (cards2) next.cards2 = cards2;
        next.setContent('swapHandcards');
        return next;
      },
      directequip: function (cards) {
        for (var i = 0; i < cards.length; i++) {
          this.$equip(cards[i]);
        }
        if (!_status.video) {
          game.addVideo('directequip', this, get.cardsInfo(cards));
        }
      },
      directgain: function (cards, broadcast, gaintag) {
        var hs = this.getCards('hs');
        for (var i = 0; i < cards.length; i++) {
          if (hs.contains(cards[i])) {
            cards.splice(i--, 1);
          }
        }
        for (var i = 0; i < cards.length; i++) {
          cards[i].fix();
          if (gaintag) cards[i].addGaintag(gaintag);
          var sort = lib.config.sort_card(cards[i]);
          if (this == game.me) {
            cards[i].classList.add('drawinghidden');
          }
          if (get.is.singleHandcard() || sort > 0) {
            this.node.handcards1.insertBefore(cards[i], this.node.handcards1.firstChild);
          }
          else {
            this.node.handcards2.insertBefore(cards[i], this.node.handcards2.firstChild);
          }
        }
        if (this == game.me || _status.video) ui.updatehl();
        if (!_status.video) {
          game.addVideo('directgain', this, get.cardsInfo(cards));
          this.update();
        }
        if (broadcast !== false) game.broadcast(function (player, cards) {
          player.directgain(cards);
        }, this, cards);
        return this;
      },
      /**
       * 本角色获取游戏牌到武将牌上，从除本角色武将牌上、手牌外的区域
       * @param {Array<GameCores.GameObjects.Card>} cards 要获取的游戏牌数组，如果一张游戏牌在本角色(手牌|武将牌上)，就从数组中移除它
       * @param {?boolean} [broadcast] 如果为trueh或未指定，通过{@link game.broadcast}同步获取游戏牌；如果为false，本机更新
       * @param {string} [gaintag] 为此次通过此函数移动到武将牌上的每张游戏牌设置`card.gaintag=`
       */
      directgains: function (cards, broadcast, gaintag) {
        var hs = this.getCards('hs');
        for (var i = 0; i < cards.length; i++) {
          if (hs.contains(cards[i])) {
            cards.splice(i--, 1);
          }
        }
        var addLast = function (card, node) {
          if (gaintag) {
            for (var i = 0; i < node.childNodes.length; i++) {
              var add = node.childNodes[node.childNodes.length - i - 1];
              if (!add.classList.contains('glows')) break;
              if (add.hasGaintag(gaintag)) {
                node.insertBefore(card, add.nextSibling);
                return;
              }
            }
          }
          node.appendChild(card);
        }
        for (var i = 0; i < cards.length; i++) {
          cards[i].fix();
          cards[i].remove();
          if (gaintag) cards[i].addGaintag(gaintag);
          cards[i].classList.add('glows');
          if (this == game.me) {
            cards[i].classList.add('drawinghidden');
          }
          if (get.is.singleHandcard()) {
            addLast(cards[i], this.node.handcards1);
          }
          else {
            addLast(cards[i], this.node.handcards2);
          }
        }
        if (this == game.me || _status.video) ui.updatehl();
        if (!_status.video) {
          game.addVideo('directgains', this, get.cardsInfo(cards));
          this.update();
        }
        if (broadcast !== false) game.broadcast(function (player, cards, gaintag) {
          player.directgains(cards, null, gaintag);//[recommend] use false instead of null
        }, this, cards, gaintag);
        return this;
      },
      gainMultiple: function (targets, position) {
        var next = game.createEvent('gainMultiple', false);
        next.setContent('gainMultiple');
        next.player = this;
        next.targets = targets;
        next.position = position || 'h';
        return next;
      },
      gain: function () {
        var next = game.createEvent('gain');
        next.player = this;
        for (var i = 0; i < arguments.length; i++) {
          if (get.itemtype(arguments[i]) == 'player') {
            next.source = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'cards') {
            next.cards = arguments[i].slice(0);
          }
          else if (get.itemtype(arguments[i]) == 'card') {
            next.cards = [arguments[i]];
          }
          else if (arguments[i] === 'log') {
            next.log = true;
          }
          else if (arguments[i] == 'fromStorage') {
            next.fromStorage = true;
          }
          else if (arguments[i] == 'bySelf') {
            next.bySelf = true;
          }
          else if (typeof arguments[i] == 'string') {
            next.animate = arguments[i];
          }
          else if (typeof arguments[i] == 'boolean') {
            next.delay = arguments[i];
          }
        }
        if (next.animate == 'gain2' || next.animate == 'draw2') {
          if (!next.hasOwnProperty('log')) {
            next.log = true;
          }
        }
        next.setContent('gain');
        next.getl = function (player) {
          var that = this;
          var map = {
            player: player,
            hs: [],
            es: [],
            js: [],
            ss: [],
            cards: [],
            cards2: [],
          };
          player.getHistory('lose', function (evt) {
            if (evt.parent == that) {
              map.hs.addArray(evt.hs);
              map.es.addArray(evt.es);
              map.js.addArray(evt.js);
              map.ss.addArray(evt.ss);
              map.cards.addArray(evt.cards);
              map.cards2.addArray(evt.cards2);
            }
          });
          if (map.cards.length > 0 || map.ss.length > 0) return map;
        };
        next.gaintag = [];
        return next;
      },
      give: function (cards, target, visible) {
        var next = target.gain(cards, this);
        next.animate = visible ? 'give' : 'giveAuto';
      },
      lose: function () {
        var next = game.createEvent('lose');
        next.player = this;
        next.forceDie = true;
        for (var i = 0; i < arguments.length; i++) {
          if (get.itemtype(arguments[i]) == 'player') {
            next.source = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'cards') {
            next.cards = arguments[i].slice(0);
          }
          else if (get.itemtype(arguments[i]) == 'card') {
            next.cards = [arguments[i]];
          }
          else if (get.objtype(arguments[i]) == 'div') {
            next.position = arguments[i];
          }
          else if (arguments[i] == 'toStorage') {
            next.toStorage = true;
          }
          else if (arguments[i] == 'visible') {
            next.visible = true;
          }
          else if (arguments[i] == 'insert') {
            next.insert_card = true;
          }
        }
        if (next.cards) {
          var hej = this.getCards('hejs');
          for (var i = 0; i < next.cards.length; i++) {
            if (!hej.contains(next.cards[i])) {
              next.cards.splice(i--, 1);
            }
          }
        }
        if (!next.cards || !next.cards.length) {
          _status.event.next.remove(next);
        }
        else {
          if (next.position == undefined) next.position = ui.discardPile;
          next.cards = next.cards.slice(0);
        }
        next.setContent('lose');
        next.getl = function (player) {
          if (this.getlx !== false && this.player == player) return this;
        };
        return next;
      },
      damage: function (...args) {
        let next = game.createEvent('damage');
        //next.forceDie=true;
        next.player = this;
        let nocard, nosource;
        let Evt = _status.event;
        for (let v of args) {
          if (get.itemtype(v) == 'cards') {
            next.cards = v.slice(0);
          }
          else if (get.itemtype(v) == 'card') {
            next.card = v;
          }
          else if (typeof v == 'number') {
            next.num = v;
          }
          else if (get.itemtype(v) == 'player') {
            next.source = v;
          }
          else if (typeof v == 'object' && v && v.name) {
            next.card = v;
          }
          else if (v == 'nocard') {
            nocard = true;
          }
          else if (v == 'nosource') {
            nosource = true;
          }
          else if (v == 'notrigger') {
            next._triggered = null;
            next.notrigger = true;
          }
          else if (v === 'nofatal'){
            next.nofatal = true
          }
          else if (get.itemtype(v) == 'nature') {
            next.nature = v;
          }
        }
        if (next.card == undefined && !nocard) next.card = Evt.card;
        if (next.cards == undefined && !nocard) next.cards = Evt.cards;
        if (next.source == undefined && !nosource) next.source = Evt.player;
        if (next.source && next.source.isDead()) delete next.source;
        if (next.num == undefined) next.num = 1;
        if (next.nature == 'poison') delete next._triggered;
        next.setContent('damage');
        next.filterStop = function () {
          if (this.source && this.source.isDead()) delete this.source;
          if (this.num <= 0) {
            delete this.filterStop;
            this.trigger('damageZero');
            this.finish();
            this._triggered = null;
            return true;
          }
        };
        return next;
      },
      recover: function () {
        var next = game.createEvent('recover');
        next.player = this;
        var nocard, nosource;
        var Evt = _status.event;
        for (var i = 0; i < arguments.length; i++) {
          if (get.itemtype(arguments[i]) == 'cards') {
            next.cards = arguments[i].slice(0);
          }
          else if (get.itemtype(arguments[i]) == 'card') {
            next.card = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'player') {
            next.source = arguments[i];
          }
          else if (typeof arguments[i] == 'object' && arguments[i] && arguments[i].name) {
            next.card = arguments[i];
          }
          else if (typeof arguments[i] == 'number') {
            next.num = arguments[i];
          }
          else if (arguments[i] == 'nocard') {
            nocard = true;
          }
          else if (arguments[i] == 'nosource') {
            nosource = true;
          }
        }
        if (next.card == undefined && !nocard) next.card = Evt.card;
        if (next.cards == undefined && !nocard) next.cards = Evt.cards;
        if (next.source == undefined && !nosource) next.source = Evt.player;
        if (next.num == undefined) next.num = 1;
        if (next.num <= 0) _status.event.next.remove(next);
        next.setContent('recover');
        return next;
      },
      doubleDraw: function () {
        if (get.is.changban()) return;
        var next = game.createEvent('doubleDraw');
        next.player = this;
        next.setContent('doubleDraw');
        return next;
      },
      loseHp: function (num) {
        var next = game.createEvent('loseHp');
        next.num = num;
        next.player = this;
        if (next.num == undefined) next.num = 1;
        next.setContent('loseHp');
        return next;
      },
      loseMaxHp: function () {
        var next = game.createEvent('loseMaxHp');
        next.player = this;
        var nosource;
        var Evt = _status.event;
        next.num = 1;
        for (var i = 0; i < arguments.length; i++) {
          if (get.itemtype(arguments[i]) == 'player') {
            next.source = arguments[i];
          }
          else if (typeof arguments[i] === 'number') {
            next.num = arguments[i];
          }
          else if (typeof arguments[i] === 'boolean') {
            next.forced = arguments[i];
          }
          else if (arguments[i] == 'nosource') {
            nosource = true;
          }
        }
        if (next.source == undefined && !nosource) next.source = Evt.player;
        next.setContent('loseMaxHp');
        return next;
      },
      gainMaxHp: function () {
        var next = game.createEvent('gainMaxHp');
        next.player = this;
        var nosource;
        var Evt = _status.event;
        next.num = 1;
        for (var i = 0; i < arguments.length; i++) {
          if (typeof arguments[i] === 'number') {
            next.num = arguments[i];
          }
          else if (get.itemtype(arguments[i]) == 'player') {
            next.source = arguments[i];
          }
          else if (typeof arguments[i] === 'boolean') {
            next.forced = arguments[i];
          }
          else if (arguments[i] == 'nosource') {
            nosource = true;
          }
        }
        if (next.source == undefined && !nosource) next.source = Evt.player;
        next.setContent('gainMaxHp');
        return next;
      },
      changeHp: function (num, popup) {
        var next = game.createEvent('changeHp', false);
        next.num = num;
        if (popup != undefined) next.popup = popup;
        next.player = this;
        next.setContent('changeHp');
        return next;
      },

      changeHujia: function (num, type) {
        var next = game.createEvent('changeHujia');
        if (typeof num != 'number') {
          num = 1;
        }
        next.num = num;
        next.player = this;
        if (type) next.type = type;
        next.setContent('changeHujia');
        return next;
      },
      getBuff: function () {
        var list = [1, 2, 3, 4, 5, 6];
        var nodelay = false;
        for (var i = 0; i < arguments.length; i++) {
          if (typeof arguments[i] == 'number') {
            list.remove(arguments[i]);
          }
          else if (arguments[i] === false) {
            nodelay = true;
          }
        }
        if (this.isHealthy()) {
          list.remove(2);
        }
        if (!this.countCards('j')) {
          list.remove(5);
        }
        if (!this.isLinked() && !this.isTurnedOver()) {
          list.remove(6);
        }
        if (this.hasSkill('qianxing')) {
          list.remove(4);
        }
        switch (list.randomGet()) {
          case 1: this.draw(nodelay ? 'nodelay' : 1); break;
          case 2: this.recover(); break;
          case 3: this.changeHujia(); break;
          case 4: this.tempHide();
          case 5: this.discard(this.getCards('j')).delay = (!nodelay); break;
          case 6: {
            if (this.isLinked()) this.link();
            if (this.isTurnedOver()) this.turnOver();
            break;
          }
        }
        return this;
      },
      getDebuff: function () {
        var list = [1, 2, 3, 4, 5, 6];
        var nodelay = false;
        for (var i = 0; i < arguments.length; i++) {
          if (typeof arguments[i] == 'number') {
            list.remove(arguments[i]);
          }
          else if (arguments[i] === false) {
            nodelay = true;
          }
        }
        if (this.countCards('he') == 0) {
          list.remove(1);
        }
        if (this.isLinked()) {
          list.remove(4);
        }
        if (this.hasSkill('fengyin')) {
          list.remove(5);
        }
        if (this.hp == 1) {
          list.remove(3);
          if (list.length > 1) list.remove(2);
        }
        if (!list.length) return this;
        var num = list.randomGet();
        switch (list.randomGet()) {
          case 1: this.randomDiscard(nodelay ? false : 'he'); break;
          case 2: this.loseHp(); break;
          case 3: this.damage(); break;
          case 4: if (!this.isLinked()) this.link(); break;
          case 5: this.addTempSkill('fengyin', { player: 'phaseAfter' }); break;
          case 6: {
            var list = [];
            for (var i = 0; i < lib.inpile.length; i++) {
              var info = lib.card[lib.inpile[i]];
              if (info.type == 'delay' && !info.cancel && !this.hasJudge(lib.inpile[i])) {
                list.push(lib.inpile[i]);
              }
            }
            if (list.length) {
              var card = game.createCard(list.randomGet());
              this.addJudge(card);
              this.$draw(card);
              if (!nodelay) game.delay();
            }
            else {
              this.getDebuff(6);
            }
            break;
          }
        }
        return this;
      },
      dying: function (reason) {
        if (this.nodying || this.hp > 0 || this.isDying()) return;
        var next = game.createEvent('dying');
        next.player = this;
        next.reason = reason;
        if (reason && reason.source) next.source = reason.source;
        next.setContent('dying');
        next.filterStop = function () {
          if (this.player.hp > 0) {
            delete this.filterStop;
            return true;
          }
        };
        return next;
      },
      die: function (reason) {
        var next = game.createEvent('die');
        next.player = this;
        next.reason = reason;
        if (reason) next.source = reason.source;
        next.setContent('die');
        return next;
      },
      revive: function (hp, log) {
        if (log !== false) game.log(this, '复活');
        if (this.maxHp < 1) this.maxHp = 1;
        if (hp) this.hp = hp;
        else {
          this.hp = 1;
        }
        game.addVideo('revive', this);
        this.classList.remove('dead');
        this.removeAttribute('style');
        this.node.avatar.style.transform = '';
        this.node.avatar2.style.transform = '';
        this.node.hp.show();
        this.node.equips.show();
        this.node.count.show();
        this.update();
        var player;
        player = this.previousSeat;
        while (player.isDead()) player = player.previousSeat;
        player.next = this;
        this.previous = player;
        player = this.nextSeat;
        while (player.isDead()) player = player.nextSeat;
        player.previous = this;
        this.next = player;
        game.players.add(this);
        game.dead.remove(this);
        if (this == game.me) {
          if (ui.auto) ui.auto.show();
          if (ui.wuxie) ui.wuxie.show();
          if (ui.revive) {
            ui.revive.close();
            delete ui.revive;
          }
          if (ui.exit) {
            ui.exit.close();
            delete ui.exit;
          }
          if (ui.swap) {
            ui.swap.close();
            delete ui.swap;
          }
          if (ui.restart) {
            ui.restart.close();
            delete ui.restart;
          }
          if (ui.continue_game) {
            ui.continue_game.close();
            delete ui.continue_game;
          }
        }
      },
      /**
       * 返回本角色是否处于混乱状态
       * @returns {!boolean}
       */
      isMad: function () {
        return this.hasSkill('mad');
      },
      /**
       * 令本角色进入混乱状态；
       * 此函数会输出日志
       * @param {(string|Object)} [end] 结束时点，下一次触发该时点时结束本角色结束混乱状态；如果未指定，默认为'phaseAfter'
       */
      goMad: function (end) {
        if (end) {
          this.addTempSkill('mad', end);
        }
        else {
          this.addSkill('mad');
        }
        game.log(this, '进入混乱状态');
      },
      /**
       * 令本角色移除混乱状态
       */
      unMad: function () {
        this.removeSkill('mad');
      },
      tempHide: function () {
        this.addTempSkill('qianxing', { player: 'phaseBegin' });
      },
      addExpose: function (num) {
        if (typeof this.ai.shown == 'number' && !this.identityShown && this.ai.shown < 1) {
          this.ai.shown += num;
          if (this.ai.shown > 0.95) {
            this.ai.shown = 0.95;
          }
        }
        return this;
      },
      equip: function (card, arg2) {
        if (get.type(card) != 'equip') return;
        var next = game.createEvent('equip');
        next.card = card;
        if (get.is.object(next.card) && get.itemtype(next.card.cards) == 'cards' && get.name(next.card.cards[0]) == next.card.name && next.card.cards.length == 1) next.card = next.card.cards[0];
        next.player = this;
        if (arg2) {
          if (arg2 === true) {
            next.draw = true;
          } else {
            next.cards = arg2;
          }
        }
        if (!next.cards) next.cards = [next.card];
        if (get.itemtype(next.cards) == 'card') next.cards = [next.cards];
        next.setContent(lib.element.content.equip);
        next.getl = function (player) {
          var that = this;
          var map = {
            player: player,
            hs: [],
            es: [],
            js: [],
            ss: [],
            cards: [],
            cards2: [],
          };
          player.getHistory('lose', function (evt) {
            if (evt.parent == that) {
              map.hs.addArray(evt.hs);
              map.es.addArray(evt.es);
              map.js.addArray(evt.js);
              map.ss.addArray(evt.ss);
              map.cards.addArray(evt.cards);
              map.cards2.addArray(evt.cards2);
            }
          });
          if (map.cards.length > 0 || map.ss.length > 0) return map;
        };
        return next;
      },
      addJudge: function (card, cards) {
        var next = game.createEvent('addJudge');
        next.card = card;
        next.cards = cards;
        if (next.cards == undefined) next.cards = [card];
        if (get.itemtype(next.cards) == 'card') next.cards = [next.cards];
        next.player = this;
        next.setContent('addJudge');
        next.getl = function (player) {
          var that = this;
          var map = {
            player: player,
            hs: [],
            es: [],
            js: [],
            ss: [],
            cards: [],
            cards2: [],
          };
          player.getHistory('lose', function (evt) {
            if (evt.parent == that) {
              map.hs.addArray(evt.hs);
              map.es.addArray(evt.es);
              map.js.addArray(evt.js);
              map.ss.addArray(evt.ss);
              map.cards.addArray(evt.cards);
              map.cards2.addArray(evt.cards2);
            }
          });
          if (map.cards.length > 0 || map.ss.length > 0) return map;
        };
        return next;
      },
      canAddJudge: function (card) {
        if (this.storage._disableJudge) return false;
        var name;
        if (typeof card == 'string') {
          name = card;
        }
        else {
          name = card.viewAs || card.name;
        }
        if (!name) return false;
        if (this.hasJudge(name)) return false;
        var mod = game.checkMod(card, this, this, 'unchanged', 'targetEnabled', this);
        if (mod != 'unchanged') return mod;
        return true;
      },
      addJudgeNext: function (card) {
        if (!card.expired) {
          var target = this.next;
          var name = card.viewAs || card.name;
          var bool = false;
          for (var iwhile = 0; iwhile < 20; iwhile++) {
            if (target.canAddJudge(card)) {
              bool = true; break;
            }
            target = target.next;
          }
          if (!bool) {
            game.log(card, '进入了弃牌堆');
            game.cardsDiscard(card);
          }
          else {
            if (card.name != name) {
              target.addJudge(name, card);
            }
            else {
              target.addJudge(card);
            }
          }
        }
        else {
          card.expired = false;
        }
      },
      /**
       * 判定事件
       * @returns {!boolean}
       */
      judge: function () {
        var next = game.createEvent('judge');
        next.player = this;
        for (var i = 0; i < arguments.length; i++) {
          if (get.itemtype(arguments[i]) == 'card') {
            next.card = arguments[i];
          }
          else if (typeof arguments[i] == 'string') {
            next.skill = arguments[i];
          }
          else if (typeof arguments[i] == 'function') {
            next.judge = arguments[i];
          }
          else if (typeof arguments[i] == 'boolean') {
            next.clearArena = arguments[i];
          }
          else if (get.objtype(arguments[i]) == 'div') {
            next.position = arguments[i];
          }
        }
        if (next.card && next.judge == undefined) {
          next.judge = get.judge(next.card);
        }
        if (next.judge == undefined) next.judge = function () { return 0 };
        if (next.position == undefined) next.position = ui.discardPile;
        if (next.card) next.cardname = next.card.viewAs || next.card.name;

        var str = '';
        if (next.card) str = get.translation(next.card.viewAs || next.card.name);
        else if (next.skill) str = get.translation(next.skill);
        else str = get.translation(_status.event.name);
        next.judgestr = str;
        next.setContent('judge');
        return next;
      },
      /**
       * 翻面事件
       * @returns {!boolean}
       */
      turnOver: function (bool) {
        if (typeof bool == 'boolean') {
          if (bool) {
            if (this.isTurnedOver()) return;
          }
          else {
            if (!this.isTurnedOver()) return;
          }
        }
        var next = game.createEvent('turnOver');
        next.player = this;
        var nosource;
        var Evt = _status.event;
        for (var i = 0; i < arguments.length; i++) {
          if (get.itemtype(arguments[i]) == 'player') {
            next.source = arguments[i];
          }
          else if (arguments[i] == 'nosource') {
            nosource = true;
          }
        }
        if (next.source == undefined && !nosource) next.source = Evt.player;
        next.setContent('turnOver');
        return next;
      },
      out: function (skill) {
        if (typeof skill == 'number') {
          this.outCount += skill;
        }
        else if (typeof skill == 'string') {
          if (!this.outSkills) {
            this.outSkills = [];
          }
          this.outSkills.add(skill);
        }
        else {
          this.outCount++;
        }
        if (!this.classList.contains('out')) {
          this.classList.add('out');
          game.log(this, '离开游戏');
        }
        if (!game.countPlayer()) {
          game.over();
        }
      },
      in: function (skill) {
        if (this.isOut()) {
          if (typeof skill == 'string') {
            if (this.outSkills) {
              this.outSkills.remove(skill);
              if (!this.outSkills.length) {
                delete this.outSkills;
              }
            }
          }
          else if (typeof skill == 'number') {
            this.outCount -= skill;
          }
          else {
            if (skill === true) {
              delete this.outSkills;
            }
            this.outCount = 0;
          }
          if (this.outCount <= 0 && !this.outSkills) {
            this.outCount = 0;
            this.classList.remove('out');
            game.log(this, '进入游戏');
          }
        }
      },
      /**
       * 横置事件
       * @returns {!boolean}
       */
      link: function (bool) {
        if (typeof bool == 'boolean') {
          if (bool) {
            if (this.isLinked()) return;
          }
          else {
            if (!this.isLinked()) return;
          }
        }
        var next = game.createEvent('link');
        next.player = this;
        var nosource;
        var Evt = _status.event;
        for (var i = 0; i < arguments.length; i++) {
          if (get.itemtype(arguments[i]) == 'player') {
            next.source = arguments[i];
          }
          else if (arguments[i] == 'nosource') {
            nosource = true;
          }
        }
        if (next.source == undefined && !nosource) next.source = Evt.player;
        next.setContent('link');
        return next;
      },
      skip: function (name) {
        this.skipList.add(name);
      },
      wait: function (callback) {
        if (lib.node) {
          if (typeof callback == 'function') {
            callback._noname_waiting = true;
            lib.node.torespond[this.playerid] = callback;
          }
          else {
            lib.node.torespond[this.playerid] = '_noname_waiting';
          }
          clearTimeout(lib.node.torespondtimeout[this.playerid]);
          if (this.ws && !this.ws.closed) {
            var player = this;
            var time = parseInt(lib.configOL.choose_timeout) * 1000;
            if (ui.arena && ui.arena.classList.contains('choose-character') && lib.configOL.chooseCharacter_timeout) {
              time *= 5;
            }
            if (_status.event.getParent().skillHidden) {
              for (var i = 0; i < game.players.length; i++) {
                game.players[i].showTimer(time);
              }
              player._hide_all_timer = true;
            }
            else if (!_status.event._global_waiting) {
              player.showTimer(time);
            }
            lib.node.torespondtimeout[this.playerid] = setTimeout(function () {
              player.unwait('ai');
              player.ws.ws.close();
            }, time + 5000);
          }
        }
      },
      unwait: function (result) {
        if (this._hide_all_timer) {
          delete this._hide_all_timer;
          for (var i = 0; i < game.players.length; i++) {
            game.players[i].hideTimer();
          }
        }
        else if (!_status.event._global_waiting) {
          this.hideTimer();
        }
        clearTimeout(lib.node.torespondtimeout[this.playerid]);
        delete lib.node.torespondtimeout[this.playerid];
        if (!lib.node.torespond.hasOwnProperty(this.playerid)) {
          return;
        }
        var noresume = false;
        var proceed = null;
        if (typeof lib.node.torespond[this.playerid] == 'function' && lib.node.torespond[this.playerid]._noname_waiting) {
          proceed = lib.node.torespond[this.playerid](result, this);
          if (proceed === false) {
            noresume = true;
          }
        }
        lib.node.torespond[this.playerid] = result;
        for (var i in lib.node.torespond) {
          if (lib.node.torespond[i] == '_noname_waiting') {
            return;
          }
          else if (lib.node.torespond[i] && lib.node.torespond[i]._noname_waiting) {
            return;
          }
        }
        _status.event.result = result;
        _status.event.resultOL = lib.node.torespond;
        lib.node.torespond = {};
        if (typeof proceed == 'function') proceed();
        else if (_status.paused && !noresume) game.resume();
      },
      /**
       * 
       * @returns {!boolean}
       */
      logSkill: function (name, targets, nature, logv, audio) {
        if (get.itemtype(targets) == 'player') targets = [targets];
        var nopop = false;
        var popname = name;
        if (Array.isArray(name)) {
          popname = name[1];
          name = name[0];
        }
        var checkShow = this.checkShow(name);
        if (lib.translate[name]) {
          this.trySkillAnimate(name, popname, checkShow);
          if (typeof targets == 'object' && targets.length) {
            var str;
            if (targets[0] == this) {
              str = '#b自己';
              if (targets.length > 1) {
                str += '、';
                str += get.translation(targets.slice(1));
              }
            }
            else str = targets;
            game.log(this, '对', str, '发动了', '#p『' + get.skillTranslation(name, this) + '』');
          }
          else {
            game.log(this, '发动了', '#p『' + get.skillTranslation(name, this) + '』');
          }
        }
        if (nature != false) {
          if (nature === undefined) {
            nature = 'green';
          }
          this.line(targets, nature);
        }
        var info = lib.skill[name];
        if (info && info.ai && info.ai.expose != undefined &&
          this.logAi && (!targets || targets.length != 1 || targets[0] != this)) {
          this.logAi(lib.skill[name].ai.expose);
        }
        if (info && info.round) {
          var roundname = name + '_roundcount';
          this.storage[roundname] = info.round;
          if (!this.hasSkill(roundname)) this.addSkill(roundname)
          // this.storage[roundname] = game.roundNumber;
          this.syncStorage(roundname);
          this.markSkill(roundname);
        }
        if (audio !== false) {
          game.trySkillAudio(name, this, true);
        }
        if (game.chess) {
          this.chessFocus();
        }
        if (logv === true) {
          game.logv(this, name, targets, null, true);
        }
        else if (info && info.logv !== false) {
          game.logv(this, name, targets);
        }
        if (this._hookTrigger) {
          for (var i = 0; i < this._hookTrigger.length; i++) {
            var info = lib.skill[this._hookTrigger[i]].hookTrigger;
            if (info && info.log) {
              info.log(this, name, targets);
            }
          }
        }
      },
      unprompt: function () {
        if (this.node.prompt) {
          this.node.prompt.delete();
          delete this.node.prompt;
        }
      },
      prompt: function (str, nature) {
        var node;
        if (this.node.prompt) {
          node = this.node.prompt;
          node.innerHTML = '';
          node.className = 'damage normal-font damageadded';
        }
        else {
          node = ui.create.div('.damage.normal-font', this);
          this.node.prompt = node;
          ui.refresh(node);
          node.classList.add('damageadded');
        }
        node.innerHTML = str;
        node.dataset.nature = nature || 'soil';
      },
      prompt_old: function (name2, className) {
        var node;
        if (this.node.prompt) {
          node = this.node.prompt;
          node.innerHTML = '';
          node.className = 'popup';
        }
        else {
          node = ui.create.div('.popup', this.parentNode);
          this.node.prompt = node;
        }
        node.dataset.position = this.dataset.position;
        if (this.dataset.position == 0 || parseInt(this.dataset.position) == parseInt(ui.arena.dataset.number) / 2 ||
          typeof name2 == 'number' || this.classList.contains('minskin')) {
          node.innerHTML = name2;
        }
        else {
          for (var i = 0; i < name2.length; i++) {
            node.innerHTML += name2[i] + '<br/>';
          }
        }
        if (className) {
          node.classList.add(className);
        }
      },
      /**
       * 文字弹出动画效果
       * [recommend] 令人迷惑的是，此函数实质调用了{@link lib.element.player.$damagepop}，而不是{@link lib.element.player.$damagepop}调用此函数
       * @param {!string} name (技能|角色|游戏牌)名或其他任意非空字符串
       * @param {string} [classname='water'] 效果色
       * @param {?boolean} [nobroadcast] 如果为true，则
       */
      popup: function (name, className, nobroadcast) {
        var name2 = get.translation(name);
        if (!name2) return;
        this.$damagepop(name2, className || 'water', true, nobroadcast);
      },
      popup_old: function (name, className) {
        var name2 = get.translation(name);
        var node = ui.create.div('.popup', this.parentNode);
        if (!name2) {
          node.remove();
          return node;
        }
        game.addVideo('popup', this, [name, className]);
        node.dataset.position = this.dataset.position;
        if (this.dataset.position == 0 || parseInt(this.dataset.position) == parseInt(ui.arena.dataset.number) / 2 ||
          typeof name2 == 'number' || this.classList.contains('minskin')) {
          node.innerHTML = name2;
        }
        else {
          for (var i = 0; i < name2.length; i++) {
            node.innerHTML += name2[i] + '<br/>';
          }
        }
        if (className) {
          node.classList.add(className);
        }
        this.popups.push(node);
        if (this.popups.length > 1) {
          node.hide();
        }
        else {
          var that = this;
          setTimeout(function () { that._popup(); }, 1000);
        }
        return node;
      },
      _popup: function () {
        if (this.popups.length) {
          this.popups.shift().delete();
          if (this.popups.length) {
            this.popups[0].show();
            var that = this;
            setTimeout(function () { that._popup(); }, 1000);
          }
        }
      },
      showTimer: function (time) {
        if (!time && lib.configOL) {
          time = parseInt(lib.configOL.choose_timeout) * 1000;
        }
        // if(ui.arena&&ui.arena.classList.contains('choose-character')&&lib.configOL.chooseCharacter_timeout){
        // 	time *= 5;
        // }
        if (_status.connectMode && !game.online) {
          game.broadcast(function (player, time) {
            player.showTimer(time);
          }, this, time);
        }
        if (this == game.me) {
          return;
        }
        if (this.node.timer) {
          this.node.timer.remove();
        }
        var timer = ui.create.div('.timerbar', this);
        this.node.timer = timer;
        ui.create.div(this.node.timer);
        var bar = ui.create.div(this.node.timer);
        ui.refresh(bar);
        bar.style.transitionDuration = (time / 1000) + 's';
        bar.style.width = 0;
      },
      hideTimer: function () {
        if (_status.connectMode && !game.online && this.playerid) {
          game.broadcast(function (player) {
            player.hideTimer();
          }, this);
        }
        if (this.node.timer) {
          this.node.timer.delete();
          delete this.node.timer;
        }
      },
      markAuto: function (name, info) {
        if (Array.isArray(info)) {
          if (!Array.isArray(this.storage[name])) this.storage[name] = [];
          this.storage[name].addArray(info);
          this.markSkill(name);
        }
        else {
          var storage = this.storage[name];
          if (Array.isArray(storage)) {
            this[storage.length > 0 ? 'markSkill' : 'unmarkSkill'](name);
          }
          else if (typeof storage == 'number') {
            this[storage.length > 0 ? 'markSkill' : 'unmarkSkill'](name);
          }
        }
      },
      unmarkAuto: function (name, info) {
        var storage = this.storage[name]
        if (Array.isArray(info) && Array.isArray(storage)) {
          storage.removeArray(info.slice(0));
          this.markAuto(name);
        }
      },
      getStorage: function (name) {
        return this.storage[name] || [];
      },
      markSkill: function (name, info, card) {
        if (info === true) {
          this.syncStorage(name);
          info = null;
        }
        if (get.itemtype(card) == 'card') {
          game.addVideo('markSkill', this, [name, get.cardInfo(card)]);
        }
        else {
          game.addVideo('markSkill', this, [name]);
        }
        game.broadcastAll(function (storage, player, name, info, card) {
          if (storage != undefined) {
            player.storage[name] = storage;
          }
          if (!info) {
            if (player.marks[name]) {
              player.updateMarks();
              return;
            }
            if (lib.skill[name]) {
              info = lib.skill[name].intro;
            }
            if (!info) {
              return;
            }
          }
          if (player.marks[name]) {
            player.marks[name].info = info;
          }
          else {
            if (card) {
              player.marks[name] = player.mark(card, info, name);
            }
            else {
              player.marks[name] = player.mark(name, info);
            }
          }
          player.updateMarks();
        }, this.storage[name], this, name, info, card);
        return this;
      },
      unmarkSkill: function (name) {
        game.addVideo('unmarkSkill', this, name);
        game.broadcast(function (player, name) {
          if (player.marks[name]) {
            player.marks[name].delete();
            player.marks[name].style.transform += ' scale(0.2)';
            delete player.marks[name];
            ui.updatem(player);
          }
        }, this, name);
        if (this.marks[name]) {
          this.marks[name].delete();
          this.marks[name].style.transform += ' scale(0.2)';
          delete this.marks[name];
          ui.updatem(this);
          var info = lib.skill[name];
          if (info && info.intro && info.intro.onunmark) {
            if (info.intro.onunmark == 'throw') {
              if (get.itemtype(this.storage[name]) == 'cards') {
                this.$throw(this.storage[name], 1000);
                game.cardsDiscard(this.storage[name]);
                game.log(this.storage[name], '进入了弃牌堆');
                this.storage[name].length = 0;
              }
            }
            else if (typeof info.intro.onunmark == 'function') {
              info.intro.onunmark(this.storage[name], this);
            }
          }
        }
        return this;
      },
      markSkillCharacter: function (id, target, name, content) {
        if (typeof target == 'object') {
          target = target.name;
        }
        game.broadcastAll(function (player, target, name, content, id) {
          if (player.marks[id]) {
            player.marks[id].name = name + '_charactermark';
            player.marks[id]._name = target;
            player.marks[id].info = {
              name: name,
              content: content,
              id: id
            };
            player.marks[id].setBackground(target, 'character');
            game.addVideo('changeMarkCharacter', player, {
              id: id,
              name: name,
              content: content,
              target: target
            });
          }
          else {
            player.marks[id] = player.markCharacter(target, {
              name: name,
              content: content,
              id: id
            });
            player.marks[id]._name = target;
            game.addVideo('markCharacter', player, {
              name: name,
              content: content,
              id: id,
              target: target
            });
          }
        }, this, target, name, content, id);
        return this;
      },
      markCharacter: function (name, info, learn, learn2) {
        if (typeof name == 'object') {
          name = name.name;
        }
        var node;
        if (name.indexOf('unknown') == 0) {
          node = ui.create.div('.card.mark.drawinghidden');
          ui.create.div('.background.skillmark', node).innerHTML = get.translation(name)[0];
        }
        else {
          if (!lib.character[name]) return;
          node = ui.create.div('.card.mark.drawinghidden').setBackground(name, 'character');
        }
        this.node.marks.insertBefore(node, this.node.marks.childNodes[1]);
        node.name = name + '_charactermark';
        if (!info) {
          info = {};
        }
        if (!info.name) {
          info.name = get.translation(name);
        }
        if (!info.content) {
          info.content = get.skillintro(name, learn, learn2)
        }
        node.info = info;
        node.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.card);
        if (!lib.config.touchscreen) {
          if (lib.config.hover_all) {
            lib.setHover(node, ui.click.hoverplayer);
          }
          if (lib.config.right_info) {
            node.oncontextmenu = ui.click.rightplayer;
          }
        }
        ui.updatem(this);
        return node;
      },
      /**
       * 标记
       * @function
       * @param {(Array<Card>|Card|string)} name 
       * @param {*} info mark info
       * @param {*} skill 
       * @returns {*}
       */
      mark: function (name, info, skill) {
        if (get.itemtype(name) == 'cards') {
          var marks = [];
          for (var i = 0; i < name.length; i++) {
            marks.push(this.mark(name[i], info));
          }
          return marks;
        }
        else {
          var node;
          if (get.itemtype(name) == 'card') {
            node = name.copy('mark');
            node.classList.add('drawinghidden');
            this.node.marks.insertBefore(node, this.node.marks.childNodes[1]);
            node.suit = name.suit;
            node.number = name.number;
            // if(name.name&&lib.card[name.name]&&lib.card[name.name].markimage){
            //     node.node.image.style.left=lib.card[name.name].markimage;
            // }

            if (name.classList.contains('fullborder')) {
              node.classList.add('fakejudge');
              node.classList.add('fakemark');
              (node.querySelector('.background') || ui.create.div('.background', node)).innerHTML = lib.translate[name.name + '_bg'] || get.translation(name.name)[0];
            }

            name = name.name;
          }
          else {
            node = ui.create.div('.card.mark.drawinghidden');
            this.node.marks.insertBefore(node, this.node.marks.childNodes[1]);
            var str = lib.translate[name + '_bg'];
            if (!str || str[0] == '+' || str[0] == '-') {
              str = get.translation(name)[0];
            }
            ui.create.div('.background.skillmark', node).innerHTML = str;
          }
          node.name = name;
          node.skill = skill || name;
          if (typeof info == 'object') {
            node.info = info;
          }
          else if (typeof info == 'string') {
            node.markidentifer = info;
          }
          node.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.card);
          if (!lib.config.touchscreen) {
            if (lib.config.hover_all) {
              lib.setHover(node, ui.click.hoverplayer);
            }
            if (lib.config.right_info) {
              node.oncontextmenu = ui.click.rightplayer;
            }
          }
          this.updateMarks();
          ui.updatem(this);
          return node;
        }
      },
      /**
       * 取消标记
       * @function
       * @param {*} name
       * @param {*} info
       */
      unmark: function (name, info) {
        game.addVideo('unmarkname', this, name);
        if (get.itemtype(name) == 'card') {
          this.unmark(name.name, info);
        }
        else if (get.itemtype(name) == 'cards') {
          for (var i = 0; i < name.length; i++) {
            this.unmark(name[i].name, info);
          }
        }
        else {
          for (var i = 0; i < this.node.marks.childNodes.length; i++) {
            if (this.node.marks.childNodes[i].name == name &&
              (!info || this.node.marks.childNodes[i].markidentifer == info)) {
              this.node.marks.childNodes[i].delete();
              this.node.marks.childNodes[i].style.transform += ' scale(0.2)';
              ui.updatem(this);
              return;
            }
          }
        }
      },
      addLink: function () {
        if (get.is.linked2(this)) {
          this.classList.add('linked2');
        }
        else {
          this.classList.add('linked');
        }
      },
      removeLink: function () {
        if (get.is.linked2(this)) {
          this.classList.remove('linked2');
        }
        else {
          this.classList.remove('linked');
        }
      },
      /**
       * 返回一张牌当前本角色是否可以(对目标角色)使用
       * @returns {!boolean}
       */
      canUse: function (card, target, distance, includecard) {
        if (typeof card == 'string') card = { name: card, isCard: true };
        var info = get.info(card);
        if (info.multicheck && !info.multicheck(card, this)) return false;
        if (!lib.filter.cardEnabled(card, this)) return false;
        if (distance !== false && !lib.filter.targetInRange(card, this, target)) return false;
        return lib.filter[includecard ? 'targetEnabledx' : 'targetEnabled'](card, this, target);
      },
      /**
       * 返回一张牌当前本角色是否可以使用
       * @returns {!boolean}
       */
      hasUseTarget: function (card, distance, includecard) {
        var player = this;
        return game.hasPlayer(function (current) {
          return player.canUse(card, current, distance, includecard);
        });
      },
      /**
       * 返回一张牌当前本角色使用的收益为正收益，当前可以使用，且有使用对象
       * @returns {!boolean}
       */
      hasValueTarget: function () {
        return this.getUseValue.apply(this, arguments) > 0;
      },
      /**
       * 返回一张牌当前本角色使用的收益
       * @returns {!boolean}
       */
      getUseValue: function (card, distance, includecard) {
        if (typeof (card) == 'string') {
          card = { name: card, isCard: true };
        }
        var player = this;
        var targets = game.filterPlayer();
        var value = [];
        var min = 0;
        var info = get.info(card);
        if (!info || info.notarget) return 0;
        var range;
        var select = get.copy(info.selectTarget);
        if (select == undefined) {
          if (info.filterTarget == undefined) return true;
          range = [1, 1];
        }
        else if (typeof select == 'number') range = [select, select];
        else if (get.itemtype(select) == 'select') range = select;
        else if (typeof select == 'function') range = select(card, player);
        if (info.singleCard) range = [1, 1];
        game.checkMod(card, player, range, 'selectTarget', player);
        if (!range) return 0;

        for (var i = 0; i < targets.length; i++) {
          if (player.canUse(card, targets[i], distance, includecard)) {
            var eff = get.effect(targets[i], card, player, player);
            value.push(eff);
          }
        }
        value.sort(function (a, b) {
          return b - a;
        });
        for (var i = 0; i < value.length; i++) {
          if (i == range[1] || range[1] != -1 && value[i] <= 0) break;
          min += value[i];
        }
        return min;
      },
      /**
       * 
       * @returns {!boolean}
       */
      addSubPlayer: function (cfg) {
        var skill = 'subplayer_' + cfg.name + '_' + get.id();
        game.log(this, '获得了随从', '#g' + get.translation(cfg.name))
        cfg.hs = cfg.hs || [];
        cfg.es = cfg.es || [];
        cfg.skills = cfg.skills || [];
        cfg.hp = cfg.hp || 1;
        cfg.maxHp = cfg.maxHp || 1;
        cfg.sex = cfg.sex || 'male';
        cfg.group = cfg.group || 'qun';
        cfg.skill = cfg.skill || _status.event.name;
        if (!cfg.source) {
          if (this.hasSkill(_status.event.name) && this.name2 && lib.character[this.name2] &&
            lib.character[this.name2][3].contains(_status.event.name)) {
            cfg.source = this.name2;
          }
          else {
            cfg.source = this.name;
          }
        }
        game.broadcastAll(function (player, skill, cfg) {
          lib.skill[skill] = {
            intro: {
              content: cfg.intro || ''
            },
            mark: 'character',
            subplayer: cfg.skill,
            ai: {
              subplayer: true
            }
          }
          lib.character[skill] = [cfg.sex, cfg.group, cfg.maxHp, cfg.skills, ['character:' + cfg.name]];
          lib.translate[skill] = cfg.caption || get.rawName(cfg.name);
          player.storage[skill] = cfg;
        }, this, skill, cfg);
        game.addVideo('addSubPlayer', this, [skill, lib.skill[skill], lib.character[skill], lib.translate[skill], { name: cfg.name }]);
        this.addSkill(skill);
        return skill;
      },
      /**
       * 
       * @returns {!boolean}
       */
      removeSubPlayer: function (name) {
        if (this.hasSkill('subplayer') && this.name == name) {
          this.exitSubPlayer(true);
        }
        else {
          if (player.storage[name].onremove) {
            player.storage[name].onremove(player);
          }
          this.removeSkill(name);
          delete this.storage[name];
          game.log(player, '牺牲了随从', '#g' + name);
          _status.event.trigger('removeSubPlayer');
        }
      },
      /**
       * 
       * @returns {!boolean}
       */
      callSubPlayer: function () {
        if (this.hasSkill('subplayer')) return;
        var next = game.createEvent('callSubPlayer');
        next.player = this;
        for (var i = 0; i < arguments.length; i++) {
          if (typeof arguments[i] == 'string') {
            next.directresult = arguments[i];
          }
        }
        next.setContent('callSubPlayer');
        return next;
      },
      /**
       * 
       * @returns {!boolean}
       */
      toggleSubPlayer: function () {
        if (!this.hasSkill('subplayer')) return;
        var next = game.createEvent('toggleSubPlayer');
        next.player = this;
        for (var i = 0; i < arguments.length; i++) {
          if (typeof arguments[i] == 'string') {
            next.directresult = arguments[i];
          }
        }
        next.setContent('toggleSubPlayer');
        return next;
      },
      /**
       * 
       * @returns {!boolean}
       */
      exitSubPlayer: function (remove) {
        if (!this.hasSkill('subplayer')) return;
        var next = game.createEvent('exitSubPlayer');
        next.player = this;
        next.remove = remove;
        next.setContent('exitSubPlayer');
        return next;
      },
      /**
       * 
       * @returns {!boolean}
       */
      getSubPlayers: function (tag) {
        var skills = this.getSkills();
        var list = [];
        for (var i = 0; i < skills.length; i++) {
          var name = skills[i];
          var info = lib.skill[name];
          if (tag && info.subplayer != tag) continue;
          if (info.ai && info.ai.subplayer && this.storage[name] && this.storage[name].name) {
            list.push(name);
          }
        }
        return list;
      },
      /**
       * 同时将info.global内的技能添加到{@link lib.skill.global}
       * @returns {!boolean}
       */
      addSkillTrigger: function (skill, hidden, triggeronly) {
        var info = lib.skill[skill];
        if (!info) return;
        if (typeof info.group == 'string') {
          this.addSkillTrigger(info.group, hidden);
        }
        else if (Array.isArray(info.group)) {
          for (var i = 0; i < info.group.length; i++) {
            this.addSkillTrigger(info.group[i], hidden);
          }
        }
        if (!triggeronly) {
          if (info.global && (!hidden || info.globalSilent)) {
            if (typeof info.global == 'string') {
              game.addGlobalSkill(info.global, this);
            }
            else {
              for (var j = 0; j < info.global.length; j++) {
                game.addGlobalSkill(info.global[j], this);
              }
            }
          }
          if (this.initedSkills.contains(skill)) return this;
          this.initedSkills.push(skill);
          if (info.init && !_status.video) {
            info.init(this, skill);
          }
        }
        if (info.trigger && this.playerid) {
          var playerid = this.playerid;
          var setTrigger = function (i, evt) {
            if (i == 'global') {
              if (!lib.hook.globaltrigger[evt]) {
                lib.hook.globaltrigger[evt] = {};
              }
              if (!lib.hook.globaltrigger[evt][playerid]) {
                lib.hook.globaltrigger[evt][playerid] = [];
              }
              lib.hook.globaltrigger[evt][playerid].add(skill);
            }
            else {
              var name = playerid + '_' + i + '_' + evt;
              if (!lib.hook[name]) {
                lib.hook[name] = [];
              }
              lib.hook[name].add(skill);
            }
            lib.hookmap[evt] = true;
          }
          for (var i in info.trigger) {
            if (typeof info.trigger[i] == 'string') {
              setTrigger(i, info.trigger[i]);
            }
            else if (Array.isArray(info.trigger[i])) {
              for (var j = 0; j < info.trigger[i].length; j++) {
                setTrigger(i, info.trigger[i][j]);
              }
            }
          }
        }
        if (info.hookTrigger) {
          if (!this._hookTrigger) {
            this._hookTrigger = [];
          }
          this._hookTrigger.add(skill);
        }
        if (_status.event && _status.event.addTrigger) _status.event.addTrigger(skill, this);
        return this;
      },
      /**
       * 
       * @returns {!boolean}
       */
      addSkillLog: function (skill) {
        this.addSkill(skill);
        this.popup(skill);
        game.log(this, '获得了技能', '#g『' + get.translation(skill) + '』');
      },
      /**
       * 添加一组技能
       * @name lib.element.player.addSkill
       * @function
       * @param {Array<string>} skills 技能名数组
       * @param {?boolean} [checkConflict] 是否检测冲突，如果为true，添加技能完成后检测；如果为false或未指定，不检测
       * @param {?boolean} [nobroadcast] 如果为true，直接添加技能；如果为false或未指定，调用{@link game.broadcast}为本角色添加技能
       * @returns {string} 如果添加技能成功，返回技能名`skill`；如果失败，返回undefined
       * @see {@link lib.element.player.addSkill(2)}
       */
      /**
       * 本角色添加技能
       * @name lib.element.player.addSkill
       * @function
       * @variation 2
       * @param {!string} skill 技能名
       * @param {?boolean} [checkConflict] 是否检测冲突，如果为true，添加技能完成后检测；如果为false或未指定，不检测
       * @param {?boolean} [nobroadcast] 如果为true，直接添加技能；如果为false或未指定，调用{@link game.broadcast}为本角色添加技能
       * @returns {string} 如果添加技能成功，返回技能名`skill`；如果失败，返回undefined
       */
      addSkill: function (skill, checkConflict, nobroadcast) {
        if (Array.isArray(skill)) {
          for (var i = 0; i < skill.length; i++) {
            this.addSkill(skill[i]);
          }
        }
        else {
          if (this.skills.contains(skill)) return;
          var info = lib.skill[skill];
          if (!info) return;
          if (!nobroadcast) {
            game.broadcast(function (player, skill) {
              player.skills.add(skill);
            }, this, skill);
          }
          this.skills.add(skill);
          this.addSkillTrigger(skill);
          if (this.awakenedSkills.contains(skill)) {
            this.awakenSkill(skill);
            return;
          }
          if (info.init2 && !_status.video) {
            info.init2(this, skill);
          }
          if (info.mark) {
            if (info.mark == 'card' &&
              get.itemtype(this.storage[skill]) == 'card') {
              this.markSkill(skill, null, this.storage[skill]);
            }
            else if (info.mark == 'card' &&
              get.itemtype(this.storage[skill]) == 'cards') {
              this.markSkill(skill, null, this.storage[skill][0]);
            }
            else if (info.mark == 'image') {
              this.markSkill(skill, null, ui.create.card(null, 'noclick').init([null, null, skill]));
            }
            else if (info.mark == 'character') {
              var intro = info.intro.content;
              if (typeof intro == 'function') {
                intro = intro(this.storage[skill], this);
              }
              else if (typeof intro == 'string') {
                intro = intro.replace(/#/g, this.storage[skill]);
                intro = intro.replace(/&/g, get.cnNumber(this.storage[skill]));
                intro = intro.replace(/\$/g, get.translation(this.storage[skill]));
              }
              var caption;
              if (typeof info.intro.name == 'function') {
                caption = info.intro.name(this.storage[skill], this);
              }
              else if (typeof info.intro.name == 'string') {
                caption = info.name;
              }
              else {
                caption = get.translation(skill);
              }
              this.markSkillCharacter(skill, this.storage[skill], caption, intro);
            }
            else {
              this.markSkill(skill);
            }
          }
        }
        if (checkConflict) this.checkConflict();
        return skill;
      },
      /**
       * 
       * @returns {!boolean}
       */
      addAdditionalSkill: function (skill, skills, keep) {
        if (this.additionalSkills[skill]) {
          if (keep) {
            if (typeof this.additionalSkills[skill] == 'string') {
              this.additionalSkills[skill] = [this.additionalSkills[skill]];
            }
          }
          else {
            this.removeAdditionalSkill(skill);
            this.additionalSkills[skill] = [];
          }
        }
        else {
          this.additionalSkills[skill] = [];
        }
        if (typeof skills == 'string') {
          skills = [skills];
        }
        for (var i = 0; i < skills.length; i++) {
          this.addSkill(skills[i], null, true);
          this.skills.remove(skills[i]);
          this.additionalSkills[skill].push(skills[i]);
        }
        this.checkConflict();
        return this;
      },
      /**
       * 
       * @returns {!boolean}
       */
      removeAdditionalSkill: function (skill, target) {
        if (this.additionalSkills[skill]) {
          var additionalSkills = this.additionalSkills[skill];
          if (Array.isArray(additionalSkills) && typeof target == 'string') {
            if (additionalSkills.contains(target)) {
              additionalSkills.remove(target);
              this.removeSkill(target);
            }
          }
          else {
            delete this.additionalSkills[skill];
            if (typeof additionalSkills == 'string') {
              this.removeSkill(additionalSkills);
            }
            else if (Array.isArray(additionalSkills)) {
              for (var i = 0; i < additionalSkills.length; i++) {
                this.removeSkill(additionalSkills[i]);
              }
            }
          }
        }
        return this;
      },
      /**
       * 
       * @returns {!boolean}
       */
      awakenSkill: function (skill, nounmark) {
        if (!nounmark) this.unmarkSkill(skill);
        this.disableSkill(skill + '_awake', skill);
        this.awakenedSkills.add(skill);
        if (this.storage[skill] === false) this.storage[skill] = true;
        return this;
      },
      /**
       * 
       * @returns {!boolean}
       */
      restoreSkill: function (skill, nomark) {
        if (this.storage[skill] === true) this.storage[skill] = false;
        this.awakenedSkills.remove(skill);
        this.enableSkill(skill + '_awake', skill);
        if (!nomark) this.markSkill(skill);
        return this;
      },
      /**
       * 
       * @returns {!boolean}
       */
      disableSkill: function (skill, skills) {
        if (typeof skills == 'string') {
          if (!this.disabledSkills[skills]) {
            this.disabledSkills[skills] = [];
            var info = get.info(skills);
            if (info.ondisable && info.onremove) {
              info.onremove(this);
            }
          }
          this.disabledSkills[skills].add(skill);
          var group = lib.skill[skills].group;
          if (typeof group == 'string' || Array.isArray(group)) {
            this.disableSkill(skill, group);
          }
        }
        else if (Array.isArray(skills)) {
          for (var i = 0; i < skills.length; i++) {
            this.disableSkill(skill, skills[i]);
          }
        }
        return this;
      },
      /**
       * 
       * @returns {!boolean}
       */
      enableSkill: function (skill) {
        for (var i in this.disabledSkills) {
          this.disabledSkills[i].remove(skill);
          if (this.disabledSkills[i].length == 0) {
            delete this.disabledSkills[i];
          }
        }
        return this;
      },
      /**
       * 
       * @returns {!boolean}
       */
      checkMarks: function () {
        var skills = this.getSkills();
        game.expandSkills(skills);
        for (var i in this.marks) {
          if (!skills.contains(i) && !this.marks[i].info.fixed) {
            this.unmarkSkill(i);
          }
        }
        return this;
      },
      /**
       * 
       * @returns {!boolean}
       */
      addEquipTrigger: function (card) {
        if (card) {
          var info = get.info(card);
          if (info.skills) {
            for (var j = 0; j < info.skills.length; j++) {
              this.addSkillTrigger(info.skills[j]);
            }
          }
        }
        else {
          var es = this.getCards('e');
          for (var i = 0; i < es.length; i++) {
            this.addEquipTrigger(es[i]);
          }
        }
        return this;
      },
      /**
       * 
       * @returns {!boolean}
       */
      removeEquipTrigger: function (card, move) {
        if (card) {
          var info = get.info(card);
          if (move === false) {
            if (card.originalName) {
              card.classList.remove('fakejudge');
              if (get.type(card.originalName) == 'equip') {
                card.classList.remove(get.subtype(card.viewAs));
                card.classList.add(get.subtype(card.originalName));
              } else {
                card.classList.remove(get.subtype(card.viewAs));
              }
              card.name = card.originalName;
              delete card.viewAs;
              delete card.originalName;
            }
          } else {
            //	if(card.viewAs&&card.originalName&&card.originalName){
            //		card.name = card.originalName
            //	}
          }
          var skills = this.getSkills(null, false);
          if (info.skills) {
            for (var j = 0; j < info.skills.length; j++) {
              if (skills.contains(info.skills[j])) continue;
              this.removeSkillTrigger(info.skills[j]);
            }
          }
          if (info.clearLose && typeof info.onLose == 'function') {
            var next = game.createEvent('lose_' + card.name);
            next.setContent(info.onLose);
            next.player = this;
            next.card = card;
          }
        }
        else {
          var es = this.getCards('e');
          for (var i = 0; i < es.length; i++) {
            this.removeEquipTrigger(es[i]);
          }
        }
        return this;
      },
      /**
       * 
       * @returns {!boolean}
       */
      removeSkillTrigger: function (skill, triggeronly) {
        var info = lib.skill[skill];
        if (!info) return;
        if (typeof info.group == 'string') {
          this.removeSkillTrigger(info.group);
        }
        else if (Array.isArray(info.group)) {
          for (var i = 0; i < info.group.length; i++) {
            this.removeSkillTrigger(info.group[i]);
          }
        }
        if (!triggeronly) this.initedSkills.remove(skill);
        if (info.trigger) {
          var playerid = this.playerid;
          var removeTrigger = function (i, evt) {
            if (i == 'global') {
              for (var j in lib.hook.globaltrigger) {
                if (lib.hook.globaltrigger[j][playerid]) {
                  lib.hook.globaltrigger[j][playerid].remove(skill);
                  if (lib.hook.globaltrigger[j][playerid].length == 0) {
                    delete lib.hook.globaltrigger[j][playerid];
                  }
                  if (get.is.empty(lib.hook.globaltrigger[j])) {
                    delete lib.hook.globaltrigger[j];
                  }
                }
              }
            }
            else {
              var name = playerid + '_' + i + '_' + evt;
              if (lib.hook[name]) {
                lib.hook[name].remove(skill);
                if (lib.hook[name].length == 0) {
                  delete lib.hook[name];
                }
              }
            }
          }
          for (var i in info.trigger) {
            if (typeof info.trigger[i] == 'string') {
              removeTrigger(i, info.trigger[i]);
            }
            else if (Array.isArray(info.trigger[i])) {
              for (var j = 0; j < info.trigger[i].length; j++) {
                removeTrigger(i, info.trigger[i][j]);
              }
            }
          }
        }
        if (info.hookTrigger) {
          if (this._hookTrigger) {
            this._hookTrigger.remove(skill);
            if (!this._hookTrigger.length) {
              delete this._hookTrigger;
            }
          }
        }
        return this;
      },
      /**
       * 
       * @returns {!boolean}
       */
      removeSkill: function (skill) {
        if (!skill) return;
        if (Array.isArray(skill)) {
          for (var i = 0; i < skill.length; i++) {
            this.removeSkill(skill[i]);
          }
        }
        else {
          var info = lib.skill[skill];
          if (info && info.fixed && arguments[1] !== true) return skill;
          this.unmarkSkill(skill);
          game.broadcastAll(function (player, skill) {
            player.skills.remove(skill);
            player.hiddenSkills.remove(skill);
          }, this, skill);
          this.checkConflict(skill);
          delete this.tempSkills[skill];
          if (info) {
            if (info.onremove) {
              if (typeof info.onremove == 'function') {
                info.onremove(this, skill);
              }
              else if (typeof info.onremove == 'string') {
                if (info.onremove == 'storage') {
                  delete this.storage[skill];
                }
                else {
                  var cards = this.storage[skill];
                  if (get.itemtype(cards) == 'card') {
                    cards = [cards];
                  }
                  if (get.itemtype(cards) == 'cards') {
                    if (this.onremove == 'discard') {
                      this.$throw(cards);
                    }
                    if (this.onremove == 'discard' || this.onremove == 'lose') {
                      game.cardsDiscard(cards);
                      delete this.storage[skill];
                    }
                  }
                }
              }
              else if (Array.isArray(info.onremove)) {
                for (var i = 0; i < info.onremove.length; i++) {
                  delete this.storage[info.onremove[i]];
                }
              }
              else if (info.onremove === true) {
                delete this.storage[skill];
              }
            }
            this.removeSkillTrigger(skill);
            if (!info.keepSkill) {
              this.removeAdditionalSkill(skill);
            }
          }
          this.enableSkill(skill + '_awake');
        }
        return skill;
      },
      /**
       * 本角色添加一个临时技能
       * @param {!string} skill 技能名
       * @param {(string|Object|undefined)} [expire='phaseAfter'] 过期时间，`expire`实际上对应一个触发器，本角色在下一次触发器被触发的时候移除此技能；如果未指定，使用'phaseAfter'
       * @param {?boolean} [checkConflict] 如果为true，添加技能完成后检测冲突；如果为false或未指定，不检测
       * @returns {string} 如果添加成功，返回技能名`skill`；否则，返回undefined
       */
      addTempSkill: function (skill, expire, checkConflict) {
        if (this.hasSkill(skill) && this.tempSkills[skill] == undefined) return;
        var noremove = this.skills.contains(skill);
        this.addSkill(skill, checkConflict, true);
        if (!noremove) this.skills.remove(skill);

        if (!expire) {
          expire = 'phaseAfter';
        }
        this.tempSkills[skill] = expire;

        if (typeof expire == 'string') {
          lib.hookmap[expire] = true;
        }
        else if (Array.isArray(expire)) {
          for (var i = 0; i < expire.length; i++) {
            lib.hookmap[expire[i]] = true;
          }
        }
        else if (get.objtype(expire) == 'object') {
          var roles = ['player', 'source', 'target'];
          for (var i = 0; i < roles.length; i++) {
            if (typeof expire[roles[i]] == 'string') {
              lib.hookmap[expire[roles[i]]] = true;
            }
            else if (Array.isArray(expire[roles[i]])) {
              for (var j = 0; j < expire[roles[i]].length; j++) {
                lib.hookmap[expire[roles[i]][j]] = true;
              }
            }
          }
          if (expire.global) {
            if (typeof expire.global == 'string') {
              lib.hookmap[expire.global] = true;
            }
            else if (Array.isArray(expire.global)) {
              for (var i = 0; i < expire.global.length; i++) {
                lib.hookmap[expire.global[i]] = true;
              }
            }
          }
        }

        for (var i in expire) {
          if (typeof expire[i] == 'string') {
            lib.hookmap[expire[i]] = true;
          }
          else if (Array.isArray(expire[i])) {
            for (var j = 0; j < expire.length; j++) {
              lib.hookmap[expire[i][j]] = true;
            }
          }
        }
        return skill;
      },
      /**
       * 
       * @returns {!boolean}
       */
      attitudeTo: function (target) {
        if (typeof get.attitude == 'function') return get.attitude(this, target);
        return 0;
      },
      /**
       * 
       * @returns {!boolean}
       */
      clearSkills: function (all) {
        var list = [];
        var exclude = [];
        for (var i = 0; i < arguments.length; i++) {
          exclude.push(arguments[i]);
        }
        for (i = 0; i < this.skills.length; i++) {
          if (lib.skill[this.skills[i]].superCharlotte) continue;
          if (!all && (lib.skill[this.skills[i]].temp || lib.skill[this.skills[i]].charlotte)) continue;
          if (!exclude.contains(this.skills[i])) {
            list.push(this.skills[i]);
          }
        }
        if (all) {
          for (var i in this.additionalSkills) {
            this.removeAdditionalSkill(i);
          }
        }
        this.removeSkill(list);
        this.checkConflict();
        this.checkMarks();
        return list;
      },
      /**
       * 
       * @returns {!boolean}
       */
      checkConflict: function (skill) {
        if (skill) {
          if (this.forbiddenSkills[skill]) {
            delete this.forbiddenSkills[skill];
          }
          else {
            for (var i in this.forbiddenSkills) {
              if (this.forbiddenSkills[i].remove(skill)) {
                if (!this.forbiddenSkills[i].length) {
                  delete this.forbiddenSkills[i];
                }
              }
            }
          }
        }
        else {
          this.forbiddenSkills = {};
          var forbid = [];
          var getName = function (arr) {
            var str = '';
            for (var i = 0; i < arr.length; i++) {
              str += arr[i] + '+';
            }
            return str.slice(0, str.length - 1);
          }
          var forbidlist = lib.config.forbid.concat(lib.config.customforbid);
          var skills = this.getSkills();
          for (var i = 0; i < forbidlist.length; i++) {
            if (lib.config.customforbid.contains(forbidlist[i]) ||
              !lib.config.forbidlist.contains(getName(forbidlist[i]))) {
              for (var j = 0; j < forbidlist[i].length; j++) {
                if (!skills.contains(forbidlist[i][j])) break;
              }
              if (j == forbidlist[i].length) {
                forbid.push(forbidlist[i]);
              }
            }
          }
          for (var i = 0; i < forbid.length; i++) {
            if (forbid[i][1] || this.name2) {
              this.forbiddenSkills[forbid[i][0]] = this.forbiddenSkills[forbid[i][0]] || [];
              if (forbid[i][1]) {
                this.forbiddenSkills[forbid[i][0]].add(forbid[i][1]);
              }
            }
          }
        }
      },
      /**
       * 返回本角色的一个记录数据
       * @returns {!boolean}
       */
      getHistory: function (key, filter, last) {
        if (!key) return this.actionHistory[this.actionHistory.length - 1];
        if (!filter) return this.actionHistory[this.actionHistory.length - 1][key];
        else {
          var history = this.getHistory(key).slice(0);
          if (last) history = history.slice(0, history.indexOf(last) + 1);
          for (var i = 0; i < history.length; i++) {
            if (!filter(history[i])) history.splice(i--, 1);
          }
          return history;
        }
      },
      hasHistory: function (key, filter, last) {
        var history = this.getHistory(key).slice(0);
        if (last) history = history.slice(0, history.indexOf(last) + 1);
        for (var i = 0; i < history.length; i++) {
          if (filter(history[i])) return true;
        }
        return false;
      },
      /**
       * 返回本角色最近(当前)的记录数据
       * @returns {Array}
       */
      getLastHistory: function (key, filter, last) {
        var history = false;
        for (var i = this.actionHistory.length - 1; i >= 0; i--) {
          if (this.actionHistory[i].isMe) {
            history = this.actionHistory[i]; break;
          }
        }
        if (!history) return null;
        if (!key) return history;
        if (!filter) return history[key];
        else {
          history = history.slice(0);
          if (last) history = history.slice(0, history.indexOf(last) + 1);
          for (var i = 0; i < history.length; i++) {
            if (!filter(history[i])) history.splice(i--, 1);
          }
          return history;
        }
      },
      /**
       * 返回本角色的记录数据 TODO
       * @returns {Array}
       */
      getAllHistory: function (key, filter, last) {
        var list = [];
        var all = this.actionHistory;
        for (var j = 0; j < all.length; j++) {
          if (!key || !all[j][key]) {
            list.push(all[j]);
          }
          else {
            if (!filter) list.addArray(all[j][key]);
            else {
              var history = all[j][key].slice(0);
              if (last) history = history.slice(0, history.indexOf(last) + 1);
              for (var i = 0; i < history.length; i++) {
                if (filter(history[i])) list.push(history[i]);
              }
            }
          }
        }
        return list;
      },
      hasAllHistory: function (key, filter, last) {
        var list = [];
        var all = this.actionHistory;
        for (var j = 0; j < all.length; j++) {
          var history = all[j][key].slice(0);
          if (last) history = history.slice(0, history.indexOf(last) + 1);
          for (var i = 0; i < history.length; i++) {
            if (filter(history[i])) return true;
          }
        }
        return false;
      },
      /**
       * 返回一张本角色使用过的牌
       * @param {number} [idx=0] 索引，从最近到最远，为0表示最近使用的牌，如果未索引到(e.g. `idx >= length`)，返回null
       * @returns {(GameCores.GameObjects.Card|null)} 
       */
      getLastUsed: function (num) {
        if (typeof num != 'number') num = 0;
        var history = this.getHistory('useCard');
        if (history.length <= num) return null;
        return history[history.length - num - 1];
      },
      /**
       * 返回最后的`stat`的指定键名的值
       * @param {string} [key] 键名；如果未指定或者为空字符串，返回最后`stat`
       * @returns {?Object}
       */
      getStat: function (key) {
        if (!key) return this.stat[this.stat.length - 1];
        return this.stat[this.stat.length - 1][key];
      },
      /**
       * 返回最后的`stat`的指定键名的值 TODO
       * @param {string} [key] 键名；如果未指定或者为空字符串，返回最后`stat`
       * @returns {?Object}
       */
      getLastStat: function (key) {
        var stat = false;
        for (var i = this.stat.length - 1; i >= 0; i--) {
          if (this.stat[i].isMe) {
            stat = this.stat[i]; break;
          }
        }
        if (!stat) return null
        if (!key) return stat;
        return stat[key];
      },
      /**
       * 设置本角色的Timeout队列，Timeout延迟一定时长，然后重置角色位置
       * @param {(number|false)} [time=500] 等待时长(ms)；如果为false，表示终止最近添加的Timeout并重置本角色Timeout队列计数
       */
      queue: function (time) {
        if (time == false) {
          clearTimeout(this.queueTimeout);
          this.queueCount = 0;
          return;
        }
        if (time == undefined) time = 500;
        var player = this;
        player.queueCount++;
        this.queueTimeout = setTimeout(function () {
          player.queueCount--;
          if (player.queueCount == 0) {
            player.style.transform = '';
            player.node.avatar.style.transform = '';
            player.node.avatar2.style.transform = '';
            if (game.chess) {
              ui.placeChess(player, player.dataset.position);
            }
            if (player == game.me) ui.me.removeAttribute('style');
          }
        }, time)
      },
      /**
       * 返回一张游戏牌可以被本角色使用的次数，如果本角色有被动技**cardUsable**改变游戏牌的使用次数，采用改变后的值
       * @param {!string} cardname 牌名
       * @param {boolean} [ignoreUsed] 是否忽略使用过的次数，如果为true，忽略使用过的次数；如果为false或者未指定，结果会减去使用过的次数
       * @returns {!number}
       */
      getCardUsable: function (card, pure) {
        var player = this;
        if (typeof card == 'string') {
          card = { name: card };
        }
        card = get.autoViewAs(card, null, player);
        var num = get.info(card).usable;
        if (typeof num == 'function') num = num(card, player);
        num = game.checkMod(card, player, num, 'cardUsable', player);
        if (typeof num != 'number') return Infinity;
        if (!pure && _status.currentPhase == player) {
          return num - player.countUsed(card);
        }
        return num;
      },
      /**
       * 返回攻击范围
       * @returns {!number}
       */
      getAttackRange: function (raw) {
        var player = this;
        var range = 0;
        if (raw) range = game.checkMod(player, player, range, 'globalFrom', player);
        range = game.checkMod(player, player, range, 'attackFrom', player);
        var equips = player.getCards('e', function (card) {
          return !ui.selected.cards || !ui.selected.cards.contains(card);
        });
        for (var i = 0; i < equips.length; i++) {
          var info = get.info(equips[i]).distance;
          if (!info) continue;
          if (raw && info.globalFrom) {
            range += info.globalFrom;
          }
          if (info.attackFrom) {
            range += info.attackFrom;
          }
        }
        return (1 - range);
      },
      /**
       * TODO
       * @returns {!boolean}
       */
      getGlobalFrom: function () {
        var player = this;
        var range = 0;
        range = game.checkMod(player, player, range, 'globalFrom', player);
        var equips = player.getCards('e', function (card) {
          return !ui.selected.cards || !ui.selected.cards.contains(card);
        });
        for (var i = 0; i < equips.length; i++) {
          var info = get.info(equips[i]).distance;
          if (!info) continue;
          if (info.globalFrom) {
            range += info.globalFrom;
          }
        }
        return (-range);
      },
      /**
       * TODO
       * @returns {!boolean}
       */
      getGlobalTo: function () {
        var player = this;
        var range = 0;
        range = game.checkMod(player, player, range, 'globalTo', player);
        var equips = player.getCards('e', function (card) {
          return !ui.selected.cards || !ui.selected.cards.contains(card);
        });
        for (var i = 0; i < equips.length; i++) {
          var info = get.info(equips[i]).distance;
          if (!info) continue;
          if (info.globalTo) {
            range += info.globalTo;
          }
        }
        return (range);
      },
      /**
       * 返回本角色的最大手牌数**num**；如果本角色有被动技**maxHandcardBase maxHandcard maxHandcardFinal**，依次改变**num**，返回改变后的**num**；**num**不会小于0
       * @returns {!number} 非负整数
       */
      getHandcardLimit: function () {
        var num = Math.max(this.hp, 0);
        num = game.checkMod(this, num, 'maxHandcardBase', this);
        num = game.checkMod(this, num, 'maxHandcard', this);
        num = game.checkMod(this, num, 'maxHandcardFinal', this);
        return Math.max(0, num);
      },
      /**
       * @callback lib.element.player~playerFilterPredicate
       * @param {!GameCores.GameObjects.Player} player
       * @returns {!boolean}
       */
      /**
       * 返回本角色的敌方角色
       * @name lib.element.player.getEnemies
       * @function
       * @param {lib.element.player~playerFilterPredicate} [predicate] 筛选函数
       * @returns {!GameCores.GameObjects.Player[]} 如果没有找到角色，返回空数组
       */
      getEnemies: function (func) {
        var player = this;
        var targets;
        var mode = get.mode();
        if (mode == 'identity') {
          if (_status.mode == 'purple') {
            switch (player.identity) {
              case 'bZhu': case 'bZhong': case 'rNei': targets = game.filterPlayer(function (target) {
                if (func && !func(target)) return false;
                return ['rZhu', 'rZhong', 'bNei'].contains(target.identity);
              }); break;
              case 'rZhu': case 'rZhong': case 'bNei': targets = game.filterPlayer(function (target) {
                if (func && !func(target)) return false;
                return ['bZhu', 'bZhong', 'rNei'].contains(target.identity);
              }); break;
              case 'rYe': case 'bYe': targets = game.filterPlayer(function (target) {
                if (func && !func(target)) return false;
                return !['rYe', 'bYe'].contains(target.identity);
              }); break;
            }
          }
          else {
            var num = get.population('fan');
            switch (player.identity) {
              case 'zhu': case 'zhong': case 'mingzhong': targets = game.filterPlayer(function (target) {
                if (func && !func(target)) return false;
                if (num >= 3) return target.identity == 'fan';
                return target.identity == 'nei' || target.identity == 'fan';
              }); break;
              case 'nei': targets = game.filterPlayer(function (target) {
                if (func && !func(target)) return false;
                if (num >= 3) return target.identity == 'fan';
                if (game.players.length == 2) return target != player;
                return target.identity == 'zhong' || target.identity == 'mingzhong' || target.identity == 'fan';
              }); break;
              case 'fan': targets = game.filterPlayer(function (target) {
                if (func && !func(target)) return false;
                return target.identity != 'fan';
              }); break;
            }
          }
        }
        else if (mode == 'guozhan') {
          if (player.identity == 'ye') {
            targets = game.filterPlayer(function (target) {
              if (func && !func(target)) return false;
              return true;
            });
          }
          else {
            var group = lib.character[player.name1][1];
            targets = game.filterPlayer(function (target) {
              if (func && !func(target)) return false;
              return target.identity == 'ye' || lib.character[target.name1][1] != group;
            });
          }
        }
        else if (mode == 'doudizhu' || mode == 'longlaoguan') {
          targets = game.filterPlayer(function (target) {
            if (func && !func(target)) return false;
            return target.identity != player.identity;
          });
        }
        else {
          targets = game.filterPlayer(function (target) {
            if (func && !func(target)) return false;
            return target.side != player.side;
          });
        }
        targets.remove(player);
        return targets;
      },
      /**
       * 返回本角色的友方角色
       * @name lib.element.player.getFriends
       * @function
       * @param {lib.element.player~playerFilterPredicate} predicate 筛选函数
       * @returns {!GameCores.GameObjects.Player[]} 如果没有找到角色，返回空数组
       */
      /**
       * 返回本角色的友方角色
       * @name lib.element.player.getFriends
       * @function
       * @param {?boolean} hasSelf 结果是否包含本角色，如果为true，则包括；如果为false或未指定，则不包括
       * @returns {!GameCores.GameObjects.Player[]} 如果没有找到角色，返回空数组
       */
      getFriends: function (func) {
        var player = this;
        var targets;
        var mode = get.mode();
        var self = false;
        if (func === true) {
          func = null;
          self = true;
        }
        if (mode == 'identity') {
          if (_status.mode == 'purple') {
            switch (player.identity) {
              case 'rZhu': case 'rZhong': case 'bNei': targets = game.filterPlayer(function (target) {
                if (func && !func(target)) return false;
                return ['rZhu', 'rZhong', 'bNei'].contains(target.identity);
              }); break;
              case 'bZhu': case 'bZhong': case 'rNei': targets = game.filterPlayer(function (target) {
                if (func && !func(target)) return false;
                return ['bZhu', 'bZhong', 'rNei'].contains(target.identity);
              }); break;
              case 'rYe': case 'bYe': targets = game.filterPlayer(function (target) {
                if (func && !func(target)) return false;
                return ['rYe', 'bYe'].contains(target.identity);
              }); break;
            }
          }
          else {
            switch (player.identity) {
              case 'zhu': case 'zhong': case 'mingzhong': targets = game.filterPlayer(function (target) {
                if (func && !func(target)) return false;
                return ['zhu', 'zhong', 'mingzhong'].contains(target.identity);
              }); break;
              case 'nei': targets = []; break;
              case 'fan': targets = game.filterPlayer(function (target) {
                if (func && !func(target)) return false;
                return target.identity == 'fan';
              }); break;
            }
          }
        }
        else if (mode == 'guozhan') {
          if (player.identity == 'ye') {
            targets = [];
          }
          else {
            var group = lib.character[player.name1][1];
            targets = game.filterPlayer(function (target) {
              if (func && !func(target)) return false;
              return target.identity != 'ye' && lib.character[target.name1][1] == group;
            });
          }
        }
        else if (mode == 'doudizhu' || mode == 'longlaoguan') {
          targets = game.filterPlayer(function (target) {
            if (func && !func(target)) return false;
            return target.identity == player.identity;
          });
        }
        else {
          targets = game.filterPlayer(function (target) {
            if (func && !func(target)) return false;
            return target.side == player.side;
          });
        }
        if (self) {
          targets.add(player);
        }
        else {
          targets.remove(player);
        }
        return targets;
      },
      /**
       * 返回本角色是否是目标的敌方
       * @param {!GameCores.GameObjects.Player} player 目标角色
       * @returns {!boolean}
       */
      isEnemyOf: function () {
        return !this.isFriendOf.apply(this, arguments);
      },
      /**
       * 返回本角色是否是目标的友方
       * @param {!GameCores.GameObjects.Player} player 目标角色
       * @returns {!boolean}
       */
      isFriendOf: function (player) {
        if (get.mode() == 'guozhan') {
          if (this == player) return true;
          if (this.storage.yexinjia_friend == player || player.$.yexinjia_friend == this) return true;
          if (this.identity == 'unknown' || this.identity == 'ye') return false;
          if (player.identity == 'unknown' || player.identity == 'ye') return false;
          return this.identity == player.identity;
        }
        if (get.mode() == 'doudizhu' || get.mode() == 'longlaoguan') {
          return this.identity == player.identity;
        }
        if (this.side != undefined && typeof player.side == 'boolean') {
          return this.side == player.side;
        }
        return this == player;
      },
      /**
       * 返回本角色是否是目标的友方
       * @param {!GameCores.GameObjects.Player} player 目标角色
       * @returns {!boolean}
       */
      isFriendsOf: function (player) {
        return player.getFriends(true).contains(this);
      },
      /**
       * 返回本角色是否是目标的敌方
       * @param {!GameCores.GameObjects.Player} player 目标角色
       * @returns {!boolean}
       */
      isEnemiesOf: function (player) {
        return player.getEnemies().contains(this);
      },
      /**
       * 返回本角色是否未死亡
       * @returns {!boolean} true表示未死亡，false表示已死亡
       */
      isAlive: function () {
        return this.classList.contains('dead') == false;
      },
      /**
       * 返回本角色是否死亡
       * @returns {!boolean}
       */
      isDead: function () {
        return this.classList.contains('dead');
      },
      /**
       * 返回本角色是否处于濒死状态
       * @returns {!boolean}
       */
      isDying: function () {
        return _status.dying.contains(this) && this.hp <= 0 && this.isAlive();
      },
      /**
       * 返回本角色是否当前血量小于最大血量，如果本角色处于**无HP状态**，返回false
       * @returns {!boolean}
       */
      isDamaged: function () {
        return this.hp < this.maxHp && !this.storage.nohp;
      },
      /**
       * 返回本角色是否当前血量等于最大血量，如果本角色处于**无HP状态**，返回true
       * @returns {!boolean}
       */
      isHealthy: function () {
        return this.hp == this.maxHp || this.storage.nohp;
      },
      /**
       * 返回本角色的血量是否是局中最多
       * @param {boolean} [isUnique] 如果为true，只在血量最多且唯一时返回true；如果为false或未指定，只要血量最多就返回true
       * @returns {!boolean}
       */
      isMaxHp: function (equal) {
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i].isOut() || game.players[i] == this) continue;
          if (equal) {
            if (game.players[i].hp >= this.hp) return false;
          }
          else {
            if (game.players[i].hp > this.hp) return false;
          }
        }
        return true;
      },
      /**
       * 返回本角色的血量是否是局中最少
       * @param {boolean} [isUnique] 如果为true，只在血量最少且唯一时返回true；如果为false或未指定，只要血量最少就返回true
       * @returns {!boolean}
       */
      isMinHp: function (equal) {
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i].isOut() || game.players[i] == this) continue;
          if (equal) {
            if (game.players[i].hp <= this.hp) return false;
          }
          else {
            if (game.players[i].hp < this.hp) return false;
          }
        }
        return true;
      },
      /**
       * 返回本角色的手牌和装备总数是否是局中最多
       * @param {boolean} [isUnique] 如果为true，只在数量最多且唯一时返回true；如果为false或未指定，只要数量是最多就返回true
       * @returns {!boolean}
       */
      isMaxCard: function (equal) {
        var nh = this.countCards('he');
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i].isOut() || game.players[i] == this) continue;
          if (equal) {
            if (game.players[i].countCards('he') >= nh) return false;
          }
          else {
            if (game.players[i].countCards('he') > nh) return false;
          }
        }
        return true;
      },
      /**
       * 返回本角色的手牌和装备总数是否是局中最少
       * @param {boolean} [isUnique] 如果为true，只在数量最少且唯一时返回true；如果为false或未指定，只要数量是最少就返回true
       * @returns {!boolean}
       */
      isMinCard: function (equal) {
        var nh = this.countCards('he');
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i].isOut() || game.players[i] == this) continue;
          if (equal) {
            if (game.players[i].countCards('he') <= nh) return false;
          }
          else {
            if (game.players[i].countCards('he') < nh) return false;
          }
        }
        return true;
      },
      /**
       * 返回本角色的手牌数量是否是局中最多
       * @param {boolean} [isUnique] 如果为true，只在手牌数量最多且唯一时返回true；如果为false或未指定，只要装备数量是最多就返回true
       * @returns {!boolean}
       */
      isMaxHandcard: function (equal) {
        var nh = this.countCards('h');
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i].isOut() || game.players[i] == this) continue;
          if (equal) {
            if (game.players[i].countCards('h') >= nh) return false;
          }
          else {
            if (game.players[i].countCards('h') > nh) return false;
          }
        }
        return true;
      },
      /**
       * 返回本角色的手牌数量是否是局中最少
       * @param {boolean} [isUnique] 如果为true，只在手牌数量最少且唯一时返回true；如果为false或未指定，只要手牌数量是最少就返回true
       * @returns {!boolean}
       */
      isMinHandcard: function (equal) {
        var nh = this.countCards('h');
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i].isOut() || game.players[i] == this) continue;
          if (equal) {
            if (game.players[i].countCards('h') <= nh) return false;
          }
          else {
            if (game.players[i].countCards('h') < nh) return false;
          }
        }
        return true;
      },
      /**
       * 返回本角色的装备数量是否是局中最多
       * @param {boolean} [isUnique] 如果为true，只在装备数量最多且唯一时返回true；如果为false或未指定，只要装备数量是最多就返回true
       * @returns {!boolean}
       */
      isMaxEquip: function (equal) {
        var nh = this.countCards('e');
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i].isOut() || game.players[i] == this) continue;
          if (equal) {
            if (game.players[i].countCards('e') >= nh) return false;
          }
          else {
            if (game.players[i].countCards('e') > nh) return false;
          }
        }
        return true;
      },
      /**
       * 返回本角色的装备数量是否是局中最少
       * @param {boolean} [isUnique] 如果为true，只在装备数量最少且唯一时返回true；如果为false或未指定，只要装备数量是最少就返回true
       * @returns {!boolean}
       */
      isMinEquip: function (equal) {
        var nh = this.countCards('e');
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i].isOut() || game.players[i] == this) continue;
          if (equal) {
            if (game.players[i].countCards('e') <= nh) return false;
          }
          else {
            if (game.players[i].countCards('e') < nh) return false;
          }
        }
        return true;
      },
      /**
       * 返回本角色是否被链接
       * @returns {!boolean} true表示被链接，false表示未被链接
       */
      isLinked: function () {
        if (get.is.linked2(this)) {
          return this.classList.contains('linked2');
        }
        return this.classList.contains('linked');
      },
      /**
       * 返回本角色是否翻面
       * @returns {!boolean} true表示翻面，false表示未翻面
       */
      isTurnedOver: function () {
        return this.classList.contains('turnedover');
      },
      /**
       * 返回本角色的玩家是否离开
       * @returns {!boolean} true表示离开，false表示未离开
       */
      isOut: function () {
        return this.classList.contains('out');
      },
      /**
       * 本角色是否不计入距离的计算
       * @param {?boolean} [distance]
       * @returns {!boolean}
       */
      //TODO
      isMin: function (distance) {
        if (distance && lib.config.mode != 'stone') return false;
        if (this.forcemin) return true;
        return this.classList.contains('minskin') && !game.chess;
      },
      /**
       * 表示本角色是否在局中(未死亡&未离开&未移出房间)
       * @returns {!boolean} true表示在局中，false表示不在局中
       */
      isIn: function () {
        return this.classList.contains('dead') == false && this.classList.contains('out') == false && !this.removed;
      },
      /**
       * 返回本角色是否可见，如果可见返回true
       * @param {number} num **0**: unseen; **1**: unseen2; **2**: unseen && unseen2; **default**: unseen && !unseen2 
       * @returns {!boolean}
       */
      isUnseen: function (num) {
        switch (num) {
          case 0: return this.classList.contains('unseen');
          case 1: return this.classList.contains('unseen2');
          case 2: return this.classList.contains('unseen') || this.classList.contains('unseen2');
          default: return this.classList.contains('unseen') && (!this.name2 || this.classList.contains('unseen2'));
        }
      },
      /**
       * 判断本角色是否可以被某角色的玩家控制
       * @param {?boolean} self 如果为true，当是两个角色是同一个角色时返回true；如果为false或未指定，返回false
       * @param {GameCores.GameObjects.Player} [me] 某角色，用于判断本角色是否被`me`的玩家控制，如果未指定，默认使用`game.me`
       * @returns {!boolean}
       */
      isUnderControl: function (self, me) {
        me = (me || game.me);
        var that = this._trueMe || this;
        if (that.isMad() || game.notMe) return false;
        if (this === me) {
          if (self) return true;
          return false;
        }
        if (that === me || this == me._trueMe) return true;
        if (_status.connectMode) return false;
        if (lib.config.mode == 'versus') {
          if (_status.mode == 'three') return this.side == me.side;
          if (_status.mode == 'standard') return lib.storage.single_control && this.side == me.side;
          if (_status.mode == 'four') return get.config('four_phaseswap') && this.side == me.side;
          if (_status.mode == 'two') return get.config('two_phaseswap') && this.side == me.side;
          return false;
        }
        else if (lib.config.mode == 'boss') {
          if (me.side) return false;
          return this.side == me.side && get.config('single_control');
        }
        else if (game.chess) {
          if (lib.config.mode == 'chess') {
            if (_status.mode == 'combat' && !get.config('single_control')) return false;
          }
          return this.side == me.side;
        }
        return false;
      },
      /**
       * 角色是否处于联机状态
       * 注意，该函数如果角色处于托管状态，返回false
       * @returns {!boolean}
       */
      isOnline: function () {
        if (this.ws && lib.node && !this.ws.closed && this.ws.inited && !this.isAuto) {
          return true;
        }
        return false;
      },
      /**
       * 角色是否处于联机状态
       * @returns {!boolean}
       */
      isOnline2: function () {
        if (this.ws && lib.node && !this.ws.closed) {
          return true;
        }
        return false;
      },
      /**
       * 角色是否处于脱机状态
       * @returns {!boolean}
       */
      isOffline: function () {
        if (this.ws && lib.node && this.ws.closed) {
          return true;
        }
        return false;
      },
      checkShow: function (skill, showonly) {
        var sourceSkill = get.info(skill);
        var noshow = false;
        if (sourceSkill && sourceSkill.sourceSkill) {
          skill = sourceSkill.sourceSkill;
        }
        if (lib.skill.global.contains(skill)) return false;
        if (get.mode() != 'guozhan' || game.expandSkills(this.getSkills()).contains(skill)) {
          if (showonly) {
            return false;
          }
          else {
            noshow = true;
          }
        }
        var unseen0 = this.isUnseen(0);
        var name1 = this.name1 || this.name;
        if (lib.character[name1] && (!showonly || unseen0)) {
          var skills = game.expandSkills(lib.character[name1][3].slice(0));
          if (skills.contains(skill)) {
            if (!noshow && this.isUnseen(0)) this.showCharacter(0);
            return 'main';
          }
        }
        var unseen1 = this.isUnseen(1);
        var name2 = this.name2;
        if (lib.character[name2] && (!showonly || unseen1)) {
          var skills = game.expandSkills(lib.character[name2][3].slice(0));
          if (skills.contains(skill)) {
            if (!noshow && this.isUnseen(1)) this.showCharacter(1);
            return 'vice';
          }
        }
        return false;
      },
      /**
       * 返回本角色当前超出手牌上限多少张牌，如果没有超出上限，返回0；
       * 如果角色有被动技**ignoredHandcard**，令被动技返回`true`的牌不计入手牌上限
       * @param {?number} [num] 
       * @returns {!number} 非负整数
       */
      needsToDiscard: function (num) {
        if (typeof num != 'number') num = 0;
        var hs = this.getCards('h');
        num += hs.length;
        for (var i = 0; i < hs.length; i++) {
          if (game.checkMod(hs[i], this, false, 'ignoredHandcard', this) == true) {
            num--;
          }
        }
        return Math.max(0, num - this.getHandcardLimit());
      },
      distanceTo: function (target, method) {
        return get.distance(this, target, method);
      },
      distanceFrom: function (target, method) {
        return get.distance(target, this, method);
      },
      /**
       * 返回本角色是否拥有一个技能；
       * 此技能会在角色拥有(技能|子技能)中查找技能名；
       * 实际调用了{@link lib.element.player.getSkills this.getSkills(arg2, arg3, arg4)}，并用{@link game.expandSkills}展开
       * @param {!string} skill 技能名
       * @param {*} arg2 为真时表示计入隐藏的技能、为'e'时表示仅返回装备技能
       * @param {*} arg3 为false时表示不计入装备技能
       * @param {*} arg4 为false时表示计入失效的技能
       * @returns {!boolean}
       */
      hasSkill: function (skill, arg2, arg3, arg4) {
        return game.expandSkills(this.getSkills(arg2, arg3, arg4)).contains(skill);
      },
      hasStockSkill: function (skill, arg1, arg2, arg3) {
        return game.expandSkills(this.getStockSkills(arg1, arg2, arg3)).contains(skill);
      },
      hasZhuSkill: function (skill, player) {
        if (!this.hasSkill(skill)) return false;
        var mode = get.mode();
        if (mode == 'identity' || (mode == 'versus' && (_status.mode == 'four' || _status.mode == 'guandu'))) {
          if (mode != 'identity') {
            if (player && this.side != player.side) return false;
          }
          if (_status.mode == 'purple') {
            if (player && this.identity.slice(0, 1) != player.identity.slice(0, 1)) return false;
          }
          if (this.isZhu == true) return true;
          for (var i in this.storage) {
            if (i.indexOf('zhuSkill_') == 0 && this.storage[i].contains(skill)) return true;
          }
        }
        return false;
      },
      hasGlobalTag: function (tag, arg) {
        var skills = lib.skill.global.slice(0);
        game.expandSkills(skills);
        for (var i = 0; i < skills.length; i++) {
          var info = lib.skill[skills[i]];
          if (info && info.ai) {
            if (info.ai.skillTagFilter && info.ai[tag] &&
              info.ai.skillTagFilter(this, tag, arg) === false) continue;
            if (typeof info.ai[tag] == 'string') {
              if (info.ai[tag] == arg) return true;
            }
            else if (info.ai[tag]) {
              return true;
            }
          }
        }
        return false;
      },
      hasSkillTag: function (tag, hidden, arg, globalskill) {
        var skills = this.getSkills(hidden);
        if (globalskill) {
          skills.addArray(lib.skill.global);
        }
        game.expandSkills(skills);
        for (var i = 0; i < skills.length; i++) {
          var info = lib.skill[skills[i]];
          if (info && info.ai) {
            if (info.ai.skillTagFilter && info.ai[tag] &&
              info.ai.skillTagFilter(this, tag, arg) === false) continue;
            if (typeof info.ai[tag] == 'string') {
              if (info.ai[tag] == arg) return true;
            }
            else if (info.ai[tag]) {
              return true;
            }
          }
        }
        return false;
      },
      hasJudge: function (name) {
        if (name && typeof name == 'object') {
          name = name.viewAs || name.name;
        }
        var judges = this.node.judges.childNodes;
        for (var i = 0; i < judges.length; i++) {
          if (judges[i].classList.contains('removing')) continue;
          if ((judges[i].viewAs || judges[i].name) == name) {
            return true;
          }
        }
        return false;
      },
      hasFriend: function () {
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i].isOut()) continue;
          if (game.players[i] != this && get.attitude(game.players[i], this) > 0) {
            return true;
          }
        }
        return false;
      },
      hasUnknown: function (num) {
        var mode = get.mode();
        if (typeof num != 'number') {
          num = 0;
        }
        if (mode == 'identity' || mode == 'guozhan') {
          for (var i = 0; i < game.players.length; i++) {
            if (game.players[i].ai.shown == 0 && game.players[i] != this) {
              num--;
              if (num <= 0) {
                return true;
              }
            }
          }
        }
        return false;
      },
      isUnknown: function (player) {
        var mode = get.mode();
        if (mode == 'identity' || mode == 'guozhan') {
          if (this.ai.shown == 0 && this != player) {
            return true;
          }
        }
        return false;
      },
      //暗属性
      hasYami: function () {
        if (this.countCards('h', { nature: 'yami' })) return true;
        var skills = this.getSkills(true).concat(lib.skill.global);
        game.expandSkills(skills);
        for (var i = 0; i < skills.length; i++) {
          var ifo = get.info(skills[i]);
          if (ifo.viewAs && typeof ifo.viewAs != 'function' && ifo.viewAs.nature == 'yami') {
            if (!ifo.viewAsFilter || ifo.viewAsFilter(this)) {
              return true;
            }
          }
          else {
            var hiddenYami = get.info(skills[i]).hiddenYami;
            if (typeof hiddenYami == 'function' && hiddenYami(this, false)) {
              return true;
            }
          }
        }
        return false;
      },
      hasWuxie: function () {
        if (this.countCards('hs', 'wuxie')) return true;
        var skills = this.getSkills(true).concat(lib.skill.global);
        game.expandSkills(skills);
        for (var i = 0; i < skills.length; i++) {
          var ifo = get.info(skills[i]);
          if (ifo.viewAs && typeof ifo.viewAs != 'function' && ifo.viewAs.name == 'wuxie') {
            if (!ifo.viewAsFilter || ifo.viewAsFilter(this)) {
              return true;
            }
          }
          else {
            var hiddenCard = get.info(skills[i]).hiddenCard;
            if (typeof hiddenCard == 'function' && hiddenCard(this, 'wuxie')) {
              return true;
            }
          }
        }
        return false;
      },
      hasSha: function (respond, noauto) {
        if (this.countCards('hs', 'sha')) return true;
        if (this.countCards('hs', 'hufu')) return true;
        if (!noauto && this.countCards('hs', 'yuchanqian')) return true;
        if (this.hasSkillTag('respondSha', true, respond ? 'respond' : 'use', true)) return true;
        return false;
      },
      hasShan: function () {
        if (this.countCards('hs', 'shan')) return true;
        if (this.countCards('hs', 'hufu')) return true;
        if (this.hasSkillTag('respondShan', true, null, true)) return true;
        return false;
      },
      mayHaveShan: function () {
        return this.hasShan();
        // modify: After AngelBeats! -2nd Beat-
      },
      hasCard: function (name, position) {
        if (typeof name == 'function') {
          var hs = this.getCards(position);
          for (var i = 0; i < hs.length; i++) {
            if (name(hs[i])) return true;
          }
        }
        else {
          if (this.countCards(position, name)) return true;
        }
        return false;
      },
      canEquip: function (name, replace) {
        if (get.type(name) == 'card') {
          name = get.equiptype(name);
        }
        var range = get.subtype(name);
        if (this.isDisabled(range)) return false;
        if (['equip3', 'equip4'].contains(range) && this.getEquip(6)) return false;
        if (!replace && !this.isEmpty(range)) return false;
        return true;
      },
      /**
       * 装备类型
       * |string|number|equip|
       * |:----:|:----:|:---:|
       * |equip1|1|武器|
       * |equip2|2|防具|
       * |equip3|3|防御载具|
       * |equip4|4|攻击载具|
       * |equip5|5|宝物|
       * |equip6|6|坐骑|
       * 
       * @typedef {('equip[1-6]'|number)} GameCores.EquipType
       */
      /**
       * 返回角色装备区的一张牌
       * @param {(GameCores.GameObjects.Card|'equip[0-9]'|number)} name 如果为游戏牌对象，使用其装备类型(如果有)；如果不是可装备类型或者`name`未指定，此函数返回null；可以取值为数值[0-9]或字符串'equip[0-9]'，但是通常只在[1-6]范围内({@link GameCores.EquipType})
       * @returns {(null|GameCores.GameObjects.Card)}
       */
      getEquip: function (name) {
        var es = this.getCards('e');
        if (typeof name == 'object' && get.info(name)) {
          name = get.info(name).subtype;
          if (name) {
            name = parseInt(name[5]);
          }
        }
        else if (typeof name == 'string' && name.indexOf('equip') == 0 && name.length == 6) {
          name = parseInt(name[5]);
        }
        if (!name) {
          return null;
        }
        for (var i = 0; i < es.length; i++) {
          if (typeof name === 'number') {
            if (get.info(es[i]).subtype === 'equip' + name) {
              return es[i];
            }
          }
          else {
            if (es[i].name === name) return es[i];
            var source = get.info(es[i]).source;
            if (Array.isArray(source) && source.contains(name)) {
              return es[i];
            }
          }
        }
        return null;
      },
      /**
       * 返回角色判定区一张(指定牌|视为指定牌)
       * @function
       * @param {?string} name 指定牌的牌名
       * @returns {(GameCores.GameObjects.Card|null)} 如果没找到，返回null
       */
      getJudge: function (name) {
        var judges = this.node.judges.childNodes;
        for (var i = 0; i < judges.length; i++) {
          if (judges[i].classList.contains('removing')) continue;
          if ((judges[i].viewAs || judges[i].name) == name) {
            return judges[i];
          }
        }
        return null;
      },
      $drawAuto: function (cards, target) {
        if (this.isUnderControl(true, target)) {
          this.$draw(cards);
        }
        else {
          this.$draw(cards.length);
        }
      },
      $draw: function (num, init, config) {
        if (init !== false && init !== 'nobroadcast') {
          game.broadcast(function (player, num, init, config) {
            player.$draw(num, init, config)
          }, this, num, init, config);
        }
        var cards, node;
        if (get.itemtype(num) == 'cards') {
          cards = num;
          num = cards.length;
        }
        else if (get.itemtype(num) == 'card') {
          cards = [num];
          num = 1;
        }
        if (init !== false) {
          if (cards) {
            game.addVideo('drawCard', this, get.cardsInfo(cards));
          }
          else {
            game.addVideo('draw', this, num);
          }
        }
        if (cards) {
          cards = cards.slice(0);
          node = cards.shift().copy('thrown', 'drawingcard');
        }
        else {
          node = ui.create.div('.card.thrown.drawingcard');
        }
        node.fixed = true;
        node.hide();

        var dx, dy;
        if (game.chess) {
          var rect = this.getBoundingClientRect();

          if (rect.left <= 80) {
            dx = -10;
            if (rect.top <= 80) {
              dy = -10;
            }
            else if (rect.top + rect.height + 80 >= ui.chessContainer.offsetHeight) {
              dy = 10;
            }
            else {
              dy = 0;
            }
          }
          else if (rect.left + rect.width + 80 >= ui.chessContainer.offsetWidth) {
            dx = 10;
            if (rect.top <= 80) {
              dy = -10;
            }
            else if (rect.top + rect.height + 80 >= ui.chessContainer.offsetHeight) {
              dy = 10;
            }
            else {
              dy = 0;
            }
          }
          else if (rect.top <= 80) {
            dx = 0;
            dy = -10;
          }
          else if (rect.top + rect.height + 80 >= ui.chessContainer.offsetHeight) {
            dx = 0;
            dy = 10;
          }
          else {
            dx = rect.left + this.offsetWidth / 2 - ui.arena.offsetWidth / 2;
            dy = rect.top + this.offsetHeight / 2 - ui.arena.offsetHeight / 2;
          }

          var coeff = 240 / Math.sqrt(dx * dx + dy * dy);
          dx *= coeff;
          dy *= coeff;

          node.style.left = (this.getLeft() + this.offsetWidth / 2 - 52 - dx) + 'px';
          node.style.top = (this.getTop() + this.offsetHeight / 2 - 52 - dy) + 'px';
          this.parentNode.appendChild(node);
        }
        else {
          this.parentNode.appendChild(node);
          node.style.left = 'calc(50% - 52px)';
          node.style.top = 'calc(50% - 52px)';

          dx = this.getLeft() + this.offsetWidth / 2 - 52 - node.offsetLeft;
          dy = this.getTop() + this.offsetHeight / 2 - 52 - node.offsetTop;

          if (get.is.mobileMe(this)) {
            dx += get.cardOffset();
            if (ui.arena.classList.contains('oblongcard')) {
              dy -= 16;
            }
          }
        }
        node.style.transitionDuration = '0.8s';
        ui.refresh(node);
        if (typeof num == 'number' && init !== false) {
          config = {
            total: num,
            current: 1
          }
        }
        if (config && config.total > 1) {
          var total = config.total, current = config.current;
          var dxtotal;
          if (total <= 5) {
            dxtotal = Math.min(80, (total - 1) * 20);
            dx += -dxtotal + 2 * dxtotal * (current - 1) / (total - 1)
          }
          else {
            var total2 = Math.floor(total / 2);
            if (current <= total2) {
              total = total2;
              dy -= 20;
            }
            else {
              current -= total2;
              total -= total2;
              dy += 20;
            }
            dxtotal = Math.min(80, (total - 1) * 20);
            dx += -dxtotal + 2 * dxtotal * (current - 1) / (total - 1)
          }
          config.current++;
        }
        if (node.style.transform && node.style.transform != 'none' && node.style.transform.indexOf('translate') == -1) {
          node.style.transform += ' translate(' + dx + 'px,' + dy + 'px)';
        }
        else {
          node.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
        }
        node.show();

        node.listenTransition(function () {
          node.style.transitionDuration = '0.5s';
          ui.refresh(node);
          node.delete();
        });
        var that = this;
        if (num && num > 1) {
          if (config && config.total > 1) {
            setTimeout(function () {
              if (cards) {
                that.$draw(cards, false, config)
              }
              else {
                that.$draw(num - 1, false, config)
              }
            }, 50)
          }
          else {
            setTimeout(function () {
              if (cards) {
                that.$draw(cards, false, config)
              }
              else {
                that.$draw(num - 1, false, config)
              }
            }, 200);
          }
        }
      },
      $compareMultiple: function (card1, targets, cards) {
        game.broadcast(function (player, card1, targets, cards) {
          player.$compareMultiple(card1, targets, cards);
        }, this, card1, targets, cards);
        game.addVideo('compareMultiple', this, [get.cardInfo(card1), get.targetsInfo(targets), get.cardsInfo(cards)]);
        var player = this;
        var node1 = player.$throwxy2(card1,
          'calc(50% - 52px)', 'calc(50% + 10px)', 'perspective(600px) rotateY(180deg)', true
        );
        if (lib.config.cardback_style != 'default') {
          node1.style.transitionProperty = 'none';
          ui.refresh(node1);
          node1.classList.add('infohidden');
          ui.refresh(node1);
          node1.style.transitionProperty = '';
        }
        else {
          node1.classList.add('infohidden');
        }

        node1.style.transform = 'perspective(600px) rotateY(180deg) translateX(0)';
        var onEnd01 = function () {
          node1.removeEventListener('webkitTransitionEnd', onEnd01);
          setTimeout(function () {
            node1.style.transition = 'all ease-in 0.3s';
            node1.style.transform = 'perspective(600px) rotateY(270deg) translateX(52px)';
            var onEnd = function () {
              node1.classList.remove('infohidden');
              node1.style.transition = 'all 0s';
              ui.refresh(node1);
              node1.style.transform = 'perspective(600px) rotateY(-90deg) translateX(52px)';
              ui.refresh(node1);
              node1.style.transition = '';
              ui.refresh(node1);
              node1.style.transform = '';
              node1.removeEventListener('webkitTransitionEnd', onEnd);
            }
            node1.listenTransition(onEnd);
          }, 300);
        };
        node1.listenTransition(onEnd01);

        setTimeout(function () {
          var left0 = -targets.length * 52 - (targets.length - 1) * 8;
          for (var i = 0; i < targets.length; i++) {
            (function (target, card2, i) {
              var left = left0 + i * 120;
              var node2;
              if (left < 0) {
                node2 = target.$throwxy2(card2,
                  'calc(50% - ' + (-left) + 'px)', 'calc(50% - 114px)', 'perspective(600px) rotateY(180deg)', true
                );
              }
              else {
                node2 = target.$throwxy2(card2,
                  'calc(50% + ' + left + 'px)', 'calc(50% - 114px)', 'perspective(600px) rotateY(180deg)', true
                );
              }
              if (lib.config.cardback_style != 'default') {
                node2.style.transitionProperty = 'none';
                ui.refresh(node2);
                node2.classList.add('infohidden');
                ui.refresh(node2);
                node2.style.transitionProperty = '';
              }
              else {
                node2.classList.add('infohidden');
              }
              node2.style.transform = 'perspective(600px) rotateY(180deg) translateX(0)';
              var onEnd02 = function () {
                node2.removeEventListener('webkitTransitionEnd', onEnd02);
                setTimeout(function () {
                  node2.style.transition = 'all ease-in 0.3s';
                  node2.style.transform = 'perspective(600px) rotateY(270deg) translateX(52px)';
                  var onEnd = function () {
                    node2.classList.remove('infohidden');
                    node2.style.transition = 'all 0s';
                    ui.refresh(node2);
                    node2.style.transform = 'perspective(600px) rotateY(-90deg) translateX(52px)';
                    ui.refresh(node2);
                    node2.style.transition = '';
                    ui.refresh(node2);
                    node2.style.transform = '';
                    node2.removeEventListener('webkitTransitionEnd', onEnd);
                  }
                  node2.listenTransition(onEnd);
                }, 200);
              };
              node2.listenTransition(onEnd02);
            }(targets[i], cards[i], i))
          }
        }, 200);
      },
      $compare: function (card1, target, card2) {
        game.broadcast(function (player, target, card1, card2) {
          player.$compare(card1, target, card2);
        }, this, target, card1, card2);
        game.addVideo('compare', this, [get.cardInfo(card1), target.dataset.position, get.cardInfo(card2)]);
        var player = this;
        var node1 = player.$throwxy2(card1,
          'calc(50% - 114px)', 'calc(50% - 52px)', 'perspective(600px) rotateY(180deg)', true
        );
        if (lib.config.cardback_style != 'default') {
          node1.style.transitionProperty = 'none';
          ui.refresh(node1);
          node1.classList.add('infohidden');
          ui.refresh(node1);
          node1.style.transitionProperty = '';
        }
        else {
          node1.classList.add('infohidden');
        }

        node1.style.transform = 'perspective(600px) rotateY(180deg) translateX(0)';
        var onEnd01 = function () {
          node1.removeEventListener('webkitTransitionEnd', onEnd01);
          setTimeout(function () {
            node1.style.transition = 'all ease-in 0.3s';
            node1.style.transform = 'perspective(600px) rotateY(270deg) translateX(52px)';
            var onEnd = function () {
              node1.classList.remove('infohidden');
              node1.style.transition = 'all 0s';
              ui.refresh(node1);
              node1.style.transform = 'perspective(600px) rotateY(-90deg) translateX(52px)';
              ui.refresh(node1);
              node1.style.transition = '';
              ui.refresh(node1);
              node1.style.transform = '';
              node1.removeEventListener('webkitTransitionEnd', onEnd);
            }
            node1.listenTransition(onEnd);
          }, 300);
        };
        node1.listenTransition(onEnd01);
        setTimeout(function () {
          var node2 = target.$throwxy2(card2,
            'calc(50% + 10px)', 'calc(50% - 52px)', 'perspective(600px) rotateY(180deg)', true
          );
          if (lib.config.cardback_style != 'default') {
            node2.style.transitionProperty = 'none';
            ui.refresh(node2);
            node2.classList.add('infohidden');
            ui.refresh(node2);
            node2.style.transitionProperty = '';
          }
          else {
            node2.classList.add('infohidden');
          }
          node2.style.transform = 'perspective(600px) rotateY(180deg) translateX(0)';
          var onEnd02 = function () {
            node2.removeEventListener('webkitTransitionEnd', onEnd02);
            setTimeout(function () {
              node2.style.transition = 'all ease-in 0.3s';
              node2.style.transform = 'perspective(600px) rotateY(270deg) translateX(52px)';
              var onEnd = function () {
                node2.classList.remove('infohidden');
                node2.style.transition = 'all 0s';
                ui.refresh(node2);
                node2.style.transform = 'perspective(600px) rotateY(-90deg) translateX(52px)';
                ui.refresh(node2);
                node2.style.transition = '';
                ui.refresh(node2);
                node2.style.transform = '';
                node2.removeEventListener('webkitTransitionEnd', onEnd);
              }
              node2.listenTransition(onEnd);
            }, 200);
          };
          node2.listenTransition(onEnd02);
        }, 200);
      },
      $throw: function (card, time, init, nosource) {
        if (typeof card == 'number') {
          var tmp = card;
          card = [];
          while (tmp--) {
            var cardx = ui.create.card();
            cardx.classList.add('infohidden');
            cardx.classList.add('infoflip');
            card.push(cardx);
          }
        }
        if (init !== false) {
          if (init !== 'nobroadcast') {
            game.broadcast(function (player, card, time, init, nosource) {
              player.$throw(card, time, init, nosource);
            }, this, card, time, init);
          }
          if (get.itemtype(card) != 'cards') {
            if (get.itemtype(card) == 'card') {
              card = [card];
            }
            else {
              return;
            }
          }
          game.addVideo('throw', this, [get.cardsInfo(card), time, nosource]);
        }
        if (game.chess) {
          this.chessFocus();
        }
        if (get.itemtype(card) == 'cards') {
          var node;
          for (var i = 0; i < card.length; i++) {
            node = this.$throw(card[i], time, false, nosource);
          }
          return node;
        }
        else {
          var node;
          if (card == undefined || card.length == 0) return;
          node = this.$throwordered(card.copy('thrown'), nosource);
          if (time != undefined) {
            node.fixed = true;
            setTimeout(function () { node.delete() }, time);
          }
          lib.listenEnd(node);
          return node;
        }
      },
      $throwordered: function () {
        return this.$throwordered2.apply(this, arguments);
        // if(lib.config.low_performance){
        //     return this.$throwordered2.apply(this,arguments);
        // }
        // else{
        //     return this.$throwordered1.apply(this,arguments);
        // }
      },
      $throwordered1: function (node, nosource) {
        node.classList.add('thrown');
        node.hide();
        node.style.transitionProperty = 'left,top,opacity,transform';
        for (var i = 0; i < ui.thrown.length; i++) {
          if (ui.thrown[i].parentNode != ui.arena ||
            ui.thrown[i].classList.contains('removing')) {
            ui.thrown.splice(i--, 1);
          }
        }
        ui.thrown.push(node);
        var uithrowns = ui.thrown.slice(0);
        var tops;
        if (game.chess) {
          switch (Math.floor((ui.thrown.length - 1) / 4)) {
            case 0:
              tops = ['calc(50% - 82px)'];
              break;
            case 1:
              tops = ['calc(50% - 139px)', 'calc(50% - 25px)'];
              break;
            case 2:
              tops = ['calc(50% - 196px)', 'calc(50% - 82px)', 'calc(50% + 32px)'];
              break;
            default:
              tops = ['calc(50% - 253px)', 'calc(50% - 139px)',
                'calc(50% - 25px)', 'calc(50% + 89px)'];
          }
        }
        else {
          switch (Math.floor((ui.thrown.length - 1) / 4)) {
            case 0:
              tops = ['calc(50% - 52px)'];
              break;
            case 1:
              tops = ['calc(50% - 109px)', 'calc(50% + 5px)'];
              break;
            case 2:
              tops = ['calc(50% - 166px)', 'calc(50% - 52px)', 'calc(50% + 62px)'];
              break;
            default:
              tops = ['calc(50% - 223px)', 'calc(50% - 109px)',
                'calc(50% + 5px)', 'calc(50% + 119px)'];
          }
        }
        while (uithrowns.length) {
          var throwns = uithrowns.splice(0, Math.min(uithrowns.length, 4));
          switch (throwns.length) {
            case 1:
              throwns[0].style.left = 'calc(50% - 52px)';
              break;
            case 2:
              throwns[0].style.left = 'calc(50% - 109px)';
              throwns[1].style.left = 'calc(50% + 5px)';
              break;
            case 3:
              throwns[0].style.left = 'calc(50% - 166px)';
              throwns[1].style.left = 'calc(50% - 52px)';
              throwns[2].style.left = 'calc(50% + 62px)';
              break;
            case 4:
              throwns[0].style.left = 'calc(50% - 223px)';
              throwns[1].style.left = 'calc(50% - 109px)';
              throwns[2].style.left = 'calc(50% + 5px)';
              throwns[3].style.left = 'calc(50% + 119px)';
              break;
          }
          var top;
          if (tops.length) {
            top = tops.shift();
          }
          else {
            if (game.chess) {
              top = 'calc(50% - 82px)';
            }
            else {
              top = 'calc(50% - 52px)';
            }
          }
          for (var i = 0; i < throwns.length; i++) {
            throwns[i].style.top = top;
          }
        }
        if (nosource) {
          node.style.transform = 'scale(0)';
          node.classList.add('center');
        }
        else {
          var parseCalc = function (str) {
            var per = str.slice(str.indexOf('calc(') + 5, str.indexOf('%'));
            var add = str.slice(str.indexOf('%') + 1, str.indexOf('px')).replace(/\s/g, '');
            return [parseInt(per), parseInt(add)];
          }
          var nx = parseCalc(node.style.left);
          var ny = parseCalc(node.style.top);
          nx = nx[0] * ui.arena.offsetWidth / 100 + nx[1];
          ny = ny[0] * ui.arena.offsetHeight / 100 + ny[1];
          var dx, dy;
          if (game.chess) {
            var rect = this.getBoundingClientRect();
            dx = rect.left + this.offsetWidth / 2 - 52 - nx;
            dy = rect.top + this.offsetHeight / 2 - 52 - ny;
          }
          else {
            dx = this.getLeft() + this.offsetWidth / 2 - 52 - nx;
            dy = this.getTop() + this.offsetHeight / 2 - 52 - ny;
            if (get.is.mobileMe(this)) {
              dx += get.cardOffset();
              if (ui.arena.classList.contains('oblongcard')) {
                dy -= 16;
              }
            }
          }
          if (node.style.transform && node.style.transform != 'none' && node.style.transform.indexOf('translate') == -1) {
            node.style.transform += ' translate(' + dx + 'px,' + dy + 'px)';
          }
          else {
            node.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
          }
        }
        ui.arena.appendChild(node);
        ui.refresh(node);
        node.style.transform = '';
        node.show();
        lib.listenEnd(node);
        return node;
      },
      $throwordered2: function (node, nosource) {
        node.classList.add('thrown');
        node.classList.add('center');
        node.hide();
        node.style.transitionProperty = 'left,top,opacity,transform';

        if (nosource) {
          // node.style.transform='scale(0)';
        }
        else {
          var nx = [50, -52];
          var ny = [50, -52];
          nx = nx[0] * ui.arena.offsetWidth / 100 + nx[1];
          ny = ny[0] * ui.arena.offsetHeight / 100 + ny[1];
          var dx, dy;
          if (game.chess) {
            var rect = this.getBoundingClientRect();
            dx = rect.left + this.offsetWidth / 2 - 52 - nx;
            dy = rect.top + this.offsetHeight / 2 - 52 - ny;
          }
          else {
            dx = this.getLeft() + this.offsetWidth / 2 - 52 - nx;
            dy = this.getTop() + this.offsetHeight / 2 - 52 - ny;
            if (get.is.mobileMe(this)) {
              dx += get.cardOffset();
              if (ui.arena.classList.contains('oblongcard')) {
                dy -= 16;
              }
            }
          }
          if (node.style.transform && node.style.transform != 'none' && node.style.transform.indexOf('translate') == -1) {
            node.style.transform += ' translate(' + dx + 'px,' + dy + 'px)';
          }
          else {
            node.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
          }
        }
        ui.arena.appendChild(node);
        ui.refresh(node);

        for (var i = 0; i < ui.thrown.length; i++) {
          if (ui.thrown[i].parentNode != ui.arena ||
            ui.thrown[i].classList.contains('removing')) {
            ui.thrown.splice(i--, 1);
          }
        }
        ui.thrown.push(node);
        var uithrowns = ui.thrown.slice(0);
        var tops;
        switch (Math.floor((ui.thrown.length - 1) / 4)) {
          case 0:
            tops = [0];
            break;
          case 1:
            tops = [-57, 57];
            break;
          case 2:
            tops = [-114, 0, 114];
            break;
          default:
            tops = [-171, -57, 57, 171];
        }
        while (uithrowns.length) {
          var throwns = uithrowns.splice(0, Math.min(uithrowns.length, 4));
          switch (throwns.length) {
            case 1:
              throwns[0]._transthrown = 'translate(0px,';
              break;
            case 2:
              throwns[0]._transthrown = 'translate(-57px,';
              throwns[1]._transthrown = 'translate(57px,';
              break;
            case 3:
              throwns[0]._transthrown = 'translate(-114px,';
              throwns[1]._transthrown = 'translate(0,';
              throwns[2]._transthrown = 'translate(114px,';
              break;
            case 4:
              throwns[0]._transthrown = 'translate(-171px,';
              throwns[1]._transthrown = 'translate(-57px,';
              throwns[2]._transthrown = 'translate(57px,';
              throwns[3]._transthrown = 'translate(171px,';
              break;
          }
          var top;
          if (tops.length) {
            top = tops.shift();
          }
          else {
            top = 0;
          }
          if (game.chess) {
            top -= 30;
          }
          for (var i = 0; i < throwns.length; i++) {
            throwns[i].style.transform = throwns[i]._transthrown + top + 'px)';
            delete throwns[i]._transthrown;
          }
        }

        node.show();
        lib.listenEnd(node);
        return node;
      },
      $throwxy: function (card, left, top) {
        var node = card.copy('thrown', 'thrownhighlight');
        node.dataset.position = this.dataset.position;
        node.hide();
        node.style.transitionProperty = 'left,top,opacity';

        ui.arena.appendChild(node);
        ui.refresh(node);
        node.show();
        node.style.left = left;
        node.style.top = top;
        lib.listenEnd(node);
        return node;
      },
      $throwxy2: function (card, left, top, trans, flipx, flipy) {
        if (game.chess) {
          return this.$throwxy.apply(this, arguments);
        }
        var node = card.copy('thrown', 'thrownhighlight');
        node.style.left = left;
        node.style.top = top;
        node.hide();
        // node.style.transitionProperty='left,top,opacity,transform';

        var parseCalc = function (str) {
          var per = str.slice(str.indexOf('calc(') + 5, str.indexOf('%'));
          var add = str.slice(str.indexOf('%') + 1, str.indexOf('px')).replace(/\s/g, '');
          return [parseInt(per), parseInt(add)];
        }
        var nx = parseCalc(node.style.left);
        var ny = parseCalc(node.style.top);
        nx = nx[0] * ui.arena.offsetWidth / 100 + nx[1];
        ny = ny[0] * ui.arena.offsetHeight / 100 + ny[1];
        var dx = this.getLeft() + this.offsetWidth / 2 - 52 - nx;
        var dy = this.getTop() + this.offsetHeight / 2 - 52 - ny;
        if (flipx) dx = -dx;
        if (flipy) dy = -dy;
        if (trans) {
          node.style.transform = trans + ' translate(' + dx + 'px,' + dy + 'px)';
        }
        else {
          node.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
        }

        ui.arena.appendChild(node);
        ui.refresh(node);
        node.show();
        // node.style.transform=trans||'';
        lib.listenEnd(node);
        return node;
      },
      throwDice: function (num) {
        if (typeof num != 'number') {
          num = get.rand(6) + 1;
        }
        _status.event.num = num;
        if (!game.online) {
          game.pause();
        }
        game.broadcastAll(function (num) {
          var diceContainer = ui.create.div('.fullsize.dice-container', ui.window);
          ui.window.classList.add('dicepaused');
          var dice = ui.create.div('.dice');
          var side;

          side = ui.create.div('.side.front', dice);
          ui.create.div('.dot.center', side);
          ui.create.div('.side.front.inner', dice);

          side = ui.create.div('.side.top', dice);
          ui.create.div('.dot.dtop.dleft', side);
          ui.create.div('.dot.dbottom.dright', side);
          ui.create.div('.side.top.inner', dice);

          side = ui.create.div('.side.right', dice);
          ui.create.div('.dot.dtop.dleft', side);
          ui.create.div('.dot.center', side);
          ui.create.div('.dot.dbottom.dright', side);
          ui.create.div('.side.right.inner', dice);

          side = ui.create.div('.side.left', dice);
          ui.create.div('.dot.dtop.dleft', side);
          ui.create.div('.dot.dtop.dright', side);
          ui.create.div('.dot.dbottom.dleft', side);
          ui.create.div('.dot.dbottom.dright', side);
          ui.create.div('.side.left.inner', dice);

          side = ui.create.div('.side.bottom', dice);
          ui.create.div('.dot.center', side);
          ui.create.div('.dot.dtop.dleft', side);
          ui.create.div('.dot.dtop.dright', side);
          ui.create.div('.dot.dbottom.dleft', side);
          ui.create.div('.dot.dbottom.dright', side);
          ui.create.div('.side.bottom.inner', dice);

          side = ui.create.div('.side.back', dice);
          ui.create.div('.dot.dtop.dleft', side);
          ui.create.div('.dot.dtop.dright', side);
          ui.create.div('.dot.dbottom.dleft', side);
          ui.create.div('.dot.dbottom.dright', side);
          ui.create.div('.dot.center dleft', side);
          ui.create.div('.dot.center dright', side);
          ui.create.div('.side.back.inner', dice);

          ui.create.div('.side.cover.x', dice);
          ui.create.div('.side.cover.y', dice);
          ui.create.div('.side.cover.z', dice);

          var map = {
            1: [75, 0, 45],
            2: [-15, 45, 0],
            3: [165, -45, 90],
            4: [345, -45, 90],
            5: [345, -45, 180],
            6: [255, 0, 135]
          };
          dice.roll = function (deg) {
            if (typeof deg == 'number') {
              dice.current[0] += deg;
              deg = dice.current;
            }
            deg = deg.slice(0);
            dice.current = deg;
            this.style.transform = 'rotateX(' + deg[0] + 'deg) rotateY(' + deg[1] + 'deg) rotateZ(' + deg[2] + 'deg)';
          };
          dice.roll(map[num]);
          diceContainer.appendChild(dice);
          ui.refresh(dice);
          dice.roll(1025);

          dice.addEventListener('webkitTransitionEnd', function () {
            if (!dice.over) {
              dice.style.transition = 'transform 0.8s ease';
              dice.roll(-20);
              dice.over = true;
            }
            else if (!dice.resumed) {
              setTimeout(function () {
                diceContainer.delete();
                ui.window.classList.remove('dicepaused');
              }, 300);
              if (!game.online) {
                setTimeout(game.resume, 800);
              }
              dice.resumed = true;
            }
          });
        }, num);
      },
      $giveAuto: function (card, player) {
        if (Array.isArray(card) && card.length == 0) return;
        var args = Array.from(arguments);
        if (_status.connectMode || (!this.isUnderControl(true) && !player.isUnderControl(true))) {
          if (Array.isArray(card)) {
            card = card.length;
          }
          else {
            card = 1;
          }
          args[0] = card;
        }
        return this.$give.apply(this, args);
      },
      $give: function (card, player, log, init) {
        if (init !== false) {
          game.broadcast(function (source, card, player, init) {
            source.$give(card, player, false, init);
          }, this, card, player, init);
          if (typeof card == 'number' && card >= 0) {
            game.addVideo('give', this, [card, player.dataset.position]);
          }
          else {
            if (get.itemtype(card) == 'card') {
              card = [card];
            }
            if (get.itemtype(card) == 'cards') {
              game.addVideo('giveCard', this, [get.cardsInfo(card), player.dataset.position]);
            }
          }
        }
        if (get.itemtype(card) == 'cards') {
          if (log != false && !_status.video) {
            game.log(player, '从', this, '获得了', card);
          }
          if (this.$givemod) {
            this.$givemod(card, player);
          }
          else {
            for (var i = 0; i < card.length; i++) {
              this.$give(card[i], player, false, false);
            }
          }
        }
        else if (typeof card == 'number' && card >= 0) {
          if (log != false && !_status.video) {
            game.log(player, '从', this, '获得了' + get.cnNumber(card) + '张牌');
          }
          if (this.$givemod) {
            this.$givemod(card, player);
          }
          else {
            while (card--) this.$give('', player, false, false);
          }
        }
        else {
          if (log != false && !_status.video) {
            if (get.itemtype(card) == 'card' && log != false) {
              game.log(player, '从', this, '获得了', card);
            }
            else {
              game.log(player, '从', this, '获得了一张牌');
            }
          }
          if (this.$givemod) {
            this.$givemod(card, player);
          }
          else {
            var node;
            if (get.itemtype(card) == 'card') {
              node = card.copy('card', 'thrown', false);
            }
            else {
              node = ui.create.div('.card.thrown');
            }
            // node.dataset.position=this.dataset.position;
            node.fixed = true;
            this.$throwordered(node);
            // lib.listenEnd(node);
            // node.hide();
            // node.style.transitionProperty='left,top,opacity';
            //
            // node.style.transform='rotate('+(Math.random()*16-8)+'deg)';
            //
            // ui.arena.appendChild(node);
            // ui.refresh(node);
            // node.show();
            // node.style.left='calc(50% - 52px '+((Math.random()-0.5<0)?'+':'-')+' '+Math.random()*100+'px)';
            // node.style.top='calc(50% - 52px '+((Math.random()-0.5<0)?'+':'-')+' '+Math.random()*80+'px)';

            node.listenTransition(function () {
              var dx = player.getLeft() + player.offsetWidth / 2 - 52 - node.offsetLeft;
              var dy = player.getTop() + player.offsetHeight / 2 - 52 - node.offsetTop;
              if (node.style.transform && node.style.transform != 'none' && node.style.transform.indexOf('translate') == -1) {
                node.style.transform += ' translate(' + dx + 'px,' + dy + 'px)';
              }
              else {
                node.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
              }

              node.delete();
            });
            // setTimeout(function(){
            //     // node.removeAttribute('style');
            //     // node.dataset.position=player.dataset.position;
            //     var dx=player.offsetLeft+player.offsetWidth/2-52-node.offsetLeft;
            //     var dy=player.offsetTop+player.offsetHeight/2-52-node.offsetTop;
            //     if(node.style.transform&&node.style.transform!='none'&&node.style.transform.indexOf('translate')==-1){
            //         node.style.transform+=' translate('+dx+'px,'+dy+'px)';
            //     }
            //     else{
            //         node.style.transform='translate('+dx+'px,'+dy+'px)';
            //     }
            //
            //     node.delete();
            // },700);
          }
        }
      },
      $equip: function (card, viewAs) {
        var originalName = card.originalName;
        if (viewAs && this.storage.disableEquip != undefined && this.storage.disableEquip.contains(get.subtype(viewAs))) {
          this.gain(card, 'gain2');
          game.log(this, '装备失败');
        }
        else if (this.storage.disableEquip != undefined && this.storage.disableEquip.contains(get.subtype(card))) {
          this.gain(card, 'gain2');
          game.log(this, '装备失败');
        }
        else {
          var player = this;
          game.broadcast(function (player, card, viewAs) {
            player.$equip(card, viewAs);
          }, player, card, viewAs);
          card.fix();
          card.style.transform = '';
          card.classList.remove('drawinghidden');
          delete card._transform;
          //已修改
          card.originalName = originalName;
          card.viewAs = viewAs;
          if (viewAs && viewAs != card.name) {
            if (card.classList.contains('fullskin') || card.classList.contains('fullborder')) {
              card.classList.add('fakejudge');
              card.node.background.innerHTML = lib.translate[viewAs.name + '_bg'] || get.translation(viewAs)[0];
            }
            card.classList.remove(get.subtype(card));
            card.classList.add(get.subtype(viewAs));
            if (typeof viewAs == 'string') card.viewAs = viewAs;
            else card.viewAs = viewAs.name;
          }
          else {
            card.classList.remove('fakejudge');
            delete card.viewAs;
          }
          //console.log(card.viewAs);
          if (card.viewAs && card.name != card.viewAs) {
            if (!card.originalName) card.originalName = card.name;
            card.name = card.viewAs;
          }
          var equipNum = get.equipNum(card);
          var equipped = false;
          for (var i = 0; i < player.node.equips.childNodes.length; i++) {
            if (get.equipNum(player.node.equips.childNodes[i]) >= equipNum) {
              player.node.equips.insertBefore(card, player.node.equips.childNodes[i]);
              equipped = true;
              break;
            }
          }
          if (!equipped) {
            player.node.equips.appendChild(card);
            if (_status.discarded) {
              _status.discarded.remove(card);
            }
          }
          var ecard = viewAs ? { name: viewAs } : card;
          var info = get.info(ecard);
          if (info.skills) {
            for (var i = 0; i < info.skills.length; i++) {
              player.addSkillTrigger(info.skills[i]);
            }
          }
          return player;
        };
      },
      $gain: function (card, log, init) {
        if (init !== false) {
          game.broadcast(function (player, card, init) {
            player.$gain(card, false, init);
          }, this, card, init);
          if (typeof card == 'number' && card >= 0) {
            game.addVideo('gain', this, card);
          }
          else {
            if (get.itemtype(card) == 'card') {
              card = [card];
            }
            if (get.itemtype(card) == 'cards') {
              game.addVideo('gainCard', this, get.cardsInfo(card));
            }
            else {
              game.addVideo('gain', this, 1);
            }
          }
        }
        if (get.itemtype(card) == 'cards') {
          if (log != false && !_status.video) {
            game.log(this, '获得了', card);
          }
          if (this.$gainmod) {
            this.$gainmod(card);
          }
          else {
            for (var i = 0; i < card.length; i++) {
              this.$gain(card[i], false, false);
            }
          }
        }
        else if (typeof card == 'number' && card > 1) {
          if (log != false && !_status.video) {
            game.log(this, '获得了' + get.cnNumber(card) + '张牌');
          }
          if (this.$gainmod) {
            this.$gainmod(card);
          }
          else {
            for (var i = 0; i < card; i++) {
              this.$gain(1, false, false);
            }
          }
        }
        else {
          if (get.itemtype(card) == 'card' && log != false && !_status.video) {
            game.log(this, '获得了', card);
          }
          if (this.$gainmod) {
            this.$gainmod(card);
          }
          else {
            var node;
            if (get.itemtype(card) == 'card') {
              // node=this.$throwordered(card.copy(),true);
              node = card.copy('thrown', false);
            }
            else {
              // node=this.$throwordered(ui.create.div('.card.thrown'),true);
              node = ui.create.div('.card.thrown');
              node.moveTo = lib.element.card.moveTo;
              node.moveDelete = lib.element.card.moveDelete;
            }
            node.fixed = true;
            node.style.left = 'calc(50% - 52px ' + ((Math.random() - 0.5 < 0) ? '+' : '-') + ' ' + Math.random() * 100 + 'px)';
            node.style.top = 'calc(50% - 52px ' + ((Math.random() - 0.5 < 0) ? '+' : '-') + ' ' + Math.random() * 100 + 'px)';
            node.style.transform = 'scale(0)';
            node.hide();
            ui.arena.appendChild(node);
            ui.refresh(node);
            node.show();
            node.style.transform = '';

            lib.listenEnd(node);
            var player = this;
            setTimeout(function () {
              node.moveDelete(player);
            }, 700);
          }
        }
      },
      $gain2: function (cards, log) {
        if (log === true) {
          game.log(this, '获得了', cards);
        }
        game.broadcast(function (player, cards) {
          player.$gain2(cards);
        }, this, cards);
        if (get.itemtype(cards) == 'card') cards = [cards];
        else if (get.itemtype(cards) != 'cards') return;
        var list = [], list2 = [];
        for (var i = 0; i < cards.length; i++) {
          if (cards[i].clone &&
            (cards[i].clone.parentNode == this.parentNode ||
              cards[i].clone.parentNode == ui.arena) &&
            parseFloat(getComputedStyle(cards[i].clone).opacity) > 0.3) {
            cards[i].clone.moveDelete(this);
            list2.push(cards[i].clone);
          }
          else {
            list.push(cards[i]);
          }
        }
        if (list2.length) {
          game.addVideo('gain2', this, get.cardsInfo(list2));
        }
        if (list.length) {
          this.$draw(list, 'nobroadcast');
          return true;
        }
      },
      /**
       * 本角色播放技能动画
       */
      //TODO
      $skill: function (name, type, color, avatar) {
        if (typeof type != 'string') type = 'legend';
        if (!avatar) {
          this.playerfocus(1500);
          game.delay(2);
        }
        else {
          game.addVideo('playerfocus2');
          game.broadcastAll(function () {
            ui.arena.classList.add('playerfocus');
            setTimeout(function () {
              ui.arena.classList.remove('playerfocus');
            }, 1800)
          });
          game.delay(3);
        }
        var that = this;
        setTimeout(function () {
          game.broadcastAll(function (that, type, name, color, avatar) {
            if (lib.config.animation && !lib.config.low_performance) {
              if (game.chess) {
                that['$' + type + '2'](1200);
              }
              else {
                that['$' + type](1200);
              }
            }
            if (name) {
              that.$fullscreenpop(name, color, avatar);
            }
          }, that, type, name, color, avatar);
        }, avatar ? 0 : 300);
      },
      $fire: function () {
        game.addVideo('flame', this, 'fire');
        var left, top;
        if (game.chess) {
          var rect = this.getBoundingClientRect();
          left = rect.left;
          top = rect.top;
        }
        else {
          left = this.getLeft();
          top = this.getTop();
        }
        game.animate.flame(left + this.offsetWidth / 2,
          top + this.offsetHeight - 20, 700, 'fire');
      },
      $thunder: function () {
        game.addVideo('flame', this, 'thunder');
        var left, top;
        if (game.chess) {
          var rect = this.getBoundingClientRect();
          left = rect.left;
          top = rect.top;
        }
        else {
          left = this.getLeft();
          top = this.getTop();
        }
        game.animate.flame(left + this.offsetWidth / 2,
          top + this.offsetHeight - 30, 700, 'thunder');
      },
      $rare2: function () {
        game.addVideo('flame', this, 'rare2');
        var rect = this.getBoundingClientRect();
        var left = rect.left;
        var top = rect.top + 15;
        game.animate.flame(left + this.offsetWidth / 2,
          top + this.offsetHeight - 30, 700, 'rare');
      },
      $epic2: function () {
        game.addVideo('flame', this, 'epic2');
        var rect = this.getBoundingClientRect();
        var left = rect.left;
        var top = rect.top + 15;
        game.animate.flame(left + this.offsetWidth / 2,
          top + this.offsetHeight - 30, 700, 'epic');
      },
      $legend2: function () {
        game.addVideo('flame', this, 'legend2');
        var rect = this.getBoundingClientRect();
        var left = rect.left;
        var top = rect.top + 15;
        game.animate.flame(left + this.offsetWidth / 2,
          top + this.offsetHeight - 30, 700, 'legend');
      },
      $rare: function (time) {
        time = time || 700;
        game.addVideo('flame', this, 'rare');
        var left, top;
        if (game.chess) {
          left = this.getLeft() - ui.arena.offsetLeft;
          top = this.getTop() - ui.arena.offsetTop;
        }
        else {
          left = this.getLeft();
          top = this.getTop();
        }
        if (this.classList.contains('minskin')) {
          top += 15;
        }
        game.animate.flame(left + this.offsetWidth / 2,
          top + this.offsetHeight - 30, time, 'rare');
      },
      $epic: function (time) {
        time = time || 700;
        game.addVideo('flame', this, 'epic');
        var left, top;
        if (game.chess) {
          left = this.getLeft() - ui.arena.offsetLeft;
          top = this.getTop() - ui.arena.offsetTop;
        }
        else {
          left = this.getLeft();
          top = this.getTop();
        }
        if (this.classList.contains('minskin')) {
          top += 15;
        }
        game.animate.flame(left + this.offsetWidth / 2,
          top + this.offsetHeight - 30, time, 'epic');
      },
      $legend: function (time) {
        time = time || 700;
        game.addVideo('flame', this, 'legend');
        var left, top;
        if (game.chess) {
          left = this.getLeft() - ui.arena.offsetLeft;
          top = this.getTop() - ui.arena.offsetTop;
        }
        else {
          left = this.getLeft();
          top = this.getTop();
        }
        if (this.classList.contains('minskin')) {
          top += 15;
        }
        game.animate.flame(left + this.offsetWidth / 2,
          top + this.offsetHeight - 30, time, 'legend');
      },
      $coin: function () {
        game.broadcast(function (player) {
          if (!lib.config.low_performance) {
            player.$coin();
          }
        }, this);
        game.addVideo('flame', this, 'coin');
        var left = this.getLeft() - ui.arena.offsetLeft;
        var top = this.getTop() - ui.arena.offsetTop;
        if (this.classList.contains('minskin')) {
          top += 15;
        }
        top -= 25;
        game.animate.flame(left + this.offsetWidth / 2,
          top + this.offsetHeight - 30, 700, 'coin');
      },
      $dust: function () {
        game.broadcast(function (player) {
          if (!lib.config.low_performance) {
            player.$dust();
          }
        }, this);
        game.addVideo('flame', this, 'dust');
        var left = this.getLeft() - ui.arena.offsetLeft;
        var top = this.getTop() - ui.arena.offsetTop;
        if (this.classList.contains('minskin')) {
          top += 15;
        }
        top -= 25;
        game.animate.flame(left + this.offsetWidth / 2,
          top + this.offsetHeight - 30, 700, 'dust');
      },
      $recover: function () {
        game.addVideo('flame', this, 'recover');
        var left, top;
        if (game.chess) {
          var rect = this.getBoundingClientRect();
          left = rect.left;
          top = rect.top;
        }
        else {
          left = this.getLeft();
          top = this.getTop();
        }
        game.animate.flame(left + this.offsetWidth / 2,
          top + this.offsetHeight - 30, 700, 'recover');
      },
      $fullscreenpop: function (str, nature, avatar, broadcast) {
        if (broadcast !== false) game.broadcast(function (player, str, nature, avatar) {
          player.$fullscreenpop(str, nature, avatar);
        }, this, str, nature, avatar);
        game.addVideo('fullscreenpop', this, [str, nature, avatar]);
        var node = ui.create.div('.damage');
        if (avatar && this.node) {
          if (avatar == 'vice') {
            if (lib.character[this.name2]) {
              avatar = this.node.avatar2;
            }
          }
          else {
            if (lib.character[this.name]) {
              avatar = this.node.avatar;
            }
          }
          if (!get.is.div(avatar)) {
            avatar = false;
          }
        }
        else {
          avatar = false;
        }
        if (avatar) {
          node.classList.add('fullscreenavatar');
          ui.create.div('', ui.create.div(node));
          // ui.create.div('',str.split('').join('<br>'),ui.create.div('.text.textbg',node));
          ui.create.div('', '<div>' + str.split('').join('</div><br><div>') + '</div>', ui.create.div('.text', node));
          node.firstChild.firstChild.style.backgroundImage = avatar.style.backgroundImage;
          node.dataset.nature = nature || 'unknown';
          var num = 0;
          var nodes = node.lastChild.firstChild.querySelectorAll('div');
          var interval = setInterval(function () {
            if (num < nodes.length) {
              nodes[num].classList.add('flashtext');
              num++;
            }
            else {
              clearInterval(interval);
            }
          }, 100);
        }
        else {
          avatar = false;
          node.innerHTML = str;
          node.dataset.nature = nature || 'soil';
        }
        if (avatar) {
          var rect1 = ui.window.getBoundingClientRect();
          var rect2 = this.getBoundingClientRect();
          var dx = Math.round(2 * rect2.left + rect2.width - rect1.width);
          var dy = Math.round(2 * rect2.top + rect2.height - rect1.height);
          node.style.transform = 'scale(0.5) translate(' + dx + 'px,' + dy + 'px)';
        }
        ui.window.appendChild(node);
        ui.refresh(node);
        if (avatar) {
          node.style.transform = 'scale(1)';
          node.style.opacity = 1;
        }
        else {
          node.classList.add('damageadded');
        }
        setTimeout(function () {
          node.delete();
          node.style.transform = 'scale(1.5)'
        }, avatar ? 1600 : 1000);
      },
      /**
       * 伤害效果
       * @param {(string|number)} num 伤害数值或者任意字符串
       * @param {string} [nature='soil'] 伤害属性
       * @param {?boolean} font 如果为true，`damage div`添加类`normal-font`；如果为false或未指定，使用伤害默认字体大小
       * @param {?boolean} nobroadcast 如果为true或未指定，调用`game.broadcast`广播；如果为false，仅在本机
       */
      $damagepop: function (num, nature, font, nobroadcast) {
        if (typeof num == 'number' || typeof num == 'string') {
          game.addVideo('damagepop', this, [num, nature, font]);
          if (nobroadcast !== false) game.broadcast(function (player, num, nature, font) {
            player.$damagepop(num, nature, font);
          }, this, num, nature, font);
          var node = ui.create.div('.damage');
          if (font) {
            node.classList.add('normal-font');
          }
          if (typeof num == 'number' && num > 0) {
            if (num == Infinity) num = '+∞'
            else num = '+' + num;
          }
          else if (num == -Infinity) num = '-∞';
          node.innerHTML = num;
          this.damagepopups.push(node);
          node.dataset.nature = nature || 'soil';
          if (this.damagepopups.length == 1) {
            this.$damagepop();
          }
        }
        else if (this.damagepopups.length) {
          var node = this.damagepopups[0];
          this.appendChild(node);
          ui.refresh(node);
          node.classList.add('damageadded');
          node.listenTransition(function () {
            setTimeout(function () {
              node.delete();
            }, 200);
          });
          // setTimeout(function(){
          //     node.delete();
          // },500);
          var that = this;
          setTimeout(function () {
            that.damagepopups.shift();
            that.$damagepop();
          }, 500);
        }
      },
      $damage: function (source) {
        if (get.itemtype(source) == 'player') {
          game.addVideo('damage', this, source.dataset.position);
        }
        else {
          game.addVideo('damage', this);
        }
        game.broadcast(function (player, source) {
          player.$damage(source);
        }, this, source);
        if (source && source != this && lib.config.damage_shake) {
          var left, top;
          if (source.getTop() == this.getTop()) {
            left = 20;
            top = 0;
          }
          else {
            var ratio = (source.getLeft() - this.getLeft()) / (source.getTop() - this.getTop());
            left = Math.abs(20 * ratio / Math.sqrt(1 + ratio * ratio));
            top = Math.abs(20 / Math.sqrt(1 + ratio * ratio));
          }
          if (source.getLeft() - this.getLeft() > 0) left = -left;
          if (source.getTop() - this.getTop() > 0) top = -top;
          if (get.is.mobileMe(this)) {
            if (this.classList.contains('linked')) {
              this.node.avatar.style.transform = 'translate(' + left + 'px,' + top + 'px) rotate(-90deg)';
              this.node.avatar2.style.transform = 'translate(' + left + 'px,' + top + 'px) rotate(-90deg)';
            }
            else {
              this.node.avatar.style.transform = 'translate(' + left + 'px,' + top + 'px)';
              this.node.avatar2.style.transform = 'translate(' + left + 'px,' + top + 'px)';
            }
          }
          else if (this.classList.contains('linked') && get.is.newLayout()) {
            this.style.transform = 'translate(' + left + 'px,' + top + 'px) rotate(-90deg)';
          }
          else if (this._chesstransform) {
            this.style.transform = 'translate(' + (left + this._chesstransform[0]) + 'px,' + (top + this._chesstransform[1]) + 'px)';
          }
          else {
            this.style.transform = 'translate(' + left + 'px,' + top + 'px)';
          }
        }
        else {
          var zoom1 = 0.9, zoom2 = 0.95;
          if (arguments[1] == 'phase') {
            zoom1 = 1.05;
            zoom2 = 1.05;
          }
          if (get.is.mobileMe(this)) {
            if (this.classList.contains('linked')) {
              this.node.avatar.style.transform = 'scale(' + zoom1 + ') rotate(-90deg)';
              this.node.avatar2.style.transform = 'scale(' + zoom1 + ') rotate(-90deg)';
            }
            else {
              this.node.avatar.style.transform = 'scale(' + zoom1 + ')';
              this.node.avatar2.style.transform = 'scale(' + zoom1 + ')';
            }
          }
          else if (this.classList.contains('linked') && get.is.newLayout()) {
            this.style.transform = 'scale(' + zoom2 + ') rotate(-90deg)';
          }
          else if (game.chess && this._chesstransform) {
            this.style.transform = 'translate(' + this._chesstransform[0] + 'px,' + this._chesstransform[1] + 'px) scale(' + zoom2 + ')';
          }
          else {
            this.style.transform = 'scale(' + zoom2 + ')';
          }
        }
        this.queue();
      },
      $die: function () {
        game.addVideo('die', this);
        game.broadcast(function (player) {
          player.$die();
        }, this);
        if (lib.config.die_move != 'off') {
          this.$dieflip(lib.config.die_move);
        }
        if (lib.element.player.$dieAfter) {
          lib.element.player.$dieAfter.call(this);
        }
      },
      $dieflip: function (type) {
        var top0 = ui.window.offsetHeight / 2;
        var left0 = ui.window.offsetWidth / 2;
        var ratio = (left0 - this.getLeft()) / (top0 - this.getTop());
        var left = Math.abs(50 * ratio / Math.sqrt(1 + ratio * ratio));
        var top = Math.abs(50 / Math.sqrt(1 + ratio * ratio));
        if (left0 - this.getLeft() > 0) left = -left;
        if (top0 - this.getTop() > 0) top = -top;
        if (get.is.mobileMe(this)) {
          left = -Math.random() * 5 - 10;
          top = Math.random() * 5 + 10;
        }
        if (this._chesstransform) {
          left += this._chesstransform[0];
          top += this._chesstransform[1];
        }
        var transform = 'translate(' + left + 'px,' + top + 'px) ' +
          'rotate(' + (Math.random() * 20 - 10) + 'deg) ';
        if (type == 'flip') {
          if (game.layout == 'long' || game.layout == 'long2') {
            transform += 'rotateY(180deg)';
          }
          else {
            transform += ((Math.random() - 0.5 < 0) ? 'rotateX(180deg)' : 'rotateY(180deg)');
          }
        }
        if (get.is.mobileMe(this)) {
          this.node.avatar.style.transform = transform;
          this.node.avatar2.style.transform = transform;
          this.style.transform = '';
        }
        else {
          this.node.avatar.style.transform = '';
          this.node.avatar2.style.transform = '';
          this.style.transform = transform;
        }
        this.queue(false);
      },
      $phaseJudge: function (card) {
        game.addVideo('phaseJudge', this, get.cardInfo(card));
        var player = this;
        var clone = player.$throw(card);
        if (lib.config.low_performance && card && card.clone) {
          var waitingForTransition = get.time();
          _status.waitingForTransition = waitingForTransition;
          card.clone.listenTransition(function () {
            if (_status.waitingForTransition == waitingForTransition && _status.paused) {
              game.resume();
            }
          });
          game.pause();
        }
        else {
          game.delay();
        }
      }
    },
    /**
     * 卡牌方法，.card节点共用的方法（比如检测卡牌是否在区域内【hasPosition】和添加去除标签【add/removeGaintag】）
     * 卡牌
     * @namespace
     * @mixin
     */
    card: {
      /**
       * 为本游戏牌添加gain标签名；本游戏牌`this.node.gaintag`也会更新
       * @param {(string|Array<string>)} gaintag gain标签名，如果是一个数组，会**覆盖**本游戏牌的原gain标签数组为此数组，而不是向原数组中添加gain标签
       */
      addGaintag: function (gaintag) {
        if (Array.isArray(gaintag)) this.gaintag = gaintag.slice(0);
        else this.gaintag.add(gaintag);
        var str = '';
        for (var gi = 0; gi < this.gaintag.length; gi++) {
          str += get.translation(this.gaintag[gi]);
          if (gi < this.gaintag.length - 1) str += ' ';
        }
        this.node.gaintag.innerHTML = str;
      },
      /**
       * 为本游戏牌移除gain标签，或置空gain标签数组；本游戏牌`this.node.gaintag`也会更新
       * @param {(string|true)} tag 要移除的gain标签名，如果此gain标签不在其中则不做任何处理；如果此值为true，置空gain标签数组
       */
      removeGaintag: function (tag) {
        if (tag === true) {
          if (this.gaintag && this.gaintag.length || this.node.gaintag.innerHTML.length) this.addGaintag([]);
        }
        else if (this.hasGaintag(tag)) {
          this.gaintag.remove(tag);
          this.addGaintag(this.gaintag);
        }
      },
      /**
       * 返回本游戏牌是否含有某一个gain标签
       * @param {!string} tag 要搜索的gain标签
       * @returns {!boolean}
       */
      hasGaintag: function (tag) {
        if (['ming_', 'an_'].contains(tag)) {
          return this.gaintag && this.gaintag.filter(function (gain) {
            return gain.indexOf(tag) == 0;
          }).length;
        }
        else return this.gaintag && this.gaintag.contains(tag);
      },
      /**
       * 初始化
       * 同时将info.global内的技能添加到{@link lib.skill.global}
       * @function
       * @param {(Array|Object)} card TODO
       * @returns {!GameCores.GameObjects.Card} this self
       */
      init: function (card) {
        if (Array.isArray(card)) {
          if (card[2] == 'huosha') {
            card[2] = 'sha';
            card[3] = 'fire';
          }
          if (card[2] == 'leisha') {
            card[2] = 'sha';
            card[3] = 'thunder';
          }
          if (card[2] == 'kamisha') {
            card[2] = 'sha';
            card[3] = 'kami';
          }
          if (card[2] == 'icesha') {
            card[2] = 'sha';
            card[3] = 'ice';
          }
          if (card[2] == 'haisha') {
            card[2] = 'sha';
            card[3] = 'ocean';
          }
          if (card[2] == 'yamisha') {
            card[2] = 'sha';
            card[3] = 'yami';
          }
          if (card[2] == 'haitao') {
            card[2] = 'tao';
            card[3] = 'ocean';
          }
          if (card[2] == 'haijiu') {
            card[2] = 'jiu';
            card[3] = 'ocean';
          }
        }
        else if (typeof card == 'object') {
          card = [card.suit, card.number, card.name, card.nature];
          card[5] = card.specialEffects
        }
        var cardnum = card[1] || '';
        if (parseInt(cardnum) == cardnum) cardnum = parseInt(cardnum);
        if ([1, 11, 12, 13, 14].contains(cardnum)) {
          cardnum = { '1': 'A', '11': 'J', '12': 'Q', '13': 'K', '14': '★' }[cardnum]
        }
        if (!lib.card[card[2]]) {
          lib.card[card[2]] = {};
        }
        var info = lib.card[card[2]];
        if (info.global && !this.classList.contains('button')) {
          if (Array.isArray(info.global)) {
            while (info.global.length) {
              game.addGlobalSkill(info.global.shift());
            }
          }
          else if (typeof info.global == 'string') {
            game.addGlobalSkill(info.global);
          }
          delete info.global;
        }
        if (this.name) {
          this.classList.remove('epic');
          this.classList.remove('legend');
          this.classList.remove('gold');
          this.classList.remove('unique');
          this.style.background = '';
          var subtype = get.subtype(this);
          if (subtype) {
            this.classList.remove(subtype);
          }
        }
        if (info.epic) {
          this.classList.add('epic');
        }
        else if (info.legend) {
          this.classList.add('legend');
        }
        else if (info.gold) {
          this.classList.add('gold');
        }
        else if (info.unique) {
          this.classList.add('unique');
        }
        var bg = card[2];
        if (info.cardimage) {
          bg = info.cardimage;
        }
        var img = lib.card[bg].image;
        if (img) {
          if (img.indexOf('db:') == 0) {
            img = img.slice(3);
          }
          else if (img.indexOf('ext:') != 0) {
            img = null;
          }
        }
        this.classList.remove('fullskin');
        this.classList.remove('fullimage');
        this.classList.remove('fullborder');
        this.dataset.cardName = card[2];
        this.dataset.cardType = info.type || '';
        this.dataset.cardSubype = info.subtype || '';
        this.dataset.cardMultitarget = info.multitarget ? '1' : '0';
        this.node.name.dataset.nature = '';
        this.node.info.classList.remove('red');
        if (lib.card[bg].fullskin) {
          this.classList.add('fullskin');
          if (img) {
            if (img.indexOf('ext:') == 0) {
              this.node.image.setBackgroundImage(img.replace(/ext:/, 'extension/'));
            }
            else {
              this.node.image.setBackgroundDB(img);
            }
          }
          else {
            if (lib.card[bg].modeimage) {
              this.node.image.setBackgroundImage('image/mode/' + lib.card[bg].modeimage + '/card/' + bg + '.png');
            }
            else {
              if (bg.indexOf('rm_') == 0) {
                var bg = bg.slice(3);
                this.node.image.setBackgroundImage('image/replace/' + bg + '.png');
              }
              else if (lib.config.replace_image) {
                this.node.image.setBackgroundImage('image/replace/' + bg + '.png');
              }
              else {
                this.node.image.setBackgroundImage('image/card/' + bg + '.png');
              }
            }
          }
        }
        else if (lib.card[bg].image == 'background') {
          if (card[3]) this.node.background.setBackground(bg + '_' + card[3], 'card');
          else this.node.background.setBackground(bg, 'card');
        }
        else if (lib.card[bg].fullimage) {
          this.classList.add('fullimage');
          if (img) {
            if (img.indexOf('ext:') == 0) {
              this.setBackgroundImage(img.replace(/ext:/, 'extension/'));
              this.style.backgroundSize = 'cover';
            }
            else {
              this.setBackgroundDB(img);
            }
          }
          else if (lib.card[bg].image) {
            if (lib.card[bg].image.indexOf('character:') == 0) {
              this.setBackground(lib.card[bg].image.slice(10), 'character');
            }
            else {
              this.setBackground(lib.card[bg].image);
            }
          }
          else {
            var cardPack = lib.cardPack['mode_' + get.mode()];
            if (Array.isArray(cardPack) && cardPack.contains(bg)) {
              this.setBackground('mode/' + get.mode() + '/card/' + bg);
            }
            else {
              this.setBackground('card/' + bg);
            }
          }
        }
        else if (lib.card[bg].fullborder) {
          this.classList.add('fullborder');
          if (lib.card[bg].fullborder == 'gold') {
            this.node.name.dataset.nature = 'metalmm';
          }
          else if (lib.card[bg].fullborder == 'silver') {
            this.node.name.dataset.nature = 'watermm';
          }
          if (!this.node.avatar) {
            this.node.avatar = ui.create.div('.cardavatar');
            this.insertBefore(this.node.avatar, this.firstChild);
          }
          if (!this.node.framebg) {
            this.node.framebg = ui.create.div('.cardframebg');
            this.node.framebg.dataset.auto = lib.card[bg].fullborder;
            this.insertBefore(this.node.framebg, this.firstChild);
          }
          if (img) {
            if (img.indexOf('ext:') == 0) {
              this.node.avatar.setBackgroundImage(img.replace(/ext:/, 'extension/'));
              this.node.avatar.style.backgroundSize = 'cover';
            }
            else {
              this.node.avatar.setBackgroundDB(img);
            }
          }
          else if (lib.card[bg].image) {
            if (lib.card[bg].image.indexOf('character:') == 0) {
              this.node.avatar.setBackground(lib.card[bg].image.slice(10), 'character');
            }
            else {
              this.node.avatar.setBackground(lib.card[bg].image);
            }
          }
          else {
            var cardPack = lib.cardPack['mode_' + get.mode()];
            if (Array.isArray(cardPack) && cardPack.contains(bg)) {
              this.node.avatar.setBackground('mode/' + get.mode() + '/card/' + bg);
            }
            else {
              this.node.avatar.setBackground('card/' + bg);
            }
          }
        }
        else if (lib.card[bg].image == 'card') {
          if (card[3]) this.setBackground(bg + '_' + card[3], 'card');
          else this.setBackground(bg, 'card');
        }
        else if (typeof lib.card[bg].image == 'string' && !lib.card[bg].fullskin) {
          if (img) {
            if (img.indexOf('ext:') == 0) {
              this.setBackgroundImage(img.replace(/ext:/, 'extension/'));
              this.style.backgroundSize = 'cover';
            }
            else {
              this.setBackgroundDB(img);
            }
          }
          else {
            this.setBackground(lib.card[bg].image);
          }
        }
        else {
          this.node.background.innerHTML = lib.translate[bg + '_cbg'] || lib.translate[bg + '_bg'] || get.translation(bg)[0];
          if (this.node.background.innerHTML.length > 1) this.node.background.classList.add('tight');
          else this.node.background.classList.remove('tight');
        }
        if ((bg == 'wuxingpan' || !lib.card[bg].fullborder) && this.node.avatar && this.node.framebg) {
          this.node.avatar.remove();
          this.node.framebg.remove();
          delete this.node.avatar;
          delete this.node.framebg;
        }
        if (info.noname && !this.classList.contains('button')) {
          this.node.name.style.display = 'none';
        }
        if (info.color) {
          this.style.color = info.color;
        }
        if (info.textShadow) {
          this.style.textShadow = info.textShadow;
        }
        if (info.opacity) {
          this.node.info.style.opacity = info.opacity;
          this.node.name.style.opacity = info.opacity;
        }
        if (info.modinfo) {
          this.node.info.innerHTML = info.modinfo;
        }
        else {
          this.node.info.innerHTML = get.translation(card[0]) + '<span> </span>' + cardnum;
        }
        if (info.addinfo) {
          if (!this.node.addinfo) {
            this.node.addinfo = ui.create.div('.range', this);
          }
          this.node.addinfo.innerHTML = info.addinfo;
        }
        else if (this.node.addinfo) {
          this.node.addinfo.remove();
          delete this.node.addinfo;
        }
        if (card[0] == 'heart' || card[0] == 'diamond') {
          this.node.info.classList.add('red');
        }
        this.node.name.innerHTML = '';
        this.node.image.className = 'image';
        var name = get.translation(card[2]);
        if (name.length == 1) {
          if (card[3] == 'fire') {
            name = '火' + name;
            this.node.image.classList.add('fire');
          }
          else if (card[3] == 'thunder') {
            name = '雷' + name;
            this.node.image.classList.add('thunder');
          }
          else if (card[3] == 'kami') {
            name = '神' + name;
            this.node.image.classList.add('kami');
          }
          else if (card[3] == 'ice') {
            name = '冰' + name;
            this.node.image.classList.add('ice');
          }
          else if (card[3] == 'ocean') {
            name = '海' + name;
            this.node.image.classList.add('ocean');
          }
          else if (card[3] == 'yami') {
            name = '暗' + name;
            this.node.image.classList.add('yami');
          }
        } else {
          if (card[3] == 'fire') {
            this.node.image.classList.add('fire');
          }
          else if (card[3] == 'thunder') {
            this.node.image.classList.add('thunder');
          }
          else if (card[3] == 'kami') {
            this.node.image.classList.add('kami');
          }
          else if (card[3] == 'ice') {
            this.node.image.classList.add('ice');
          }
          else if (card[3] == 'ocean') {
            name = name.replace(name.charAt(0), '海');
            this.node.image.classList.add('ocean');
          }
          else if (card[3] == 'yami') {
            name = name.replace(name.charAt(0), '暗');
            this.node.image.classList.add('yami');
          }
        }
        for (var i = 0; i < name.length; i++) {
          this.node.name.innerHTML += name[i] + '<br/>';
        }
        if (name.length >= 5) {
          this.node.name.classList.add('long');
          if (name.length >= 7) {
            this.node.name.classList.add('longlong');
          }
        }
        this.node.name2.innerHTML = get.translation(card[0]) + cardnum + ' ' + name;
        this.suit = card[0];
        this.number = parseInt(card[1]) || 0;
        this.name = card[2];
        this.classList.add('card');
        if (card[3]) {
          if (lib.nature.contains(card[3])) this.nature = card[3];
          this.classList.add(card[3]);
        }
        else if (this.nature) {
          this.classList.remove(this.nature);
          delete this.nature;
        }
        if (info.subtype) this.classList.add(info.subtype);
        if (this.inits) {
          for (var i = 0; i < lib.element.card.inits.length; i++) {
            lib.element.card.inits[i](this);
          }
        }
        if (typeof info.init == 'function') info.init();
        this.node.range.innerHTML = '';
        switch (get.subtype(this)) {
          case 'equip1':
            var added = false;
            if (lib.card[this.name] && lib.card[this.name].distance) {
              var dist = lib.card[this.name].distance;
              if (dist.attackFrom) {
                added = true;
                this.node.range.innerHTML = '范围: ' + (-dist.attackFrom + 1);
              }
            }
            if (!added) {
              this.node.range.innerHTML = '范围: 1';
            }
            break;
          case 'equip3':
            if (info.distance && info.distance.globalTo) {
              this.node.range.innerHTML = '防御: ' + info.distance.globalTo;
              this.node.name2.innerHTML += '+';
            }
            break;
          case 'equip4':
            if (info.distance && info.distance.globalFrom) {
              this.node.range.innerHTML = '进攻: ' + (-info.distance.globalFrom);
              this.node.name2.innerHTML += '-';
            }
            break;
        }
        var specialEffects = [];
        if (Array.isArray(card[5])) {
          specialEffects.addArray(card[5]);
        }
        if (this.node.image.parentNode.classList.length > 0)
          this.node.image.parentNode.classList.forEach(element => {
            if (element.indexOf("card_") != -1) {
              this.node.image.parentNode.classList.remove(element);
            }
          });
        if (specialEffects.length) {
          for (var i = 0; i < specialEffects.length; i++) {
            this.node.image.parentNode.classList.add(specialEffects[i]);
          }
          this.specialEffects = specialEffects;
        }
        if (_status.connectMode && !game.online && lib.cardOL && !this.cardid) {
          this.cardid = get.id();
          lib.cardOL[this.cardid] = this;
        }
        if (!_status.connectMode && !_status.video) {
          this.cardid = get.id();
        }
        var tags = [];
        if (Array.isArray(card[4])) {
          tags.addArray(card[4]);
        }
        if (this.cardid) {
          if (!_status.cardtag) {
            _status.cardtag = {};
          }
          for (var i in _status.cardtag) {
            if (_status.cardtag[i].contains(this.cardid)) {
              tags.add(i);
            }
          }
          if (tags.length) {
            var tagstr = ' <span class="cardtag">';
            for (var i = 0; i < tags.length; i++) {
              var tag = tags[i];
              if (!_status.cardtag[tag]) {
                _status.cardtag[tag] = [];
              }
              _status.cardtag[tag].add(this.cardid);
              tagstr += lib.translate[tag + '_tag'];
            }
            tagstr += '</span>';
            this.node.range.innerHTML += tagstr;
          }
        }
        return this;
      },
      /**
       * 选中状态，更新本游戏牌的位置；仅供`ui.me`中的手牌使用的函数(本机)
       * @param {?boolean} [bool] 如果为true，translate`translateY(-20px)`
       * @param {?number} [delay] 延迟`delay`(ms)时长，再更新本游戏牌位置；如果未指定或为0，不调用延迟函数，立即更新
       */
      updateTransform: function (bool, delay) {
        if (delay) {
          var that = this;
          setTimeout(function () {
            that.updateTransform(that.classList.contains('selected'));
          }, delay);
        }
        else {
          if (_status.event.player != game.me) return;
          if (this._transform && this.parentNode && this.parentNode.parentNode &&
            this.parentNode.parentNode.parentNode == ui.me &&
            (!_status.mousedown || _status.mouseleft) &&
            (!this.parentNode.parentNode.classList.contains('scrollh') || (game.layout == 'long2' || game.layout == 'nova'))) {
            if (bool) {
              this.style.transform = this._transform + ' translateY(-20px)';
            }
            else {
              this.style.transform = this._transform || '';
            }
          }
        }
      },
      aiexclude: function () {
        _status.event._aiexclude.add(this);
      },
      getSource: function (name) {
        if (this.name == name) return true;
        var info = lib.card[this.name];
        if (info && Array.isArray(info.source)) {
          return info.source.contains(name);
        }
        return false;
      },
      moveDelete: function (player) {
        this.fixed = true;
        if (!this._listeningEnd || this._transitionEnded) {
          this.moveTo(player);
          var that = this;
          setTimeout(function () {
            that.delete();
          }, 200);
        }
        else {
          this._onEndMoveDelete = player;
        }
      },
      moveTo: function (player) {
        this.fixed = true;
        var dx, dy;
        if (this.classList.contains('center')) {
          var nx = [50, -52];
          var ny = [50, -52];
          nx = nx[0] * ui.arena.offsetWidth / 100 + nx[1];
          ny = ny[0] * ui.arena.offsetHeight / 100 + ny[1];
          dx = player.getLeft() + player.offsetWidth / 2 - 52 - nx;
          dy = player.getTop() + player.offsetHeight / 2 - 52 - ny;
        }
        else {
          this.style.left = this.offsetLeft + 'px';
          this.style.top = this.offsetTop + 'px';

          dx = player.getLeft() + player.offsetWidth / 2 - 52 - this.offsetLeft;
          dy = player.getTop() + player.offsetHeight / 2 - 52 - this.offsetTop;
        }
        if (get.is.mobileMe(player)) {
          dx += get.cardOffset();
          if (ui.arena.classList.contains('oblongcard')) {
            dy -= 16;
          }
        }


        if (this.style.transform && this.style.transform != 'none' && this.style.transform.indexOf('translate') == -1) {
          this.style.transform += ' translate(' + dx + 'px,' + dy + 'px)';
        }
        else {
          this.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
        }
        return this;
      },
      copy: function () {
        var node = this.cloneNode(true);
        node.style.transform = '';
        node.name = this.name;
        node.suit = this.suit;
        node.number = this.number;
        node.classList.remove('hidden');
        node.classList.remove('start');
        node.classList.remove('thrown');
        node.classList.remove('selectable');
        node.classList.remove('selected');
        node.classList.remove('removing');
        node.classList.remove('drawinghidden');
        node.classList.remove('glows');
        node.node = {
          name: node.querySelector('.name'),
          info: node.querySelector('.info'),
          intro: node.querySelector('.intro'),
          background: node.querySelector('.background'),
          image: node.querySelector('.image'),
          gaintag: node.querySelector('.gaintag'),
        }
        node.node.gaintag.innerHTML = '';
        var clone = true;
        var position;
        for (var i = 0; i < arguments.length; i++) {
          if (typeof arguments[i] == 'string') node.classList.add(arguments[i]);
          else if (get.objtype(arguments[i]) == 'div') position = arguments[i];
          else if (typeof arguments[i] == 'boolean') clone = arguments[i];
        }
        node.moveTo = lib.element.card.moveTo;
        node.moveDelete = lib.element.card.moveDelete;
        if (clone) this.clone = node;
        if (position) position.appendChild(node);
        return node;
      },
      uncheck: function (skill) {
        if (skill) this._uncheck.add(skill);
        this.classList.add('uncheck');
      },
      recheck: function (skill) {
        if (skill) this._uncheck.remove(skill);
        else this._uncheck.length = 0;
        if (this._uncheck.length == 0) this.classList.remove('uncheck');
      },
      discard: function (bool) {
        if (!this.destroyed) {
          ui.discardPile.appendChild(this);
        }
        this.fix();
        this.classList.remove('glow');
        if (bool === false) {
          ui.cardPile.insertBefore(this, ui.cardPile.childNodes[Math.floor(Math.random() * ui.cardPile.childNodes.length)]);
        }
        else {
          if (_status.discarded) {
            _status.discarded.add(this);
          }
        }
      },
      hasTag: function (tag) {
        if (this.cardid && _status.cardtag && _status.cardtag[tag] && _status.cardtag[tag].contains(this.cardid)) {
          return true;
        }
        return false;
      },
      /**
       * 判断本卡牌是否在某角色的区域中
       * @returns {!boolean}
       */
      hasPosition: function () {
        return ['h', 'e', 'j'].contains(get.position(this));
      },
      /**
       * 判断本卡牌是否在牌堆或弃牌堆中
       * @returns {!boolean}
       */
      isInPile: function () {
        return ['c', 'd'].contains(get.position(this));
      }
    },
    /**
     * 按钮方法
     * @name element.button
     * @type {!Object}
     */
    button: {
      exclude: function () {
        if (_status.event.excludeButton == undefined) {
          _status.event.excludeButton = [];
        }
        _status.event.excludeButton.add(this);
      }
    },
    /**
     * 事件方法，游戏进行过程中每一个事件所具有的方法（比如设置事件内容【setContent】和停止事件【finish】）
     * 事件
     * @namespace
     * @mixin
     */
    event: {
      changeToZero: function () {
        this.num = 0;
        this.numFixed = true;
      },
      /**
       * 结束事件
       * @function
       */
      finish: function () {
        this.finished = true;
      },
      /**
       * 取消事件
       * 直接结束事件，也跳过子事件的触发和执行
       * @function
       * @param {?boolean} all 见{@link lib.element.event.untrigger}
       * @param {?GameCores.GameObjects.Player} player 见{@link lib.element.event.untrigger}
       * @param {?string} notrigger 如果为'notrigger'则**不尝试触发**`${this.name}Cancelled`
       */
      cancel: function (arg1, arg2, notrigger) {
        this.untrigger.call(this, arguments);//??
        this.finish();
        if (notrigger != 'notrigger') {
          this.trigger(this.name + 'Cancelled');
          if (this.player && lib.phaseName.contains(this.name)) this.player.getHistory('skipped').add(this.name)
        }
      },
      /**
       * 转移状态
       * @function
       * @param {!number} step 新状态
       */
      goto: function (step) {
        this.step = step - 1;
      },
      /**
       * 自环(循环)
       * @function
       */
      redo: function () {
        this.step--;
      },
      setHiddenSkill: function (skill) {
        if (!this.player) return this;
        var hidden = this.player.hiddenSkills.slice(0);
        game.expandSkills(hidden);
        if (hidden.contains(skill)) this.set('hsskill', skill);
        return this;
      },
      /**
       * 链式函数，为Event的属性赋值
       * 赋值`this[key] = value`，同时绑定`this._set.push([key, value])`
       * @function lib.element.event.set
       * @param {!string} key 键名
       * @param {?Object} value 键值
       * @returns {GameCores.GameObjects.Event} this self
       */
      /**
       * 为Event的属性赋值
       * 对每个键值对，调用{@link lib.element.event.set}绑定到Event上
       * @function lib.element.event.set
       * @variation 2
       * @param {!Array<Array>} pairs 要设置键值对数组
       * @param {!string} pairs[].'[0]' 键名
       * @param {?Object} pairs[].'[1]' 键值
       */
      set: function (key, value) {
        if (arguments.length == 1 && Array.isArray(arguments[0])) {
          for (var i = 0; i < arguments[0].length; i++) {
            if (Array.isArray(arguments[0][i])) {
              this.set(arguments[0][i][0], arguments[0][i][1]);
            }
          }
        }
        else {
          if (typeof key != 'string') {
            console.log('warning: using non-string object as Evt key');
            console.log(key, value);
            console.log(_status.event);
          }
          this[key] = value;
          this._set.push([key, value]);
        }
        return this;
      },
      /**
       * 设置事件的状态机
       * @function
       * @param {?GameCores.Bases.StateMachine} stateMachine 状态机，如果未指定则不设置
       * @returns {GameCores.Bases.Event} this self
       */
      /**
       * 设置事件的状态机
       * @param {?string} name 状态机名，使用`lib.element.content[name]`作为事件的状态机，见{@link lib.element.content}
       * @returns {GameCores.Bases.Event} this self
       */
      setContent: function (name) {
        if (typeof name == 'function' || Array.isArray(name)) {
          this.content = lib.init.parse(name);
        }
        else {
          if (!lib.element.content[name]) console.log(name)
          if (!lib.element.content[name]._parsed) {
            lib.element.content[name] = lib.init.parse(lib.element.content[name]);
            lib.element.content[name]._parsed = true;
          }
          this.content = lib.element.content[name];
        }
        return this;
      },
      getLogv: function () {
        for (var i = 1; i <= 3; i++) {
          var Evt = this.getParent(i);
          if (Evt && Evt.logvid) return Evt.logvid;
        }
        return null;
      },
      send: function () {
        this.player.send(function (name, args, set, Evt, skills) {
          game.me.applySkills(skills);
          var next = game.me[name].apply(game.me, args);
          for (var i = 0; i < set.length; i++) {
            next.set(set[i][0], set[i][1]);
          }
          if (next._backupevent) {
            next.backup(next._backupevent);
          }
          next._modparent = Evt;
          game.resume();
        }, this.name, this._args || [], this._set,
          get.stringifiedResult(this.parent, 3), get.skillState(this.player));
        this.player.wait();
        game.pause();
      },
      /**
       * 选择结束，清空事件的选择(card，target, skill)
       */
      resume: function () {
        delete this._cardChoice;
        delete this._targetChoice;
        delete this._skillChoice;
      },
      /**
       * 获取本事件的指定父事件
       * @function
       * @param {(string|number)} [level] 指定父事件的名称 | 为number值时表示重复取level次_parent
       * @param {?boolean} [forced] 为true表示强制返回：获取不到指定父事件时返回{null}
       * @returns {?GameCores.Bases.Event} 通过_parent（_modparent）属性获取本事件的父事件，若父事件不满足要求或重复次数少于level，则取父事件的_parent，依此类推直至获取到满足条件的父事件
       */
      getParent: function (level, forced) {
        var parent;
        if (this._modparent && game.online) {
          parent = this._modparent;
        }
        else {
          parent = this.parent;
        }
        var toreturn = {};
        if (typeof level == 'string' && forced == true) {
          toreturn = null;
        }
        if (!parent) return toreturn;
        if (typeof level == 'number') {
          for (var i = 1; i < level; i++) {
            if (!parent) return toreturn;
            parent = parent.parent;
          }
        }
        else if (typeof level == 'string') {
          for (var i = 0; i < 20; i++) {
            if (!parent) return toreturn;
            if (parent.name == level) return parent;
            parent = parent.parent;
          }
          if (!parent) return toreturn;
        }
        if (toreturn === null) {
          return null;
        }
        return parent;
      },
      /**
       * 获取本事件的触发事件
       * @function
       * @returns {?GameCores.Bases.Event} 本事件的触发事件，如果本事件没有触发事件，返回undefined/null
       */
      getTrigger: function () {
        return this.getParent()._trigger;
      },
      /**
       * 返回本事件的随机值，如果已经有随机值就返回之前的随机值；未调用该函数时，随机值`this._rand`默认未指定(undefined)
       * @returns {!number} this._rand
       */
      getRand: function (name) {
        if (name) {
          if (!this._rand_map) this._rand_map = {};
          if (!this._rand_map[name]) this._rand_map[name] = Math.random();
          return this._rand_map[name];
        }
        if (!this._rand) this._rand = Math.random();
        return this._rand;
      },
      /**
       * 创建不可触发的`${this.name}Inserted`事件，立即执行
       * @function
       * @param {?GameCores.Bases.StateMachine} stateMachine 状态机
       * @param {?Object<string, Object>} map 键值对对象
       * @returns {!GameCores.Bases.Event} 创建的事件
       */
      insert: function (func, map) {
        var next = game.createEvent(this.name + 'Inserted', false, this);
        next.setContent(func);
        for (var i in map) {
          next.set(i, map[i]);
        }
        return next;
      },
      /**
       * 创建不可触发的`${this.name}Inserted`事件，于本事件结算后执行
       * @function
       * @param {?GameCores.Bases.StateMachine} stateMachine 状态机
       * @param {?Object<string, Object>} map 键值对对象
       * @returns {!GameCores.Bases.Event} 创建的事件
       */
      insertAfter: function (func, map) {
        var next = game.createEvent(this.name + 'Inserted', false, { next: [] });
        this.after.push(next);
        next.setContent(func);
        for (var i in map) {
          next.set(i, map[i]);
        }
        return next;
      },
      /**
       * 备份
       * @function
       * @param {?string} skill 技能ID
       */
      backup: function (skill) {
        this._backup = {
          filterButton: this.filterButton,
          selectButton: this.selectButton,
          filterTarget: this.filterTarget,
          selectTarget: this.selectTarget,
          filterCard: this.filterCard,
          selectCard: this.selectCard,
          position: this.position,
          forced: this.forced,
          fakeforce: this.fakeforce,
          _aiexclude: this._aiexclude,
          complexSelect: this.complexSelect,
          complexCard: this.complexCard,
          complexTarget: this.complexTarget,
          _cardChoice: this._cardChoice,
          _targetChoice: this._targetChoice,
          _skillChoice: this._skillChoice,
          ai1: this.ai1,
          ai2: this.ai2,
        }
        if (skill) {
          var info = get.info(skill);
          this.skill = skill;
          this._aiexclude = [];
          if (typeof info.viewAs == 'function') {
            if (info.filterButton != undefined) this.filterButton = get.filter(info.filterButton);
            if (info.selectButton != undefined) this.selectButton = info.selectButton;
            if (info.filterTarget != undefined) this.filterTarget = get.filter(info.filterTarget);
            if (info.selectTarget != undefined) this.selectTarget = info.selectTarget;
            if (info.filterCard != undefined) {
              if (info.ignoreMod) this.ignoreMod = true;
              this.filterCard2 = get.filter(info.filterCard);
              this.filterCard = function (card, player, Evt) {
                var evt = Evt || _status.event;
                if (!evt.ignoreMod && player) {
                  var mod = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
                  if (mod != 'unchanged') return mod;
                  if (evt._backup && evt._backup.filterCard) {
                    var cardx2 = lib.skill[evt.skill].viewAs(ui.selected.cards.concat([card]), player);
                    if (get.is.object(cardx2)) {
                      var cardx = get.autoViewAs(cardx2, ui.selected.cards.concat([card]));
                      if (!get.filter(evt._backup.filterCard)(cardx, player, evt)) return false;
                    }
                  }
                }
                return get.filter(evt.filterCard2).apply(this, arguments);
              };
            }
            if (info.selectCard != undefined) this.selectCard = info.selectCard;
            if (info.position != undefined) this.position = info.position;
            if (info.forced != undefined) this.forced = info.forced;
            if (info.complexSelect != undefined) this.complexSelect = info.complexSelect;
            if (info.complexCard != undefined) this.complexCard = info.complexCard;
            if (info.complexTarget != undefined) this.complexTarget = info.complexTarget;
            if (info.ai1 != undefined) this.ai1 = info.ai1;
            if (info.ai2 != undefined) this.ai2 = info.ai2;
          }
          else if (info.viewAs) {
            if (info.filterButton != undefined) this.filterButton = get.filter(info.filterButton);
            if (info.selectButton != undefined) this.selectButton = info.selectButton;
            if (info.filterTarget != undefined) this.filterTarget = get.filter(info.filterTarget);
            if (info.selectTarget != undefined) this.selectTarget = info.selectTarget;
            if (info.filterCard != undefined) {
              if (info.ignoreMod) this.ignoreMod = true;
              this.filterCard2 = get.filter(info.filterCard);
              this.filterCard = function (card, player, Evt) {
                var evt = Evt || _status.event;
                if (!evt.ignoreMod && player) {
                  var mod = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
                  if (mod != 'unchanged') return mod;
                  if (evt._backup && evt._backup.filterCard) {
                    var cardx = get.autoViewAs(lib.skill[evt.skill].viewAs, ui.selected.cards.concat([card]));
                    if (!get.filter(evt._backup.filterCard)(cardx, player, evt)) return false;
                  };
                }
                return get.filter(evt.filterCard2).apply(this, arguments);
              };
            }
            if (info.selectCard != undefined) this.selectCard = info.selectCard;
            if (info.position != undefined) this.position = info.position;
            if (info.forced != undefined) this.forced = info.forced;
            if (info.complexSelect != undefined) this.complexSelect = info.complexSelect;
            if (info.complexCard != undefined) this.complexCard = info.complexCard;
            if (info.complexTarget != undefined) this.complexTarget = info.complexTarget;
            if (info.ai1 != undefined) this.ai1 = info.ai1;
            if (info.ai2 != undefined) this.ai2 = info.ai2;
          }
          else {
            this.filterButton = info.filterButton ? get.filter(info.filterButton) : undefined;
            this.selectButton = info.selectButton;
            this.filterTarget = info.filterTarget ? get.filter(info.filterTarget) : undefined;
            this.selectTarget = info.selectTarget;
            this.filterCard = info.filterCard ? get.filter(info.filterCard) : undefined;
            this.selectCard = info.selectCard;
            this.position = info.position;
            this.forced = info.forced;
            this.complexSelect = info.complexSelect;
            this.complexCard = info.complexCard;
            this.complexTarget = info.complexTarget;
            if (info.ai1 != undefined) this.ai1 = info.ai1;
            if (info.ai2 != undefined) this.ai2 = info.ai2;
          }
          delete this.fakeforce;
        }
        delete this._cardChoice;
        delete this._targetChoice;
        delete this._skillChoice;
      },
      restore: function () {
        if (this._backup) {
          this.filterButton = this._backup.filterButton;
          this.selectButton = this._backup.selectButton;
          this.filterTarget = this._backup.filterTarget;
          this.selectTarget = this._backup.selectTarget;
          this.filterCard = this._backup.filterCard;
          this.selectCard = this._backup.selectCard;
          this.position = this._backup.position;
          this.forced = this._backup.forced;
          this.fakeforce = this._backup.fakeforce;
          this._aiexclude = this._backup._aiexclude;
          this.complexSelect = this._backup.complexSelect;
          this.complexCard = this._backup.complexCard;
          this.complexTarget = this._backup.complexTarget;
          this.ai1 = this._backup.ai1;
          this.ai2 = this._backup.ai2;
          this._cardChoice = this._backup._cardChoice;
          this._targetChoice = this._backup._targetChoice;
          this._skillChoice = this._backup._skillChoice;
        }
        delete this.skill;
        delete this.ignoreMod;
        delete this.filterCard2;
      },
      isMine: function () {
        return (this.player && this.player == game.me && !_status.auto && !this.player.isMad() && !game.notMe);
      },
      isOnline: function () {
        return (this.player && this.player.isOnline());
      },
      notLink: function () {
        return this.getParent().name != '_lianhuan' && this.getParent().name != '_lianhuan2';
      },
      isPhaseUsing: function (player) {
        var evt = this.getParent('phaseUse');
        if (!evt || evt.name != 'phaseUse') return false;
        return !player || player == evt.player;
      },
      addTrigger: function (skill, player) {
        if (!player) return;
        var evt = this;
        while (true) {
          var evt = evt.getParent('arrangeTrigger');
          if (!evt || evt.name != 'arrangeTrigger' || !evt.map) return;
          if (typeof skill == 'string') skill = [skill];
          game.expandSkills(skill);
          var filter = function (content) {
            if (typeof content == 'string') return content == triggername;
            return content.contains(triggername);
          };
          var trigger = evt._trigger;
          var triggername = evt.triggername;
          var map = false;
          if (evt.doing && evt.doing.player == player) map = evt.doing;
          else {
            for (var i = 0; i < evt.map.length; i++) {
              if (evt.map[i].player == player) { map = evt.map[i]; break; }
            }
          }
          if (!map) return;
          var func = function (skillx) {
            var info = lib.skill[skillx];
            var bool = false;
            for (var i in info.trigger) {
              if (filter(info.trigger[i])) { bool = true; break }
            }
            if (!bool) return;
            var priority = 0;
            if (info.priority) {
              priority = info.priority * 100;
            }
            if (info.silent) {
              priority++;
            }
            if (info.equipSkill) priority -= 25;
            if (info.cardSkill) priority -= 50;
            if (info.ruleSkill) priority -= 75;
            var toadd = [skillx, player, priority];
            if (map.list2) {
              for (var i = 0; i < map.list2.length; i++) {
                if (map.list2[i][0] == toadd[0] && map.list2[i][1] == toadd[1]) return;
              }
            };
            for (var i = 0; i < map.list.length; i++) {
              if (map.list[i][0] == toadd[0] && map.list[i][1] == toadd[1]) return;
            }
            map.list.add(toadd);
            map.list.sort(function (a, b) {
              return b[2] - a[2];
            });
          }
          for (var j = 0; j < skill.length; j++) {
            func(skill[j]);
          }
        }
      },
      /**
       * 尝试触发子事件
       * @param {!string} name trigger name
       */
      trigger: function (name) {
        //??
        if (_status.video) return;
        //如果是游戏开始前，分发手牌时，一切因获得/失去牌而触发的技能不会触发
        if ((this.name === 'gain' || this.name === 'lose') && !_status.gameDrawed) return;
        //分发手牌结束 [recommend] why here//??
        /**
         * 如果为true，表示游戏开始前分发手牌结束；如果未指定，则游戏未开始且手牌没有分发完成
         * @name _status.gameDrawed
         * @type {?true}
         */
        if (name === 'gameDrawEnd') _status.gameDrawed = true;
        if (name === 'gameStart') {
          if (_status.brawl && _status.brawl.gameStart) {
            _status.brawl.gameStart();
          }
          if (lib.config.show_cardpile) {
            ui.cardPileButton.style.display = '';
          }
          /**
           * 如果为true，表示游戏已经开始；如果未指定，则游戏还在分发武将和手牌，尚未开始
           * @name _status.gameStarted
           * @type {?true}
           */
          _status.gameStarted = true;
          game.showHistory();
        }
        //通过hookmap优化性能，但是hookmap不向下兼容；如果处于兼容模式，则忽略hookmap优化
        if (!lib.hookmap[name] && !lib.config.compatiblemode) return;
        //?? 是否需要判空?
        if (!game.players || !game.players.length) return;
        var Evt = this;
        //?? 是否可以简化?
        //??
        var start = false;
        var starts = [_status.currentPhase, Evt.source, Evt.player, game.me, game.players[0]];
        for (var i = 0; i < starts.length; i++) {
          if (get.itemtype(starts[i]) == 'player') {
            start = starts[i]; break;
          }
        }
        if (!start) return;
        //确保start角色在游戏之中
        if (!game.players.contains(start)) {
          start = game.findNext(start);
        }
        var list = [];
        var list2 = [];
        var mapx = [];
        var allbool = false;
        var roles = ['player', 'source', 'target'];
        var listAdded;
        var mapxx;
        var addList = function (skill, player) {
          if (listAdded[skill]) return;
          if (player.forbiddenSkills[skill]) return;
          if (player.disabledSkills[skill]) return;
          listAdded[skill] = true;
          var info = lib.skill[skill];
          var num = 0;
          if (info.priority) {
            num = info.priority * 100;
          }
          if (info.silent) {
            num++;
          }
          if (info.equipSkill) num -= 30;
          if (info.ruleSkill) num -= 30;
          if (info.firstDo) {
            list.push([skill, player, num]);
            list.sort(function (a, b) {
              return b[2] - a[2];
            });
            allbool = true;
            return;
          }
          else if (info.lastDo) {
            list2.push([skill, player, num]);
            list2.sort(function (a, b) {
              return b[2] - a[2];
            });
            allbool = true;
            return;
          }
          mapxx.list.push([skill, player, num]);
          mapxx.list.sort(function (a, b) {
            return b[2] - a[2];
          });
          allbool = true;
        };
        var totalPopulation = game.players.length + game.dead.length + 1;
        var player = start;
        var globalskill = 'global_' + name;
        var map = _status.connectMode ? lib.playerOL : game.playerMap;
        for (var iwhile = 0; iwhile < totalPopulation; iwhile++) {
          var id = player.playerid;
          var mapxx = {
            player: player,
            list: [],
            list2: [],
          };
          listAdded = {};
          var notemp = player.skills.slice(0);
          for (var j in player.additionalSkills) {
            if (j.indexOf('hidden:') != 0) notemp.addArray(player.additionalSkills[j]);
          }
          for (var j in player.tempSkills) {
            if (notemp.contains(j)) return;
            var expire = player.tempSkills[j];
            if (expire === name ||
              (Array.isArray(expire) && expire.contains(name)) ||
              (typeof expire === 'function' && expire(Evt, player, name))) {
              delete player.tempSkills[j];
              player.removeSkill(j);
            }
            else if (get.objtype(expire) === 'object') {
              for (var i = 0; i < roles.length; i++) {
                if (expire[roles[i]] && player === Evt[roles[i]] &&
                  (expire[roles[i]] === name || (Array.isArray(expire[roles[i]]) && expire[roles[i]].contains(name)))) {
                  delete player.tempSkills[j];
                  player.removeSkill(j);
                }
              }
            }
          }
          if (lib.config.compatiblemode) {
            (function () {
              var skills = player.getSkills(true).concat(lib.skill.global);
              game.expandSkills(skills);
              for (var i = 0; i < skills.length; i++) {
                var info = get.info(skills[i]);
                if (info && info.trigger) {
                  var trigger = info.trigger;
                  var add = false;
                  if (trigger.player) {
                    if (typeof trigger.player === 'string') {
                      if (trigger.player === name) add = true;
                    }
                    else if (trigger.player.contains(name)) add = true;
                  }
                  if (trigger.target) {
                    if (typeof trigger.target === 'string') {
                      if (trigger.target === name) add = true;
                    }
                    else if (trigger.target.contains(name)) add = true;
                  }
                  if (trigger.source) {
                    if (typeof trigger.source === 'string') {
                      if (trigger.source === name) add = true;
                    }
                    else if (trigger.source.contains(name)) add = true;
                  }
                  if (trigger.global) {
                    if (typeof trigger.global === 'string') {
                      if (trigger.global === name) add = true;
                    }
                    else if (trigger.global.contains(name)) add = true;
                  }
                  if (add) {
                    addList(skills[i], player);
                  }
                }
              }
            }());
          }
          else {
            for (var i = 0; i < roles.length; i++) {
              var triggername = player.playerid + '_' + roles[i] + '_' + name;
              if (lib.hook[triggername]) {
                for (var j = 0; j < lib.hook[triggername].length; j++) {
                  addList(lib.hook[triggername][j], player);
                }
              }
              triggername = roles[i] + '_' + name;
              if (lib.hook.globalskill[triggername]) {
                for (var j = 0; j < lib.hook.globalskill[triggername].length; j++) {
                  addList(lib.hook.globalskill[triggername][j], player);
                }
              }
            }
            if (lib.hook.globalskill[globalskill]) {
              for (var j = 0; j < lib.hook.globalskill[globalskill].length; j++) {
                addList(lib.hook.globalskill[globalskill][j], player);
              }
            }
            for (var i in lib.hook.globaltrigger[name]) {
              if (map[i] === player) {
                for (var j = 0; j < lib.hook.globaltrigger[name][i].length; j++) {
                  addList(lib.hook.globaltrigger[name][i][j], map[i]);
                }
              }
            }
          }
          mapx.push(mapxx);
          player = player.nextSeat;
          if (!player || player === start) {
            break;
          }
        }

        if (allbool) {
          var next = game.createEvent('arrangeTrigger', false, Evt);
          next.setContent('arrangeTrigger');
          next.list = list;
          next.list2 = list2;
          next.map = mapx;
          next._trigger = Evt;
          next.triggername = name;
          //next.starter=start;
          Evt._triggering = next;
        }
      },
      /**
       * 取消将要触发的子事件；如果无参调用，不进行任何处理
       * @function
       * @param {?boolean} all 如果为true，取消全部要触发的子事件；如果未指定或为false，忽略该值
       * @param {?GameCores.GameObjects.Player} player 一个角色，取消所有将要对该角色触发的子事件，如果未指定，忽略该值
       */
      untrigger: function (all, player) {
        var evt = this._triggering;
        if (all) {
          if (evt && evt.map) {
            for (var i = 0; i < evt.map.length; i++) {
              evt.map[i].list = [];
            }
            evt.list = [];
            if (evt.doing) evt.doing.list = [];
          };
          this._triggered = 5;
        }
        else {
          if (player) {
            this._notrigger.add(player);
            if (!evt || !evt.map) return;
            for (var i = 0; i < evt.map.length; i++) {
              if (evt.map[i].player == player) evt.map[i].list.length = 0;
            }
          }
        }
      }
    },
    /**
     * 弹窗方法，.dialog节点共用的方法（比如开启和关闭弹窗【open/close】）
     * 对话框(弹窗)
     * @name element.dialog
     * @type {!Object}
     */
    dialog: {
      add: function (item, noclick, zoom) {
        if (typeof item == 'string') {
          if (item.indexOf('###') == 0) {
            var items = item.slice(3).split('###');
            this.add(items[0], noclick, zoom);
            this.addText(items[1], items[1].length <= 20, zoom);
          }
          else if (noclick) {
            var strstr = item;
            item = ui.create.div('', this.content);
            item.innerHTML = strstr;
          }
          else {
            item = ui.create.caption(item, this.content);
          }
        }
        else if (get.objtype(item) == 'div') {
          this.content.appendChild(item);
        }
        else if (get.itemtype(item) == 'cards') {
          var buttons = ui.create.div('.buttons', this.content);
          if (zoom) buttons.classList.add('smallzoom');
          this.buttons = this.buttons.concat(ui.create.buttons(item, 'card', buttons, noclick));
        }
        else if (get.itemtype(item) == 'players') {
          var buttons = ui.create.div('.buttons', this.content);
          if (zoom) buttons.classList.add('smallzoom');
          this.buttons = this.buttons.concat(ui.create.buttons(item, 'player', buttons, noclick));
        }
        else {
          var buttons = ui.create.div('.buttons', this.content);
          if (zoom) buttons.classList.add('smallzoom');
          this.buttons = this.buttons.concat(ui.create.buttons(item[0], item[1], buttons, noclick));
        }
        if (this.buttons.length) {
          if (this.forcebutton !== false) this.forcebutton = true;
          if (this.buttons.length > 3 || (zoom && this.buttons.length > 5)) {
            this.classList.remove('forcebutton-auto');
          }
          else if (!this.noforcebutton) {
            this.classList.add('forcebutton-auto');
          }
        }
        ui.update();
        return item;
      },
      addText: function (str, center) {
        if (center !== false) {
          this.add('<div class="text center">' + str + '</div>');
        }
        else {
          this.add('<div class="text">' + str + '</div>');
        }
        return this;
      },
      addSmall: function (item, noclick) {
        return this.add(item, noclick, true);
      },
      addAuto: function (content) {
        if (content && content.length > 4 && !this._hovercustomed) {
          this.addSmall(content);
        }
        else {
          this.add(content);
        }
      },
      open: function () {
        if (this.noopen) return;
        for (var i = 0; i < ui.dialogs.length; i++) {
          if (ui.dialogs[i] == this) {
            this.show();
            this.refocus();
            ui.dialogs.remove(this);
            ui.dialogs.unshift(this);
            ui.update();
            return this;
          }
          if (ui.dialogs[i].static) ui.dialogs[i].unfocus();
          else ui.dialogs[i].hide();
        }
        ui.dialog = this;
        var translate;
        if (lib.config.remember_dialog && lib.config.dialog_transform && !this.classList.contains('fixed')) {
          translate = lib.config.dialog_transform;
          this._dragtransform = translate;
          this.style.transform = 'translate(' + translate[0] + 'px,' + translate[1] + 'px) scale(0.8)';
        }
        else {
          this.style.transform = 'scale(0.8)';
        }
        this.style.transitionProperty = 'opacity,transform';
        this.style.opacity = 0;
        ui.arena.appendChild(this);
        ui.dialogs.unshift(this);
        ui.update();
        ui.refresh(this);
        if (lib.config.remember_dialog && lib.config.dialog_transform && !this.classList.contains('fixed')) {
          this.style.transform = 'translate(' + translate[0] + 'px,' + translate[1] + 'px) scale(1)';
        }
        else {
          this.style.transform = 'scale(1)';
        }
        this.style.opacity = 1;
        var that = this;
        setTimeout(function () {
          that.style.transitionProperty = '';
        }, 500);
        return this;
      },
      close: function () {
        ui.dialogs.remove(this);
        this.delete();
        if (ui.dialogs.length > 0) {
          ui.dialog = ui.dialogs[0];
          ui.dialog.show();
          ui.dialog.refocus();
          ui.update();
        }
        // if(ui.arenalog){
        //     ui.arenalog.classList.remove('withdialog');
        // }
        return this;
      },
      setCaption: function (str) {
        this.querySelector('.caption').innerHTML = str;
        return this;
      }
    },
    /**
     * 选项方法，参考弹窗方法，在创建.control节点时依次为其添加
     * 选择项
     * @name element.control
     * @type {!Object}
     */
    control: {
      open: function () {
        ui.control.insertBefore(this, _status.createControl || ui.confirm);
        ui.controls.unshift(this);
        if (this.childNodes.length) {
          this.style.transition = 'opacity 0.5s';
          ui.refresh(this);
          this.style.transform = 'translateX(-' + (this.offsetWidth / 2) + 'px)';
          this.style.opacity = 1;
          ui.refresh(this);
          this.style.transition = '';
        }
        else {
          this.animate('controlpressdownx', 500);
        }
        ui.updatec();
        return this;
      },
      add: function (item) {
        var node = document.createElement('div');
        this.appendChild(node);
        node.link = item;
        node.innerHTML = get.translation(item);
        node.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.control);
      },
      close: function () {
        this.animate('controlpressdownx', 500);

        ui.controls.remove(this);
        this.delete();

        setTimeout(ui.updatec, 100);


        if (ui.confirm == this) delete ui.confirm;
        if (ui.skills == this) delete ui.skills;
        if (ui.skills2 == this) delete ui.skills2;
        if (ui.skills3 == this) delete ui.skills3;
      },
      replace: function () {
        // this.animate('controlpressdownx',500);
        if (this.replaceTransition === false) {
          this.style.transitionProperty = 'none';
          ui.refresh(this);
        }

        while (this.childNodes.length) this.firstChild.remove();
        var i, controls;
        if (Array.isArray(arguments[0])) controls = arguments[0];
        else controls = arguments;
        delete this.custom;
        for (i = 0; i < controls.length; i++) {
          if (typeof controls[i] == 'function') {
            this.custom = controls[i];
          }
          else {
            this.add(controls[i]);
          }
        }
        if (this.childNodes.length) {
          var width = 0;
          for (i = 0; i < this.childNodes.length; i++) width += this.childNodes[i].offsetWidth;
          ui.refresh(this);
          this.style.width = width + 'px';
        }
        ui.updatec();
        if (this.replaceTransition === false) {
          var that = this;
          setTimeout(function () {
            that.style.transitionProperty = '';
          }, 200);
        }
        return this;
      }
    },
    /**
     * 客户端
     * @name element.client
     * @type {!Object}
     */
    client: {
      send: function () {
        if (this.closed) return this;
        var args = Array.from(arguments);
        if (typeof args[0] == 'function') {
          args.unshift('exec');
        }
        for (var i = 1; i < args.length; i++) {
          args[i] = get.stringifiedResult(args[i]);
        }
        try {
          this.ws.send(JSON.stringify(args));
        }
        catch (e) {
          this.ws.close();
        }
        return this;
      },
      close: function () {
        lib.node.clients.remove(this);
        lib.node.observing.remove(this);
        if (ui.removeObserve && !lib.node.observing.length) {
          ui.removeObserve.remove();
          delete ui.removeObserve;
        }
        this.closed = true;
        if (_status.waitingForPlayer) {
          for (var i = 0; i < game.connectPlayers.length; i++) {
            if (game.connectPlayers[i].playerid == this.id) {
              game.connectPlayers[i].uninitOL();
              delete game.connectPlayers[i].playerid;
            }
          }
          if (game.onlinezhu == this.id) {
            game.onlinezhu = null;
          }
          game.updateWaiting();
        }
        else if (lib.playerOL[this.id]) {
          var player = lib.playerOL[this.id];
          player.setNickname(player.nickname + ' - 离线');
          game.broadcast(function (player) {
            player.setNickname(player.nickname + ' - 离线');
          }, player);
          player.unwait('ai');
        }

        if (window.isNonameServer) {
          document.querySelector('#server_count').innerHTML = lib.node.clients.length;
        }
        return this;
      }
    },
    /**
     * Node Web Server listeners and callbacks
     * @name element.nodews
     * @type {!Object}
     */
    nodews: {
      send: function (message) {
        game.send('server', 'send', this.wsid, message);
      },
      on: function (type, func) {
        this['on' + type] = func;
      },
      close: function () {
        game.send('server', 'close', this.wsid);
      }
    },
    /**
     * Web Server
     * @name element.ws
     * @type {!Object}
     */
    ws: {
      onopen: function () {
        if (_status.connectCallback) {
          _status.connectCallback(true);
          delete _status.connectCallback;
        }
      },
      onmessage: function (messageevent) {
        if (messageevent.data == 'heartbeat') {
          this.send('heartbeat');
          return;
        }
        var message;
        try {
          message = JSON.parse(messageevent.data);
          if (!Array.isArray(message) ||
            typeof lib.message.client[message[0]] !== 'function') {
            throw ('err');
          }
          for (var i = 1; i < message.length; i++) {
            message[i] = get.parsedResult(message[i]);
          }
        }
        catch (e) {
          console.log(e);
          console.log('invalid message: ' + messageevent.data);
          return;
        }
        lib.message.client[message.shift()].apply(null, message);
      },
      onerror: function (e) {
        if (this._nocallback) return;
        if (_status.connectCallback) {
          _status.connectCallback(false);
          delete _status.connectCallback;
        }
        else {
          alert('连接失败');
        }
      },
      onclose: function () {
        if (this._nocallback) return;
        if (_status.connectCallback) {
          _status.connectCallback(false);
          delete _status.connectCallback;
        }
        if (game.online || game.onlineroom) {
          if ((game.servermode || game.onlinehall) && _status.over) {

          }
          else {
            localStorage.setItem(lib.configprefix + 'directstart', true);
            game.reload();
          }
        }
        else {
          // game.saveConfig('reconnect_info');
        }
        game.online = false;
        game.ws = null;
      }
    }
  }
}

/***/ }),

/***/ 669:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = function (element, _mode, _message) {
  /**
   * 基础属性
   * @namespace
   */
  const { game, ui, get, ai, lib, _status } = vkCore
  /**
   * dist 路径
   */
  const dist = () => lib.assetURL + 'dist'

  let init = {
    /**
     * 初始化游戏，向HTMLDivElement和Array的原型链上添加一批方法（比如delete和addArray）
     * 入口函数
     * @function
     */
    init: function () {
      //part: `lib.configprefix` 初始化
      //如果是从PC端（node.js）载入，额外需要`__dirname`的各级文件夹首字母来拼接
      //例如：`__dirname` 为 `'F:\\vtb\\test\\src'`，则`lib.configprefix`为`'noname_0.9_Fvts_'|'vtuberkill_1.9_Fvts_'`
      //BUG: [PC win10] 路径使用`\`时，只获取了盘符
      if (typeof global !== 'undefined' && __dirname.length) {
        let dirsplit = __dirname.split('/');
        for (let i = 0; i < dirsplit.length; i++) {
          if (dirsplit[i]) {
            let c = dirsplit[i][0];
            lib.configprefix += /[A-Z]|[a-z]/.test(c) ? c : '_';
          }
        }
        lib.configprefix += '_';
      }
      window.resetGameTimeout = setTimeout(init.reset, parseInt(localStorage.getItem(lib.configprefix + 'loadtime')) || 5000);
      //part: `cordovaLoadTimeout`的创建，在 ../app/redirect.js
      if (window.cordovaLoadTimeout) {
        clearTimeout(window.cordovaLoadTimeout);
        delete window.cordovaLoadTimeout;
      }
      //part: 从html中，删除首次启动使用的样式（css）
      let links = document.head.querySelectorAll('link');
      for (let i = 0; i < links.length; i++) {
        if (links[i].href.indexOf('app/color.css') != -1) {
          links[i].remove();
          break;
        }
      }
      //part: 如果是phantom，则禁用indexedDB
      let index = window.location.href.indexOf('index.html?server=');
      if (index != -1) {
        /**
         * 服务器ID
         * @type {string}
         * @global
         */
        window.isNonameServer = window.location.href.slice(index + 18);
        /**
         * 禁用indexedDB，为真值时禁用
         * @type {boolean}
         * @global
         */
        window.nodb = true;
      }
      else {
        //??
        index = localStorage.getItem(lib.configprefix + 'asserver');
        if (index) {
          window.isNonameServer = index;
          window.isNonameServerIp = lib.hallURL;
        }
      }
      //part: 设置背景图
      var htmlbg = localStorage.getItem(lib.configprefix + 'background');
      if (htmlbg) {
        if (htmlbg[0] == '[') {
          try {
            htmlbg = JSON.parse(htmlbg);
            htmlbg = htmlbg[get.rand(htmlbg.length)];
            if (htmlbg.indexOf('custom_') == 0) {
              throw ('err');
            }
            _status.htmlbg = htmlbg;
          }
          catch (e) {
            htmlbg = null;
          }
        }
        if (htmlbg) {
          if (htmlbg.indexOf('svg_') == 0) {
            document.documentElement.style.backgroundImage = 'url("' + lib.assetURL + 'image/background/' + htmlbg.slice(4) + '.svg")';
          }
          else {
            document.documentElement.style.backgroundImage = 'url("' + lib.assetURL + 'image/background/' + htmlbg + '.jpg")';
            document.documentElement.style.backgroundSize = 'cover';
            document.documentElement.style.backgroundPosition = '50% 50%';
          }
        }
      }
      //part: get, ui, ai, game 引用到 lib对象
      lib.get = get;
      lib.ui = ui;
      lib.ai = ai;
      lib.game = game;
      //part: 拓展 HTMLDivElement.
      /**
       * 本元素播放动画
       * @function HTMLDivElement#animate
       * @param {string} name - 动画名称
       * @param {number} [time=1000] - 动画持续时间（ms）
       * @returns {HTMLDivElement} this self
       */
      {
        HTMLDivElement.prototype.animate = function (name, time) {
          var that;
          if (get.is.mobileMe(this) && name == 'target') {
            that = ui.mebg;
          }
          else {
            that = this;
          }
          that.classList.add(name);
          setTimeout(function () {
            that.classList.remove(name);
          }, time || 1000);
          return this;
        };
        /**
         * 隐藏本元素及其子元素
         * @function HTMLDivElement#hide
         * @returns {HTMLDivElement} this self
         */
        HTMLDivElement.prototype.hide = function () {
          this.classList.add('hidden');
          return this;
        };
        /**
         * 本元素取消焦点
         * @function HTMLDivElement#unfocus
         * @returns {HTMLDivElement} this self
         */
        HTMLDivElement.prototype.unfocus = function () {
          if (lib.config.transparent_dialog) this.classList.add('transparent');
          return this;
        };
        /**
         * 本元素重获焦点
         * @function HTMLDivElement#refocus
         * @returns {HTMLDivElement} this self
         */
        HTMLDivElement.prototype.refocus = function () {
          this.classList.remove('transparent');
          return this;
        };
        /**
         * 本元素取消隐藏
         * @function HTMLDivElement#show
         * @returns {HTMLDivElement} this self
         */
        HTMLDivElement.prototype.show = function () {
          this.classList.remove('hidden');
          return this;
        };
        /**
         * @callback HTMLDivElement~deleteCallback
         * @see {@link HTMLDivElement#delete}
         */
        /**
         * 延时从所属DOM树移除本元素
         * @function HTMLDivElement#delete
         * @param {number} time - 延迟时间（ms）
         * @param {HTMLDivElement~deleteCallback} callback - 移除后回调函数
         * @returns {HTMLDivElement} this self
         */
        HTMLDivElement.prototype.delete = function (time, callback) {
          if (this.timeout) {
            clearTimeout(this.timeout);
            delete this.timeout;
          }
          if (!this._listeningEnd || this._transitionEnded) {
            if (typeof time != 'number') time = 500;
            this.classList.add('removing');
            var that = this;
            this.timeout = setTimeout(function () {
              that.remove();
              that.classList.remove('removing');
              if (typeof callback == 'function') {
                callback();
              }
            }, time);
          }
          else {
            this._onEndDelete = true;
          }
          return this;
        };
        /**
         * 移动本元素(牌)
         * @function HTMLDivElement#goto
         * @param {*} position - 位置
         * @param {number} time - 持续时间
         * @returns {HTMLDivElement} this self
         */
        HTMLDivElement.prototype.goto = function (position, time) {
          if (this.timeout) {
            clearTimeout(this.timeout);
            delete this.timeout;
          }

          if (typeof time != 'number') time = 500;
          this.classList.add('removing');

          var that = this;
          this.timeout = setTimeout(function () {
            if (!that.destroyed) {
              position.appendChild(that);
            }
            that.classList.remove('removing');
            delete that.destiny;
          }, time);
          this.destiny = position;
          return this;
        };
        /**
         * 强制取消移动，固定在当前位置
         * @function HTMLDivElement#fix
         * @returns {HTMLDivElement} this self
         */
        HTMLDivElement.prototype.fix = function () {
          clearTimeout(this.timeout);
          delete this.timeout;
          delete this.destiny;
          this.classList.remove('removing');
          return this;
        };
        /**
         * 设置背景图片，当name为虚值或为空白字符串时，使用原背景。
         * 对应路径：`image/${type?type+'/':''}${type?subfolder+'/':''}${name}${ext}`
         * @function HTMLDivElement#setBackground
         * @param {string} [name] - 图片名（无后缀）
         * @param {string} [type] - 类型对应路径
         * @param {string} [ext='.jpg'] - 图片后缀
         * @param {string} [subfolder='default'] - 类型文件夹下的子路径，仅在参数`type`指定值时有效
         * @returns {?HTMLDivElement} this self
         */
        HTMLDivElement.prototype.setBackground = function (name, type, ext, subfolder) {
          if (!name) return;
          var src;
          if (ext == 'noskin') {
            ext = '.jpg';
          }
          ext = ext || '.jpg';
          subfolder = subfolder || 'default'
          if (type) {
            var dbimage = null, extimage = null, modeimage = null;
            var nameinfo;
            var gzbool = false;
            var mode = get.mode();
            if (type == 'character') {
              if (lib.characterPack['mode_' + mode] && lib.characterPack['mode_' + mode][name]) {
                if (mode == 'guozhan') {
                  nameinfo = lib.character[name];
                  if (name.indexOf('gz_shibing') == 0) {
                    name = name.slice(3, 11);
                  }
                  else {
                    if (lib.config.mode_config.guozhan.guozhanSkin && lib.character[name] && lib.character[name][4].contains('gzskin')) gzbool = true;
                    name = name.slice(3);
                  }
                }
                else {
                  modeimage = mode;
                }
              }
              else if (lib.character[name]) {
                nameinfo = lib.character[name];
              }
              else if (name.indexOf('::') != -1) {
                name = name.split('::');
                modeimage = name[0];
                name = name[1];
              }
            }
            if (!modeimage && nameinfo && nameinfo[4]) {
              for (var i = 0; i < nameinfo[4].length; i++) {
                if (nameinfo[4][i].indexOf('ext:') == 0) {
                  extimage = nameinfo[4][i]; break;
                }
                else if (nameinfo[4][i].indexOf('db:') == 0) {
                  dbimage = nameinfo[4][i]; break;
                }
                else if (nameinfo[4][i].indexOf('mode:') == 0) {
                  modeimage = nameinfo[4][i].slice(5); break;
                }
                else if (nameinfo[4][i].indexOf('character:') == 0) {
                  name = nameinfo[4][i].slice(10); break;
                }
              }
            }
            if (extimage) {
              src = extimage.replace(/ext:/, 'extension/');
            }
            else if (dbimage) {
              this.setBackgroundDB(dbimage.slice(3));
              return this;
            }
            else if (modeimage) {
              src = 'image/mode/' + modeimage + '/character/' + name + ext;
            }
            else if (type == 'character' && lib.config.skin[name] && arguments[2] != 'noskin') {
              src = 'image/skin/' + name + '/' + lib.config.skin[name] + ext;
            }
            else {
              if (type == 'character') {
                src = 'image/character/' + (gzbool ? 'gz_' : '') + name + ext;
              }
              else {
                src = 'image/' + type + '/' + subfolder + '/' + name + ext;
              }
            }
          }
          else {
            src = 'image/' + name + ext;
          }
          this.setBackgroundImage(src, type === 'character' ? 'true' : null);
          this.style.backgroundSize = "cover";
          return this;
        };
        /**
         * 设置本元素的背景图片为数据库中的图片
         * @function HTMLDivElement#setBackgroundDB
         * @param {string} img - 图片对应的键值
         */
        HTMLDivElement.prototype.setBackgroundDB = function (img) {
          var node = this;
          game.getDB('image', img, function (src) {
            node.style.backgroundImage = `url('${src}')`;
            node.style.backgroundSize = "cover";
          });
        };
        /**
         * 设置本元素的背景图片
         * @function HTMLDivElement#setBackgroundImage
         * @param {string} img - 图片相对{@link lib.assetURL|assertURL}路径
         * @param {boolean} loading - 是否显示加载中图片
         */
        HTMLDivElement.prototype.setBackgroundImage = function (img, loading) {
          this.style.backgroundImage = `url("${lib.assetURL}${img}")${loading ? `,url("${lib.assetURL}image/loading.gif")` : ``}`;
        },
          /**
           * {@link HTMLDivElement#listen|listen}（click）的回调函数
           * @callback HTMLDivElement#listen~listenCallback
           * @param {(MouseEvent|TouchEvent)} e - 触发事件
           */
          /**
           * 监听点击事件
           * @function HTMLDivElement#listen
           * @param {HTMLDivElement#listen~listenCallback} func - 点击回调函数
           * @returns {HTMLDivElement} this self
           */
          HTMLDivElement.prototype.listen = function (func) {
            if (lib.config.touchscreen) {
              this.addEventListener('touchend', function (e) {
                if (!_status.dragged) {
                  func.call(this, e);
                }
              });
              var fallback = function (e) {
                if (!_status.touchconfirmed) {
                  func.call(this, e);
                }
                else {
                  this.removeEventListener('click', fallback);
                }
              }
              this.addEventListener('click', fallback);
            }
            else {
              this.addEventListener('click', func);
            }
            return this;
          };
        /**
         * @callback HTMLDivElement#listenTransition~callback
         * @see {@link HTMLDivElement#listenTransition}
         */
        /**
         * 延时触发回调函数，同时监听本元素变换动画，如果变换结束则立即触发回调函数
         * @function HTMLDivElement#listenTransition
         * @param {HTMLDivElement#listenTransition~callback} func - 回调函数
         * @param {number} [time=1000] - 延迟时间
         * @returns {!number} timeoutID 
         */
        HTMLDivElement.prototype.listenTransition = function (func, time) {
          var that = this;
          var done = false;
          var callback = function () {
            if (!done) {
              func.call(that);
              done = true;
            }
          };
          this.addEventListener('webkitTransitionEnd', callback);
          return setTimeout(callback, time || 1000);
        };
        /**
         * 设置本元素位置
         * ```JavaScript
         * top = calc(`offsets[0]`%+`offsets[1]`px)
         * left = calc(`offsets[2]`%+`offsets[3]`px)
         * ```
         * @function HTMLDivElement#setPosition
         * @param {!number[]} offsets - 偏移量数组（长度必须为4）。
         * @returns {HTMLDivElement} this self
         */
        /**
         * 设置本元素位置
         * ```JavaScript
         * top  = calc(`top_pc`%+`top_px`px)
         * left = calc(`lft_pc`%+`lft_px`px)
         * ```
         * @function HTMLDivElement#setPosition
         * @variation 2
         * @param {number} top_pc
         * @param {number} top_px
         * @param {number} lft_pc
         * @param {number} lft_px
         * @returns {HTMLDivElement} this self
         */
        HTMLDivElement.prototype.setPosition = function () {
          var position;
          if (arguments.length == 4) {
            position = [];
            for (var i = 0; i < arguments.length; i++) position.push(arguments[i]);
          }
          else if (arguments.length == 1 && Array.isArray(arguments[0]) && arguments[0].length == 4) {
            position = arguments[0];
          }
          else {
            return this;
          }
          var top = 'calc(' + position[0] + '% ';
          if (position[1] > 0) top += '+ ' + position[1] + 'px)';
          else top += '- ' + Math.abs(position[1]) + 'px)';
          var left = 'calc(' + position[2] + '% ';
          if (position[3] > 0) left += '+ ' + position[3] + 'px)';
          else left += '- ' + Math.abs(position[3]) + 'px)';
          this.style.top = top;
          this.style.left = left;
          return this;
        };
        /**
         * 设置本元素css样式
         * @function HTMLDivElement#css
         * @param {Object} style - style
         * @param {string} [style.innerHTML] - 设置本元素内部HTML
         * @param {string[]} [style.cssProperty] - 设置任意数量的css属性。{@link https://developer.mozilla.org/en-US/docs/Web/CSS/Reference|cssProperty}
         * @returns {HTMLDivElement} this self
         */
        HTMLDivElement.prototype.css = function (style) {
          for (var i in style) {
            if (i == 'innerHTML') {
              this.innerHTML = style[i];
            }
            else {
              this.style[i] = style[i];
            }
          }
          return this;
        };
        /**
         * 获取Table[row][col]对应的元素
         * @deprecated <span style="color:red;">[never use]</span> 实现有问题
         * @function HTMLTableElement#get
         * @param {!number} row - 行元素数组索引
         * @param {!number} col - 列元素数组索引
         * @returns {HTMLTableCellElement} 要索引的标题/单元格元素
         */
        HTMLTableElement.prototype.get = function (row, col) {
          if (row < this.childNodes.length) {
            return this.childNodes[row].childNodes[col];
          }
        };
      }
      {
        //part: 拓展数组
        /**
         * 统计数组中元素`item`出现的数量
         * @function Array#numOf
         * @param {*} item - 要统计的元素
         * @returns {!number} 统计结果（非负）
         */
        Array.prototype.numOf = function (item) {
          var num = 0;
          for (var i = 0; i < this.length; i++) {
            if (this[i] == item) num++;
          }
          return num;
        };
        //数组降维替代方案
        Array.prototype.vkflat = function (depth = 1) {
          const result = [];
          // 开始递归
          (function flat(arr, depth) {
            arr.forEach((item) => {
              if (Array.isArray(item) && depth > 0) {
                // 递归数组
                flat(item, depth - 1)
              } else {
                result.push(item)
              }
            })
          })(this, depth)
          return result;
        };
        /**
         * 创建一个新的数组（浅复制），包含原数组中匹配卡牌位置的卡牌对象
         * @function Array#filterInD
         * @param {CardPosition[]} [pos='o'] - 卡牌位置字符串，匹配其中任意位置
         * @returns {!Array} 新的数组，如果没有匹配位置的卡牌，返回空数组
         */
        Array.prototype.filterInD = function (pos) {
          if (!pos) pos = 'o';
          var list = [];
          for (var i = 0; i < this.length; i++) {
            if (pos.indexOf(get.position(this[i], true)) != -1) list.push(this[i]);
          }
          return list;
        };
        /**
         * 定位元素，等同于{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf|Array.prototype.indexOf()}
         * @function Array#find
         * @param {*} item - 要在数组中定位的元素
         * @returns {!number} 数组中元素的第一个索引；如果没有找到返回-1
         */
        Array.prototype.find = function (item) {
          return this.indexOf(item);
        };
        /**
         * 查找元素是否存在，等同于{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf|Array.prototype.indexOf(item)!=-1}
         * @function Array#contains
         * @param {any} item - 要在数组中查找的元素
         * @returns {boolean} 存在返回`true`，不存在返回`false`
         */
        Array.prototype.contains = function (item) {
          return this.indexOf(item) != -1;
        };
        /**
         * 向原数组不重复地添加任意数量的元素；但是不保证，添加前，原数组中的元素是否唯一
         * @function Array#add
         * @param {...any} elements - 要添加的任意数量的元素
         * @returns {Array} this self
         */
        Array.prototype.add = function () {
          for (var i = 0; i < arguments.length; i++) {
            if (this.contains(arguments[i])) {
              return false;
            }
            this.push(arguments[i]);
          }
          return this;
        };
        /**
         * 将数组中的元素不重复地添加（{@link Array#add}）到原数组中
         * @deprecated [since ES 2015] 使用ES2015 Spread语法（详见{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax|Spread syntax}）
         * @function Array#addArray
         * @param {!Array} arr - 要添加的数组
         * @returns {Array} this self
         */
        Array.prototype.addArray = function (arr) {
          for (var i = 0; i < arr.length; i++) {
            this.add(arr[i]);
          }
          return this;
        };
        /**
         * 删除元素，如果原数组中可以找到要删除的元素，就会移除该元素；如果原数组有多个元素与要删除的元素等值（==），仅删除第一个
         * <ul>
         *   <li>注意，该函数要删除的元素不能是数组类型，因为数组类型会被当做要删除元素组成的数组</li>
         * </ul>
         * @function Array#remove
         * @deprecated [performance warning] 该函数内部通过迭代删除每个元素，每多一个要删除的元素，就会多一次迭代
         * @param {(*|Array)} item - 要删除的元素；要删除元素的（一维|二维|多维）数组
         * @returns {?Array} this self；如果`item`是数组，返回undefined
         */
        Array.prototype.remove = function (item) {
          if (Array.isArray(item)) {
            for (var i = 0; i < item.length; i++) this.remove(item[i]);
            return;
          }
          var pos = this.find(item);
          if (pos == -1) {
            return false;
          }
          this.splice(pos, 1);
          return this;
        };
        /**
         * 删除元素，如果原数组中可以找到要删除的元素，就会移除该元素；如果原数组有多个元素与要删除的元素等值（==），仅删除第一个
         * <ul>
         *   <li>注意，该函数要删除的元素不能是数组类型，因为数组类型会被当做要删除元素组成的数组</li>
         *   <li>对`arr`中的每个元素会调用{@link Array#remove|Array.prototype.remove}</li>
         * </ul>
         * @function Array#removeArray
         * @deprecated [performance warning] {@link Array#remove}
         * @param {!Array} arr - 要删除元素的数组
         * @returns {Array} this self
         */
        Array.prototype.removeArray = function (arr) {
          for (var i = 0; i < arr.length; i++) {
            this.remove(arr[i]);
          }
          return this;
        };
        /**
         * 从原数组中随机取出一个元素
         * @function Array#randomGet
         * @param {...any} elements - 任意元素，不包含在随机选择的元素中；实质对`elements`中的每个元素调用了{@link Array#remove|Array.prototype.remove}
         * @returns {any} 取出的元素
         */
        Array.prototype.randomGet = function () {
          var arr = this.slice(0);
          for (var i = 0; i < arguments.length; i++) arr.remove(arguments[i]);
          return arr[Math.floor(Math.random() * arr.length)];
        };
        /**
         * 返回一个新的数组，随机删除指定数量的元素
         * @function Array#randomRemove
         * @deprecated [performance warning] 该函数内部通过迭代删除每个元素，每多一个要删除的元素，就会多一次迭代
         * @param {number} [num=undefined] - 要删除的元素数量；默认移除一个
         * @returns {(Array|any)} 被删除元素的数组；当无参调用该函数时，返回被删除的元素而非数组
         */
        Array.prototype.randomRemove = function (num) {
          if (typeof num == 'number') {
            var list = [];
            for (var i = 0; i < num; i++) {
              if (this.length) {
                list.push(this.randomRemove());
              }
              else {
                break;
              }
            }
            return list;
          }
          else {
            return this.splice(Math.floor(Math.random() * this.length), 1)[0];
          }
        };
        /**
         * 对原数组随机排序
         * @function Array#randomSort
         * @returns {Array} this self
         */
        Array.prototype.randomSort = function () {
          var list = [];
          while (this.length) {
            list.push(this.randomRemove());
          }
          for (var i = 0; i < list.length; i++) {
            this.push(list[i]);
          }
          return this;
        };
        /**
         * 从原数组中随机取出指定数量的元素
         * @function Array#randomGet
         * @param {...any} elements - 任意元素，不包含在随机选择的元素中；实质对`elements`中的每个元素调用了{@link Array#remove|Array.prototype.remove}
         * @returns {!Array<any>} 随机取出的元素数组
         */
        Array.prototype.randomGets = function (num) {
          if (num > this.length) {
            num = this.length;
          }
          var arr = this.slice(0);
          var list = [];
          for (var i = 0; i < num; i++) {
            list.push(arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
          }
          return list;
        };
        /**
         * 角色数组排序；以给定角色/当前事件角色为参考，对角色数组排序。- TODO
         * @function Array#sortBySeat
         * @param {GameCores.GameObjects.Player} target 给定的参考角色
         * @returns {Array} this self
         */
        Array.prototype.sortBySeat = function (target) {
          lib.tempSortSeat = target;
          this.sort(lib.sort.seat);
          delete lib.tempSortSeat;
          return this;
        };
        if (!Array.from) {
          /**
           * 由参数数组生成新的数组（浅复制）
           * @function Array#from
           * @param {...any} args - 参数数组
           * @returns {!Array} 生成的数组；如果`args`为虚值或为空则返回空数组
           */
          Array.from = function (args) {
            var list = [];
            if (args && args.length) {
              for (var i = 0; i < args.length; i++) {
                list.push(args[i]);
              }
            }
            return list;
          }
        }
      }
      {
        //part: 设置全局window.onkeydown, window.onload, window.onerror，直到关闭网页（退出游戏）
        /**
         * 监听键盘按下事件
         * @function
         * @global
         * @param {KeyboardEvent} e - 键盘事件
         * @listens KeyboardEvent
         */
        window.onkeydown = function (e) {
          if (!ui.menuContainer || !ui.menuContainer.classList.contains('hidden')) {
            if (e.keyCode == 116 || ((e.ctrlKey || e.metaKey) && e.keyCode == 82)) {
              if (e.shiftKey) {
                if (confirm('是否重置游戏？')) {
                  var noname_inited = localStorage.getItem('noname_inited');
                  var onlineKey = localStorage.getItem(lib.configprefix + 'key');
                  localStorage.clear();
                  if (noname_inited) {
                    localStorage.setItem('noname_inited', noname_inited);
                  }
                  if (onlineKey) {
                    localStorage.setItem(lib.configprefix + 'key', onlineKey);
                  }
                  if (indexedDB) indexedDB.deleteDatabase(lib.configprefix + 'data');
                  game.reload();
                  return;
                }
              }
              else {
                game.reload();
              }
            }
            else if (e.keyCode == 83 && (e.ctrlKey || e.metaKey)) {
              if (window.saveNonameInput) {
                window.saveNonameInput();
              }
              e.preventDefault();
              e.stopPropagation();
              return false;
            }
            else if (e.keyCode == 74 && (e.ctrlKey || e.metaKey) && lib.node) {
              lib.node.debug();
            }
          }
          else {
            game.closePopped();
            var dialogs = document.querySelectorAll('#window>.dialog.popped:not(.static)');
            for (var i = 0; i < dialogs.length; i++) {
              dialogs[i].delete();
            }
            if (e.keyCode == 32) {
              var node = ui.window.querySelector('pausedbg');
              if (node) {
                node.click();
              }
              else {
                ui.click.pause();
              }
            }
            else if (e.keyCode == 65) {
              if (ui.auto) ui.auto.click();
            }
            else if (e.keyCode == 87) {
              if (ui.wuxie && ui.wuxie.style.display != 'none') {
                ui.wuxie.classList.toggle('glow')
              }
              else if (ui.tempnowuxie) {
                ui.tempnowuxie.classList.toggle('glow')
              }
            }
            else if (e.keyCode == 116 || ((e.ctrlKey || e.metaKey) && e.keyCode == 82)) {
              if (e.shiftKey) {
                if (confirm('是否重置游戏？')) {
                  var noname_inited = localStorage.getItem('noname_inited');
                  var onlineKey = localStorage.getItem(lib.configprefix + 'key');
                  localStorage.clear();
                  if (noname_inited) {
                    localStorage.setItem('noname_inited', noname_inited);
                  }
                  if (onlineKey) {
                    localStorage.setItem(lib.configprefix + 'key', onlineKey);
                  }
                  if (indexedDB) indexedDB.deleteDatabase(lib.configprefix + 'data');
                  game.reload();
                  return;
                }
              }
              else {
                game.reload();
              }
            }
            else if (e.keyCode == 83 && (e.ctrlKey || e.metaKey)) {
              e.preventDefault();
              e.stopPropagation();
              return false;
            }
            else if (e.keyCode == 74 && (e.ctrlKey || e.metaKey) && lib.node) {
              lib.node.debug();
            }
            // else if(e.keyCode==27){
            //     if(!ui.arena.classList.contains('paused')) ui.click.config();
            // }
          }
        };
        /**
         * window加载结束时调用
         * @function
         * @global
         */
        window.onload = function () {
          if (lib.device) {
            var script = document.createElement('script');
            script.src = 'cordova.js';
            document.body.appendChild(script);
            document.addEventListener('deviceready', function () {
              if (init.cordovaReady) {
                init.cordovaReady();
                delete init.cordovaReady;
              }
            });
          }
          if (_status.packLoaded) {
            delete _status.packLoaded;
            init.onload();
          }
          else {
            /**
             * 当onload调用先于包的加载时，标志onload已经运行完毕，直至包全部加载完毕则删除该标志
             * @private
             * @default
             */
            _status.windowLoaded = true;
          }
        };
        /**
         * 触发错误时调用
         * @function
         * @global
         * @param {string} msg - 错误信息
         * @param {string} src - 引发错误的脚本URL
         * @param {string} line - 引发错误的行号
         * @param {string} column - 发生错误的行的列号
         * @param {Error} err - 错误对象
         */
        window.onerror = function (msg, src, line, column, err) {
          var str = msg;
          if (window._status && _status.event) {
            var evt = _status.event;
            str += ('\n' + evt.name + ': ' + evt.step);
            if (evt.parent) str += '\n' + evt.parent.name + ': ' + evt.parent.step;
            if (evt.parent && evt.parent.parent) str += '\n' + evt.parent.parent.name + ': ' + evt.parent.parent.step;
            if (evt.player || evt.target || evt.source || evt.skill || evt.card) {
              str += '\n-------------'
            }
            if (evt.player) {
              str += '\nplayer: ' + evt.player.name;
            }
            if (evt.target) {
              str += '\ntarget: ' + evt.target.name;
            }
            if (evt.source) {
              str += '\nsource: ' + evt.source.name;
            }
            if (evt.skill) {
              str += '\nskill: ' + evt.skill.name;
            }
            if (evt.card) {
              str += '\ncard: ' + evt.card.name;
            }
          }
          str += '\n-------------';
          str += '\n' + line;
          str += '\n' + column;
          if (err && err.stack) str += '\n' + decodeURI(err.stack);
          alert(str);
          window.ea = Array.from(arguments);
          window.em = msg;
          window.el = line;
          window.ec = column;
          window.eo = err;
          game.print(msg);
          game.print(line);
          game.print(column);
          game.print(decodeURI(err.stack));
          if (!lib.config.errstop) {
            _status.withError = true;
            game.loop();
          }
        };
      }
      //part: 更新内容，window.nogame_update，创建于config.js
      if (window.noname_update) {
        lib.version = window.noname_update.version;
        lib.changeLog = window.noname_update.changeLog;
        if (window.noname_update.players) {
          lib.changeLog.push('players://' + JSON.stringify(window.noname_update.players));
        }
        if (window.noname_update.cards) {
          lib.changeLog.push('cards://' + JSON.stringify(window.noname_update.cards));
        }
        delete window.noname_update;
      }
      //part: 如果是移动端，设置移动设备信息lib.device, 资源根路径lib.assetURL
      var noname_inited = localStorage.getItem('noname_inited');
      if (noname_inited && noname_inited !== 'nodejs') {
        var ua = navigator.userAgent.toLowerCase();
        if (ua.indexOf('android') != -1) {
          lib.device = 'android';
        }
        else if (ua.indexOf('iphone') != -1 || ua.indexOf('ipad') != -1) {
          lib.device = 'ios';
        }
        lib.assetURL = noname_inited;
      }
      //part: flag变量，标志`ui.css`是否加载完成，完成时设置为true；如果其他UI和config数据加载完成时`ui.css`未加载完毕，寄存config数据于`config3`，并在css加载完成时调用
      var config3 = null;
      var proceed = function (config2) {
        //[recommend] 移到`init`函数结尾更好，`proceed`函数更整洁
        if (config3 === null) {
          config3 = config2;
          return;
        }
        //part: 如果`config2.mode`存在，则直接进入游戏的`config2.mode`；模式初始化`lib.config.mode_config`
        if (config2.mode) lib.config.mode = config2.mode;
        if (lib.config.mode_config[lib.config.mode] == undefined) lib.config.mode_config[lib.config.mode] = {};
        for (let i in lib.config.mode_config.global) {
          if (lib.config.mode_config[lib.config.mode][i] == undefined) {
            lib.config.mode_config[lib.config.mode][i] = lib.config.mode_config.global[i];
          }
        }
        //part: defaultcharacters
        if (lib.config.characters) {
          lib.config.defaultcharacters = lib.config.characters.slice(0);
        }
        //part: defaultcards
        if (lib.config.cards) {
          lib.config.defaultcards = lib.config.cards.slice(0);
        }
        //part: 从`config2`加载`lib.config`和`_mode_config`的数据
        for (let i in config2) {
          if (i.indexOf('_mode_config') != -1) {
            var thismode = i.substr(i.indexOf('_mode_config') + 13);
            if (!lib.config.mode_config[thismode]) {
              lib.config.mode_config[thismode] = {};
            }
            lib.config.mode_config[thismode][i.substr(0, i.indexOf('_mode_config'))] = config2[i];
          }
          else {
            lib.config[i] = config2[i];
          }
        }
        //part: 从`lib.config.translate`拷贝到`lib.translate`
        for (let i in lib.config.translate) {
          lib.translate[i] = lib.config.translate[i];
        }

        lib.config.all.characters = [];
        lib.config.all.cards = [];
        lib.config.all.plays = [];
        lib.config.all.mode = [];
        //part: 如果测试模式已开启，重置资源列表
        if (lib.config.debug) {
          init.js(lib.assetURL + 'game', 'asset', function () {
            lib.skin = window.vk_skin_list;
            delete window.vk_skin_list;
            delete window.vk_asset_list;
          });
        }

        if (window.isNonameServer) {
          lib.config.mode = 'connect';
        }
        //part: `window.vk_package`，创建于package.js
        var pack = window.vk_package;
        delete window.vk_package;
        if (lib.init_pack) {
          lib.init_pack(pack)
        }
        for (let i in pack.character) {
          if (lib.config.hiddenCharacterPack.indexOf(i) == -1) {
            lib.config.all.characters.push(i);
            lib.translate[i + '_character_config'] = pack.character[i];
          }
        }
        for (let i in pack.card) {
          if (lib.config.hiddenCardPack.indexOf(i) == -1) {
            lib.config.all.cards.push(i);
            lib.translate[i + '_card_config'] = pack.card[i];
          }
        }
        for (let i in pack.play) {
          lib.config.all.plays.push(i);
          lib.translate[i + '_play_config'] = pack.play[i];
        }
        for (let i in pack.submode) {
          for (let j in pack.submode[i]) {
            lib.translate[i + '|' + j] = pack.submode[i][j];
          }
        }

        if (!lib.config.gameRecord) {
          lib.config.gameRecord = {};
        }
        for (let i in pack.mode) {
          if (lib.config.hiddenModePack.indexOf(i) == -1) {
            lib.config.all.mode.push(i);
            lib.translate[i] = pack.mode[i];
            if (!lib.config.gameRecord[i]) {
              lib.config.gameRecord[i] = { data: {} };
            }
          }
        }
        //??
        if (lib.config.all.mode.length == 0) {
          lib.config.all.mode.push('identity');
          lib.translate.identity = '身份';
          if (!lib.config.gameRecord.identity) {
            lib.config.gameRecord.identity = { data: {} };
          }
        }
        {
          if (pack.background) {
            for (let i in pack.background) {
              if (lib.config.hiddenBackgroundPack.contains(i)) continue;
              lib.configMenu.appearence.config.image_background.item[i] = pack.background[i];
            }
            for (let i = 0; i < lib.config.customBackgroundPack.length; i++) {
              var link = lib.config.customBackgroundPack[i];
              lib.configMenu.appearence.config.image_background.item[link] = link.slice(link.indexOf('_') + 1);
            }
            lib.configMenu.appearence.config.image_background.item.default = '默认';
          }
          if (pack.music) {
            if (lib.device || typeof window.require == 'function') {
              lib.configMenu.audio.config.background_music.item.music_custom = '自定义音乐';
            }
            lib.config.all.background_music = ['music_danji'];
            for (let i in pack.music) {
              lib.config.all.background_music.push(i);
              lib.configMenu.audio.config.background_music.item[i] = pack.music[i];
            }
            if (lib.config.customBackgroundMusic) {
              for (let i in lib.config.customBackgroundMusic) {
                lib.config.all.background_music.push(i);
                lib.configMenu.audio.config.background_music.item[i] = lib.config.customBackgroundMusic[i];
              }
            }
            lib.configMenu.audio.config.background_music.item.music_random = '随机播放';
            lib.configMenu.audio.config.background_music.item.music_off = '关闭';
          }
          if (pack.theme) {
            for (let i in pack.theme) {
              lib.configMenu.appearence.config.theme.item[i] = pack.theme[i];
            }
          }
          if (lib.config.extension_sources) {
            for (let i in lib.config.extension_sources) {
              lib.configMenu.general.config.extension_source.item[i] = i;
            }
          }

          if (pack.font) {
            ui.css.fontsheet = init.sheet();
            for (let i in pack.font) {
              lib.configMenu.appearence.config.name_font.item[i] = pack.font[i];
              lib.configMenu.appearence.config.identity_font.item[i] = pack.font[i];
              lib.configMenu.appearence.config.cardtext_font.item[i] = pack.font[i];
              lib.configMenu.appearence.config.global_font.item[i] = pack.font[i];
              ui.css.fontsheet.sheet.insertRule(`@font-face {font-family: '${i}';src: url('${lib.assetURL}font/${i}.ttf');}`, 0);
            }
            lib.configMenu.appearence.config.cardtext_font.item.default = '默认';
            lib.configMenu.appearence.config.global_font.item.default = '默认';
          }
        }
        //part: touch, layout, scroll config
        var ua = navigator.userAgent.toLowerCase();
        if ('ontouchstart' in document) {
          //移动端
          if (!lib.config.totouched) {
            game.saveConfig('totouched', true);
            if (lib.device) {
              //移动端通过客户端访问
              game.saveConfig('low_performance', true);
              game.saveConfig('confirm_exit', true);
              game.saveConfig('touchscreen', true);
              game.saveConfig('fold_mode', false);
              if (ua.indexOf('ipad') == -1) {
                game.saveConfig('phonelayout', true);
              }
              else if (lib.device == 'ios') {
                game.saveConfig('show_statusbar_ios', 'overlay');
              }
            }
            else if (confirm('是否切换到触屏模式？（触屏模式可提高触屏设备的响应速度，但无法使用鼠标）')) {
              //移动端通过网页访问
              game.saveConfig('touchscreen', true);
              if (ua.indexOf('iphone') != -1 || ua.indexOf('android') != -1) {
                game.saveConfig('phonelayout', true);
              }

              game.reload();
            }
          }
        }
        else if (lib.config.touchscreen) {//非移动端，如果触屏模式开启，就设置关闭
          game.saveConfig('touchscreen', false);
        }

        if (!lib.config.toscrolled && ua.indexOf('macintosh') != -1) {
          game.saveConfig('toscrolled', true);
          game.saveConfig('mousewheel', false);
        }
        //part: 是否打开开始界面
        var show_splash = lib.config.show_splash;
        if (show_splash == 'off') {
          show_splash = false;
        }
        else if (show_splash == 'init') {
          if (localStorage.getItem('show_splash_off')) {
            show_splash = false;
          }
        }
        localStorage.removeItem('show_splash_off');
        //part: extension list
        //??
        //[never executed]
        var extensionlist = [];
        if (!localStorage.getItem(lib.configprefix + 'disable_extension')) {
          if (lib.config.extensions && lib.config.extensions.length) {
            window.resetExtension = function () {
              for (let i = 0; i < lib.config.extensions.length; i++) {
                game.saveConfig('extension_' + lib.config.extensions[i] + '_enable', false);
              }
              localStorage.setItem(lib.configprefix + 'disable_extension', true);
            }
          }
          for (let i = 0; i < lib.config.plays.length; i++) {
            if (lib.config.all.plays.indexOf(lib.config.plays[i]) != -1) {
              extensionlist.push(lib.config.plays[i]);
            }
          }
          for (let i = 0; i < lib.config.extensions.length; i++) {
            var extcontent = localStorage.getItem(lib.configprefix + 'extension_' + lib.config.extensions[i]);
            if (extcontent) {
              _status.evaluatingExtension = true;
              try {
                eval(extcontent);
              }
              catch (e) {
                console.log(e);
              }
              _status.evaluatingExtension = false;
            }
            else if (lib.config.mode != 'connect' || (!localStorage.getItem(lib.configprefix + 'directstart') && show_splash)) {
              extensionlist.push(lib.config.extensions[i]);
            }
          }
        }
        else {
          if (lib.config.mode != 'connect' || (!localStorage.getItem(lib.configprefix + 'directstart') && show_splash)) {
            for (let i = 0; i < lib.config.extensions.length; i++) {
              game.import('extension', { name: lib.config.extensions[i] });
            }
          }
        }
        //用于加载包的函数
        let loadPack = function () {
          let toLoad = 2;
          let packLoaded = function () {
            toLoad--;
            if (toLoad == 0) {
              if (_status.windowLoaded) {
                delete _status.windowLoaded;
                init.onload();
              }
              else {
                /**
                 * 当包加载完毕先于window.onload时，标志包已经加载完毕，直至onload加载完毕则删除该标志
                 * @private
                 * @default
                 */
                _status.packLoaded = true;
              }
            }
          };
          if (localStorage.getItem(lib.configprefix + 'playback')
            || ((localStorage.getItem(lib.configprefix + 'directstart') || !show_splash) &&
              lib.config.all.mode.indexOf(lib.config.mode) != -1)) {
            toLoad++;
            init.js(dist(), 'mode', packLoaded, packLoaded);
          }
          init.js(dist(), ['card', 'character'], packLoaded, packLoaded);
        };
        //part: 检查layout并设置`game.layout = layout`
        let layout = lib.config.layout;
        if (lib.layoutfixed.indexOf(lib.config.mode) !== -1) {
          layout = 'mobile';
        }
        if (layout == 'phone') {
          layout = 'mobile';
          game.saveConfig('layout', 'mobile');
          game.saveConfig('phonelayout', true);
        }
        game.layout = layout;
        //part: 随机选取背景或选择_status.htmlbg作为背景图像
        if (lib.config.image_background_random) {
          if (_status.htmlbg) {
            game.saveConfig('image_background', _status.htmlbg);
          }
          else {
            console.log(lib.configMenu.appearence.config.image_background.item)
            let list = [];
            for (let i in lib.configMenu.appearence.config.image_background.item) {
              if (i == 'default') continue;
              list.push(i);
            }
            game.saveConfig('image_background', list.randomGet(lib.config.image_background));
          }
          init.background();
        }
        delete _status.htmlbg;
        //part: game to window.game
        window.game = game;
        //part: 加载js(卡牌, 角色, 模式拓展等)以及css(UI布局, 样式)
        let styleToLoad = 6;
        let styleLoaded = function () {
          styleToLoad--;
          if (styleToLoad == 0) {
            if (extensionlist.length && (lib.config.mode != 'connect' || show_splash)) {
              let extToLoad = extensionlist.length;
              let extLoaded = function () {
                extToLoad--;
                if (extToLoad == 0) {
                  loadPack();
                }
              }
              for (let i = 0; i < extensionlist.length; i++) {
                init.js(lib.assetURL + 'extension/' + extensionlist[i], 'extension', extLoaded, (function (i) {
                  return function () {
                    game.removeExtension(i);
                    extToLoad--;
                    if (extToLoad == 0) {
                      loadPack();
                    }
                  }
                }(extensionlist[i])));
              }
            }
            else {
              loadPack();
            }
          }
        };
        //css.layout
        if (lib.config.layout != 'default') {
          ui.css.layout = init.css(lib.assetURL + 'layout/' + layout, 'layout', styleLoaded);
        }
        else {
          ui.css.layout = init.css();
          styleToLoad--;
        }
        //css.phone
        if (get.is.phoneLayout()) {
          ui.css.phone = init.css(lib.assetURL + 'layout/default', 'phone', styleLoaded);
        }
        else {
          ui.css.phone = init.css();
          styleToLoad--;
        }
        //css.theme
        ui.css.theme = init.css(lib.assetURL + 'theme/' + lib.config.theme, 'style', styleLoaded);
        //css.card_style
        ui.css.card_style = init.css(lib.assetURL + 'theme/style/card', lib.config.card_style, styleLoaded);
        //css_cardpack_style
        ui.css.cardback_style = init.css(lib.assetURL + 'theme/style/cardback', lib.config.cardback_style, styleLoaded);
        //css.hp_style
        ui.css.hp_style = init.css(lib.assetURL + 'theme/style/hp', lib.config.hp_style, styleLoaded);
        //part: 通过配置创建`<link>`, 设置角色牌的背景、边框、边饰、文本样式
        if (lib.config.player_style && lib.config.player_style != 'default' && lib.config.player_style != 'custom') {
          let str = '';
          switch (lib.config.player_style) {
            case 'wood': str = 'url("' + lib.assetURL + 'theme/woodden/wood.jpg")'; break;
            case 'music': str = 'linear-gradient(#4b4b4b, #464646)'; break;
            case 'simple': str = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4))'; break;
          }
          ui.css.player_stylesheet = init.sheet('#window .player{background-image:' + str + '}');
        }
        if (lib.config.border_style && lib.config.border_style != 'default' && lib.config.border_style != 'custom' && lib.config.border_style != 'auto') {
          ui.css.border_stylesheet = init.sheet();
          let bstyle = lib.config.border_style;
          if (bstyle.indexOf('dragon_') == 0) {
            bstyle = bstyle.slice(7);
          }
          ui.css.border_stylesheet.sheet.insertRule('#window .player>.framebg,#window #arena.long.mobile:not(.fewplayer) .player[data-position="0"]>.framebg{display:block;background-image:url("' + lib.assetURL + 'theme/style/player/' + bstyle + '1.png")}', 0);
          ui.css.border_stylesheet.sheet.insertRule('#window #arena.long:not(.fewplayer) .player>.framebg, #arena.oldlayout .player>.framebg{background-image:url("' + lib.assetURL + 'theme/style/player/' + bstyle + '3.png")}', 0);
          ui.css.border_stylesheet.sheet.insertRule('.player>.count{z-index: 3 !important;border-radius: 2px !important;text-align: center !important;}', 0);
        }
        if (lib.config.control_style && lib.config.control_style != 'default' && lib.config.control_style != 'custom') {
          let str = '';
          switch (lib.config.control_style) {
            case 'wood': str = 'url("' + lib.assetURL + 'theme/woodden/wood.jpg")'; break;
            case 'music': str = 'linear-gradient(#4b4b4b, #464646);color:white;text-shadow:black 0 0 2px'; break;
            case 'simple': str = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4));color:white;text-shadow:black 0 0 2px'; break;
          }
          if (lib.config.control_style == 'wood') {
            ui.css.control_stylesheet = init.sheet('#window .control,#window .menubutton,#window #system>div>div,#window #system>div>.pressdown2{background-image:' + str + '}');
          }
          else {
            ui.css.control_stylesheet = init.sheet('#window .control,.menubutton:not(.active):not(.highlight):not(.red):not(.blue),#window #system>div>div{background-image:' + str + '}');
          }
        }
        if (lib.config.menu_style && lib.config.menu_style != 'default' && lib.config.menu_style != 'custom') {
          let str = '';
          switch (lib.config.menu_style) {
            case 'wood': str = 'url("' + lib.assetURL + 'theme/woodden/wood2.png")'; break;
            case 'music': str = 'linear-gradient(#4b4b4b, #464646);color:white;text-shadow:black 0 0 2px'; break;
            case 'simple': str = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4));color:white;text-shadow:black 0 0 2px'; break;
          }
          ui.css.menu_stylesheet = init.sheet('html #window>.dialog.popped,html .menu,html .menubg{background-image:' + str + '}');
        }
        //part: ??
        lib.config.duration = 500;
        //part: add mouse/touch Evt listeners to document.
        if (!lib.config.touchscreen) {
          document.addEventListener('mousewheel', ui.click.windowmousewheel, { passive: true });
          document.addEventListener('mousemove', ui.click.windowmousemove);
          document.addEventListener('mousedown', ui.click.windowmousedown);
          document.addEventListener('mouseup', ui.click.windowmouseup);
          document.addEventListener('contextmenu', ui.click.right);
        }
        else {
          document.addEventListener('touchstart', ui.click.touchconfirm);
          document.addEventListener('touchstart', ui.click.windowtouchstart);
          document.addEventListener('touchend', ui.click.windowtouchend);
          document.addEventListener('touchmove', ui.click.windowtouchmove);
        }
      };
      var proceed2 = function () {
        if (config3) {
          proceed(config3);
        }
        else {
          config3 = true;
        }
      };
      __webpack_require__(2568)
      //part: 初始化ui.css.menu和ui.css.default样式
      ui.css = {
        menu: init.css(lib.assetURL + 'layout/default', 'menu', function () {
          ui.css.default = init.css(lib.assetURL + 'layout/default', 'layout');
          proceed2();
        })
      };
      //part: config for different type of devices(PC, mobile devices).
      if (lib.device) {
        //移动端，window加载完成时被调用
        init.cordovaReady = function () {
          if (lib.device == 'android') {
            document.addEventListener("pause", function () {
              if (!_status.paused2 && (typeof _status.event.isMine == 'function' && !_status.event.isMine())) {
                ui.click.pause();
              }
              if (ui.backgroundMusic) {
                ui.backgroundMusic.pause();
              }
            });
            document.addEventListener("resume", function () {
              if (ui.backgroundMusic) {
                ui.backgroundMusic.play();
              }
            });
            document.addEventListener("backbutton", function () {
              if (ui.arena && ui.arena.classList.contains('menupaused')) {
                if (window.saveNonameInput) {
                  window.saveNonameInput();
                }
                else {
                  ui.click.configMenu();
                }
              }
              else if (lib.config.confirm_exit) {
                navigator.notification.confirm(
                  '是否退出游戏？',
                  function (index) {
                    switch (index) {
                      case 2: game.saveConfig('null'); game.reload(); break;
                      case 3: navigator.app.exitApp(); break;
                    }
                  },
                  '确认退出',
                  ['取消', '重新开始', '退出']
                );
              }
              else {
                navigator.app.exitApp();
              }
            });
          }
          game.download = function (url, folder, onsuccess, onerror, dev, onprogress) {
            if (url.indexOf('http') != 0) {
              url = get.url(dev) + url;
            }
            var fileTransfer = new FileTransfer();
            folder = lib.assetURL + folder;
            if (onprogress) {
              fileTransfer.onprogress = function (progressEvent) {
                onprogress(progressEvent.loaded, progressEvent.total);
              };
            }
            lib.config.brokenFile.add(folder);
            game.saveConfigValue('brokenFile');
            fileTransfer.download(encodeURI(url), encodeURI(folder), function () {
              lib.config.brokenFile.remove(folder);
              game.saveConfigValue('brokenFile');
              if (onsuccess) {
                onsuccess();
              }
            }, onerror);
          };
          game.readFile = function (filename, callback, onerror) {
            window.resolveLocalFileSystemURL(lib.assetURL, function (entry) {
              entry.getFile(filename, {}, function (fileEntry) {
                fileEntry.file(function (fileToLoad) {
                  var fileReader = new FileReader();
                  fileReader.onload = function (e) {
                    callback(e.target.result);
                  };
                  fileReader.readAsArrayBuffer(fileToLoad);
                }, onerror);
              }, onerror);
            }, onerror);
          };
          game.writeFile = function (data, path, name, callback) {
            game.ensureDirectory(path, function () { });
            if (Object.prototype.toString.call(data) == '[object File]') {
              var fileReader = new FileReader();
              fileReader.onload = function (e) {
                game.writeFile(e.target.result, path, name, callback);
              };
              fileReader.readAsArrayBuffer(data);
            }
            else {
              window.resolveLocalFileSystemURL(lib.assetURL + path, function (entry) {
                entry.getFile(name, { create: true }, function (fileEntry) {
                  fileEntry.createWriter(function (fileWriter) {
                    fileWriter.onwriteend = callback;
                    fileWriter.write(data);
                  });
                });
              });
            }
          };
          game.removeFile = function (dir, callback) {
            window.resolveLocalFileSystemURL(lib.assetURL, function (entry) {
              entry.getFile(dir, {}, function (fileEntry) {
                fileEntry.remove();
                if (callback) {
                  callback();
                }
              });
            });
          };
          game.getFileList = function (dir, callback) {
            var files = [], folders = [];
            window.resolveLocalFileSystemURL(lib.assetURL + dir, function (entry) {
              var dirReader = entry.createReader();
              var entries = [];
              var readEntries = function () {
                dirReader.readEntries(function (results) {
                  if (!results.length) {
                    entries.sort();
                    for (var i = 0; i < entries.length; i++) {
                      if (entries[i].isDirectory) {
                        folders.push(entries[i].name);
                      }
                      else {
                        files.push(entries[i].name);
                      }
                    }
                    callback(folders, files);
                  }
                  else {
                    entries = entries.concat(Array.from(results));
                    readEntries();
                  }
                });
              };
              readEntries();
            });
          };
          game.ensureDirectory = function (list, callback, file) {
            var directorylist;
            var num = 0;
            if (file) {
              num = 1;
            }
            if (typeof list == 'string') {
              directorylist = [list];
            }
            else {
              var directorylist = list.slice(0);
            }
            window.resolveLocalFileSystemURL(lib.assetURL, function (rootEntry) {
              var access = function (entry, dir, callback) {
                if (dir.length <= num) {
                  callback();
                }
                else {
                  var str = dir.shift();
                  entry.getDirectory(str, { create: false }, function (entry) {
                    access(entry, dir, callback);
                  }, function () {
                    entry.getDirectory(str, { create: true }, function (entry) {
                      access(entry, dir, callback);
                    });
                  });
                }
              }
              var createDirectory = function () {
                if (directorylist.length) {
                  access(rootEntry, directorylist.shift().split('/'), createDirectory);
                }
                else {
                  callback();
                }
              };
              createDirectory();
            });
          }
          if (ui.updateUpdate) {
            ui.updateUpdate();
          }
          var showbar = function () {
            if (window.StatusBar) {
              if (lib.device == 'android') {
                if (lib.config.show_statusbar_android) {
                  window.StatusBar.overlaysWebView(false);
                  window.StatusBar.backgroundColorByName('black');
                  window.StatusBar.show();
                }
              }
              else if (lib.device == 'ios') {
                if (lib.config.show_statusbar_ios != 'off' && lib.config.show_statusbar_ios != 'auto') {
                  if (lib.config.show_statusbar_ios == 'default') {
                    window.StatusBar.overlaysWebView(false);
                  }
                  else {
                    window.StatusBar.overlaysWebView(true);
                  }
                  window.StatusBar.backgroundColorByName('black');
                  window.StatusBar.show();
                }
              }
            }
          }
          if (lib.arenaReady) {
            lib.arenaReady.push(showbar);
          }
          else {
            showbar();
          }
        }
      }
      else if (typeof window.require == 'function') {
        //part: PC端
        lib.node = {
          fs: __webpack_require__(7147),
          debug: function () {
            (__webpack_require__(6459).remote.getCurrentWindow)().toggleDevTools();
          }
        };
        game.download = function (url, folder, onsuccess, onerror, dev, onprogress) {
          if (url.indexOf('http') != 0) {
            url = get.url(dev) + url;
          }
          game.ensureDirectory(folder, function () {
            try {
              var file = lib.node.fs.createWriteStream(__dirname + '/' + folder);
            }
            catch (e) {
              onerror();
            }
            lib.config.brokenFile.add(folder);
            game.saveConfigValue('brokenFile');
            if (!lib.node.http) lib.node.http = __webpack_require__(3685);
            if (!lib.node.https) lib.node.https = __webpack_require__(5687);
            var opts = (__webpack_require__(7310).parse)(encodeURI(url));
            opts.headers = { 'User-Agent': 'AppleWebkit' };
            var request = (url.indexOf('https') == 0 ? lib.node.https : lib.node.http).get(opts, function (response) {
              var stream = response.pipe(file);
              stream.on('finish', function () {
                lib.config.brokenFile.remove(folder);
                game.saveConfigValue('brokenFile');
                if (onsuccess) {
                  onsuccess();
                }
              });
              stream.on('error', onerror);
              if (onprogress) {
                var streamInterval = setInterval(function () {
                  if (stream.closed) {
                    clearInterval(streamInterval);
                  }
                  else {
                    onprogress(stream.bytesWritten);
                  }
                }, 200);
              }
            });
          }, true);
        };
        game.readFile = function (filename, callback, onerror) {
          lib.node.fs.readFile(__dirname + '/' + filename, function (err, data) {
            if (err) {
              onerror(err);
            }
            else {
              callback(data);
            }
          });
        };
        game.writeFile = function (data, path, name, callback) {
          game.ensureDirectory(path, function () { });
          if (Object.prototype.toString.call(data) == '[object File]') {
            var fileReader = new FileReader();
            fileReader.onload = function (e) {
              game.writeFile(e.target.result, path, name, callback);
            };
            fileReader.readAsArrayBuffer(data);
          }
          else {
            get.zip(function (zip) {
              zip.file('i', data);
              lib.node.fs.writeFile(__dirname + '/' + path + '/' + name, zip.files.i.asNodeBuffer(), null, callback);
            });
          }
        };
        game.removeFile = function (filename, callback) {
          lib.node.fs.unlink(__dirname + '/' + filename, callback || function () { });
        };
        game.getFileList = function (dir, callback) {
          var files = [], folders = [];
          dir = __dirname + '/' + dir;
          lib.node.fs.readdir(dir, function (err, filelist) {
            for (var i = 0; i < filelist.length; i++) {
              if (filelist[i][0] != '.' && filelist[i][0] != '_') {
                if (lib.node.fs.statSync(dir + '/' + filelist[i]).isDirectory()) {
                  folders.push(filelist[i]);
                }
                else {
                  files.push(filelist[i]);
                }
              }
            }
            callback(folders, files);
          });
        };
        game.ensureDirectory = function (list, callback, file) {
          var directorylist;
          var num = 0;
          if (file) {
            num = 1;
          }
          if (typeof list == 'string') {
            directorylist = [list];
          }
          else {
            var directorylist = list.slice(0);
          }
          var access = function (str, dir, callback) {
            if (dir.length <= num) {
              callback();
            }
            else {
              str += '/' + dir.shift();
              lib.node.fs.access(__dirname + str, function (e) {
                if (e) {
                  try {
                    lib.node.fs.mkdir(__dirname + str, function () {
                      access(str, dir, callback);
                    });
                  }
                  catch (e) {
                    console.log(e);
                  }
                }
                else {
                  access(str, dir, callback);
                }
              });
            }
          }
          var createDirectory = function () {
            if (directorylist.length) {
              access('', directorylist.shift().split('/'), createDirectory);
            }
            else {
              callback();
            }
          };
          createDirectory();
        };
        if (ui.updateUpdate) {
          ui.updateUpdate();
        }
      }
      else {
        //part: 网页端
        window.onbeforeunload = function () {
          if (lib.config.confirm_exit && !_status.reloading) {
            return '是否离开游戏？'
          }
          else {
            return null;
          }
        }
      }
      //part: 游戏设置信息，window.config，创建于config.js
      lib.config = window.config;
      //part: 联机部分的设置
      lib.configOL = {};
      delete window.config;
      var config2;
      if (localStorage.getItem(lib.configprefix + 'nodb')) {
        window.nodb = true;
      }
      //part: 持久化数据
      //`config2` 在这里从indexedDB/localStorage加载config数据，存入`config2`；`config2`，可能是`{}`，`false`或者读取到的config对象
      //如果config加载完成时，`ui.css`未加载完成，则暂存`config2`于`config3`中，等到完成再调用`proceed`
      if (window.indexedDB && !window.nodb) {
        //part: indexedDB
        var request = window.indexedDB.open(lib.configprefix + 'data', 4);
        request.onupgradeneeded = function (e) {
          var db = e.target.result;
          if (!db.objectStoreNames.contains('video')) {
            db.createObjectStore('video', { keyPath: 'time' });
          }
          if (!db.objectStoreNames.contains('image')) {
            db.createObjectStore('image');
          }
          if (!db.objectStoreNames.contains('audio')) {
            db.createObjectStore('audio');
          }
          if (!db.objectStoreNames.contains('config')) {
            db.createObjectStore('config');
          }
          if (!db.objectStoreNames.contains('data')) {
            db.createObjectStore('data');
          }
        };
        request.onsuccess = function (e) {
          lib.db = e.target.result;
          //part: indexedDB 读取config对象
          game.getDB('config', null, function (obj) {
            if (!obj.storageImported) {
              try {
                config2 = JSON.parse(localStorage.getItem(lib.configprefix + 'config'));
                if (!config2 || typeof config2 != 'object') throw 'err'
              }
              catch (err) {
                config2 = {};
              }
              for (var i in config2) {
                game.saveConfig(i, config2[i]);
              }
              for (var i in _mode) {
                try {
                  config2 = JSON.parse(localStorage.getItem(lib.configprefix + i));
                  if (!config2 || typeof config2 != 'object' || get.is.empty(config2)) throw 'err'
                }
                catch (err) {
                  config2 = false;
                }
                localStorage.removeItem(lib.configprefix + i);
                if (config2) {
                  game.putDB('data', i, config2);
                }
              }
              game.saveConfig('storageImported', true);
              //init background
              init.background();
              localStorage.removeItem(lib.configprefix + 'config');
            }
            else {
              config2 = obj;
            }
            proceed(config2);
          });
        }
      }
      else {
        //part: localStorage
        try {
          config2 = JSON.parse(localStorage.getItem(lib.configprefix + 'config'));
          if (!config2 || typeof config2 != 'object') throw 'err'
        }
        catch (err) {
          config2 = {};
          localStorage.setItem(lib.configprefix + 'config', JSON.stringify({}));
        }
        proceed(config2);
      }
      if (lib.init_extra) {
        lib.init_extra()
      }
    },
    /**
     * 重置游戏
     * 在游戏初始载入过程中超时的回调函数，发出弹窗询问是否重置（重启）游戏。
     * @function
     */
    reset: function () {
      if (window.inSplash) return;
      if (window.resetExtension) {
        if (confirm('游戏似乎未正常载入，是否禁用扩展并重新打开？')) {
          window.resetExtension();
          window.location.reload();
        }
      }
      else {
        if (lib.device) {
          if (navigator.notification) {
            navigator.notification.confirm(
              '游戏似乎未正常载入，是否重置游戏？',
              function (index) {
                if (index == 2) {
                  localStorage.removeItem('noname_inited');
                  window.location.reload();
                }
                else if (index == 3) {
                  var noname_inited = localStorage.getItem('noname_inited');
                  var onlineKey = localStorage.getItem(lib.configprefix + 'key');
                  localStorage.clear();
                  if (noname_inited) {
                    localStorage.setItem('noname_inited', noname_inited);
                  }
                  if (onlineKey) {
                    localStorage.setItem(lib.configprefix + 'key', onlineKey);
                  }
                  if (indexedDB) indexedDB.deleteDatabase(lib.configprefix + 'data');
                  setTimeout(function () {
                    window.location.reload();
                  }, 200);
                }
              },
              '确认退出',
              ['取消', '重新下载', '重置设置']
            );
          }
          else {
            if (confirm('游戏似乎未正常载入，是否重置游戏？')) {
              localStorage.removeItem('noname_inited');
              window.location.reload();
            }
          }
        }
        else {
          if (confirm('游戏似乎未正常载入，是否重置游戏？')) {
            var onlineKey = localStorage.getItem(lib.configprefix + 'key');
            localStorage.clear();
            if (onlineKey) {
              localStorage.setItem(lib.configprefix + 'key', onlineKey);
            }
            if (indexedDB) indexedDB.deleteDatabase(lib.configprefix + 'data');
            setTimeout(function () {
              window.location.reload();
            }, 200);
          }
        }
      }
    },
    /**
     * 游戏初始载入成功时被调用，加载游戏样式数据，并载入开始界面。
     * @function
     */
    onload: function () {
      ui.updated();
      /**
       * 文档缩放比例
       * @type {number}
       */
      game.documentZoom = game.deviceZoom;
      if (game.documentZoom != 1) {
        ui.updatez();
      }
      {
        if (!lib.config.low_performance) game.clickCanvas.init()
        ui.background = ui.create.div('.background');
        ui.background.style.backgroundSize = "cover";
        ui.background.style.backgroundPosition = '50% 50%';
        if (lib.config.image_background && lib.config.image_background != 'default' && lib.config.image_background.indexOf('custom_') != 0) {
          if (lib.config.image_background.indexOf('svg_') == 0) {
            ui.background.setBackgroundImage('image/background/' + lib.config.image_background.slice(4) + '.svg');
          }
          else {
            ui.background.setBackgroundImage('image/background/' + lib.config.image_background + '.jpg');
            if(!ui.backgroundFlash){
                ui.backgroundFlash = ui.create.div('.background', ui.background);
                ui.backgroundFlash.style.backgroundImage = `linear-gradient(to bottom, rgba(255, 255, 255, 0.1),rgba(255, 255, 255, 0.4) 60%,rgba(255, 255, 255, 0.6))`;
                ui.backgroundFlash.style.mixBlendMode = 'overlay';
                ui.backgroundSVG = ui.create.div('.background.slow_flash', ui.backgroundFlash);
                ui.backgroundSVG.style.backgroundImage = `url("${lib.assetURL}image/background/simple1_bg.svg")`;
            }
          }
          if (lib.config.image_background_blur) {
            ui.background.style.filter = 'blur(8px)';
            ui.background.style.webkitFilter = 'blur(8px)';
            ui.background.style.transform = 'scale(1.05)';
          }
        }
        document.documentElement.style.backgroundImage = '';
        document.documentElement.style.backgroundSize = '';
        document.documentElement.style.backgroundPosition = '';
        document.body.insertBefore(ui.background, document.body.firstChild);
        document.body.onresize = ui.updatexr;
        if (lib.config.touchscreen) {
          document.body.addEventListener('touchstart', function (e) {
            this.startX = e.touches[0].clientX / game.documentZoom;
            this.startY = e.touches[0].clientY / game.documentZoom;
            _status.dragged = false;
          });
          document.body.addEventListener('touchmove', function (e) {
            if (_status.dragged) return;
            if (Math.abs(e.touches[0].clientX / game.documentZoom - this.startX) > 10 ||
              Math.abs(e.touches[0].clientY / game.documentZoom - this.startY) > 10) {
              _status.dragged = true;
            }
          });
        }
      }
      {
        if (lib.config.image_background.indexOf('custom_') == 0) {
          ui.background.style.backgroundImage = "none";
          game.getDB('image', lib.config.image_background, function (fileToLoad) {
            if (!fileToLoad) return;
            var fileReader = new FileReader();
            fileReader.onload = function (fileLoadedEvent) {
              var data = fileLoadedEvent.target.result;
              ui.background.style.backgroundImage = 'url(' + data + ')';
              if (lib.config.image_background_blur) {
                ui.background.style.filter = 'blur(8px)';
                ui.background.style.webkitFilter = 'blur(8px)';
                ui.background.style.transform = 'scale(1.05)';
              }
            };
            fileReader.readAsDataURL(fileToLoad);
          });
        }
        if (lib.config.card_style == 'custom') {
          game.getDB('image', 'card_style', function (fileToLoad) {
            if (!fileToLoad) return;
            var fileReader = new FileReader();
            fileReader.onload = function (fileLoadedEvent) {
              if (ui.css.card_stylesheet) {
                ui.css.card_stylesheet.remove();
              }
              ui.css.card_stylesheet = init.sheet('.card:not(*:empty){background-image:url(' + fileLoadedEvent.target.result + ')}');
            };
            fileReader.readAsDataURL(fileToLoad);
          });
        }
        if (lib.config.cardback_style == 'custom') {
          game.getDB('image', 'cardback_style', function (fileToLoad) {
            if (!fileToLoad) return;
            var fileReader = new FileReader();
            fileReader.onload = function (fileLoadedEvent) {
              if (ui.css.cardback_stylesheet) {
                ui.css.cardback_stylesheet.remove();
              }
              ui.css.cardback_stylesheet = init.sheet('.card:empty,.card.infohidden{background-image:url(' + fileLoadedEvent.target.result + ')}');
            };
            fileReader.readAsDataURL(fileToLoad);
          });
          game.getDB('image', 'cardback_style2', function (fileToLoad) {
            if (!fileToLoad) return;
            var fileReader = new FileReader();
            fileReader.onload = function (fileLoadedEvent) {
              if (ui.css.cardback_stylesheet2) {
                ui.css.cardback_stylesheet2.remove();
              }
              ui.css.cardback_stylesheet2 = init.sheet('.card.infohidden:not(.infoflip){background-image:url(' + fileLoadedEvent.target.result + ')}');
            };
            fileReader.readAsDataURL(fileToLoad);
          });
        }
        if (lib.config.hp_style == 'custom') {
          game.getDB('image', 'hp_style1', function (fileToLoad) {
            if (!fileToLoad) return;
            var fileReader = new FileReader();
            fileReader.onload = function (fileLoadedEvent) {
              if (ui.css.hp_stylesheet1) {
                ui.css.hp_stylesheet1.remove();
              }
              ui.css.hp_stylesheet1 = init.sheet('.hp:not(.text):not(.actcount)[data-condition="high"]>div:not(.lost){background-image:url(' + fileLoadedEvent.target.result + ')}');
            };
            fileReader.readAsDataURL(fileToLoad);
          });
          game.getDB('image', 'hp_style2', function (fileToLoad) {
            if (!fileToLoad) return;
            var fileReader = new FileReader();
            fileReader.onload = function (fileLoadedEvent) {
              if (ui.css.hp_stylesheet2) {
                ui.css.hp_stylesheet2.remove();
              }
              ui.css.hp_stylesheet2 = init.sheet('.hp:not(.text):not(.actcount)[data-condition="mid"]>div:not(.lost){background-image:url(' + fileLoadedEvent.target.result + ')}');
            };
            fileReader.readAsDataURL(fileToLoad);
          });
          game.getDB('image', 'hp_style3', function (fileToLoad) {
            if (!fileToLoad) return;
            var fileReader = new FileReader();
            fileReader.onload = function (fileLoadedEvent) {
              if (ui.css.hp_stylesheet3) {
                ui.css.hp_stylesheet3.remove();
              }
              ui.css.hp_stylesheet3 = init.sheet('.hp:not(.text):not(.actcount)[data-condition="low"]>div:not(.lost){background-image:url(' + fileLoadedEvent.target.result + ')}');
            };
            fileReader.readAsDataURL(fileToLoad);
          });
          game.getDB('image', 'hp_style4', function (fileToLoad) {
            if (!fileToLoad) return;
            var fileReader = new FileReader();
            fileReader.onload = function (fileLoadedEvent) {
              if (ui.css.hp_stylesheet4) {
                ui.css.hp_stylesheet4.remove();
              }
              ui.css.hp_stylesheet4 = init.sheet('.hp:not(.text):not(.actcount)>.lost{background-image:url(' + fileLoadedEvent.target.result + ')}');
            };
            fileReader.readAsDataURL(fileToLoad);
          });
        }
        if (lib.config.player_style == 'custom') {
          ui.css.player_stylesheet = init.sheet('#window .player{background-image:none;background-size:100% 100%;}');
          game.getDB('image', 'player_style', function (fileToLoad) {
            if (!fileToLoad) return;
            var fileReader = new FileReader();
            fileReader.onload = function (fileLoadedEvent) {
              if (ui.css.player_stylesheet) {
                ui.css.player_stylesheet.remove();
              }
              ui.css.player_stylesheet = init.sheet('#window .player{background-image:url("' + fileLoadedEvent.target.result + '");background-size:100% 100%;}');
            };
            fileReader.readAsDataURL(fileToLoad);
          });
        }
        if (lib.config.border_style == 'custom') {
          game.getDB('image', 'border_style', function (fileToLoad) {
            if (!fileToLoad) return;
            var fileReader = new FileReader();
            fileReader.onload = function (fileLoadedEvent) {
              if (ui.css.border_stylesheet) {
                ui.css.border_stylesheet.remove();
              }
              ui.css.border_stylesheet = init.sheet();
              ui.css.border_stylesheet.sheet.insertRule('#window .player>.framebg{display:block;background-image:url("' + fileLoadedEvent.target.result + '")}', 0);
              ui.css.border_stylesheet.sheet.insertRule('.player>.count{z-index: 3 !important;border-radius: 2px !important;text-align: center !important;}', 0);
            };
            fileReader.readAsDataURL(fileToLoad);
          });
        }
        if (lib.config.control_style == 'custom') {
          game.getDB('image', 'control_style', function (fileToLoad) {
            if (!fileToLoad) return;
            var fileReader = new FileReader();
            fileReader.onload = function (fileLoadedEvent) {
              if (ui.css.control_stylesheet) {
                ui.css.control_stylesheet.remove();
              }
              ui.css.control_stylesheet = init.sheet('#window .control,.menubutton:not(.active):not(.highlight):not(.red):not(.blue),#window #system>div>div{background-image:url("' + fileLoadedEvent.target.result + '")}');
            };
            fileReader.readAsDataURL(fileToLoad);
          });
        }
        if (lib.config.menu_style == 'custom') {
          game.getDB('image', 'menu_style', function (fileToLoad) {
            if (!fileToLoad) return;
            var fileReader = new FileReader();
            fileReader.onload = function (fileLoadedEvent) {
              if (ui.css.menu_stylesheet) {
                ui.css.menu_stylesheet.remove();
              }
              ui.css.menu_stylesheet = init.sheet('html #window>.dialog.popped,html .menu,html .menubg{background-image:url("' + fileLoadedEvent.target.result + '");background-size:cover}');
            };
            fileReader.readAsDataURL(fileToLoad);
          });
        }
      }


      var proceed2 = function () {
        var mode = lib.imported.mode;
        var card = lib.imported.card;
        var character = lib.imported.character;
        var play = lib.imported.play;
        delete window.game;
        var i, j, k;
        for (i in mode[lib.config.mode].element) {
          if (!element[i]) element[i] = [];
          for (j in mode[lib.config.mode].element[i]) {
            if (j == 'init') {
              if (!element[i].inits) element[i].inits = [];
              element[i].inits.push(mode[lib.config.mode].element[i][j]);
            }
            else {
              element[i][j] = mode[lib.config.mode].element[i][j];
            }
          }
        }
        for (i in mode[lib.config.mode].ai) {
          if (typeof mode[lib.config.mode].ai[i] == 'object') {
            if (ai[i] == undefined) ai[i] = {};
            for (j in mode[lib.config.mode].ai[i]) {
              ai[i][j] = mode[lib.config.mode].ai[i][j];
            }
          }
          else {
            ai[i] = mode[lib.config.mode].ai[i];
          }
        }
        for (i in mode[lib.config.mode].ui) {
          if (typeof mode[lib.config.mode].ui[i] == 'object') {
            if (ui[i] == undefined) ui[i] = {};
            for (j in mode[lib.config.mode].ui[i]) {
              ui[i][j] = mode[lib.config.mode].ui[i][j];
            }
          }
          else {
            ui[i] = mode[lib.config.mode].ui[i];
          }
        }
        for (i in mode[lib.config.mode].game) {
          game[i] = mode[lib.config.mode].game[i];
        }
        for (i in mode[lib.config.mode].get) {
          get[i] = mode[lib.config.mode].get[i];
        }
        init.start = mode[lib.config.mode].start;
        init.startBefore = mode[lib.config.mode].startBefore;
        if (game.onwash) {
          lib.onwash.push(game.onwash);
          delete game.onwash;
        }
        if (game.onover) {
          lib.onover.push(game.onover);
          delete game.onover;
        }
        lib.config.banned = lib.config[lib.config.mode + '_banned'] || [];
        lib.config.bannedcards = lib.config[lib.config.mode + '_bannedcards'] || [];

        lib.rank = __webpack_require__(7876);
        for (i in mode[lib.config.mode]) {
          if (i == 'element') continue;
          if (i == 'game') continue;
          if (i == 'ai') continue;
          if (i == 'ui') continue;
          if (i == 'get') continue;
          if (i == 'config') continue;
          if (i == 'onreinit') continue;
          if (i == 'start') continue;
          if (i == 'startBefore') continue;
          if (lib[i] == undefined) lib[i] = (Array.isArray(mode[lib.config.mode][i])) ? [] : {};
          for (j in mode[lib.config.mode][i]) {
            lib[i][j] = mode[lib.config.mode][i][j];
          }
        }
        if (typeof mode[lib.config.mode].init == 'function') {
          mode[lib.config.mode].init();
        }

        var connectCharacterPack = [];
        var connectCardPack = [];
        for (i in character) {
          if (character[i].character) {
            lib.characterPack[i] = character[i].character
          }
          for (j in character[i]) {
            if (j == 'mode' || j == 'forbid') continue;
            if (j == 'connect') {
              connectCharacterPack.push(i);
              continue;
            }
            if (j == 'character' && !lib.config.characters.contains(i) && lib.config.mode != 'connect') {
              if (lib.config.mode == 'chess' && get.config('chess_mode') == 'leader' && get.config('chess_leader_allcharacter')) {
                for (k in character[i][j]) {
                  lib.hiddenCharacters.push(k);
                }
              }
              else if (lib.config.mode != 'boss' || i != 'boss') {
                continue;
              }
            }
            if (Array.isArray(lib[j]) && Array.isArray(character[i][j])) {
              lib[j].addArray(character[i][j]);
              continue;
            }
            for (k in character[i][j]) {
              if (j == 'character') {
                if (!character[i][j][k][4]) {
                  character[i][j][k][4] = [];
                }
                if (character[i][j][k][4].contains('boss') ||
                  character[i][j][k][4].contains('hiddenboss')) {
                  lib.config.forbidai.add(k);
                }
                if (lib.config.forbidai_user && lib.config.forbidai_user.contains(k)) {
                  lib.config.forbidai.add(k);
                }
                for (var l = 0; l < character[i][j][k][3].length; l++) {
                  lib.skilllist.add(character[i][j][k][3][l]);
                }
              }
              if (j == 'skill' && k[0] == '_' && (lib.config.mode != 'connect' ? (!lib.config.characters.contains(i)) : (!character[i].connect))) {
                continue;
              }
              if (j == 'translate' && k == i) {
                lib[j][k + '_character_config'] = character[i][j][k];
              }
              else {
                if (lib[j][k] == undefined) {
                  if (j == 'skill' && !character[i][j][k].forceLoad && lib.config.mode == 'connect' && !character[i].connect) {
                    lib[j][k] = {
                      nopop: character[i][j][k].nopop,
                      derivation: character[i][j][k].derivation
                    };
                  }
                  else {
                    lib[j][k] = character[i][j][k];
                  }
                  if (j == 'card' && lib[j][k].derivation) {
                    if (!lib.cardPack.mode_derivation) {
                      lib.cardPack.mode_derivation = [k];
                    }
                    else {
                      lib.cardPack.mode_derivation.push(k);
                    }
                  }
                }
                else if (Array.isArray(lib[j][k]) && Array.isArray(character[i][j][k])) {
                  lib[j][k].addArray(character[i][j][k]);
                }
                else {
                  console.log('dublicate ' + j + ' in character ' + i + ':\n' + k + '\n' + ': ' + lib[j][k] + '\n' + character[i][j][k]);
                }
              }
            }
          }
        }
        var connect_avatar_list = [];
        for (var i in lib.character) {
          connect_avatar_list.push(i);
        }
        connect_avatar_list.sort(lib.sort.capt);
        for (var i = 0; i < connect_avatar_list.length; i++) {
          var ia = connect_avatar_list[i];
          _mode.connect.config.connect_avatar.item[ia] = lib.translate[ia];
        }
        if (lib.config.mode != 'connect') {
          var pilecfg = lib.config.customcardpile[get.config('cardpilename') || '当前牌堆'];
          if (pilecfg) {
            lib.config.bannedpile = get.copy(pilecfg[0] || {});
            lib.config.addedpile = get.copy(pilecfg[1] || {});
          }
          else {
            lib.config.bannedpile = {};
            lib.config.addedpile = {};
          }
        }
        else {
          lib.cardPackList = {};
        }
        for (i in card) {
          lib.cardPack[i] = [];
          if (card[i].card) {
            for (var j in card[i].card) {
              if (!card[i].card[j].hidden && card[i].translate[j + '_info']) {
                lib.cardPack[i].push(j);
              }
            }
          }
          for (j in card[i]) {
            if (j == 'mode' || j == 'forbid') continue;
            if (j == 'connect') {
              connectCardPack.push(i);
              continue;
            }
            if (j == 'list') {
              if (lib.config.mode == 'connect') {
                lib.cardPackList[i] = card[i][j];
              }
              else {
                if (lib.config.cards.contains(i)) {
                  var pile;
                  if (typeof card[i][j] == 'function') {
                    pile = card[i][j]();
                  }
                  else {
                    pile = card[i][j];
                  }
                  lib.cardPile[i] = pile.slice(0);
                  if (lib.config.bannedpile[i]) {
                    for (var k = 0; k < lib.config.bannedpile[i].length; k++) {
                      pile[lib.config.bannedpile[i][k]] = null;
                    }
                  }
                  for (var k = 0; k < pile.length; k++) {
                    if (!pile[k]) {
                      pile.splice(k--, 1);
                    }
                  }
                  if (lib.config.addedpile[i]) {
                    for (var k = 0; k < lib.config.addedpile[i].length; k++) {
                      pile.push(lib.config.addedpile[i][k]);
                    }
                  }
                  lib.card.list = lib.card.list.concat(pile);
                }
              }
            }
            else {
              for (k in card[i][j]) {
                if (j == 'skill' && k[0] == '_' && !card[i][j][k].forceLoad && (lib.config.mode != 'connect' ? (!lib.config.cards.contains(i)) : (!card[i].connect))) {
                  continue;
                }
                if (j == 'translate' && k == i) {
                  lib[j][k + '_card_config'] = card[i][j][k];
                }
                else {
                  if (lib[j][k] == undefined) {
                    if (j == 'skill' && !card[i][j][k].forceLoad && lib.config.mode == 'connect' && !card[i].connect) {
                      lib[j][k] = {
                        nopop: card[i][j][k].nopop,
                        derivation: card[i][j][k].derivation
                      };
                    }
                    else {
                      lib[j][k] = card[i][j][k];
                    }
                  }
                  else console.log('dublicate ' + j + ' in card ' + i + ':\n' + k + '\n' + lib[j][k] + '\n' + card[i][j][k]);
                  if (j == 'card' && lib[j][k].derivation) {
                    if (!lib.cardPack.mode_derivation) {
                      lib.cardPack.mode_derivation = [k];
                    }
                    else {
                      lib.cardPack.mode_derivation.push(k);
                    }
                  }
                }
              }
            }
          }
        }
        if (lib.cardPack.mode_derivation) {
          for (var i = 0; i < lib.cardPack.mode_derivation.length; i++) {
            if (typeof lib.card[lib.cardPack.mode_derivation[i]].derivation == 'string' && !lib.character[lib.card[lib.cardPack.mode_derivation[i]].derivation]) {
              lib.cardPack.mode_derivation.splice(i--, 1);
            }
            else if (typeof lib.card[lib.cardPack.mode_derivation[i]].derivationpack == 'string' && !lib.config.cards.contains(lib.card[lib.cardPack.mode_derivation[i]].derivationpack)) {
              lib.cardPack.mode_derivation.splice(i--, 1);
            }
          }
          if (lib.cardPack.mode_derivation.length == 0) {
            delete lib.cardPack.mode_derivation;
          }
        }
        if (lib.config.mode != 'connect') {
          for (i in play) {
            if (lib.config.hiddenPlayPack.contains(i)) continue;
            if (play[i].forbid && play[i].forbid.contains(lib.config.mode)) continue;
            if (play[i].mode && play[i].mode.contains(lib.config.mode) == false) continue;
            for (j in play[i].element) {
              if (!element[j]) element[j] = [];
              for (k in play[i].element[j]) {
                if (k == 'init') {
                  if (!element[j].inits) element[j].inits = [];
                  element[j].inits.push(play[i].element[j][k]);
                }
                else {
                  element[j][k] = play[i].element[j][k];
                }
              }
            }
            for (j in play[i].ui) {
              if (typeof play[i].ui[j] == 'object') {
                if (ui[j] == undefined) ui[j] = {};
                for (k in play[i].ui[j]) {
                  ui[j][k] = play[i].ui[j][k];
                }
              }
              else {
                ui[j] = play[i].ui[j];
              }
            }
            for (j in play[i].game) {
              game[j] = play[i].game[j];
            }
            for (j in play[i].get) {
              get[j] = play[i].get[j];
            }
            for (j in play[i]) {
              if (j == 'mode' || j == 'forbid' || j == 'init' || j == 'element' ||
                j == 'game' || j == 'get' || j == 'ui' || j == 'arenaReady') continue;
              for (k in play[i][j]) {
                if (j == 'translate' && k == i) {
                  // lib[j][k+'_play_config']=play[i][j][k];
                }
                else {
                  if (lib[j][k] != undefined) {
                    console.log('dublicate ' + j + ' in play ' + i + ':\n' + k + '\n' + ': ' + lib[j][k] + '\n' + play[i][j][k]);
                  }
                  lib[j][k] = play[i][j][k];
                }
              }
            }
            if (typeof play[i].init == 'function') play[i].init();
            if (typeof play[i].arenaReady == 'function') lib.arenaReady.push(play[i].arenaReady);
          }
        }

        lib.connectCharacterPack = [];
        lib.connectCardPack = [];
        for (var i = 0; i < lib.config.all.characters.length; i++) {
          var packname = lib.config.all.characters[i];
          if (connectCharacterPack.contains(packname)) {
            lib.connectCharacterPack.push(packname)
          }
        }
        for (var i = 0; i < lib.config.all.cards.length; i++) {
          var packname = lib.config.all.cards[i];
          if (connectCardPack.contains(packname)) {
            lib.connectCardPack.push(packname)
          }
        }
        if (lib.config.mode != 'connect') {
          for (i = 0; i < lib.card.list.length; i++) {
            if (lib.card.list[i][2] == 'huosha') {
              lib.card.list[i] = lib.card.list[i].slice(0);
              lib.card.list[i][2] = 'sha';
              lib.card.list[i][3] = 'fire';
            }
            else if (lib.card.list[i][2] == 'leisha') {
              lib.card.list[i] = lib.card.list[i].slice(0);
              lib.card.list[i][2] = 'sha';
              lib.card.list[i][3] = 'thunder';
            }
            else if (lib.card.list[i][2] == 'haisha') {
              lib.card.list[i] = lib.card.list[i].slice(0);
              lib.card.list[i][2] = 'sha';
              lib.card.list[i][3] = 'ocean';
            }
            else if (lib.card.list[i][2] == 'yamisha') {
              lib.card.list[i] = lib.card.list[i].slice(0);
              lib.card.list[i][2] = 'sha';
              lib.card.list[i][3] = 'yami';
            }
            if (lib.card.list[i][2] == 'haitao') {
              lib.card.list[i] = lib.card.list[i].slice(0);
              lib.card.list[i][2] = 'tao';
              lib.card.list[i][3] = 'ocean';
            }
            if (lib.card.list[i][2] == 'haijiu') {
              lib.card.list[i] = lib.card.list[i].slice(0);
              lib.card.list[i][2] = 'jiu';
              lib.card.list[i][3] = 'ocean';
            }
            if (!lib.card[lib.card.list[i][2]]) {
              lib.card.list.splice(i, 1); i--;
            }
            else if (lib.card[lib.card.list[i][2]].mode &&
              lib.card[lib.card.list[i][2]].mode.contains(lib.config.mode) == false) {
              lib.card.list.splice(i, 1); i--;
            }
          }
        }

        if (lib.config.mode == 'connect') {
          _status.connectMode = true;
        }
        if (window.isNonameServer) {
          lib.cheat.i();
        }
        else if (lib.config.dev && (!_status.connectMode || lib.config.debug)) {
          lib.cheat.i();
        }
        lib.config.sort_card = get.sortCard(lib.config.sort);
        delete lib.imported.character;
        delete lib.imported.card;
        delete lib.imported.mode;
        delete lib.imported.play;
        for (var i in init) {
          if (i.indexOf('setMode_') == 0) {
            delete init[i];
          }
        }
        if (!_status.connectMode) {
          for (var i = 0; i < lib.extensions.length; i++) {
            try {
              _status.extension = lib.extensions[i][0];
              _status.evaluatingExtension = lib.extensions[i][3];
              lib.extensions[i][1](lib.extensions[i][2], lib.extensions[i][4]);
              if (lib.extensions[i][4]) {
                if (lib.extensions[i][4].character) {
                  for (var j in lib.extensions[i][4].character.character) {
                    game.addCharacterPack(get.copy(lib.extensions[i][4].character));
                    break;
                  }
                }
                if (lib.extensions[i][4].card) {
                  for (var j in lib.extensions[i][4].card.card) {
                    game.addCardPack(get.copy(lib.extensions[i][4].card));
                    break;
                  }
                }
                if (lib.extensions[i][4].skill) {
                  for (var j in lib.extensions[i][4].skill.skill) {
                    game.addSkill(j, lib.extensions[i][4].skill.skill[j],
                      lib.extensions[i][4].skill.translate[j], lib.extensions[i][4].skill.translate[j + '_info']);
                  }
                }
              }
              delete _status.extension;
              delete _status.evaluatingExtension;
            }
            catch (e) {
              console.log(e);
            }
          }
        }
        delete lib.extensions;

        if (init.startBefore) {
          init.startBefore();
          delete init.startBefore;
        }
        ui.create.arena();
        game.createEvent('game', false).setContent(init.start);
        if (_mode[lib.config.mode] && _mode[lib.config.mode].fromextension) {
          var startstr = mode[lib.config.mode].start.toString();
          if (startstr.indexOf('onfree') == -1) {
            setTimeout(init.onfree, 500);
          }
        }
        delete init.start;
        game.loop();
      }
      var proceed = function () {
        if (!lib.db) {
          try {
            lib.storage = JSON.parse(localStorage.getItem(lib.configprefix + lib.config.mode));
            if (typeof lib.storage != 'object') throw ('err');
            if (lib.storage == null) throw ('err');
          }
          catch (err) {
            lib.storage = {};
            localStorage.setItem(lib.configprefix + lib.config.mode, "{}");
          }
          proceed2();
        }
        else {
          game.getDB('data', lib.config.mode, function (obj) {
            lib.storage = obj || {};
            proceed2();
          });
        }
      };
      if (!lib.imported.mode || !lib.imported.mode[lib.config.mode]) {
        window.inSplash = true;
        clearTimeout(window.resetGameTimeout);
        delete window.resetGameTimeout;
        var clickedNode = false;
        var clickNode = function () {
          if (clickedNode) return;
          this.classList.add('clicked');
          clickedNode = true;
          lib.config.mode = this.link;
          game.saveConfig('mode', this.link);
          if (this.link == 'connect') {
            localStorage.setItem(lib.configprefix + 'directstart', true);
            game.reload();
          }
          else {
            if (game.layout != 'mobile' && lib.layoutfixed.indexOf(lib.config.mode) !== -1) {
              game.layout = 'mobile';
              ui.css.layout.href = lib.assetURL + 'layout/' + game.layout + '/layout.css';
            }
            else if (game.layout == 'mobile' && lib.config.layout != 'mobile' && lib.layoutfixed.indexOf(lib.config.mode) === -1) {
              game.layout = lib.config.layout;
              if (game.layout == 'default') {
                ui.css.layout.href = '';
              }
              else {
                ui.css.layout.href = lib.assetURL + 'layout/' + game.layout + '/layout.css';
              }
            }
            splash.delete(1000);
            delete window.inSplash;
            window.resetGameTimeout = setTimeout(init.reset, 5000);

            this.listenTransition(() => {
              init.js(dist(), 'mode', proceed);
            }, 500);
          }
        }
        var downNode = function () {
          this.classList.add('glow');
        }
        var upNode = function () {
          this.classList.remove('glow');
        }
        var splash = ui.create.div('#splash', document.body);
        if (lib.config.touchscreen) {
          splash.classList.add('touch');
          lib.setScroll(splash);
        }
        if (lib.config.player_border != 'wide') {
          splash.classList.add('slim');
        }
        splash.dataset.radius_size = lib.config.radius_size;
        for (var i = 0; i < lib.config.all.mode.length; i++) {
          var node = ui.create.div('.hidden', splash, clickNode);
          node.link = lib.config.all.mode[i];
          node.dataset.cursor_style = "pointer";
          ui.create.div(node, '.splashtext', get.verticalStr(get.translation(lib.config.all.mode[i])));
          if (lib.config.all.stockmode.indexOf(lib.config.all.mode[i]) != -1) {
            ui.create.div(node, '.avatar').setBackgroundImage(`image/splash/${lib.config.all.mode[i]}.jpg`, true);
          }
          else {
            var avatarnode = ui.create.div(node, '.avatar');
            var avatarbg = _mode[lib.config.all.mode[i]].splash;
            if (avatarbg.indexOf('ext:') == 0) {
              avatarnode.setBackgroundImage(avatarbg.replace(/ext:/, 'extension/'));
            }
            else {
              avatarnode.setBackgroundDB(avatarbg);
            }
          }
          if (!lib.config.touchscreen) {
            node.addEventListener('mousedown', downNode);
            node.addEventListener('mouseup', upNode);
            node.addEventListener('mouseleave', upNode);
          }
          setTimeout((function (node) {
            return function () {
              node.show();
            }
          }(node)), i * 100);
        }
        if (lib.config.mousewheel) {
          splash.onmousewheel = ui.click.mousewheel;
        }
      }
      else {
        proceed();
      }
      localStorage.removeItem(lib.configprefix + 'directstart');
      delete init.init;
    },
    startOnline: [function () {
      Evt._resultid = null;
      Evt._result = null;
      game.pause();
    },
    function () {
      if (result) {
        if (Evt._resultid) {
          result.id = Evt._resultid;
        }
        game.send('result', result);
      }
      Evt.goto(0);
    }],
    /**
     * 闲时执行，一般选择角色后开始执行这个方法
     * @function
     */
    onfree: function () {
      if (lib.onfree) {
        clearTimeout(window.resetGameTimeout);
        delete window.resetGameTimeout;
        if (!game.syncMenu) {
          delete window.resetExtension;
          localStorage.removeItem(lib.configprefix + 'disable_extension');
        }

        if (game.removeFile && lib.config.brokenFile.length) {
          while (lib.config.brokenFile.length) {
            game.removeFile(lib.config.brokenFile.shift());
          }
          game.saveConfigValue('brokenFile');
        }

        var onfree = lib.onfree;
        delete lib.onfree;
        var loop = function () {
          if (onfree.length) {
            (onfree.shift())();
            setTimeout(loop, 100);
          }
        };
        setTimeout(loop, 500);
      }
    },
    connection: function (ws) {
      var client = {
        ws: ws,
        id: ws.wsid || get.id(),
        closed: false
      };
      lib.node.clients.push(client);
      for (var i in element.client) {
        client[i] = element.client[i];
      }
      if (window.isNonameServer) {
        document.querySelector('#server_count').innerHTML = lib.node.clients.length;
      }
      ws.on('message', function (messagestr) {
        var message;
        try {
          message = JSON.parse(messagestr);
          if (!Array.isArray(message) ||
            typeof _message.server[message[0]] !== 'function') {
            throw ('err');
          }
          for (var i = 1; i < message.length; i++) {
            message[i] = get.parsedResult(message[i]);
          }
        }
        catch (e) {
          console.log(e);
          console.log('invalid message: ' + messagestr);
          return;
        }
        _message.server[message.shift()].apply(client, message);
      });
      ws.on('close', function () {
        client.close();
      });
      client.send('opened');
    },
    /**
     * 创建（并插入文档）新的`<style>`
     * @function
     * @param {...string} rules css rules
     * @returns {!HTMLStyleElement} 新的`<style>`
     */
    sheet: function (...args) {
      var style = document.createElement('style');
      document.head.appendChild(style);
      for (let v of args) {
        if (typeof v == 'string') {
          style.sheet.insertRule(v, 0);
        }
      }
      return style;
    },
    /**
     * 读取一个css文件
     * 于文档中创建（并插入文档中）新的`<link>`，如果设置路径则先加载再返回，否则直接返回空`<link>`
     * @function init.css
     * @param {string} [path=null] 要加载的css文件所在目录, 如果为null，不设置生成的`<link>`的href值
     * @param {string} file 文件名（不包括拓展名），自动添加后缀.css；如果path为null，则被忽略
     * @param {function():void} [before] 可选，onload回调函数，在新`<link>`加载完成时被调用
     */
    /**
     * 读取一个css文件
     * 于文档中创建（并插入文档中）新的`<link>`，如果设置路径则先加载再返回，否则直接返回空`<link>`
     * @function init.css
     * @variation 2
     * @param {string} [path=null] 要加载的css文件所在目录, 如果为null，不设置生成的`<link>`的href值
     * @param {string} file 文件名（不包括拓展名），自动添加后缀.css；如果path为null，则被忽略
     * @param {HTMLLinkElement} [before] 可选，一个{@link HTMLLinkElement}对象，新`<link>`会插入到`before`前
     * @returns {HTMLLinkElement} 新的`<link>`
     */
    css: function (path, file, before) {
      var style = document.createElement("link");
      style.rel = "stylesheet";
      if (path) {
        style.href = path + '/' + file + ".css";
      }
      if (typeof before == 'function') {
        style.addEventListener('load', before);
        document.head.appendChild(style);
      }
      else if (before) {
        document.head.insertBefore(style, before);
      }
      else {
        document.head.appendChild(style);
      }
      return style;
    },
    /**
     * 读取一个js文件
     * 于文档中创建新的`<script>`对象
     * @function init.js
     * @param {!string} dir 要加载的js文件所在目录, 如果为null，不设置生成的`<link>`的href值
     * @param {!string} file 文件名（不包括拓展名），自动添加后缀.js；如果path为null，则被忽略
     * @param {function():void} [onload] 可选，onload回调函数
     * @param {function():void} [onerror] 可选，onerror回调函数 
     * @returns {!HTMLScriptElement} 新的`<script>`
     */
    /**
     * 读取一个js文件
     * 于文档中创建新的`<script>`对象
     * @function init.js
     * @variation 2
     * @param {!string} path 要加载的js文件所在路径, 如果为null，不设置生成的`<link>`的href值
     * @param {null} file 文件名（无拓展名），自动添加后缀.js
     * @param {function():void} [onload] 可选，onload回调函数
     * @param {function():void} [onerror] 可选，onerror回调函数 
     * @returns {!HTMLScriptElement} 新的`<script>`
     */
    /**
     * 读取一个js文件
     * 于文档中创建一组新的`<script>`对象
     * @function init.js
     * @variation 3
     * @param {!string} path 要加载的js文件所在路径, 如果为null，不设置生成的`<link>`的href值
     * @param {Array<string>} files 文件名数组
     * @param {?function():void} [onload] 可选，onload回调函数，对每个新的`<script>`调用
     * @param {?function():void} [onerror] 可选，onerror回调函数，对每个新的`<script>`调度
     */
    js: function (path, file, onload, onerror) {
      if (path[path.length - 1] == '/') {
        path = path.slice(0, path.length - 1);
      }
      //??
      if (file === 'mode' && lib.config.all.stockmode.indexOf(lib.config.mode) == -1) {
        init['setMode_' + lib.config.mode]();
        onload();
        return;
      }
      if (path == lib.assetURL + 'mode' && lib.config.all.stockmode.indexOf(file) == -1) {
        init['setMode_' + file]();
        onload();
        return;
      }
      if (Array.isArray(file)) {
        for (var i = 0; i < file.length; i++) {
          init.js(path, file[i], onload, onerror);
        }
      }
      else {
        var script = document.createElement('script');
        if (!file) {
          script.src = path;
        }
        else {
          script.src = path + '/' + file + ".js";
        }
        if (path.indexOf('http') == 0) {
          script.src += '?rand=' + get.id();
          script.addEventListener('load', function () {
            script.remove();
          });
        }
        document.head.appendChild(script);
        if (typeof onload == 'function') {
          script.addEventListener('load', onload);
          script.addEventListener('error', onerror);
        }
        return script;
      }
    },
    req: function (str, onload, onerror, master) {
      var sScriptURL;
      if (str.indexOf('http') == 0) {
        sScriptURL = str;
      }
      else {
        var url = get.url(master);
        if (url[url.length - 1] != '/') {
          url += '/';
        }
        sScriptURL = url + str;
      }
      var oReq = new XMLHttpRequest();
      if (onload) oReq.addEventListener("load", onload);
      if (onerror) oReq.addEventListener("error", onerror);
      oReq.open("GET", sScriptURL);
      oReq.send();
    },
    /**
     * 读取一个json文件
     * @function
     * @param {!string} url url路径
     * @param {function(Object):void} onload 成功时的回调函数
     * @param {function():void} onerror 失败时回调函数
     */
    json: function (url, onload, onerror) {
      var oReq = new XMLHttpRequest();
      if (onload) oReq.addEventListener("load", function () {
        var result;
        try {
          result = JSON.parse(this.responseText);
          if (!result) {
            throw ('err');
          }
        }
        catch (e) {
          onerror();
          return;
        }
        onload(result);
      });
      if (onerror) oReq.addEventListener("error", onerror);
      oReq.open("GET", url);
      oReq.send();
    },
    /**
     * 初始化角色字体样式和边缘样式
     * @function
     */
    cssstyles: function () {
      if (ui.css.styles) {
        ui.css.styles.remove();
      }
      ui.css.styles = init.sheet();
      ui.css.styles.sheet.insertRule('#arena .player>.name,#arena .button.character>.name {font-family: ' + (lib.config.name_font || 'xinwei') + ',xinwei}', 0);
      ui.css.styles.sheet.insertRule('#arena .player .identity>div {font-family: ' + (lib.config.identity_font || 'huangcao') + ',xinwei}', 0);
      ui.css.styles.sheet.insertRule('.button.character.newstyle>.identity {font-family: ' + (lib.config.identity_font || 'huangcao') + ',xinwei}', 0);
      if (lib.config.cardtext_font && lib.config.cardtext_font != 'default') {
        ui.css.styles.sheet.insertRule(`.card div:not(.info):not(.background) {font-family: ${lib.config.cardtext_font};Tiejili}`, 0);
      }
      if (lib.config.global_font && lib.config.global_font != 'default') {
        ui.css.styles.sheet.insertRule('#window {font-family: ' + lib.config.global_font + ',xinwei}', 0);
        ui.css.styles.sheet.insertRule('#window #control{font-family: STHeiti,SimHei,Microsoft JhengHei,Microsoft YaHei,WenQuanYi Micro Hei,Helvetica,Arial,sans-serif}', 0);
      }
      switch (lib.config.glow_phase) {
        case 'yellow': ui.css.styles.sheet.insertRule('#arena .player:not(.selectable):not(.selected).glow_phase {box-shadow: rgba(0, 0, 0, 0.3) 0 0 0 1px, rgb(217, 152, 62) 0 0 15px, rgb(217, 152, 62) 0 0 15px !important;}', 0); break;
        case 'green': ui.css.styles.sheet.insertRule('#arena .player:not(.selectable):not(.selected).glow_phase {box-shadow: rgba(0, 0, 0, 0.3) 0 0 0 1px, rgba(10, 155, 67, 1) 0 0 15px, rgba(10, 155, 67, 1) 0 0 15px !important;}', 0); break;
        case 'purple': ui.css.styles.sheet.insertRule('#arena .player:not(.selectable):not(.selected).glow_phase {box-shadow: rgba(0, 0, 0, 0.3) 0 0 0 1px, rgb(189, 62, 170) 0 0 15px, rgb(189, 62, 170) 0 0 15px !important;}', 0); break;
      }
    },
    /**
     * 初始化布局
     * @function
     * @param {string} layout 布局类型
     * @param {boolean} nosave 是否保存
     */
    layout: function (layout, nosave) {
      if (!nosave) game.saveConfig('layout', layout);
      game.layout = layout;
      ui.arena.hide();
      setTimeout(function () {
        if (game.layout == 'default') {
          ui.css.layout.href = '';
        }
        else {
          ui.css.layout.href = lib.assetURL + 'layout/' + game.layout + '/layout.css';
        }
        if (game.layout == 'mobile' || game.layout == 'long') {
          ui.arena.classList.add('mobile');
        }
        else {
          ui.arena.classList.remove('mobile');
        }
        if (game.layout == 'mobile' || game.layout == 'long' || game.layout == 'long2' || game.layout == 'nova') {
          if (game.me && game.me.node.handcards2.childNodes.length) {
            while (game.me.node.handcards2.childNodes.length) {
              game.me.node.handcards1.appendChild(game.me.node.handcards2.firstChild);
            }
          }
        }
        if (game.layout == 'default') {
          ui.arena.classList.add('oldlayout');
        }
        else {
          ui.arena.classList.remove('oldlayout');
        }
        if (lib.config.cardshape == 'oblong' && (game.layout == 'long' || game.layout == 'mobile' || game.layout == 'long2' || game.layout == 'nova')) {
          ui.arena.classList.add('oblongcard');
          ui.window.classList.add('oblongcard');
        }
        else {
          ui.arena.classList.remove('oblongcard');
          ui.window.classList.remove('oblongcard');
        }
        // if (lib.config.textequip == 'text' && (game.layout == 'long' || game.layout == 'mobile')) {
        //   ui.arena.classList.add('textequip');
        // }
        // else {
        //   ui.arena.classList.remove('textequip');
        // }
        if (get.is.phoneLayout()) {
          ui.css.phone.href = lib.assetURL + 'layout/default/phone.css';
          ui.arena.classList.add('phone');
        }
        else {
          ui.css.phone.href = '';
          ui.arena.classList.remove('phone');
        }
        for (var i = 0; i < game.players.length; i++) {
          if (get.is.linked2(game.players[i])) {
            if (game.players[i].classList.contains('linked')) {
              game.players[i].classList.remove('linked');
              game.players[i].classList.add('linked2');
            }
          }
          else {
            if (game.players[i].classList.contains('linked2')) {
              game.players[i].classList.remove('linked2');
              game.players[i].classList.add('linked');
            }
          }
        }
        if (game.layout == 'long' || game.layout == 'long2') {
          ui.arena.classList.add('long');
        }
        else {
          ui.arena.classList.remove('long');
        }
        if (lib.config.player_border != 'wide' || game.layout == 'long' || game.layout == 'long2') {
          ui.arena.classList.add('slim_player');
        }
        else {
          ui.arena.classList.remove('slim_player');
        }
        if (lib.config.player_border == 'normal' && lib.config.mode != 'brawl' && (game.layout == 'long' || game.layout == 'long2')) {
          ui.arena.classList.add('lslim_player');
        }
        else {
          ui.arena.classList.remove('lslim_player');
        }
        if (lib.config.player_border == 'slim') {
          ui.arena.classList.add('uslim_player');
        }
        else {
          ui.arena.classList.remove('uslim_player');
        }
        if (lib.config.player_border == 'narrow') {
          ui.arena.classList.add('mslim_player');
        }
        else {
          ui.arena.classList.remove('mslim_player');
        }
        ui.updatej();
        ui.updatem();
        setTimeout(function () {
          ui.arena.show();
          if (game.me) game.me.update();
          setTimeout(function () {
            ui.updatex();
          }, 500);
          setTimeout(function () {
            ui.updatec();
          }, 1000);
        }, 100);
      }, 500);
    },
    /**
     * 保存当前的背景图片
     * @function
     */
    background: function () {
      if (lib.config.image_background_random) {
        var list = [];
        for (var i in lib.configMenu.appearence.config.image_background.item) {
          if (i == 'default') continue;
          list.push(i);
        }
        list.remove(lib.config.image_background);
        localStorage.setItem(lib.configprefix + 'background', JSON.stringify(list));
      }
      else if (lib.config.image_background && lib.config.image_background != 'default' && lib.config.image_background.indexOf('custom_') != 0) {
        localStorage.setItem(lib.configprefix + 'background', lib.config.image_background);
      }
      else if (lib.config.image_background == 'default' && lib.config.theme == 'simple') {
        localStorage.setItem(lib.configprefix + 'background', 'ol_bg');
      }
      else {
        localStorage.removeItem(lib.configprefix + 'background');
      }
    },
    parsex: function (func) {
      var k;
      var str = '(';
      str += func.toString();
      if (str.indexOf('step 0') == -1) {
        str = str.replace(/\{/, '{{if(Evt.step==1) {Evt.finish();return;}');
      }
      else {
        for (k = 1; k < 99; k++) {
          if (str.indexOf('step ' + k) == -1) break;
          str = str.replace(new RegExp("'step " + k + "'", 'g'), "break;case " + k + ":");
          str = str.replace(new RegExp('"step ' + k + '"', 'g'), "break;case " + k + ":");
        }
        str = str.replace(/'step 0'|"step 0"/, 'if(Evt.step==' + k + ') {Evt.finish();return;}switch(step){case 0:');
      }
      str += '})';
      return str;
    },
    parse: function (func) {
      let str = ''
      if (Array.isArray(func)) {
        str += `if(Evt.step==${func.length}) {Evt.finish();return;}switch(step){`
        for (let i = 0; i < func.length; i++) {
          let f = func[i].toString().replace(/galgame\./g, 'game.galgame.').replace(/event/g, 'Evt').replace(/([\.\w])Evt/g, '$1event')
          str += `case ${i}:${f.slice(f.indexOf('{'))}break;`
        }
        str += `}`
      }
      else {
        str += func.toString();
        //galgame调整
        // str = str.replace(/(?<!\.)galgame(?=\.)/g, 'game.galgame').replace(/(?<![\.'])event(?!:)/g, 'Evt');
        str = str.replace(/galgame\./g, 'game.galgame.').replace(/event/g, 'Evt').replace(/event/g, 'Evt').replace(/([\.\w])Evt/g, '$1event');
        str = str.slice(str.indexOf('{') + 1);
        if (str.indexOf('step 0') == -1) {
          str = `{if(Evt.step==1) {Evt.finish();return;}${str}`;
        }
        else {
          // str = str.replace(/['"]step ([1-9]\d*)['"]/g, `break;case $1:`);
          for (var k = 1; k < 99; k++) {
            if (str.indexOf('step ' + k) == -1) break;
            str = str.replace(new RegExp(`'step ${k}'`, 'g'), `break;case ${k}:`);
            str = str.replace(new RegExp(`"step ${k}"`, 'g'), `break;case ${k}:`);
          }
          str = str.replace(/'step 0'|"step 0"/, `if(Evt.step==${k}) {Evt.finish();return;}switch(step){case 0:`);
        }
      }
      return (new Function('Evt', 'step', 'source', 'player', 'target', 'targets',
        'card', 'cards', 'skill', 'forced', 'num', 'trigger', 'result',
        '_status', 'lib', 'game', 'ui', 'get', 'ai', str));
    },
    /**
     * 执行一个，或一组无参函数，并返回结果；如果是`{a:function(){}, b:function(){}}`的形式，返回`{a: any, b: any}`作为结果
     * @function
     * @param {(function():any|Object<string, function():any>)} func 要执行的函数/函数组
     * @returns {(any|Object<string, any>)}
     */
    eval: function (func) {
      if (typeof func == 'function') {
        return eval('(' + func.toString() + ')');
      }
      else if (typeof func == 'object') {
        for (var i in func) {
          if (func.hasOwnProperty(i)) {
            func[i] = init.eval(func[i]);
          }
        }
      }
      return func;
    },
    /**
     * 加密文本
     * @function
     * @param {string} strUni 原文本
     * @returns 加密文本
     */
    encode: function (strUni) {
      var strUtf = strUni.replace(
        /[\u0080-\u07ff]/g, function (c) {
          var cc = c.charCodeAt(0);
          return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);
        });
      strUtf = strUtf.replace(
        /[\u0800-\uffff]/g, function (c) {
          var cc = c.charCodeAt(0);
          return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);
        });
      return btoa(strUtf);
    },
    /**
     * 解密
     * @function
     * @param {string} str 加密文本
     * @returns {string} 原文本
     */
    decode: function (str) {
      var strUtf = atob(str);
      var strUni = strUtf.replace(
        /[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g, function (c) {
          var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);
          return String.fromCharCode(cc);
        });
      strUni = strUni.replace(
        /[\u00c0-\u00df][\u0080-\u00bf]/g, function (c) {
          var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;
          return String.fromCharCode(cc);
        });
      return strUni;
    },
    /**
     * js对象转为json字符串
     * @function
     * @returns {!string} 
     */
    stringify: function (obj) {
      var str = '{'
      for (var i in obj) {
        str += '"' + i + '":'
        if (Object.prototype.toString.call(obj[i]) == '[object Object]') {
          str += init.stringify(obj[i]);
        }
        else if (typeof obj[i] == 'function') {
          str += obj[i].toString();
        }
        else {
          str += JSON.stringify(obj[i]);
        }
        str += ','
      }
      str += '}';
      return str;
    },
    /**
     * 技能对象转为json字符串
     * @function
     * @returns {!string} 
     */
    stringifySkill: function (obj) {
      var str = '';
      for (var i in obj) {
        str += i + ':'
        if (Object.prototype.toString.call(obj[i]) == '[object Object]') {
          str += '{\n' + init.stringifySkill(obj[i]) + '}';
        }
        else if (typeof obj[i] == 'function') {
          str += obj[i].toString().replace(/\t/g, '');
        }
        else {
          str += JSON.stringify(obj[i]);
        }
        str += ',\n'
      }
      return str;
    }
  }
  return init
}

/***/ }),

/***/ 717:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
   uiFun: (vkCore) => {
      let { game, ui, get, ai, lib, _status } = vkCore
      return {
         updates: [],
         thrown: [],
         touchlines: [],
         todiscard: {},
         /**
          * 立即应用缓存的更改，回流页面
          * @param {HTMLElement} node DOM节点
          */
         refresh: function (node) {
            void window.getComputedStyle(node, null).getPropertyValue("opacity");
         },
         /**
          * 创建UI
          * @namespace
          */
         create: {
            connectRooms: function (list) {
               ui.rooms = [];
               ui.roombase = ui.create.dialog();
               ui.roombase.classList.add('fullwidth');
               ui.roombase.classList.add('fullheight');
               ui.roombase.classList.add('fixed');
               ui.roombase.classList.add('scroll1');
               ui.roombase.classList.add('scroll2');
               ui.roombase.classList.add('noupdate');
               for (var i = 0; i < list.length; i++) {
                  var player = ui.roombase.add('<div class="popup text pointerdiv" style="width:calc(100% - 10px);display:inline-block;white-space:nowrap">空房间</div>');
                  player.roomindex = i;
                  player.initRoom = lib.element.player.initRoom;
                  player.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.connectroom);
                  player.initRoom(list[i]);
                  ui.rooms.push(player);
               }
            },
            rarity: function (button) {
               var rarity = game.getRarity(button.link);
               if (rarity != 'common' && lib.config.show_rarity) {
                  var intro = button.node.intro;
                  intro.classList.add('showintro');
                  intro.style.fontFamily = 'yuanli';
                  intro.style.fontSize = '16px';
                  intro.style.bottom = '6px';
                  intro.style.left = '6px';
                  switch (rarity) {
                     case 'beginner': intro.dataset.nature = 'oceanm'; break;
                     case 'rare': intro.dataset.nature = 'thunderm'; break;
                     case 'epic': intro.dataset.nature = 'metalm'; break;
                     case 'legend': intro.dataset.nature = 'orangem'; break;
                     case 'junk': intro.dataset.nature = 'woodm'; break;
                  }
                  intro.innerHTML = get.translation(rarity);
               }
               if ((button.link == 'xushu' || button.link == 'xin_xushu') && button.node && button.node.name && button.node.group) {
                  if (button.classList.contains('newstyle')) {
                     button.node.name.dataset.nature = 'watermm';
                     button.node.group.dataset.nature = 'water';
                  }
                  else button.node.group.style.backgroundColor = get.translation('weiColor');
               }
            },
            /**
             * 创建`<div>`元素
             * @function
             * @param {?string} selectors 类选择器和id选择器的任意组合，用于设置创建元素的类和id；如果有id选择器，id选择器的数量不能超过一个；如果为null，不设置
             * @param {?string} innerHTML 创建元素内的HTML，如果为null，不设置
             * @param {?HTMLElement} parent 元素的父节点，如果为null，不设置父节点
             * @param {?number} referenceNode 参考子节点，新节点会插入在参考节点的前；如果为null，插入在最后
             * @param {?Object} style 参考{@link HTMLDivElement#css}，如果为null，不设置内联样式
             * @param {?number[]} offsets 元素定位，参考{@link HTMLDivElement#setPosition}
             * @param {?function} clickCallback 点击回调函数
             * @returns {HTMLDivElement} 返回生成的div
             */
            div: function () {
               var str, innerHTML, position, position2, style, divposition, listen;
               for (var i = 0; i < arguments.length; i++) {
                  if (typeof arguments[i] == 'string') {
                     if (typeof str == 'string') {
                        innerHTML = arguments[i];
                     }
                     else {
                        str = arguments[i];
                     }
                  }
                  else if (get.objtype(arguments[i]) == 'div' ||
                     get.objtype(arguments[i]) == 'table' ||
                     get.objtype(arguments[i]) == 'tr' ||
                     get.objtype(arguments[i]) == 'td' ||
                     get.objtype(arguments[i]) == 'body') position = arguments[i];
                  else if (typeof arguments[i] == 'number') position2 = arguments[i];
                  else if (get.itemtype(arguments[i]) == 'divposition') divposition = arguments[i];
                  else if (typeof arguments[i] == 'object') style = arguments[i];
                  else if (typeof arguments[i] == 'function') listen = arguments[i];
               }
               if (str == undefined) str = '';
               var node = document.createElement('div');
               for (var i = 0; i < str.length; i++) {
                  if (str[i] == '.') {
                     if (node.className.length != 0) {
                        node.className += ' ';
                     }
                     while (str[i + 1] != '.' && str[i + 1] != '#' && i + 1 < str.length) {
                        node.className += str[i + 1];
                        i++;
                     }
                  }
                  else if (str[i] == '#') {
                     while (str[i + 1] != '.' && str[i + 1] != '#' && i + 1 < str.length) {
                        node.id += str[i + 1];
                        i++;
                     }
                  }
               }
               if (position) {
                  if (typeof position2 == 'number' && position.childNodes.length > position2) {
                     position.insertBefore(node, position.childNodes[position2]);
                  }
                  else {
                     position.appendChild(node);
                  }
               }
               if (style) node.css(style);
               if (divposition) node.setPosition(divposition);
               if (innerHTML) node.innerHTML = innerHTML;
               if (listen) node.listen(listen);
               return node;
            },
            filediv: function () {
               var args = Array.from(arguments);
               var func = null;
               for (var i = 0; i < args.length; i++) {
                  if (typeof args[i] == 'function') {
                     func = args[i];
                     args.splice(i, 1);
                     break;
                  }
               }
               var div = ui.create.div.apply(this, args);
               var input = ui.create.node('input.fileinput');
               input.type = 'file';
               input.onchange = function (e) {
                  func.call(this, this.files[0], e);
               };
               div.appendChild(input);
               div.inputNode = input;
               return div;
            },
            node: function () {
               var tagName, str, innerHTML, position, position2, style, divposition, listen;
               for (var i = 0; i < arguments.length; i++) {
                  if (typeof arguments[i] == 'string') {
                     if (typeof tagName == 'string') {
                        innerHTML = arguments[i];
                     }
                     else {
                        tagName = arguments[i];
                     }
                  }
                  else if (get.objtype(arguments[i]) == 'div' ||
                     get.objtype(arguments[i]) == 'table' ||
                     get.objtype(arguments[i]) == 'tr' ||
                     get.objtype(arguments[i]) == 'td' ||
                     get.objtype(arguments[i]) == 'body') position = arguments[i];
                  else if (typeof arguments[i] == 'number') position2 = arguments[i];
                  else if (get.itemtype(arguments[i]) == 'divposition') divposition = arguments[i];
                  else if (typeof arguments[i] == 'object') style = arguments[i];
                  else if (typeof arguments[i] == 'function') listen = arguments[i];
               }
               if (tagName == undefined) {
                  tagName = 'div';
               }
               else {
                  var i1 = tagName.indexOf('.');
                  var i2 = tagName.indexOf('#');
                  if (i1 != -1 || i2 != -1) {
                     if (i2 != -1 && i2 < i1) {
                        i1 = i2;
                     }
                     str = tagName.slice(i1);
                     tagName = tagName.slice(0, i1);
                  }
               }
               var node = document.createElement(tagName);
               if (str) {
                  for (var i = 0; i < str.length; i++) {
                     if (str[i] == '.') {
                        if (node.className.length != 0) {
                           node.className += ' ';
                        }
                        while (str[i + 1] != '.' && str[i + 1] != '#' && i + 1 < str.length) {
                           node.className += str[i + 1];
                           i++;
                        }
                     }
                     else if (str[i] == '#') {
                        while (str[i + 1] != '.' && str[i + 1] != '#' && i + 1 < str.length) {
                           node.id += str[i + 1];
                           i++;
                        }
                     }
                  }
               }
               if (position) {
                  if (typeof position2 == 'number' && position.childNodes.length > position2) {
                     position.insertBefore(node, position.childNodes[position2]);
                  }
                  else {
                     position.appendChild(node);
                  }
               }
               if (style) HTMLDivElement.prototype.css.call(node, style);
               if (divposition) HTMLDivElement.prototype.setPosition.call(node, divposition);
               if (innerHTML) node.innerHTML = innerHTML;
               if (listen) node.onclick = listen;
               return node;
            },
            iframe: function (src) {
               var layer = document.createElement('div');
               layer.classList.add('poplayer');
               layer.style.zIndex = '100';
               layer.listen(function () {
                  this.remove();
               });
               layer.style.background = 'white';

               var webview = document.createElement('iframe');
               webview.src = src;
               webview.style.width = '100%';
               webview.style.height = '100%';
               webview.style.left = '0px';
               webview.style.top = '0px';
               webview.style.position = 'absolute';
               webview.style.border = 'none';
               layer.appendChild(webview);

               var backbutton = ui.create.div('.menubutton.round', '返', layer, function () {
                  layer.remove();
               });
               backbutton.style.bottom = '10px';
               backbutton.style.right = '10px';
               backbutton.style.background = 'rgba(0,0,0,0.4)';
               backbutton.style.color = 'white';
               backbutton.style.textShadow = 'rgba(0,0,0,0.5) 0px 0px 2px';
               backbutton.style.boxShadow = 'rgba(0, 0, 0, 0.3) 0 0 0 1px, rgba(0, 0, 0, 0.3) 0 3px 10px';
               backbutton.style.position = 'fixed';

               ui.window.appendChild(layer);
            },
            identitycircle: function (list, target) {
               var container = ui.create.div('.identitycircle.menubg', target);
               var circle = ui.create.div(container);
               container.dataset.num = list.length;
               for (var i = 0; i < list.length; i++) {
                  var sec1 = ui.create.div(circle);
                  sec1.dataset.color = list[i];
                  var sec2 = ui.create.div(circle);
                  sec2.dataset.color = list[i];
                  var deg1 = 360 / list.length * i;
                  var deg2 = 0;
                  if (list.length == 2) {
                     deg2 = 90;
                  }
                  else if (list.length == 3) {
                     deg2 = 30;
                  }
                  sec1.style.transform = 'rotate(' + deg1 + 'deg)';
                  sec2.style.transform = 'rotate(' + (deg1 + deg2) + 'deg)';
               }
            },
            chat: function () {
               var chat = ui.create.system('聊天', null, true);
               ui.chatButton = chat;
               lib.setPopped(chat, ui.click.chat, 220);
            },
            exit: function () {
               if (!ui.exit) {
                  ui.exit = ui.create.control('退出房间', ui.click.exit);
               }
            },
            connecting: function (bool) {
               if (bool) {
                  ui.window.classList.remove('connecting');
                  if (ui.connecting) {
                     ui.connecting.delete();
                     delete ui.connecting;
                  }
               }
               else {
                  ui.window.classList.add('connecting');
                  ui.connecting = ui.create.div('.fullsize.connectlayer');
                  document.body.appendChild(ui.connecting);
                  ui.create.div('', '正在重连...', ui.connecting);
                  ui.connecting.splashtimeout = setTimeout(function () {
                     if (ui.connecting) {
                        delete ui.connecting.splashtimeout;
                     }
                  }, 300);
                  // setTimeout(function(){
                  //     if(ui.connecting){
                  //         ui.connecting.firstChild.show();
                  //     }
                  // },1000);
               }
            },
            roomInfo: function () {
               var chat = ui.create.system(game.online ? '房间信息' : '房间设置', function () {
                  if (!game.online || game.onlinezhu) {
                     ui.click.connectMenu();
                  }
               }, true);
               ui.roomInfo = chat;
               lib.setPopped(chat, function () {
                  if (game.getRoomInfo) {
                     var uiintro = ui.create.dialog('hidden');
                     game.getRoomInfo(uiintro);
                     return uiintro;
                  }
               }, 180);
            },
            templayer: function (time) {
               if (typeof time != 'number' || isNaN(time) || time == Infinity) {
                  time = 500;
               }
               var templayer = ui.create.div('.popup-container', ui.window);
               setTimeout(function () {
                  templayer.remove();
               }, time);
            },
            selectlist: function (list, init, position, onchange) {
               var select = document.createElement('select');
               for (var i = 0; i < list.length; i++) {
                  var option = document.createElement('option');
                  if (Array.isArray(list[i])) {
                     option.value = list[i][0];
                     option.innerHTML = list[i][1];
                  }
                  else {
                     option.value = list[i];
                     option.innerHTML = list[i];
                  }
                  if (init == option.value) {
                     option.selected = 'selected';
                  }
                  select.appendChild(option);
               }
               if (position) {
                  position.appendChild(select);
               }
               if (onchange) {
                  select.onchange = onchange;
               }
               return select;
            },
            /**
             * 菜单创建
             * @param {*} connectMenu 
             */
            menu: function (connectMenu) {
               var menuTimeout = null;
               if (!connectMenu && !game.syncMenu) {
                  menuTimeout = setTimeout(lib.init.reset, 1000);
               }
               var menu, menuContainer;
               var startButton;
               var popupContainer;
               var closeMenu = function () {
                  if (popupContainer.noclose) {
                     popupContainer.noclose = false;
                     return;
                  }
                  popupContainer.classList.add('hidden');
                  if (popupContainer.onclose) {
                     popupContainer.onclose();
                  }
               };
               popupContainer = ui.create.div('.popup-container.hidden', ui.window, closeMenu);

               var openMenu = function (node, e, onclose) {
                  popupContainer.innerHTML = '';
                  var left = Math.round(e.clientX / game.documentZoom);
                  var zoom = get.is.phoneLayout ? 1.3 : 1;
                  popupContainer.appendChild(node);
                  // var rect=node.getBoundingClientRect();
                  if (node.classList.contains('visual')) {
                     // var num=node.querySelectorAll('.menu.visual>div').length;
                     // node.style.top=(e.y-node.offsetHeight/2+30)+'px';
                     for (var i = 0; i < node.childElementCount; i++) {
                        if (node.childNodes[i].update) {
                           node.childNodes[i].update();
                        }
                     }
                     // if(node.offsetTop<10){
                     //     node.style.top='10px';
                     // }
                  }
                  // else if(get.is.phoneLayout()&&rect.top*1.3+rect.height*1.3+20>ui.window.offsetHeight){
                  //     node.style.top=(ui.winheightdow.offsetHeight-20-rect.height*1.3)/1.3+'px';
                  // }
                  // if(e){
                  var height = node.offsetHeight;
                  var idealtop = e.clientY / game.documentZoom;
                  if (idealtop < 10) {
                     idealtop = 10;
                  }
                  else if ((idealtop + height) * zoom + 10 > ui.window.offsetHeight) {
                     idealtop = (ui.window.offsetHeight - 10) / zoom - height;
                  }
                  node.style.top = idealtop + 'px';
                  node.style.left = left + 'px';
                  // }

                  popupContainer.classList.remove('hidden');
                  popupContainer.onclose = onclose;
               };
               var clickToggle = function () {
                  if (this.classList.contains('disabled')) return;
                  this.classList.toggle('on');
                  var config = this._link.config;
                  if (config.onclick) {
                     if (config.onclick.call(this, this.classList.contains('on')) === false) {
                        this.classList.toggle('on');
                     }
                  }
                  if (config.update) {
                     config.update();
                  }
               };
               var clickSwitcher = function () {
                  if (this.classList.contains('disabled')) return;
                  var node = this;
                  this.classList.add('on');
                  if (this._link.menu) {
                     var pos1 = this.lastChild.getBoundingClientRect();
                     var pos2 = ui.window.getBoundingClientRect();
                     if (this._link.menu.classList.contains('visual')) {
                        openMenu(this._link.menu, {
                           clientX: pos1.left + pos1.width + 5 - pos2.left,
                           clientY: pos1.top - pos2.top
                        }, function () {
                           node.classList.remove('on');
                        });
                     }
                     else if (this._link.menu.childElementCount > 10) {
                        openMenu(this._link.menu, {
                           clientX: pos1.left + pos1.width + 5 - pos2.left,
                           clientY: Math.min((ui.window.offsetHeight - 400) / 2, pos1.top - pos2.top)
                        }, function () {
                           node.classList.remove('on');
                        });
                        lib.setScroll(this._link.menu);
                     }
                     else {
                        openMenu(this._link.menu, {
                           clientX: pos1.left + pos1.width + 5 - pos2.left,
                           clientY: pos1.top - pos2.top
                        }, function () {
                           node.classList.remove('on');
                        });
                     }
                  }
               };
               var clickContainer = function () {
                  menuContainer.classList.add('hidden');
                  if (connectMenu) {
                     if (_status.enteringroom) {
                        _status.enteringroom = false;
                     }
                     if (_status.creatingroom) {
                        _status.creatingroom = false;
                     }
                     ui.window.classList.remove('shortcutpaused');
                  }
                  else {
                     game.resume2();
                     if (game.onresume2) {
                        game.onresume2();
                     }
                     ui.arena.classList.remove('menupaused');
                     ui.historybar.classList.remove('menupaused');
                     ui.window.classList.remove('touchinfohidden');
                     ui.config2.classList.remove('pressdown2');
                  }
               };
               var clickMenuItem = function () {
                  var node = this.parentNode._link;
                  var config = node._link.config;
                  node._link.current = this.link;
                  var tmpName = node.lastChild.innerHTML;
                  node.lastChild.innerHTML = config.item[this._link];
                  if (config.onclick) {
                     if (config.onclick.call(node, this._link, this) === false) {
                        node.lastChild.innerHTML = tmpName;
                     }
                  }
                  if (config.update) {
                     config.update();
                  }
               };
               var createMenu = function (tabs, config) {
                  var createPage = function (position) {
                     var node = ui.create.div(position);
                     lib.setScroll(ui.create.div('.left.pane', node));
                     lib.setScroll(ui.create.div('.right.pane', node));
                     return node;
                  };
                  var menu = ui.create.div('.main.menu.dialog.popped.static', config.position, function (e) {
                     e.stopPropagation();
                  });
                  if (connectMenu) {
                     menu.classList.add('center');
                     menuContainer.classList.add('centermenu');
                  }
                  var menuTab = ui.create.div('.menu-tab', menu);
                  var menuTabBar = ui.create.div('.menu-tab-bar', menu);
                  menuTabBar.style.left = (config.bar || 0) + 'px';
                  if (Math.round(2 * game.documentZoom) < 2) {
                     menuTabBar.style.height = '3px';
                  }
                  var menuContent = ui.create.div('.menu-content', menu);
                  var clickTab = function () {
                     if (this.classList.contains('disabled')) return;
                     var active = this.parentNode.querySelector('.active');
                     if (active) {
                        active.classList.remove('active');
                        active._link.remove();
                     }
                     this.classList.add('active');
                     menuTabBar.style.transform = 'translateX(' + (this.getBoundingClientRect().left - this.parentNode.firstChild.getBoundingClientRect().left) / game.documentZoom + 'px)';
                     menuContent.appendChild(this._link);
                  };
                  ui.click.menuTab = function (tab) {
                     for (var i = 0; i < menuTab.childNodes.length; i++) {
                        if (menuTab.childNodes[i].innerHTML == tab) {
                           clickTab.call(menuTab.childNodes[i]);
                           return;
                        }
                     }
                  };
                  var pages = [];
                  for (var i = 0; i < tabs.length; i++) {
                     var active = (i === (config.init || 0));
                     pages[i] = createPage(active ? menuContent : null);
                     ui.create.div(active ? '.active' : '', tabs[i], menuTab, clickTab)._link = pages[i];
                  }
                  return {
                     menu: menu,
                     pages: pages
                  };
               };
               var createConfig = function (config, position) {
                  var node = ui.create.div('.config', config.name);
                  node._link = { config: config };
                  if (!config.clear) {
                     if (config.name != '开启') {
                        if (config.name == '屏蔽弱将') {
                           config.intro = '强度过低的武将（孙策除外）不会出现在选将框，也不会被AI选择'
                        }
                        else if (config.name == '屏蔽强将') {
                           config.intro = '强度过高的武将不会出现在选将框，也不会被AI选择'
                        }
                        else if (!config.intro) {
                           config.intro = '设置' + config.name;
                        }
                        lib.setIntro(node, function (uiintro) {
                           if (lib.config.touchscreen) _status.dragged = true;
                           uiintro.style.width = '170px';
                           var str = config.intro;
                           if (typeof str == 'function') {
                              str = str();
                           }
                           uiintro._place_text = uiintro.add('<div class="text" style="display:inline">' + str + '</div>');
                        });
                     }
                  }
                  else {
                     node.innerHTML = '<span>' + config.name + '</span>';
                     if (!config.nopointer) {
                        node.classList.add('pointerspan');
                     }
                  }
                  if (config.item) {
                     if (typeof config.item == 'function') {
                        config.item = config.item();
                     }
                     if (Array.isArray(config.init)) {

                     }
                     else {
                        node.classList.add('switcher');
                        node.listen(clickSwitcher);
                        node._link.choosing = ui.create.div('', config.item[config.init], node);
                        node._link.menu = ui.create.div('.menu');
                        if (config.visualMenu) {
                           node._link.menu.classList.add('visual');
                           var updateVisual = function () {
                              config.visualMenu(this, this._link, config.item[this._link], config);
                           };
                           var createNode = function (i, before) {
                              var visualMenu = ui.create.div();
                              if (config.visualBar) {
                                 if (before) {
                                    node._link.menu.insertBefore(visualMenu, before);
                                 }
                                 else {
                                    node._link.menu.insertBefore(visualMenu, node._link.menu.lastChild);
                                 }
                              }
                              else {
                                 node._link.menu.appendChild(visualMenu);
                              }
                              ui.create.div('.name', get.verticalStr(config.item[i]), visualMenu);
                              visualMenu._link = i;
                              if (config.visualMenu(visualMenu, i, config.item[i], config) !== false) {
                                 visualMenu.listen(clickMenuItem);
                              }
                              visualMenu.update = updateVisual;
                           };
                           if (config.visualBar) {
                              var visualBar = ui.create.div(node._link.menu, function () {
                                 this.parentNode.parentNode.noclose = true;
                              });
                              node._link.menu.classList.add('withbar');
                              config.visualBar(visualBar, config.item, createNode, node);
                              visualBar.update = function () {
                                 config.visualBar(visualBar, config.item, createNode, node);
                              }
                           }
                           for (var i in config.item) {
                              createNode(i);
                           }
                           lib.setScroll(node._link.menu);
                           node._link.menu.updateBr = function () {
                              var br = Array.from(this.querySelectorAll('.menu.visual>br'));
                              while (br.length) {
                                 br.shift().remove();
                              }
                              var split = [];
                              for (var i = 1; i < this.childElementCount; i++) {
                                 if (i % 3 == 0) {
                                    split.push(this.childNodes[i]);
                                 }
                              }
                              for (var i = 0; i < split.length; i++) {
                                 this.insertBefore(ui.create.node('br'), split[i]);
                              }
                           }
                           node._link.menu.updateBr();
                        }
                        else {
                           for (var i in config.item) {
                              var textMenu = ui.create.div('', config.item[i], node._link.menu, clickMenuItem);
                              textMenu._link = i;
                              if (config.textMenu) {
                                 config.textMenu(textMenu, i, config.item[i], config)
                              }
                              lib.setScroll(node._link.menu);
                           }
                        }
                        node._link.menu._link = node;
                        node._link.current = config.init;
                     }
                  }
                  else if (config.range) {

                  }
                  else if (config.clear) {
                     if (node.innerHTML.length >= 15) node.style.height = 'auto';
                     node.listen(clickToggle);
                  }
                  else if (config.input) {
                     node.classList.add('switcher');
                     var input = ui.create.div(node);
                     if (!config.fixed) {
                        input.contentEditable = true;
                        input.style.webkitUserSelect = 'text';
                     }
                     input.style.minWidth = '10px';
                     input.onkeydown = function (e) {
                        if (e.keyCode == 13) {
                           e.preventDefault();
                           e.stopPropagation();
                           input.blur();
                        }
                     };
                     if (config.name == '联机昵称') {
                        input.innerHTML = config.init || '无名玩家';
                        input.onblur = function () {
                           input.innerHTML = input.innerHTML.replace(/<br>/g, '');
                           if (!input.innerHTML || get.is.banWords(input.innerHTML)) {
                              input.innerHTML = '无名玩家';
                           }
                           input.innerHTML = input.innerHTML.slice(0, 12);
                           game.saveConfig('connect_nickname', input.innerHTML);
                           game.saveConfig('connect_nickname', input.innerHTML, 'connect');
                        }
                     }
                     else if (config.name == '联机大厅') {
                        input.innerHTML = config.init || lib.hallURL;
                        input.onblur = function () {
                           if (!input.innerHTML) {
                              input.innerHTML = lib.hallURL;
                           }
                           input.innerHTML = input.innerHTML.replace(/<br>/g, '');
                           game.saveConfig('hall_ip', input.innerHTML, 'connect');
                        }
                     }
                     else {
                        input.innerHTML = config.init;
                        input.onblur = config.onblur;
                     }
                  }
                  else {
                     node.classList.add('toggle');
                     node.listen(clickToggle);
                     ui.create.div(ui.create.div(node));
                     if (config.init == true) {
                        node.classList.add('on');
                     }
                  }
                  if (position) {
                     position.appendChild(node);
                  }
                  return node;
               };
               var updateActive, updateActiveCard;
               var menuUpdates = [];
               menuContainer = ui.create.div('.menu-container.hidden', ui.window, clickContainer);
               var menux;
               if (!connectMenu) {
                  ui.menuContainer = menuContainer;
                  ui.click.configMenu = function () {
                     ui.click.shortcut(false)
                     if (menuContainer.classList.contains('hidden')) {
                        ui.config2.classList.add('pressdown2');
                        ui.arena.classList.add('menupaused');
                        ui.historybar.classList.add('menupaused');
                        ui.window.classList.add('touchinfohidden');
                        menuContainer.classList.remove('hidden');
                        for (var i = 0; i < menuUpdates.length; i++) {
                           menuUpdates[i]();
                        }
                     }
                     else {
                        clickContainer.call(menuContainer);
                     }
                  }
                  menux = createMenu(['开始', '选项', '武将', '卡牌', '扩展', '其它'], {
                     position: menuContainer, bar: 40
                  });
               }
               else {
                  ui.connectMenuContainer = menuContainer;
                  ui.click.connectMenu = function () {
                     if (menuContainer.classList.contains('hidden')) {
                        if (_status.waitingForPlayer) {
                           startButton.innerHTML = '设';
                           var start = menux.pages[0].firstChild;
                           for (var i = 0; i < start.childNodes.length; i++) {
                              if (start.childNodes[i].mode != lib.configOL.mode) {
                                 start.childNodes[i].classList.add('unselectable');
                                 start.childNodes[i].classList.remove('active');
                                 start.childNodes[i].link.remove();
                              }
                              else {
                                 start.childNodes[i].classList.add('active');
                                 start.nextSibling.appendChild(start.childNodes[i].link);
                              }
                           }
                        }
                        ui.window.classList.add('shortcutpaused');
                        menuContainer.classList.remove('hidden');
                        for (var i = 0; i < menuUpdates.length; i++) {
                           menuUpdates[i]();
                        }
                     }
                     else {
                        clickContainer.call(menuContainer);
                     }
                  }

                  menux = createMenu(['模式', '武将', '卡牌'], {
                     position: menuContainer, bar: 123
                  });
                  menu = menux.menu;
               }
               var menuxpages = menux.pages.slice(0);

               var copyObj = get.copy;

               (function () {
                  var start = menuxpages.shift();
                  var rightPane = start.lastChild;

                  startButton = ui.create.div('.menubutton.round.highlight', '启', start, function () {
                     if (this.animating || this.classList.contains('dim')) {
                        return;
                     }
                     var active = this.parentNode.querySelector('.active');
                     if (active) {
                        if (connectMenu) {
                           if (_status.waitingForPlayer) {
                              var config = {};
                              for (var i in lib.mode[lib.configOL.mode].connect) {
                                 if (i == 'update') continue;
                                 config[i.slice(8)] = get.config(i, lib.configOL.mode);
                              }
                              if (game.online) {
                                 if (game.onlinezhu) {
                                    game.send('changeRoomConfig', config);
                                 }
                              }
                              else {
                                 game.broadcastAll(function (config) {
                                    for (var i in config) {
                                       lib.configOL[i] = config[i];
                                    }
                                 }, config);
                                 if (lib.configOL.mode == 'identity' && lib.configOL.identity_mode == 'zhong' && game.connectPlayers) {
                                    for (var i = 0; i < game.connectPlayers.length; i++) {
                                       game.connectPlayers[i].classList.remove('unselectable2');
                                    }
                                    lib.configOL.number = 8;
                                    game.updateWaiting();
                                 }
                                 if (game.onlineroom) {
                                    game.send('server', 'config', lib.configOL);
                                 }
                                 game.connectPlayers[0].chat('房间设置已更改');
                              }
                           }
                           else if (_status.enteringroom || _status.creatingroom) {
                              lib.configOL.mode = active.mode;
                              if (_status.enteringroomserver) {
                                 game.saveConfig('connect_mode', lib.configOL.mode);

                                 var config = {};
                                 for (var i in lib.mode[lib.configOL.mode].connect) {
                                    if (i == 'update') continue;
                                    config[i.slice(8)] = get.config(i, lib.configOL.mode);
                                 }

                                 config.characterPack = lib.connectCharacterPack.slice(0);
                                 config.cardPack = lib.connectCardPack.slice(0);
                                 for (var i = 0; i < lib.config.connect_characters.length; i++) {
                                    config.characterPack.remove(lib.config.connect_characters[i]);
                                 }
                                 for (var i = 0; i < lib.config.connect_cards.length; i++) {
                                    config.cardPack.remove(lib.config.connect_cards[i]);
                                 }
                                 config.banned = lib.config['connect_' + active.mode + '_banned'];
                                 config.bannedcards = lib.config['connect_' + active.mode + '_bannedcards'];
                                 game.send('server', 'create', game.onlineKey, get.connectNickname(), lib.config.connect_avatar, config, active.mode);
                              }
                              else {
                                 game.send('server', 'create', game.onlineKey, get.connectNickname(), lib.config.connect_avatar);
                              }
                           }
                           else {
                              localStorage.setItem(lib.configprefix + 'directstart', true);
                              game.saveConfig('directstartmode', active.mode);
                              game.saveConfig('mode', 'connect');
                              ui.exitroom = ui.create.system('退出房间', function () {
                                 game.saveConfig('directstartmode');
                                 game.reload();
                              }, true);
                              game.switchMode(active.mode);
                           }
                           clickContainer.call(menuContainer);
                        }
                        else {
                           game.saveConfig('mode', active.mode);
                           localStorage.setItem(lib.configprefix + 'directstart', true);
                           game.reload();
                        }
                     }
                  });

                  var clickMode = function () {
                     if (this.classList.contains('unselectable')) return;
                     var active = this.parentNode.querySelector('.active');
                     if (active === this) {
                        return;
                     }
                     active.classList.remove('active');
                     active.link.remove();
                     active = this;
                     this.classList.add('active');
                     rightPane.appendChild(this.link);
                     if (connectMenu) {
                        if (updateActive) updateActive();
                        if (updateActiveCard) updateActiveCard();
                     }
                  };

                  var createModeConfig = function (mode, position) {
                     var info = lib.mode[mode];
                     var page = ui.create.div('');
                     var node = ui.create.div('.menubutton.large', info.name, position, clickMode);
                     node.link = page;
                     node.mode = mode;
                     if (connectMenu) {
                        if (mode == lib.config.connect_mode) {
                           node.classList.add('active');
                        }
                     }
                     else {
                        if (mode == lib.config.mode) {
                           node.classList.add('active');
                        }
                     }
                     var map = {};
                     var infoconfig = connectMenu ? info.connect : info.config;
                     if (infoconfig) {
                        var hiddenNodes = [];
                        var config = lib.config.mode_config[mode] || {};
                        if (connectMenu) {
                           infoconfig.connect_choose_timeout = {
                              name: '出牌时限',
                              init: '30',
                              item: {
                                 '10': '10秒',
                                 '15': '15秒',
                                 '30': '30秒',
                                 '60': '60秒',
                                 '90': '90秒',
                              },
                              connect: true,
                              frequent: true
                           };
                           infoconfig.connect_chooseCharacter_timeout = {
                              name: '五倍选将时间',
                              init: true,
                              connect: true,
                              intro: function () {
                                 return '将选将阶段（包括选择是否使用手气牌）的时间翻五倍';
                              },
                           };
                           infoconfig.connect_observe = {
                              name: '允许旁观',
                              init: true,
                              connect: true
                           };
                           infoconfig.connect_observe_handcard = {
                              name: '允许观看手牌',
                              init: false,
                              connect: true
                           };
                           infoconfig.connect_protect_beginner = {
                              name: '保护新手模式',
                              init: true,
                              connect: true,
                              intro: function () {
                                 return '开启保护新手模式时，化鲸包、测试包、特殊包和一些上手难度较高的角色不会出现在选将框中，卡包限制在标准与军争之内，不能进行升阶';
                              },
                           };
                           infoconfig.connect_observe_race = {
                              name: '比赛模式',
                              init: false,
                              connect: true,
                              intro: function () {
                                 return '开启比赛模式后，游戏内的座次始终等于玩家进入房间的顺序';
                              },
                           };
                        }
                        for (var j in infoconfig) {
                           if (j === 'update') {
                              continue;
                           }
                           var cfg = copyObj(infoconfig[j]);
                           cfg._name = j;
                           cfg.mode = mode;
                           if (!config.hasOwnProperty(j)) {
                              game.saveConfig(j, cfg.init, mode);
                           }
                           else {
                              cfg.init = config[j];
                           }
                           if (!cfg.onclick) {
                              cfg.onclick = function (result) {
                                 var cfg = this._link.config;
                                 game.saveConfig(cfg._name, result, mode);
                                 if (cfg.onsave) {
                                    cfg.onsave.call(this, result);
                                 }
                                 if (!_status.connectMode || game.online) {
                                    if (typeof cfg.restart == 'function') {
                                       if (cfg.restart()) {
                                          startButton.classList.add('glowing');
                                       }
                                    }
                                    else if (cfg.restart) {
                                       startButton.classList.add('glowing');
                                    }
                                 }
                              };
                           }
                           if (infoconfig.update) {
                              cfg.update = function () {
                                 infoconfig.update(config, map);
                              };
                           }
                           var cfgnode = createConfig(cfg);
                           map[j] = cfgnode;
                           if (cfg.frequent) {
                              page.appendChild(cfgnode);
                           }
                           else {
                              cfgnode.classList.add('auto-hide');
                              hiddenNodes.push(cfgnode);
                           }
                        }
                        if (!connectMenu) {
                           var move = ui.create.div('.auto-hide.config', '<div style="margin-right:10px" class="pointerdiv">上移↑</div><div class="pointerdiv">下移↓</div>');
                           move.firstChild.listen(function () {
                              if (node.previousSibling) {
                                 node.parentNode.insertBefore(node, node.previousSibling);
                                 var order = [];
                                 for (var i = 0; i < node.parentNode.childNodes.length; i++) {
                                    order.push(node.parentNode.childNodes[i].mode);
                                 }
                                 game.saveConfig('modeorder', order);
                              }
                           });
                           move.lastChild.listen(function () {
                              if (node.nextSibling) {
                                 if (node.nextSibling.nextSibling) {
                                    node.parentNode.insertBefore(node, node.nextSibling.nextSibling);
                                 }
                                 else {
                                    node.parentNode.insertBefore(node.nextSibling, node);
                                 }
                                 var order = [];
                                 for (var i = 0; i < node.parentNode.childNodes.length; i++) {
                                    order.push(node.parentNode.childNodes[i].mode);
                                 }
                                 game.saveConfig('modeorder', order);
                              }
                           });
                           hiddenNodes.push(move);
                        }
                        var expanded = false;
                        var hasexpand = true;
                        if (hiddenNodes.length) {
                           if (lib.config.fold_mode) {
                              var clickmore = function (type) {
                                 if (type === 'expand' && expanded) return;
                                 if (type === 'unexpand' && !expanded) return;
                                 if (expanded) {
                                    this.classList.remove('on');
                                    this.parentNode.classList.remove('expanded');
                                 }
                                 else {
                                    this.classList.add('on');
                                    this.parentNode.classList.add('expanded');
                                 }
                                 expanded = !expanded;
                              };
                              var morenodes = ui.create.div('.config.more', '更多 <div>&gt;</div>', page);
                              morenodes.listen(clickmore);
                              morenodes._onclick = clickmore;
                              page.morenodes = morenodes;
                           }
                           else {
                              page.classList.add('expanded');
                              if (!connectMenu) {
                                 page.classList.add('expanded2');
                              }
                           }
                           for (var k = 0; k < hiddenNodes.length; k++) {
                              page.appendChild(hiddenNodes[k]);
                           }
                        }
                        else {
                           hasexpand = false;
                        }
                        if (!connectMenu) {
                           var hidemode = ui.create.div('.config.pointerspan', '<span>隐藏此模式</span>', page, function () {
                              if (this.firstChild.innerHTML == '隐藏此模式') {
                                 this.firstChild.innerHTML = '此模式将在重启后隐藏';
                                 lib.config.hiddenModePack.add(mode);
                                 if (!lib.config.prompt_hidepack) {
                                    alert('隐藏的扩展包可通过选项-其它-重置隐藏内容恢复');
                                    game.saveConfig('prompt_hidepack', true);
                                 }
                              }
                              else {
                                 this.firstChild.innerHTML = '隐藏此模式';
                                 lib.config.hiddenModePack.remove(mode);
                              }
                              game.saveConfig('hiddenModePack', lib.config.hiddenModePack);
                           });
                           if (hasexpand) {
                              hidemode.classList.add('auto-hide');
                           }
                        }
                        if (infoconfig.update) {
                           infoconfig.update(config, map);
                           node.update = function () {
                              infoconfig.update(config, map);
                           }
                        }
                     }
                     if (connectMenu) {
                        menuUpdates.push(function () {
                           if (_status.waitingForPlayer) {
                              if (map.connect_player_number) {
                                 map.connect_player_number.style.display = 'none';
                              }
                              if (map.connect_versus_mode) {
                                 map.connect_versus_mode.style.display = 'none';
                              }
                           }
                        })
                     }
                     return node;
                  };
                  var modeorder = lib.config.modeorder || [];
                  for (var i in lib.mode) {
                     modeorder.add(i);
                  }
                  for (var i = 0; i < modeorder.length; i++) {
                     if (connectMenu) {
                        if (!lib.mode[modeorder[i]].connect) continue;
                        if (!lib.config['connect_' + modeorder[i] + '_banned']) {
                           lib.config['connect_' + modeorder[i] + '_banned'] = [];
                        }
                        if (!lib.config['connect_' + modeorder[i] + '_bannedcards']) {
                           lib.config['connect_' + modeorder[i] + '_bannedcards'] = [];
                        }
                     }
                     if (lib.config.all.mode.contains(modeorder[i])) {
                        createModeConfig(modeorder[i], start.firstChild);
                     }
                  }
                  var active = start.firstChild.querySelector('.active');
                  if (!active) {
                     active = start.firstChild.firstChild;
                     active.classList.add('active');
                  }
                  rightPane.appendChild(active.link);
                  if (lib.config.fold_mode) {
                     rightPane.addEventListener('mousewheel', function (e) {
                        var morenodes = this.firstChild.morenodes;
                        if (morenodes) {
                           if (e.wheelDelta < 0) {
                              morenodes._onclick.call(morenodes, 'expand');
                           }
                           else if (this.scrollTop == 0) {
                              morenodes._onclick.call(morenodes, 'unexpand');
                           }
                        }
                     }, { passive: true });
                  }
               }());

               (function () {
                  if (connectMenu) return;
                  var start = menuxpages.shift();
                  var rightPane = start.lastChild;

                  var clickMode = function () {
                     var active = this.parentNode.querySelector('.active');
                     if (active === this) {
                        return;
                     }
                     active.classList.remove('active');
                     active.link.remove();
                     active = this;
                     this.classList.add('active');
                     rightPane.appendChild(this.link);
                  };

                  var clickAutoSkill = function (bool) {
                     var name = this._link.config._name;
                     var list = lib.config.autoskilllist;
                     if (bool) {
                        list.remove(name);
                     }
                     else {
                        list.add(name);
                     }
                     game.saveConfig('autoskilllist', list);
                  };
                  var skilllistexpanded = game.expandSkills(lib.skilllist);
                  for (var i in lib.skill) {
                     if (!skilllistexpanded.contains(i)) continue;
                     if (lib.skill[i].frequent && lib.translate[i]) {
                        lib.configMenu.skill.config[i] = {
                           name: lib.translate[i + '_noconf'] || lib.translate[i],
                           init: true,
                           type: 'autoskill',
                           onclick: clickAutoSkill,
                           intro: lib.translate[i + '_info']
                        }
                     }
                  }
                  var clickBanSkill = function (bool) {
                     var name = this._link.config._name;
                     var list = lib.config.forbidlist;
                     if (bool) {
                        list.remove(name);
                     }
                     else {
                        list.add(name);
                     }
                     game.saveConfig('forbidlist', list);
                  };
                  var forbid = lib.config.forbid;
                  if (!lib.config.forbidlist) {
                     game.saveConfig('forbidlist', []);
                  }
                  for (var i = 0; i < forbid.length; i++) {
                     var skip = false;
                     var str = '';
                     var str2 = '';
                     var str3 = '';
                     for (var j = 0; j < forbid[i].length; j++) {
                        if (!lib.skilllist.contains(forbid[i][j])) {
                           skip = true;
                           break;
                        }
                        str += get.translation(forbid[i][j]) + '+';
                        str2 += forbid[i][j] + '+';
                        str3 += get.translation(forbid[i][j]) + '：' + lib.translate[forbid[i][j] + '_info'];
                        if (j < forbid[i].length - 1) {
                           str3 += '<div class="placeholder slim" style="display:block;height:8px"></div>';
                        }
                     }
                     if (skip) continue;
                     str = str.slice(0, str.length - 1);
                     str2 = str2.slice(0, str2.length - 1);

                     lib.configMenu.skill.config[str2] = {
                        name: str,
                        init: true,
                        type: 'banskill',
                        onclick: clickBanSkill,
                        intro: str3
                     }
                  }

                  var updateView = null;
                  var updateAppearence = null;
                  var createModeConfig = function (mode, position) {
                     var info = lib.configMenu[mode];
                     var page = ui.create.div('');
                     var node = ui.create.div('.menubutton.large', info.name, position, clickMode);
                     node.link = page;
                     node.mode = mode;
                     var map = {};
                     if (info.config) {
                        var hiddenNodes = [];
                        var autoskillNodes = [];
                        var banskillNodes = [];
                        var custombanskillNodes = [];
                        var banskill;

                        if (mode == 'skill') {
                           var autoskillexpanded = false;
                           var banskillexpanded = false;
                           ui.create.div('.config.more', '自动发动 <div>&gt;</div>', page, function () {
                              if (autoskillexpanded) {
                                 this.classList.remove('on');
                                 for (var k = 0; k < autoskillNodes.length; k++) {
                                    autoskillNodes[k].style.display = 'none';
                                 }
                              }
                              else {
                                 this.classList.add('on');
                                 for (var k = 0; k < autoskillNodes.length; k++) {
                                    autoskillNodes[k].style.display = '';
                                 }
                              }
                              autoskillexpanded = !autoskillexpanded;
                           });
                           banskill = ui.create.div('.config.more', '双将禁配 <div>&gt;</div>', page, function () {
                              if (banskillexpanded) {
                                 this.classList.remove('on');
                                 for (var k = 0; k < banskillNodes.length; k++) {
                                    banskillNodes[k].style.display = 'none';
                                 }
                              }
                              else {
                                 this.classList.add('on');
                                 for (var k = 0; k < banskillNodes.length; k++) {
                                    banskillNodes[k].style.display = '';
                                 }
                              }
                              banskillexpanded = !banskillexpanded;
                           });

                           var banskilladd = ui.create.div('.config.indent', '<span class="pointerdiv">添加...</span>', page, function () {
                              this.nextSibling.classList.toggle('hidden');
                           });
                           banskilladd.style.display = 'none';
                           banskillNodes.push(banskilladd);

                           var banskilladdNode = ui.create.div('.config.indent.hidden.banskilladd', page);
                           banskilladdNode.style.display = 'none';
                           banskillNodes.push(banskilladdNode);

                           var matchBanSkill = function (skills1, skills2) {
                              if (skills1.length != skills2.length) return false;
                              for (var i = 0; i < skills1.length; i++) {
                                 if (!skills2.contains(skills1[i])) return false;
                              }
                              return true;
                           }
                           var deleteCustomBanSkill = function () {
                              for (var i = 0; i < lib.config.customforbid.length; i++) {
                                 if (matchBanSkill(lib.config.customforbid[i], this.parentNode.link)) {
                                    lib.config.customforbid.splice(i--, 1);
                                    break;
                                 }
                              }
                              game.saveConfig('customforbid', lib.config.customforbid);
                              this.parentNode.remove();
                           }
                           var createCustomBanSkill = function (skills) {
                              var node = ui.create.div('.config.indent.toggle');
                              node.style.display = 'none';
                              node.link = skills;
                              banskillNodes.push(node);
                              custombanskillNodes.push(node);
                              var str = get.translation(skills[0]);
                              for (var i = 1; i < skills.length; i++) {
                                 str += '+' + get.translation(skills[i]);
                              }
                              node.innerHTML = str;
                              var span = document.createElement('span');
                              span.classList.add('cardpiledelete');
                              span.innerHTML = '删除';
                              span.onclick = deleteCustomBanSkill;
                              node.appendChild(span);
                              page.insertBefore(node, banskilladdNode.nextSibling);
                              return node;
                           };
                           for (var i = 0; i < lib.config.customforbid.length; i++) {
                              createCustomBanSkill(lib.config.customforbid[i]);
                           }
                           (function () {
                              var list = [];
                              for (var i in lib.character) {
                                 if (lib.character[i][3].length)
                                    list.push([i, lib.translate[i]]);
                              }

                              list.sort(function (a, b) {
                                 a = a[0]; b = b[0];
                                 var aa = a, bb = b;
                                 if (aa.indexOf('_') != -1) {
                                    aa = aa.slice(aa.indexOf('_') + 1);
                                 }
                                 if (bb.indexOf('_') != -1) {
                                    bb = bb.slice(bb.indexOf('_') + 1);
                                 }
                                 if (aa != bb) {
                                    return aa > bb ? 1 : -1;
                                 }
                                 return a > b ? 1 : -1;
                              });

                              var list2 = [];
                              var skills = lib.character[list[0][0]][3];
                              for (var i = 0; i < skills.length; i++) {
                                 list2.push([skills[i], lib.translate[skills[i]]]);
                              }

                              var selectname = ui.create.selectlist(list, list[0], banskilladdNode);
                              selectname.onchange = function () {
                                 var skills = lib.character[this.value][3];
                                 skillopt.innerHTML = '';
                                 for (var i = 0; i < skills.length; i++) {
                                    var option = document.createElement('option');
                                    option.value = skills[i];
                                    option.innerHTML = lib.translate[skills[i]];
                                    skillopt.appendChild(option);
                                 }
                              };
                              selectname.style.maxWidth = '85px';
                              var skillopt = ui.create.selectlist(list2, list2[0], banskilladdNode);

                              var span = document.createElement('span');
                              span.innerHTML = '＋';
                              banskilladdNode.appendChild(span);
                              var br = document.createElement('br');
                              banskilladdNode.appendChild(br);

                              var selectname2 = ui.create.selectlist(list, list[0], banskilladdNode);
                              selectname2.onchange = function () {
                                 var skills = lib.character[this.value][3];
                                 skillopt2.innerHTML = '';
                                 for (var i = 0; i < skills.length; i++) {
                                    var option = document.createElement('option');
                                    option.value = skills[i];
                                    option.innerHTML = lib.translate[skills[i]];
                                    skillopt2.appendChild(option);
                                 }
                              };
                              selectname2.style.maxWidth = '85px';
                              var skillopt2 = ui.create.selectlist(list2, list2[0], banskilladdNode);
                              var confirmbutton = document.createElement('button');
                              confirmbutton.innerHTML = '确定';
                              banskilladdNode.appendChild(confirmbutton);

                              confirmbutton.onclick = function () {
                                 var skills = [skillopt.value, skillopt2.value];
                                 if (skills[0] == skills[1]) {
                                    skills.shift();
                                 }
                                 if (!lib.config.customforbid) return;
                                 for (var i = 0; i < lib.config.customforbid.length; i++) {
                                    if (matchBanSkill(lib.config.customforbid[i], skills)) return;
                                 }
                                 lib.config.customforbid.push(skills);
                                 game.saveConfig('customforbid', lib.config.customforbid);
                                 createCustomBanSkill(skills).style.display = '';
                              }
                           }());
                           page.style.paddingBottom = '10px';
                        }
                        var config = lib.config;
                        if (mode == 'appearence') {
                           updateAppearence = function () {
                              info.config.update(config, map);
                           };
                        }
                        else if (mode == 'view') {
                           updateView = function () {
                              info.config.update(config, map);
                           };
                        }
                        for (var j in info.config) {
                           if (j === 'update') {
                              continue;
                           }
                           var cfg = copyObj(info.config[j]);
                           cfg._name = j;
                           if (!config.hasOwnProperty(j)) {
                              if (cfg.type != 'autoskill' && cfg.type != 'banskill') {
                                 game.saveConfig(j, cfg.init);
                              }
                           }
                           else {
                              cfg.init = config[j];
                           }
                           if (!cfg.onclick) {
                              cfg.onclick = function (result) {
                                 var cfg = this._link.config;
                                 game.saveConfig(cfg._name, result);
                                 if (cfg.onsave) {
                                    cfg.onsave.call(this, result);
                                 }
                              };
                           }
                           if (info.config.update) {
                              if (mode == 'appearence' || mode == 'view') {
                                 cfg.update = function () {
                                    if (updateAppearence) {
                                       updateAppearence();
                                    }
                                    if (updateView) {
                                       updateView();
                                    }
                                 };
                              }
                              else {
                                 cfg.update = function () {
                                    info.config.update(config, map);
                                 };
                              }
                           }
                           var cfgnode = createConfig(cfg);
                           if (cfg.type == 'autoskill') {
                              autoskillNodes.push(cfgnode);
                              // cfgnode.style.transition='all 0s';
                              cfgnode.classList.add('indent');
                              // cfgnode.hide();
                              cfgnode.style.display = 'none';
                           }
                           else if (cfg.type == 'banskill') {
                              banskillNodes.push(cfgnode);
                              // cfgnode.style.transition='all 0s';
                              cfgnode.classList.add('indent');
                              // cfgnode.hide();
                              cfgnode.style.display = 'none';
                           }
                           if (j == 'import_data_button') {
                              ui.import_data_button = cfgnode;
                              cfgnode.hide();
                              cfgnode.querySelector('button').onclick = function () {
                                 var fileToLoad = this.previousSibling.files[0];
                                 if (fileToLoad) {
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                       var data = fileLoadedEvent.target.result;
                                       if (!data) return;
                                       try {
                                          data = JSON.parse(lib.init.decode(data));
                                          if (!data || typeof data != 'object') {
                                             throw ('err');
                                          }
                                          if (lib.db && (!data.config || !data.data)) {
                                             throw ('err');
                                          }
                                       }
                                       catch (e) {
                                          console.log(e);
                                          alert('导入失败');
                                          return;
                                       }
                                       alert('导入成功');
                                       if (!lib.db) {
                                          var noname_inited = localStorage.getItem('noname_inited');
                                          var onlineKey = localStorage.getItem(lib.configprefix + 'key');
                                          localStorage.clear();
                                          if (noname_inited) {
                                             localStorage.setItem('noname_inited', noname_inited);
                                          }
                                          if (onlineKey) {
                                             localStorage.setItem(lib.configprefix + 'key', onlineKey);
                                          }
                                          for (var i in data) {
                                             localStorage.setItem(i, data[i]);
                                          }
                                       }
                                       else {
                                          for (var i in data.config) {
                                             game.putDB('config', i, data.config[i]);
                                             lib.config[i] = data.config[i];
                                          }
                                          for (var i in data.data) {
                                             game.putDB('data', i, data.data[i]);
                                          }
                                       }
                                       lib.init.background();
                                       game.reload();
                                    };
                                    fileReader.readAsText(fileToLoad, "UTF-8");
                                 }
                              }
                           }
                           else if (j == 'import_music') {
                              cfgnode.querySelector('button').onclick = function () {
                                 if (_status.music_importing) return;
                                 _status.music_importing = true;
                                 var fileToLoad = this.previousSibling.files[0];
                                 if (fileToLoad) {
                                    if (!lib.config.customBackgroundMusic) lib.config.customBackgroundMusic = {};
                                    var name = fileToLoad.name;
                                    if (name.indexOf('.') != -1) {
                                       name = name.slice(0, name.indexOf('.'));
                                    }
                                    var link = (game.writeFile ? 'cdv_' : 'custom_') + name;
                                    if (lib.config.customBackgroundMusic[link]) {
                                       if (!confirm('已经存在文件名称相同的背景音乐，是否仍然要继续导入？')) { _status.music_importing = false; return };
                                       for (var i = 1; i < 1000; i++) {
                                          if (!lib.config.customBackgroundMusic[link + '_' + i]) {
                                             link = link + '_' + i; break;
                                          }
                                       }
                                    }
                                    var callback = function () {
                                       var nodexx = ui.background_music_setting;
                                       var nodeyy = nodexx._link.menu;
                                       var nodezz = nodexx._link.config;
                                       var musicname = link.slice(link.indexOf('_') + 1);
                                       game.prompt('###请输入音乐的名称###' + musicname, true, function (str) {
                                          if (str) musicname = str;
                                          lib.config.customBackgroundMusic[link] = musicname;
                                          lib.config.background_music = link;
                                          lib.config.all.background_music.add(link);
                                          game.saveConfig('background_music', link);
                                          game.saveConfig('customBackgroundMusic', lib.config.customBackgroundMusic);
                                          nodezz.item[link] = lib.config.customBackgroundMusic[link];
                                          var textMenu = ui.create.div('', lib.config.customBackgroundMusic[link], nodeyy, clickMenuItem, nodeyy.childElementCount - 2);
                                          textMenu._link = link;
                                          nodezz.updatex.call(nodexx, []);
                                          _status.music_importing = false;
                                          if (!_status._aozhan) game.playBackgroundMusic();
                                       });
                                    };
                                    if (game.writeFile) {
                                       game.writeFile(fileToLoad, 'audio/background', link + '.mp3', callback);
                                    }
                                    else {
                                       game.putDB('audio', link, fileToLoad, callback);
                                    }
                                 }
                              }
                           }
                           else if (j == 'extension_source') {
                              ui.extension_source = cfgnode;
                              cfgnode.updateInner = function () {
                                 this._link.choosing.innerHTML = lib.config.extension_source;
                              }
                           }
                           map[j] = cfgnode;
                           if (!cfg.unfrequent) {
                              if (cfg.type == 'autoskill') {
                                 page.insertBefore(cfgnode, banskill);
                              }
                              else {
                                 page.appendChild(cfgnode);
                              }
                           }
                           else {
                              // cfgnode.classList.add('auto-hide');
                              hiddenNodes.push(cfgnode);
                           }
                        }
                        if (hiddenNodes.length) {
                           page.classList.add('morenodes');
                           for (var k = 0; k < hiddenNodes.length; k++) {
                              page.appendChild(hiddenNodes[k]);
                           }
                        }
                        if (info.config.update) {
                           info.config.update(config, map);
                        }
                     }
                     return node;
                  };

                  for (var i in lib.configMenu) {
                     if (i != 'others') createModeConfig(i, start.firstChild);
                  }
                  createModeConfig('others', start.firstChild);

                  var active = start.firstChild.querySelector('.active');
                  if (!active) {
                     active = start.firstChild.firstChild;
                     active.classList.add('active');
                  }
                  rightPane.appendChild(active.link);
               }());

               (function () {
                  var start = menuxpages.shift();
                  var rightPane = start.lastChild;

                  var clickMode = function () {
                     var active = this.parentNode.querySelector('.active');
                     if (active) {
                        if (active === this) {
                           return;
                        }
                        active.classList.remove('active');
                        active.link.remove();
                     }
                     this.classList.add('active');
                     updateActive(this);
                     rightPane.appendChild(this.link);
                  };
                  updateActive = function (node) {
                     if (!node) {
                        node = start.firstChild.querySelector('.active');
                        if (!node) {
                           return;
                        }
                     }
                     for (var i = 0; i < node.link.childElementCount; i++) {
                        if (node.link.childNodes[i].updateBanned) {
                           node.link.childNodes[i].updateBanned();
                        }
                     }
                  };
                  var updateNodes = function () {
                     for (var i = 0; i < start.firstChild.childNodes.length; i++) {
                        var node = start.firstChild.childNodes[i];
                        if (node.link) {
                           if (node.mode.indexOf('mode_') == 0) continue;
                           if (node.mode == 'custom') continue;
                           if (connectMenu) {
                              if (!lib.config.connect_characters.contains(node.mode)) {
                                 node.classList.remove('off');
                                 node.link.firstChild.classList.add('on');
                              }
                              else {
                                 node.classList.add('off');
                                 node.link.firstChild.classList.remove('on');
                              }
                           }
                           else {
                              if (lib.config.characters.contains(node.mode)) {
                                 node.classList.remove('off');
                                 node.link.firstChild.classList.add('on');
                              }
                              else {
                                 node.classList.add('off');
                                 node.link.firstChild.classList.remove('on');
                              }
                           }
                        }
                     }
                  }
                  var togglePack = function (bool) {
                     var name = this._link.config._name;
                     if (connectMenu) {
                        if (!bool) {
                           lib.config.connect_characters.add(name);
                        }
                        else {
                           lib.config.connect_characters.remove(name);
                        }
                        game.saveConfig('connect_characters', lib.config.connect_characters);
                     }
                     else {
                        if (bool) {
                           lib.config.characters.add(name);
                        }
                        else {
                           lib.config.characters.remove(name);
                        }
                        game.saveConfig('characters', lib.config.characters);
                     }
                     updateNodes();
                  };

                  var createModeConfig = function (mode, position, position2) {
                     var info = lib.characterPack[mode];
                     var page = ui.create.div('');
                     var node = ui.create.div('.menubutton.large', lib.translate[mode + '_character_config'], position, clickMode);
                     if (node.innerHTML.length >= 5) {
                        node.classList.add('smallfont');
                     }
                     if (position2) {
                        position.insertBefore(node, position2);
                     }
                     node.link = page;
                     node.mode = mode;
                     page.node = node;
                     var list = [];
                     var boolAI = true;
                     var alterableSkills = [];
                     var alterableCharacters = [];
                     var charactersToAlter = [];
                     for (var i in info) {
                        if (info[i][4] && info[i][4].contains('unseen')) continue;
                        if (connectMenu && lib.connectBanned.contains(i)) continue;
                        if (connectMenu && lib.configOL.protect_beginner && get.is.banForBeginner(i)) return true;
                        list.push(i);
                        if (boolAI && !lib.config.forbidai_user.contains(i)) boolAI = false;
                        for (var j = 0; j < info[i][3].length; j++) {
                           if (!lib.skill[info[i][3][j]]) {
                              continue;
                           }
                           if (lib.skill[info[i][3][j]].alter) {
                              alterableSkills.add(info[i][3][j]);
                              alterableCharacters.add(i);
                              if (lib.config.vintageSkills.contains(info[i][3][j])) {
                                 charactersToAlter.add(i);
                              }
                           }
                        }
                     }
                     alterableCharacters.sort();
                     var getGroup = function (name) {
                        var group = get.is.double(name, true);
                        if (group) return group[0];
                        return lib.character[name][1];
                     },
                        groupSort = function (name) {
                           if (!lib.character[name]) return 50;
                           var group = getGroup(name);
                           if (group == 'vtuber') return 40;
                           if (group == 'clubs') return 41;
                           var list = get.groups();
                           if (list.contains(group)) return list.indexOf(group);
                           return 49;
                        };
                     list.sort(function (a, b) {
                        var del = groupSort(a) - groupSort(b);
                        if (del != 0) return del;
                        var aa = a, bb = b;
                        if (a.indexOf('_') != -1) {
                           a = a.slice(a.lastIndexOf('_') + 1);
                        }
                        if (b.indexOf('_') != -1) {
                           b = b.slice(b.lastIndexOf('_') + 1);
                        }
                        if (a != b) {
                           return a > b ? 1 : -1;
                        }
                        return aa > bb ? 1 : -1;
                     });
                     var list2 = list.slice(0);
                     var cfgnode = createConfig({
                        name: '开启',
                        _name: mode,
                        init: lib.config.characters.contains(mode),
                        onclick: togglePack
                     });
                     var cfgnodeAI = createConfig({
                        name: '仅点将可用',
                        _name: mode,
                        init: boolAI,
                        intro: '将该武将包内的武将全部设置为仅点将可用',
                        onclick: function (bool) {
                           if (bool) {
                              for (var i = 0; i < list.length; i++) {
                                 lib.config.forbidai_user.add(list[i]);
                              }
                           }
                           else {
                              for (var i = 0; i < list.length; i++) {
                                 lib.config.forbidai_user.remove(list[i]);
                              }
                           }
                           game.saveConfig('forbidai_user', lib.config.forbidai_user);
                        },
                     });
                     if (mode.indexOf('mode_') != 0) {
                        cfgnodeAI.style.marginTop = '0px';
                        page.appendChild(cfgnode);
                        page.appendChild(cfgnodeAI);
                        if (alterableCharacters.length) {
                           var cfgnode2 = createConfig({
                              name: '新版替换',
                              _name: mode,
                              init: charactersToAlter.length == 0,
                              intro: '以下武将将被修改：' + get.translation(alterableCharacters),
                              onclick: function (bool) {
                                 if (bool) {
                                    for (var i = 0; i < alterableSkills.length; i++) {
                                       lib.config.vintageSkills.remove(alterableSkills[i]);
                                       lib.translate[alterableSkills[i] + '_info'] = lib.translate[alterableSkills[i] + '_info_alter'];
                                    }
                                 }
                                 else {
                                    for (var i = 0; i < alterableSkills.length; i++) {
                                       lib.config.vintageSkills.add(alterableSkills[i]);
                                       lib.translate[alterableSkills[i] + '_info'] = lib.translate[alterableSkills[i] + '_info_origin'];
                                    }
                                 }
                                 game.saveConfig('vintageSkills', lib.config.vintageSkills);
                              }
                           });
                           cfgnode2.style.marginTop = '0px';
                           page.appendChild(cfgnode2);
                        }
                     }
                     else if (mode.indexOf('mode_extension') == 0) {
                        page.appendChild(cfgnodeAI);
                     }
                     else {
                        page.style.paddingTop = '8px';
                     }
                     var banCharacter = function (e) {
                        if (_status.clicked) {
                           _status.clicked = false;
                           return;
                        }
                        if (mode.indexOf('mode_') == 0 && mode.indexOf('mode_extension_') != 0 &&
                           mode != 'mode_favourite' && mode != 'mode_banned') {
                           if (!connectMenu && lib.config.show_charactercard) {
                              ui.click.charactercard(this.link, this, mode == 'mode_guozhan' ? 'guozhan' : true);
                           }
                           return;
                        }
                        ui.click.touchpop();
                        this._banning = connectMenu ? 'online' : 'offline';
                        if (!connectMenu && lib.config.show_charactercard) {
                           ui.click.charactercard(this.link, this);
                        }
                        else {
                           ui.click.intro.call(this, e);
                        }
                        _status.clicked = false;
                        delete this._banning;
                     };
                     var updateBanned = function () {
                        var list;
                        if (connectMenu) {
                           var mode = menux.pages[0].firstChild.querySelector('.active');
                           if (mode && mode.mode) {
                              list = lib.config['connect_' + mode.mode + '_banned'];
                           }
                        }
                        else {
                           list = lib.config[get.mode() + '_banned'];
                        }
                        if (list && list.contains(this.link)) {
                           this.classList.add('banned');
                        }
                        else {
                           this.classList.remove('banned');
                        }
                     };
                     if (lib.characterSort[mode]) {
                        var listb = [];
                        if (!connectMenu) {
                           listb = lib.config[get.mode() + '_banned'] || [];
                        }
                        else {
                           var modex = menux.pages[0].firstChild.querySelector('.active');
                           if (modex && modex.mode) {
                              listb = lib.config['connect_' + modex.mode + '_banned'];
                           }
                        }
                        for (var pak in lib.characterSort[mode]) {
                           var info = lib.characterSort[mode][pak];
                           var listx = [];
                           var boolx = false;
                           for (var ii = 0; ii < list2.length; ii++) {
                              if (info.contains(list2[ii])) {
                                 listx.add(list2[ii]);
                                 if (!listb.contains(list2[ii])) boolx = true;
                                 list2.splice(ii--, 1);
                              }
                           }
                           if (listx.length) {
                              var cfgnodeY = {
                                 name: lib.translate[pak],
                                 _name: pak,
                                 init: boolx,
                                 onclick: function (bool) {
                                    var banned = [];
                                    if (connectMenu) {
                                       var modex = menux.pages[0].firstChild.querySelector('.active');
                                       if (modex && modex.mode) {
                                          banned = lib.config['connect_' + modex.mode + '_banned'];
                                       }
                                    }
                                    else if (_status.connectMode) return;
                                    else banned = lib.config[get.mode() + '_banned'] || [];
                                    var listx = lib.characterSort[mode][this._link.config._name];
                                    if (bool) {
                                       for (var i = 0; i < listx.length; i++) {
                                          banned.remove(listx[i]);
                                       }
                                    }
                                    else {
                                       for (var i = 0; i < listx.length; i++) {
                                          banned.add(listx[i]);
                                       }
                                    }
                                    game.saveConfig(connectMenu ? ('connect_' + modex.mode + '_banned') : (get.mode() + '_banned'), banned);
                                    updateActive();
                                 },
                              };
                              if (mode.indexOf('mode_') == 0 && mode.indexOf('mode_extension_') != 0 && mode.indexOf('mode_guozhan') != 0) {
                                 cfgnodeY.clear = true;
                                 delete cfgnodeY.onclick;
                              }
                              var cfgnodeX = createConfig(cfgnodeY);
                              page.appendChild(cfgnodeX);
                              var buttons = ui.create.buttons(listx, 'character', page);
                              for (var i = 0; i < buttons.length; i++) {
                                 buttons[i].classList.add('noclick');
                                 buttons[i].listen(banCharacter);
                                 ui.create.rarity(buttons[i]);
                                 buttons[i].node.hp.style.transition = 'all 0s';
                                 buttons[i].node.hp._innerHTML = buttons[i].node.hp.innerHTML;
                                 if (mode != 'mode_banned') {
                                    buttons[i].updateBanned = updateBanned;
                                 }
                              }
                           }
                        }
                        if (list2.length) {
                           var cfgnodeX = createConfig({
                              name: '其他',
                              _name: 'others',
                              clear: true,
                           });
                           page.appendChild(cfgnodeX);
                           var buttons = ui.create.buttons(list2, 'character', page);
                           for (var i = 0; i < buttons.length; i++) {
                              buttons[i].classList.add('noclick');
                              buttons[i].listen(banCharacter);
                              ui.create.rarity(buttons[i]);
                              buttons[i].node.hp.style.transition = 'all 0s';
                              buttons[i].node.hp._innerHTML = buttons[i].node.hp.innerHTML;
                              if (mode != 'mode_banned') {
                                 buttons[i].updateBanned = updateBanned;
                              }
                           }
                        }
                     }
                     else {
                        var buttons = ui.create.buttons(list, 'character', page);
                        for (var i = 0; i < buttons.length; i++) {
                           buttons[i].classList.add('noclick');
                           ui.create.rarity(buttons[i]);
                           buttons[i].listen(banCharacter);
                           buttons[i].node.hp.style.transition = 'all 0s';
                           buttons[i].node.hp._innerHTML = buttons[i].node.hp.innerHTML;
                           if (mode != 'mode_banned') {
                              buttons[i].updateBanned = updateBanned;
                           }
                        }
                     }
                     page.classList.add('menu-buttons');
                     page.classList.add('leftbutton');
                     // if (!connectMenu) {
                     //     if (mode.indexOf('mode_') != 0) {
                     //         ui.create.div('.config.pointerspan', '<span>隐藏武将包</span>', page, function () {
                     //             if (this.firstChild.innerHTML == '隐藏武将包') {
                     //                 this.firstChild.innerHTML = '武将包将在重启后隐藏';
                     //                 lib.config.hiddenCharacterPack.add(mode);
                     //                 if (!lib.config.prompt_hidepack) {
                     //                     alert('隐藏的扩展包可通过选项-其它-重置隐藏内容恢复');
                     //                     game.saveConfig('prompt_hidepack', true);
                     //                 }
                     //             }
                     //             else {
                     //                 this.firstChild.innerHTML = '隐藏武将包';
                     //                 lib.config.hiddenCharacterPack.remove(mode);
                     //             }
                     //             game.saveConfig('hiddenCharacterPack', lib.config.hiddenCharacterPack);
                     //         });
                     //     }
                     // }
                     return node;
                  };
                  if (lib.config.show_favourite_menu && !connectMenu && Array.isArray(lib.config.favouriteCharacter)) {
                     lib.characterPack.mode_favourite = {};
                     for (var i = 0; i < lib.config.favouriteCharacter.length; i++) {
                        var favname = lib.config.favouriteCharacter[i];
                        if (lib.character[favname]) {
                           lib.characterPack.mode_favourite[favname] = lib.character[favname];
                        }
                     }
                     ui.favouriteCharacter = createModeConfig('mode_favourite', start.firstChild).link;
                     if (get.is.empty(lib.characterPack.mode_favourite)) {
                        ui.favouriteCharacter.node.style.display = 'none';
                     }
                     delete lib.characterPack.mode_favourite;
                  }
                  if (!connectMenu && lib.config.show_ban_menu) {
                     lib.characterPack.mode_banned = {};
                     for (var i = 0; i < lib.config.all.mode.length; i++) {
                        var banned = lib.config[lib.config.all.mode[i] + '_banned'];
                        if (banned) {
                           for (var j = 0; j < banned.length; j++) {
                              if (lib.character[banned[j]]) {
                                 lib.characterPack.mode_banned[banned[j]] = lib.character[banned[j]];
                              }
                           }
                        }
                     }
                     var bannednode = createModeConfig('mode_banned', start.firstChild);
                     if (get.is.empty(lib.characterPack.mode_banned)) {
                        bannednode.style.display = 'none';
                     }
                     delete lib.characterPack.mode_banned;
                  }
                  var characterlist = connectMenu ? lib.connectCharacterPack : lib.config.all.characters;
                  for (var i = 0; i < characterlist.length; i++) {
                     //if(['sololive'].contains(characterlist[i])) continue;
                     createModeConfig(characterlist[i], start.firstChild);
                  }
                  if (!connectMenu) {
                     for (var i in lib.characterPack) {
                        if (i.indexOf('mode_') == 0) {
                           createModeConfig(i, start.firstChild);
                        }
                     }
                  }
                  var active = start.firstChild.querySelector('.active');
                  if (!active) {
                     active = start.firstChild.firstChild;
                     if (active.style.display == 'none') {
                        active = active.nextSibling;
                        if (active.style.display == 'none') {
                           active = active.nextSibling;
                        }
                     }
                     active.classList.add('active');
                     updateActive(active);
                  }
                  rightPane.appendChild(active.link);

                  if (!connectMenu) {
                     var node1 = ui.create.div('.lefttext', '全部开启', start.firstChild, function () {
                        game.saveConfig('characters', lib.config.all.characters);
                        updateNodes();
                     });
                     var node2 = ui.create.div('.lefttext', '恢复默认', start.firstChild, function () {
                        game.saveConfig('characters', lib.config.defaultcharacters);
                        updateNodes();
                     });
                     node1.style.marginTop = '12px';
                     node2.style.marginTop = '7px';
                  }

                  updateNodes();
               }());

               (function () {
                  var start = menuxpages.shift();
                  var rightPane = start.lastChild;
                  var pileCreated = false;
                  var recreatePile = function () {
                     lib.config.customcardpile['当前牌堆'] = [lib.config.bannedpile, lib.config.addedpile];
                     game.saveConfig('customcardpile', lib.config.customcardpile);
                     game.saveConfig('cardpilename', '当前牌堆', true);
                     pileCreated = false;
                  };

                  var clickMode = function () {
                     var active = this.parentNode.querySelector('.active');
                     if (active === this) {
                        return;
                     }
                     active.classList.remove('active');
                     active.link.remove();
                     active = this;
                     this.classList.add('active');
                     updateActiveCard(this);
                     if (this.mode == 'cardpile') {
                        this.create();
                     }
                     rightPane.appendChild(this.link);
                  };
                  updateActiveCard = function (node) {
                     if (!node) {
                        node = start.firstChild.querySelector('.active');
                        if (!node) {
                           return;
                        }
                     }
                     for (var i = 0; i < node.link.childElementCount; i++) {
                        if (node.link.childNodes[i].updateBanned) {
                           node.link.childNodes[i].updateBanned();
                        }
                     }
                  };
                  var updateNodes = function () {
                     for (var i = 0; i < start.firstChild.childNodes.length; i++) {
                        var node = start.firstChild.childNodes[i];
                        if (node.link) {
                           if (node.mode.indexOf('mode_') == 0) continue;
                           if (node.mode == 'custom') continue;
                           if (node.mode == 'cardpile') continue;
                           if (connectMenu) {
                              if (!lib.config.connect_cards.contains(node.mode)) {
                                 node.classList.remove('off');
                                 node.link.firstChild.classList.add('on');
                              }
                              else {
                                 node.classList.add('off');
                                 node.link.firstChild.classList.remove('on');
                              }
                           }
                           else {
                              if (lib.config.cards.contains(node.mode)) {
                                 node.classList.remove('off');
                                 node.link.firstChild.classList.add('on');
                              }
                              else {
                                 node.classList.add('off');
                                 node.link.firstChild.classList.remove('on');
                              }
                           }
                        }
                     }
                  }
                  var togglePack = function (bool) {
                     var name = this._link.config._name;
                     if (connectMenu) {
                        if (!bool) {
                           lib.config.connect_cards.add(name);
                        }
                        else {
                           lib.config.connect_cards.remove(name);
                        }
                        game.saveConfig('connect_cards', lib.config.connect_cards);
                     }
                     else {
                        if (bool) {
                           lib.config.cards.add(name);
                        }
                        else {
                           lib.config.cards.remove(name);
                        }
                        game.saveConfig('cards', lib.config.cards);
                     }
                     updateNodes();
                  };
                  var toggleCardPile = function (bool) {
                     var name = this._link.config._name;
                     var number = this._link.config._number;
                     if (!lib.config.bannedpile[name]) {
                        lib.config.bannedpile[name] = [];
                     }
                     if (bool) {
                        lib.config.bannedpile[name].remove(number);
                     }
                     else {
                        lib.config.bannedpile[name].add(number);
                     }
                     recreatePile();
                  }

                  var createModeConfig = function (mode, position) {
                     var info = lib.cardPack[mode];
                     var page = ui.create.div('');
                     var node = ui.create.div('.menubutton.large', lib.translate[mode + '_card_config'], position, clickMode);
                     if (node.innerHTML.length >= 5) {
                        node.classList.add('smallfont');
                     }
                     node.link = page;
                     node.mode = mode;
                     var list = [];
                     for (var i = 0; i < info.length; i++) {
                        if (!lib.card[info[i]] || (lib.card[info[i]].derivation && mode != 'mode_derivation')) continue;
                        list.push(['', get.translation(get.type(info[i], 'trick')), info[i]]);
                     }
                     var sortCard = function (card) {
                        var type = lib.card[card[2]].type;
                        var subtype = lib.card[card[2]].subtype;
                        if (lib.cardType[subtype]) {
                           return lib.cardType[subtype];
                        }
                        if (lib.cardType[type]) {
                           return lib.cardType[type];
                        }
                        switch (type) {
                           case 'basic': return 0;
                           case 'chess': return 1.5;
                           case 'trick': return 2;
                           case 'delay': return 3;
                           case 'equip': {
                              switch (lib.card[card[2]].subtype) {
                                 case 'equip1': return 4.1;
                                 case 'equip2': return 4.2;
                                 case 'equip3': return 4.3;
                                 case 'equip4': return 4.4;
                                 case 'equip5': return 4.5;
                                 default: return 4;
                              }
                           }
                           case 'zhenfa': return 5;
                           default: return 6;
                        }
                     }
                     list.sort(function (a, b) {
                        var sort1 = sortCard(a);
                        var sort2 = sortCard(b);
                        if (sort1 == sort2) {
                           return (b[2] < a[2]) ? 1 : -1;
                        }
                        else if (sort1 > sort2) {
                           return 1;
                        }
                        else {
                           return -1;
                        }
                     });
                     var cfgnode = createConfig({
                        name: '开启',
                        _name: mode,
                        init: lib.config.cards.contains(mode),
                        onclick: togglePack
                     });
                     if (mode.indexOf('mode_') != 0) {
                        page.appendChild(cfgnode);
                     }
                     else {
                        page.style.paddingTop = '8px';
                     }
                     var banCard = function (e) {
                        if (_status.clicked) {
                           _status.clicked = false;
                           return;
                        }
                        if (mode.indexOf('mode_') == 0 && mode.indexOf('mode_extension_') != 0 && mode != 'mode_banned') {
                           return;
                        }
                        ui.click.touchpop();
                        this._banning = connectMenu ? 'online' : 'offline';
                        ui.click.intro.call(this, e);
                        _status.clicked = false;
                        delete this._banning;
                     };
                     var updateBanned = function () {
                        var list;
                        if (connectMenu) {
                           var mode = menux.pages[0].firstChild.querySelector('.active');
                           if (mode && mode.mode) {
                              list = lib.config['connect_' + mode.mode + '_bannedcards'];
                           }
                        }
                        else {
                           list = lib.config[get.mode() + '_bannedcards'];
                        }
                        if (list && list.contains(this.link[2])) {
                           this.classList.add('banned');
                        }
                        else {
                           this.classList.remove('banned');
                        }
                     };
                     var buttons = ui.create.buttons(list, 'vcard', page);
                     for (var i = 0; i < buttons.length; i++) {
                        buttons[i].classList.add('noclick');
                        buttons[i].listen(banCard);
                        if (mode != 'mode_banned') {
                           buttons[i].updateBanned = updateBanned;
                        }
                     }
                     page.classList.add('menu-buttons');
                     page.classList.add('leftbutton');
                     if (!connectMenu && mode.indexOf('mode_') != 0) {
                        ui.create.div('.config.pointerspan', '<span>隐藏卡牌包</span>', page, function () {
                           if (this.firstChild.innerHTML == '隐藏卡牌包') {
                              this.firstChild.innerHTML = '卡牌包将在重启后隐藏';
                              lib.config.hiddenCardPack.add(mode);
                              if (!lib.config.prompt_hidepack) {
                                 alert('隐藏的扩展包可通过选项-其它-重置隐藏内容恢复');
                                 game.saveConfig('prompt_hidepack', true);
                              }
                           }
                           else {
                              this.firstChild.innerHTML = '隐藏卡牌包';
                              lib.config.hiddenCardPack.remove(mode);
                           }
                           game.saveConfig('hiddenCardPack', lib.config.hiddenCardPack);
                        });
                     }
                     if (mode.indexOf('mode_') != 0 && lib.cardPile[mode]) {
                        var cardpileNodes = [];
                        var cardpileexpanded = false;
                        if (!lib.config.bannedpile[mode]) {
                           lib.config.bannedpile[mode] = [];
                        }
                        if (!lib.config.addedpile[mode]) {
                           lib.config.addedpile[mode] = [];
                        }
                        ui.create.div('.config.more.pile', '编辑牌堆 <div>&gt;</div>', page, function () {
                           if (cardpileexpanded) {
                              this.classList.remove('on');
                              for (var k = 0; k < cardpileNodes.length; k++) {
                                 cardpileNodes[k].style.display = 'none';
                              }
                           }
                           else {
                              this.classList.add('on');
                              for (var k = 0; k < cardpileNodes.length; k++) {
                                 cardpileNodes[k].style.display = '';
                              }
                           }
                           cardpileexpanded = !cardpileexpanded;
                        });
                        var cfgnode = ui.create.div(page, '.config.pointerspan.cardpilecfg.toggle');
                        var cfgaddcard = ui.create.node('button', '', '添加卡牌', cfgnode, function () {
                           this.parentNode.nextSibling.classList.toggle('hidden');
                        });
                        var cfgbancard = ui.create.node('button', '', '全部关闭', cfgnode, function () {
                           for (var i = 0; i < cardpileNodes.length; i++) {
                              if (cardpileNodes[i].type == 'defaultcards' && cardpileNodes[i].classList.contains('on')) {
                                 clickToggle.call(cardpileNodes[i]);
                              }
                           }
                        });
                        var cfgenablecard = ui.create.node('button', '', '全部开启', cfgnode, function () {
                           for (var i = 0; i < cardpileNodes.length; i++) {
                              if (cardpileNodes[i].type == 'defaultcards' && !cardpileNodes[i].classList.contains('on')) {
                                 clickToggle.call(cardpileNodes[i]);
                              }
                           }
                        });
                        cfgbancard.style.marginLeft = '5px';
                        cfgenablecard.style.marginLeft = '5px';
                        cardpileNodes.push(cfgnode);
                        cfgnode.style.display = 'none';
                        cfgnode.classList.add('cardpilecfg');
                        cfgnode.classList.add('toggle');
                        cfgnode.style.marginTop = '5px';
                        page.appendChild(cfgnode);

                        var cardpileadd = ui.create.div('.config.toggle.hidden.cardpilecfg.cardpilecfgadd', page);
                        var pileaddlist = [];
                        for (var i = 0; i < lib.config.cards.length; i++) {
                           if (!lib.cardPack[lib.config.cards[i]]) continue;
                           for (var j = 0; j < lib.cardPack[lib.config.cards[i]].length; j++) {
                              var cname = lib.cardPack[lib.config.cards[i]][j];
                              pileaddlist.push([cname, get.translation(cname)]);
                              if (cname == 'sha') {
                                 pileaddlist.push(['huosha', '火杀']);
                                 pileaddlist.push(['leisha', '雷杀']);
                                 pileaddlist.push(['haisha', '海杀']);
                              }
                              if (cname == 'tao') {
                                 pileaddlist.push(['haitao', '海桃']);
                              }
                           }
                        }
                        var cardpileaddname = ui.create.selectlist(pileaddlist, null, cardpileadd);
                        cardpileaddname.style.width = '75px';
                        cardpileaddname.style.marginRight = '2px';
                        cardpileaddname.style.marginLeft = '-1px';
                        var cardpileaddsuit = ui.create.selectlist([
                           ['heart', '红桃'],
                           ['diamond', '方片'],
                           ['club', '梅花'],
                           ['spade', '黑桃'],
                        ], null, cardpileadd);
                        cardpileaddsuit.style.width = '53px';
                        cardpileaddsuit.style.marginRight = '2px';
                        var cardpileaddnumber = ui.create.selectlist([
                           1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13
                        ], null, cardpileadd);
                        cardpileaddnumber.style.width = '43px';
                        cardpileaddnumber.style.marginRight = '2px';
                        var button = document.createElement('button');
                        button.innerHTML = '确定';
                        button.style.width = '40px';
                        var deletecard = function () {
                           this.parentNode.remove();
                           var info = this.parentNode._info;
                           var list = lib.config.addedpile[mode];
                           for (var i = 0; i < list.length; i++) {
                              if (list[i][0] == info[0] && list[i][1] == info[1] && list[i][2] == info[2]) {
                                 list.splice(i, 1); break;
                              }
                           }
                           recreatePile();
                        };
                        button.onclick = function () {
                           var card = [
                              cardpileaddsuit.value,
                              cardpileaddnumber.value,
                              cardpileaddname.value,
                           ];
                           lib.config.addedpile[mode].push(card);
                           recreatePile();
                           var cfgnode = ui.create.div('.config.toggle.cardpilecfg');
                           cfgnode._info = card;
                           cfgnode.innerHTML = get.translation(card[2]) + ' ' + get.translation(card[0]) + card[1];
                           var cfgnodedelete = document.createElement('span');
                           cfgnodedelete.classList.add('cardpiledelete');
                           cfgnodedelete.innerHTML = '删除';
                           cfgnodedelete.onclick = deletecard;
                           cfgnode.appendChild(cfgnodedelete);
                           page.insertBefore(cfgnode, cardpileadd.nextSibling);
                        };
                        cardpileadd.appendChild(button);
                        cardpileadd.style.whiteSpace = 'nowrap';
                        cardpileNodes.push(cardpileadd);

                        for (var i = 0; i < lib.config.addedpile[mode].length; i++) {
                           var card = lib.config.addedpile[mode][i];
                           var cfgnode = ui.create.div('.config.toggle.cardpilecfg');
                           cfgnode._info = card;
                           cfgnode.innerHTML = get.translation(card[2]) + ' ' + get.translation(card[0]) + card[1];
                           var cfgnodedelete = document.createElement('span');
                           cfgnodedelete.classList.add('cardpiledelete');
                           cfgnodedelete.innerHTML = '删除';
                           cfgnodedelete.onclick = deletecard;
                           cfgnode.appendChild(cfgnodedelete);
                           cfgnode.style.display = 'none';
                           cardpileNodes.push(cfgnode);
                           page.appendChild(cfgnode);
                        }

                        for (var i = 0; i < lib.cardPile[mode].length; i++) {
                           var card = lib.cardPile[mode][i];
                           var cfgnode = createConfig({
                              name: get.translation(card[2]) + ' ' + get.translation(card[0]) + card[1],
                              _number: i,
                              _name: mode,
                              init: !lib.config.bannedpile[mode].contains(i),
                              onclick: toggleCardPile
                           });
                           cfgnode.type = 'defaultcards';
                           cardpileNodes.push(cfgnode);
                           cfgnode.style.display = 'none';
                           cfgnode.classList.add('cardpilecfg');
                           page.appendChild(cfgnode);
                        }
                        ui.create.div('.menuplaceholder', page);
                     }
                     return node;
                  };
                  if (!connectMenu && lib.config.show_ban_menu) {
                     lib.cardPack.mode_banned = [];
                     for (var i = 0; i < lib.config.all.mode.length; i++) {
                        var banned = lib.config[lib.config.all.mode[i] + '_bannedcards'];
                        if (banned) {
                           for (var j = 0; j < banned.length; j++) {
                              lib.cardPack.mode_banned.add(banned[j]);
                           }
                        }
                     }
                     var bannednode = createModeConfig('mode_banned', start.firstChild);
                     if (lib.cardPack.mode_banned.length == 0) {
                        bannednode.style.display = 'none';
                     }
                     delete lib.cardPack.mode_banned;
                  }
                  for (var i = 0; i < lib.config.all.cards.length; i++) {
                     if (connectMenu && !lib.connectCardPack.contains(lib.config.all.cards[i])) continue;
                     createModeConfig(lib.config.all.cards[i], start.firstChild);
                  }
                  if (!connectMenu) {
                     for (var i in lib.cardPack) {
                        if (i.indexOf('mode_') == 0) {
                           createModeConfig(i, start.firstChild);
                        }
                     }
                  }
                  var active = start.firstChild.querySelector('.active');
                  if (!active) {
                     active = start.firstChild.firstChild;
                     if (active.style.display == 'none') {
                        active = active.nextSibling;
                     }
                     active.classList.add('active');
                     updateActiveCard(active);
                  }
                  rightPane.appendChild(active.link);

                  (function () {
                     if (connectMenu) return;
                     var page = ui.create.div('.menu-buttons');
                     var node = ui.create.div('.menubutton.large', '牌堆', clickMode);
                     start.firstChild.insertBefore(node, start.firstChild.querySelector('.lefttext'));
                     node.link = page;
                     node.mode = 'cardpile';
                     node.create = function () {
                        if (pileCreated) return;
                        pileCreated = true;
                        page.innerHTML = '';

                        var pileList = null;
                        var createList = function () {
                           if (pileList) {
                              pileList.remove();
                           }
                           var list = ['默认牌堆'];
                           if (lib.config.customcardpile['当前牌堆']) {
                              list.push('当前牌堆');
                           }
                           for (var i in lib.config.customcardpile) {
                              list.add(i);
                           }
                           var currentpile = get.config('cardpilename');
                           if (!currentpile) {
                              if (list.contains('当前牌堆')) {
                                 currentpile = '当前牌堆';
                              }
                              else {
                                 currentpile = '默认牌堆';
                              }
                           }
                           pileList = ui.create.selectlist(list, currentpile, pileChoose, function (e) {
                              game.saveConfig('cardpilename', this.value, true);
                              restart.style.display = '';
                           });
                           pileList.style.float = 'right';
                        }
                        var pileChoose = ui.create.div('.config.toggle.cardpilecfg.nomarginleft', '选择牌堆', page);
                        createList();

                        var pileDel = function () {
                           delete lib.config.customcardpile[this.parentNode.link];
                           this.parentNode.remove();
                           game.saveConfig('customcardpile', lib.config.customcardpile);
                           for (var i in lib.config.mode_config) {
                              if (i == 'global') continue;
                              if (lib.config.mode_config[i].cardpilename == this.parentNode.link) {
                                 game.saveConfig('cardpilename', null, i);
                              }
                           }
                           createList();
                        };

                        var restart = ui.create.div('.config.more', '重新启动', game.reload, page);
                        restart.style.display = 'none';
                        var createPileNode = function (name) {
                           var node = ui.create.div('.config.toggle.cardpilecfg.nomarginleft', name);
                           node.link = name;
                           var del = document.createElement('span');
                           del.innerHTML = '删除';
                           del.classList.add('cardpiledelete');
                           del.onclick = pileDel;
                           node.appendChild(del);
                           if (name == '当前牌堆') {
                              page.insertBefore(node, pileChoose.nextSibling);
                           }
                           else {
                              page.insertBefore(node, restart);
                           }
                        };
                        for (var i in lib.config.customcardpile) {
                           createPileNode(i);
                        }
                        var exportCardPile;
                        ui.create.div('.config.more', '保存当前牌堆 <div>&gt;</div>', page, function () {
                           this.classList.toggle('on');
                           if (this.classList.contains('on')) {
                              exportCardPile.classList.remove('hidden');
                           }
                           else {
                              exportCardPile.classList.add('hidden');
                           }
                        });
                        exportCardPile = ui.create.div('.config.cardpileadd.indent', page);
                        exportCardPile.classList.add('hidden');
                        ui.create.div('', '名称：<input type="text"><button>确定</button>', exportCardPile);
                        var input = exportCardPile.firstChild.lastChild.previousSibling;
                        input.value = '自定义牌堆';
                        input.style.marginRight = '3px';
                        input.style.width = '120px';
                        exportCardPile.firstChild.lastChild.onclick = function () {
                           var name = input.value;
                           var ok = true;
                           if (lib.config.customcardpile[name] || name == '默认牌堆' || name == '当前牌堆') {
                              for (var i = 1; i <= 1000; i++) {
                                 if (!lib.config.customcardpile[name + '(' + i + ')']) {
                                    name = name + '(' + i + ')';
                                    break;
                                 }
                              }
                           }
                           lib.config.customcardpile[name] = [lib.config.bannedpile, lib.config.addedpile];
                           delete lib.config.customcardpile['当前牌堆'];
                           for (var i in lib.mode) {
                              if (lib.config.mode_config[i] &&
                                 (lib.config.mode_config[i].cardpilename == '当前牌堆' || !lib.config.mode_config[i].cardpilename)) {
                                 game.saveConfig('cardpilename', name, i);
                              }
                           }
                           for (var i = 0; i < page.childElementCount; i++) {
                              if (page.childNodes[i].link == '当前牌堆') {
                                 page.childNodes[i].remove();
                                 break;
                              }
                           }
                           game.saveConfig('customcardpile', lib.config.customcardpile);
                           createPileNode(name);
                           createList();
                        };
                     }
                  }());

                  if (!connectMenu) {
                     var node1 = ui.create.div('.lefttext', '全部开启', start.firstChild, function () {
                        game.saveConfig('cards', lib.config.all.cards);
                        updateNodes();
                     });
                     var node2 = ui.create.div('.lefttext', '恢复默认', start.firstChild, function () {
                        game.saveConfig('cards', lib.config.defaultcards);
                        updateNodes();
                     });
                     node1.style.marginTop = '12px';
                     node2.style.marginTop = '7px';
                  }

                  updateNodes();
               }());

               (function () {
                  if (connectMenu) return;
                  var start = menuxpages.shift();
                  var rightPane = start.lastChild;

                  var clickMode = function () {
                     if (this.mode == 'get') {
                        this.update();
                     }
                     var active = this.parentNode.querySelector('.active');
                     if (active === this) {
                        return;
                     }
                     active.classList.remove('active');
                     active.link.remove();
                     active = this;
                     this.classList.add('active');
                     rightPane.appendChild(this.link);
                  };
                  ui.click.extensionTab = function (name) {
                     ui.click.menuTab('扩展');
                     for (var i = 0; i < start.firstChild.childElementCount; i++) {
                        if (start.firstChild.childNodes[i].innerHTML == name) {
                           clickMode.call(start.firstChild.childNodes[i]);
                           break;
                        }
                     }
                  }
                  var updateNodes = function () {
                     for (var i = 0; i < start.firstChild.childNodes.length; i++) {
                        var node = start.firstChild.childNodes[i];
                        if (node.link) {
                           if (node.mode == 'get') continue;
                           if (node.mode == 'create') continue;
                           if (node.mode.indexOf('extension_') == 0) {
                              if (lib.config[node.mode + '_enable']) {
                                 node.classList.remove('off');
                                 node.link.firstChild.classList.add('on');
                              }
                              else {
                                 node.classList.add('off');
                                 node.link.firstChild.classList.remove('on');
                              }
                           }
                           else {
                              if (lib.config.plays.contains(node.mode)) {
                                 node.classList.remove('off');
                                 node.link.firstChild.classList.add('on');
                              }
                              else {
                                 node.classList.add('off');
                                 node.link.firstChild.classList.remove('on');
                              }
                           }
                        }
                     }
                  }
                  var togglePack = function (bool) {
                     var name = this._link.config._name;
                     if (name.indexOf('extension_') == 0) {
                        if (bool) {
                           game.saveConfig(name, true);
                        }
                        else {
                           game.saveConfig(name, false);
                        }
                     }
                     else {
                        name = name.slice(0, name.indexOf('_enable_playpackconfig'));
                        if (bool) {
                           lib.config.plays.add(name);
                        }
                        else {
                           lib.config.plays.remove(name);
                        }
                        game.saveConfig('plays', lib.config.plays);
                     }
                     if (this.onswitch) {
                        this.onswitch(bool);
                     }
                     updateNodes();
                  };

                  var createModeConfig = function (mode, position) {
                     var page = ui.create.div('');
                     page.style.paddingBottom = '10px';
                     var node;
                     if (mode.indexOf('extension_') == 0) {
                        node = ui.create.div('.menubutton.large', mode.slice(10), position, clickMode);
                     }
                     else {
                        node = ui.create.div('.menubutton.large', lib.translate[mode + '_play_config'], position, clickMode);
                     }
                     if (node.innerHTML.length >= 5) {
                        node.classList.add('smallfont');
                     }
                     node.link = page;
                     node.mode = mode;
                     for (var i in lib.extensionMenu[mode]) {
                        if (i == 'game') continue;
                        var cfg = copyObj(lib.extensionMenu[mode][i]);
                        var j;
                        if (mode.indexOf('extension_') == 0) {
                           j = mode + '_' + i;
                        }
                        else {
                           j = mode + '_' + i + '_playpackconfig';
                        }
                        cfg._name = j;
                        if (!lib.config.hasOwnProperty(j)) {
                           game.saveConfig(j, cfg.init);
                        }
                        else {
                           cfg.init = lib.config[j];
                        }

                        if (i == 'enable') {
                           cfg.onclick = togglePack;
                        }
                        else if (!lib.extensionMenu[mode][i].onclick) {
                           cfg.onclick = function (result) {
                              var cfg = this._link.config;
                              game.saveConfig(cfg._name, result);
                           };
                        }
                        var cfgnode = createConfig(cfg);
                        if (cfg.onswitch) {
                           cfgnode.onswitch = cfg.onswitch;
                        }
                        page.appendChild(cfgnode);
                     }
                     return node;
                  };
                  for (var i in lib.extensionMenu) {
                     if (lib.config.all.stockextension.contains(i) && !lib.config.all.plays.contains(i)) continue;
                     if (lib.config.hiddenPlayPack.contains(i)) continue;
                     createModeConfig(i, start.firstChild);
                  }
                  (function () {
                     var page = ui.create.div('');
                     var node = ui.create.div('.menubutton.large', '获取扩展', start.firstChild, clickMode);
                     node.link = page;
                     node.mode = 'get';
                     page.listen(function () {
                        if (!page.currenttimeout) {
                           var active = page.querySelector('.videonode.current');
                           if (active) {
                              active.classList.remove('current');
                           }
                        }
                     });
                     var importextensionexpanded = false;
                     page.style.paddingBottom = '10px';
                     var importExtension;
                     var extensionnode = ui.create.div('.config.more', '导入扩展 <div>&gt;</div>', page, function () {
                        if (importextensionexpanded) {
                           this.classList.remove('on');
                           importExtension.style.display = 'none';
                        }
                        else {
                           this.classList.add('on');
                           importExtension.style.display = '';
                        }
                        importextensionexpanded = !importextensionexpanded;
                     });
                     importExtension = ui.create.div('.new_character.export.import', page);
                     importExtension.style.marginLeft = '5px';
                     importExtension.style.marginTop = '5px';
                     importExtension.style.marginBottom = '5px';
                     importExtension.style.display = 'none';
                     importExtension.style.width = '100%';
                     importExtension.style.textAlign = 'left';
                     ui.create.div('', '<input type="file" accept="application/zip" style="width:153px"><button>确定</button>', importExtension);

                     var reloadnode = ui.create.div('.config.toggle.pointerdiv', '重新启动', page, game.reload);
                     reloadnode.style.display = 'none';
                     var placeholder = ui.create.div('.config.toggle', page);
                     placeholder.style.height = 0;
                     placeholder.style.marginTop = '5px';

                     importExtension.firstChild.lastChild.onclick = function () {
                        var fileToLoad = this.previousSibling.files[0];
                        if (fileToLoad) {
                           var fileReader = new FileReader();
                           fileReader.onload = function (fileLoadedEvent) {
                              var finishLoad = function () {
                                 extensionnode.innerHTML = '导入成功，3秒后将重启';
                                 setTimeout(function () {
                                    extensionnode.innerHTML = '导入成功，2秒后将重启';
                                    setTimeout(function () {
                                       extensionnode.innerHTML = '导入成功，1秒后将重启';
                                       setTimeout(game.reload, 1000);
                                    }, 1000);
                                 }, 1000);
                              };
                              var data = fileLoadedEvent.target.result;
                              if (game.importExtension(data, finishLoad) !== false) {
                                 importExtension.style.display = 'none';
                              }
                           };
                           fileReader.readAsArrayBuffer(fileToLoad, "UTF-8");
                        }
                     }

                     node.update = function () { };
                  }());
                  var active = start.firstChild.querySelector('.active');
                  if (!active) {
                     active = start.firstChild.firstChild;
                     active.classList.add('active');
                  }
                  rightPane.appendChild(active.link);
                  updateNodes();
               }());

               (function () {
                  if (connectMenu) return;
                  var start = menuxpages.shift();
                  var rightPane = start.lastChild;
                  var cheatButton = ui.create.div('.menubutton.round.highlight', '作', start);
                  cheatButton.style.display = 'none';
                  var runButton = ui.create.div('.menubutton.round.highlight', '执', start);
                  runButton.style.display = 'none';
                  var clearButton = ui.create.div('.menubutton.round.highlight', '清', start);
                  clearButton.style.display = 'none';
                  clearButton.style.left = '275px';
                  var playButton = ui.create.div('.menubutton.round.highlight.hidden', '播', start);
                  playButton.style.display = 'none';
                  playButton.style.left = '215px';
                  playButton.style.transition = 'opacity 0.3s';
                  var deleteButton = ui.create.div('.menubutton.round.highlight.hidden', '删', start);
                  deleteButton.style.display = 'none';
                  deleteButton.style.left = '275px';
                  deleteButton.style.transition = 'opacity 0.3s';
                  var saveButton = ui.create.div('.menubutton.round.highlight.hidden', '存', start);
                  saveButton.style.display = 'none';
                  saveButton.style.transition = 'opacity 0.3s';


                  var clickMode = function () {
                     if (this.classList.contains('off')) return;
                     var active = this.parentNode.querySelector('.active');
                     if (active === this) {
                        return;
                     }
                     if (active) {
                        active.classList.remove('active');
                        active.link.remove();
                     }
                     active = this;
                     this.classList.add('active');
                     rightPane.appendChild(this.link);
                     if (this.type == 'cheat') {
                        cheatButton.style.display = '';
                     }
                     else {
                        cheatButton.style.display = 'none';
                     }
                     if (this.type == 'cmd') {
                        runButton.style.display = '';
                        clearButton.style.display = '';
                     }
                     else {
                        runButton.style.display = 'none';
                        clearButton.style.display = 'none';
                     }
                     if (this.type == 'video') {
                        playButton.style.display = '';
                        saveButton.style.display = '';
                        deleteButton.style.display = '';
                     }
                     else {
                        playButton.style.display = 'none';
                        saveButton.style.display = 'none';
                        deleteButton.style.display = 'none';
                     }
                  };

                  ui.click.consoleMenu = function () {
                     ui.click.menuTab('其它');
                     clickMode.call(ui.commandnode);
                  };
                  (function () {
                     var page = ui.create.div('');
                     var node = ui.create.div('.menubutton.large', '更新', start.firstChild, clickMode);
                     node.link = page;
                     page.classList.add('menu-help');
                     var ul = document.createElement('ul');
                     var li1 = document.createElement('li');
                     var li2 = document.createElement('li');
                     var li3 = document.createElement('li');
                     var trimurl = function (str) {
                        if (str == lib.updateURLS.github) {
                           return 'GitHub';
                        }
                        if (str == lib.updateURLS.coding) {
                           return 'Coding';
                        }
                        var index;
                        index = str.indexOf('://');
                        if (index != -1) {
                           str = str.slice(index + 3);
                        }
                        index = str.indexOf('/');
                        if (index != -1) {
                           str = str.slice(0, index);
                        }
                        if (str.length > 15) {
                           var list = str.split('.');
                           if (list.length > 1) {
                              list.shift();
                           }
                           str = list[0];
                           for (var i = 1; i < list.length; i++) {
                              str += '.' + list[i];
                           }
                        }
                        if (str.length > 15) {
                           var list = str.split('.');
                           if (list.length > 1) {
                              list.pop();
                           }
                           str = list[0];
                           for (var i = 1; i < list.length; i++) {
                              str += '.' + list[i];
                           }
                        }
                        return str;
                     }
                     li1.innerHTML = '游戏版本：' + lib.version + '<p style="margin-top:8px;white-space:nowrap"></p>';
                     li2.innerHTML = '素材版本：' + (lib.config.asset_version || '无') + '<p style="margin-top:8px"></p>';
                     li3.innerHTML = '更新地址：<span>' + trimurl(lib.config.updateURL || lib.updateURL) + '</span><p style="margin-top:8px"></p>';
                     li3.style.whiteSpace = 'nowrap';
                     li3.style.display = 'none';// coding

                     var button1, button2, button3, button4, button5;

                     game.checkForUpdate = function (forcecheck, dev) {
                        if (!dev && button1.disabled) {
                           return;
                        }
                        else if (dev && button3.disabled) {
                           return;
                        }
                        else if (!game.download) {
                           // alert('此版本不支持游戏内更新，请手动更新');
                           return;
                        }
                        else {
                           if (dev) {
                              button3.innerHTML = '正在检查更新';
                           }
                           else {
                              button1.innerHTML = '正在检查更新';
                           }
                           button3.disabled = true;
                           button1.disabled = true;

                           var goupdate = function (files, update) {
                              lib.version = update.version;
                              if (update.dev && !lib.config.debug) {
                                 dev = 'nodev';
                              }
                              lib.init.req('game/source.js', function () {
                                 try {
                                    eval(this.responseText);
                                    if (!window.noname_source_list) {
                                       throw ('err');
                                    }
                                 }
                                 catch (e) {
                                    alert('更新地址有误');
                                    console.log(e);
                                    return;
                                 }

                                 var updates = window.noname_source_list;
                                 delete window.noname_source_list;
                                 if (Array.isArray(files)) {
                                    files.add('game/update.js');
                                    var files2 = [];
                                    for (var i = 0; i < files.length; i++) {
                                       var str = files[i].indexOf('*');
                                       if (str != -1) {
                                          str = files[i].slice(0, str);
                                          files.splice(i--, 1);
                                          for (var j = 0; j < updates.length; j++) {
                                             if (updates[j].indexOf(str) == 0) {
                                                files2.push(updates[j]);
                                             }
                                          }
                                       }
                                    }
                                    updates = files.concat(files2);
                                 }
                                 for (var i = 0; i < updates.length; i++) {
                                    if (updates[i].indexOf('theme/') == 0 && updates[i].indexOf('.css') == -1) {
                                       updates.splice(i--, 1);
                                    }
                                    else if (updates[i].indexOf('node_modules/') == 0 && !update.node) {
                                       updates.splice(i--, 1);
                                    }
                                 }

                                 if (!ui.arena.classList.contains('menupaused')) {
                                    ui.click.configMenu();
                                    ui.click.menuTab('其它');
                                 }
                                 var p = button1.parentNode;
                                 button1.remove();
                                 button3.remove();
                                 var span = document.createElement('span');
                                 var n1 = 0;
                                 var n2 = updates.length;
                                 span.innerHTML = '正在下载文件（' + n1 + '/' + n2 + '）';
                                 p.appendChild(span);
                                 var finish = function () {
                                    span.innerHTML = '游戏更新完毕（' + n1 + '/' + n2 + '）';
                                    p.appendChild(document.createElement('br'));
                                    var button = document.createElement('button');
                                    button.innerHTML = '重新启动';
                                    button.onclick = game.reload;
                                    button.style.marginTop = '8px';
                                    p.appendChild(button);
                                 }
                                 game.multiDownload(updates, function () {
                                    n1++;
                                    span.innerHTML = '正在下载文件（' + n1 + '/' + n2 + '）';
                                 }, function (e) {
                                    game.print('下载失败：' + e.source);
                                 }, function () {
                                    setTimeout(finish, 500);
                                 }, null, dev);
                              }, function () {
                                 alert('更新地址有误');
                              }, true);
                           };

                           lib.init.req('game/update.js', function () {
                              try {
                                 eval(this.responseText);
                                 if (!window.noname_update) {
                                    throw ('err');
                                 }
                              }
                              catch (e) {
                                 alert('更新地址有误');
                                 console.log(e);
                                 return;
                              }

                              var update = window.noname_update;
                              delete window.noname_update;
                              if (forcecheck === false) {
                                 if (update.version == lib.config.check_version) {
                                    return;
                                 }
                              }
                              game.saveConfig('check_version', update.version);
                              var goon = true;
                              if (!dev) {
                                 if (update.version.indexOf('beta') != -1 || update.version == lib.version) {
                                    goon = false;
                                 }
                              }
                              if (goon) {
                                 var files = null;
                                 var version = lib.version;
                                 if (Array.isArray(update.dev) && dev) {
                                    files = update.dev;
                                 }
                                 else if (Array.isArray(update.files) && update.update && !dev) {
                                    var version1 = version.split('.');
                                    var version2 = update.update.split('.');
                                    for (var i = 0; i < version1.length && i < version2.length; i++) {
                                       if (version2[i] > version1[i]) {
                                          files = false; break;
                                       }
                                       else if (version1[i] > version2[i]) {
                                          files = update.files.slice(0); break;
                                       }
                                    }
                                    if (files === null) {
                                       if (version1.length >= version2.length) {
                                          files = update.files.slice(0);
                                       }
                                    }
                                 }
                                 var str;
                                 if (dev) {
                                    str = '开发版仅供测试使用，可能存在风险，是否确定更新？'
                                 }
                                 else {
                                    str = '有新版本' + update.version + '可用，是否下载？';
                                 }
                                 if (navigator.notification && navigator.notification.confirm) {
                                    var str2;
                                    if (dev) {
                                       str2 = str;
                                       str = '更新到开发版';
                                    }
                                    else {
                                       str2 = update.changeLog[0];
                                       for (var i = 1; i < update.changeLog.length; i++) {
                                          if (update.changeLog[i].indexOf('://') == -1) {
                                             str2 += '；' + update.changeLog[i];
                                          }
                                       }
                                    }
                                    navigator.notification.confirm(
                                       str2,
                                       function (index) {
                                          if (index == 1) {
                                             goupdate(files, update);
                                          }
                                          else {
                                             button1.disabled = false;
                                             button1.innerHTML = '检查游戏更新';
                                             button3.disabled = false;
                                             button3.innerHTML = '更新到开发版';
                                          }
                                       },
                                       str,
                                       ['确定', '取消']
                                    );
                                 }
                                 else {
                                    if (confirm(str)) {
                                       goupdate(files, update);
                                    }
                                    else {
                                       button1.disabled = false;
                                       button1.innerHTML = '检查游戏更新';
                                       button3.disabled = false;
                                       button3.innerHTML = '更新到开发版';
                                    }
                                 }
                              }
                              else {
                                 alert('当前版本已是最新');
                                 button1.disabled = false;
                                 button1.innerHTML = '检查游戏更新';
                                 button3.disabled = false;
                                 button3.innerHTML = '更新到开发版';
                              }
                           }, function () {
                              if (forcecheck === false) {
                                 return;
                              }
                              alert('连接失败');
                              button1.disabled = false;
                              button1.innerHTML = '检查游戏更新';
                              button3.disabled = false;
                              button3.innerHTML = '更新到开发版';
                           }, true);
                        }
                     };
                     game.checkForAssetUpdate = function (type) {
                        if (button2.disabled) {
                           return;
                        }
                        else if (game.download) {
                           button2.innerHTML = '正在检查更新';
                           button2.disabled = true;
                           lib.init.req('game/asset.js', function () {
                              try {
                                 eval(this.responseText);
                                 if (!window.vk_asset_list || !window.vk_skin_list) {
                                    throw ('err');
                                 }
                              }
                              catch (e) {
                                 alert('更新地址有误');
                                 console.log(e);
                                 return;
                              }

                              var updates = window.vk_asset_list;
                              delete window.vk_asset_list;
                              var skins = window.vk_skin_list;
                              delete window.vk_skin_list;
                              var asset_version = updates.shift();

                              var skipcharacter = [], skipcard = ['tiesuo_mark'];
                              if (!lib.config.asset_full) {
                                 for (var i = 0; i < lib.config.all.sgscharacters.length; i++) {
                                    var pack = lib.characterPack[lib.config.all.sgscharacters[i]];
                                    for (var j in pack) {
                                       skipcharacter.add(j);
                                    }
                                 }
                                 for (var i = 0; i < lib.config.all.sgscards.length; i++) {
                                    var pack = lib.cardPack[lib.config.all.sgscards[i]];
                                    if (pack) {
                                       skipcard = skipcard.concat(pack);
                                    }
                                 }
                              }
                              for (var i = 0; i < updates.length; i++) {
                                 switch (updates[i].slice(0, 5)) {
                                    case 'image': {
                                       if (!lib.config.asset_full) {
                                          if (!lib.config.asset_image) {
                                             updates.splice(i--, 1);
                                          }
                                          else {
                                             if (updates[i].indexOf('image/character') == 0) {
                                                if (updates[i].indexOf('jun_') != 16 && updates[i].indexOf('gz_') != 16 && !skipcharacter.contains(updates[i].slice(16, updates[i].lastIndexOf('.')))) {
                                                   updates.splice(i--, 1);
                                                }
                                             }
                                             else if (updates[i].indexOf('image/card') == 0) {
                                                if (updates[i].indexOf('qiaosi_card') != 11 && !skipcard.contains(updates[i].slice(11, updates[i].lastIndexOf('.')))) {
                                                   updates.splice(i--, 1);
                                                }
                                             }
                                             else if (updates[i].indexOf('image/mode/stone') == 0) {
                                                updates.splice(i--, 1);
                                             }
                                          }
                                       }
                                       break;
                                    }
                                    case 'audio': {
                                       if (!lib.config.asset_audio) {
                                          updates.splice(i--, 1);
                                       }
                                       break;
                                    }
                                    case 'font/': {
                                       if (!lib.config.asset_font) {
                                          updates.splice(i--, 1);
                                       }
                                    }
                                 }
                              }
                              if (lib.config.asset_skin) {
                                 for (var i in skins) {
                                    for (var j = 1; j <= skins[i]; j++) {
                                       updates.push('image/skin/' + i + '/' + j + '.jpg');
                                    }
                                 }
                              }
                              if (!ui.arena.classList.contains('menupaused')) {
                                 ui.click.configMenu();
                                 ui.click.menuTab('其它');
                              }

                              var proceed = function () {
                                 if (updates.length == 0) {
                                    game.print(updates);
                                    game.saveConfig('asset_version', asset_version);
                                    alert('素材已是最新');
                                    button2.disabled = false;
                                    button2.innerHTML = '检查素材更新';
                                    return;
                                 }
                                 var p = button2.parentNode;
                                 button2.remove();
                                 var span = document.createElement('span');
                                 span.style.whiteSpace = 'nowrap';
                                 var n1 = 0;
                                 var n2 = updates.length;
                                 span.innerHTML = '正在下载素材（' + n1 + '/' + n2 + '）';
                                 span1.remove();
                                 span2.remove();
                                 span2_check.remove();
                                 span3.remove();
                                 span3_check.remove();
                                 span4.remove();
                                 span4_check.remove();
                                 span5.remove();
                                 span5_check.remove();
                                 span6.remove();
                                 span6_check.remove();
                                 span2_br.remove();
                                 span3_br.remove();
                                 span4_br.remove();
                                 span5_br.remove();
                                 span6_br.remove();
                                 p.appendChild(span);

                                 var br6 = ui.create.node('br');
                                 var span7 = ui.create.div('.hrefnode', '详细信息');
                                 span7.style.marginTop = '6px';
                                 span7.listen(ui.click.consoleMenu);
                                 p.appendChild(br6);
                                 p.appendChild(span7);

                                 var finish = function () {
                                    if (n1 == n2) {
                                       game.saveConfig('asset_version', asset_version);
                                    }
                                    span.innerHTML = '素材更新完毕（' + n1 + '/' + n2 + '）';
                                    p.appendChild(document.createElement('br'));
                                    var button = document.createElement('button');
                                    button.innerHTML = '重新启动';
                                    button.onclick = game.reload;
                                    button.style.marginTop = '8px';
                                    p.appendChild(button);
                                 }
                                 game.multiDownload(updates, function () {
                                    n1++;
                                    span.innerHTML = '正在下载素材（' + n1 + '/' + n2 + '）';
                                 }, function (e) {
                                    game.print('下载失败：' + e.source);
                                 }, function () {
                                    setTimeout(finish, 500);
                                 });
                              };
                              game.checkFileList(updates, proceed);
                           }, function () {
                              alert('连接失败');
                              button2.disabled = false;
                              button2.innerHTML = '检查素材更新';
                           }, true);
                        }
                        else {
                           alert('此版本不支持游戏内更新素材，请手动更新');
                        }
                     };

                     button1 = document.createElement('button');
                     button1.innerHTML = '检查游戏更新';
                     button1.onclick = game.checkForUpdate;
                     li1.lastChild.appendChild(button1);

                     button3 = document.createElement('button');
                     button3.innerHTML = '更新到开发版';
                     button3.style.marginLeft = '5px';
                     button3.onclick = function () {
                        game.checkForUpdate(null, true);
                     };
                     // if(lib.config.dev){
                     //     li1.lastChild.appendChild(button3);
                     // }

                     (function () {
                        var updatep1 = li1.querySelector('p');
                        var updatep2 = li2;
                        var updatep3 = li3;
                        var updatep4 = node;
                        var updatepx = ui.create.node('p');
                        li1.appendChild(updatepx);
                        updatepx.style.display = 'none';
                        updatepx.style.whiteSpace = 'nowrap';
                        updatepx.style.marginTop = '8px';
                        var buttonx = ui.create.node('button', '访问项目主页', function () {
                           window.open('https://github.com/libccy/noname');
                        });
                        updatepx.appendChild(buttonx);
                        ui.updateUpdate = function () {
                           if (!game.download) {
                              updatep1.style.display = 'none';
                              updatep2.style.display = 'none';
                              updatep3.style.display = 'none';
                              updatepx.style.display = '';
                              updatep4.innerHTML = '关于';
                           }
                           else {
                              updatep1.style.display = '';
                              updatep2.style.display = '';
                              updatep3.style.display = 'none'; // coding
                              updatepx.style.display = 'none';
                              updatep4.innerHTML = '更新';
                           }
                        }
                        ui.updateUpdate();
                     }());

                     button4 = document.createElement('button');
                     button4.innerHTML = '设置更新地址';
                     button4.onclick = function () {
                        game.prompt('设置更新地址', function (str) {
                           if (str) {
                              game.saveConfig('updateURL', str);
                              li3.querySelector('span').innerHTML = trimurl(str);
                              button5.style.display = '';
                              button6.style.display = 'none';
                           }
                        });
                     };
                     // li3.lastChild.appendChild(button4);

                     var button6 = document.createElement('button');
                     button6.innerHTML = '设为备用镜像';
                     button6.style.display = 'none';// coding
                     // button6.style.marginLeft='5px';
                     button6.onclick = function () {
                        game.saveConfig('updateURL', lib.mirrorURL);
                        button5.style.display = '';
                        button6.style.display = 'none';
                        li3.querySelector('span').innerHTML = trimurl(lib.mirrorURL);
                     };
                     li3.lastChild.appendChild(button6);

                     button5 = document.createElement('button');
                     button5.innerHTML = '设为默认镜像';
                     // button5.style.marginLeft='5px';
                     button5.onclick = function () {
                        game.saveConfig('updateURL');
                        button5.style.display = 'none';
                        button6.style.display = '';
                        li3.querySelector('span').innerHTML = trimurl(lib.updateURL);
                     };
                     li3.lastChild.appendChild(button5);
                     if (!lib.config.updateURL) {
                        button5.style.display = 'none';
                     }
                     else {
                        button6.style.display = 'none';
                     }

                     button2 = document.createElement('button');
                     button2.innerHTML = '检查素材更新';
                     button2.onclick = game.checkForAssetUpdate;
                     li2.lastChild.appendChild(button2);

                     var span1 = ui.create.div('.config.more', '选项 <div>&gt;</div>');
                     span1.style.fontSize = 'small';
                     span1.style.display = 'inline';
                     span1.toggle = function () {
                        if (!this.classList.toggle('on')) {
                           game.saveConfig('asset_toggle_off', true);
                           span2.style.display = 'none';
                           span2_br.style.display = 'none';
                           span2_check.style.display = 'none';
                           span3.style.display = 'none';
                           span3_br.style.display = 'none';
                           span3_check.style.display = 'none';
                           span4.style.display = 'none';
                           span4_br.style.display = 'none';
                           span4_check.style.display = 'none';
                           span5.style.display = 'none';
                           span5_br.style.display = 'none';
                           span5_check.style.display = 'none';
                           span6.style.display = 'none';
                           span6_br.style.display = 'none';
                           span6_check.style.display = 'none';
                        }
                        else {
                           game.saveConfig('asset_toggle_off');
                           span2.style.display = '';
                           span2_br.style.display = '';
                           span2_check.style.display = '';
                           span3.style.display = '';
                           span3_br.style.display = '';
                           span3_check.style.display = '';
                           span4.style.display = '';
                           span4_br.style.display = '';
                           span4_check.style.display = '';
                           span5.style.display = '';
                           span5_br.style.display = '';
                           span5_check.style.display = '';
                           span6.style.display = '';
                           span6_br.style.display = '';
                           span6_check.style.display = '';
                        }
                     };
                     span1.listen(span1.toggle);
                     li2.lastChild.appendChild(span1);

                     var span6_br = ui.create.node('br');
                     li2.lastChild.appendChild(span6_br);

                     var span5 = ui.create.div('', '图片素材（精简，221MB）');
                     span5.style.fontSize = 'small';
                     span5.style.lineHeight = '16px';
                     var span5_check = document.createElement('input');
                     span5_check.type = 'checkbox';
                     span5_check.style.marginLeft = '5px';
                     if (lib.config.asset_image) {
                        span5_check.checked = true;
                     }
                     span5_check.onchange = function () {
                        game.saveConfig('asset_image', this.checked);
                     }
                     var span2_br = ui.create.node('br');

                     var span4 = ui.create.div('', '字体素材（56MB）');
                     span4.style.fontSize = 'small';
                     span4.style.lineHeight = '16px';
                     li2.lastChild.appendChild(span4);
                     var span4_check = document.createElement('input');
                     span4_check.type = 'checkbox';
                     span4_check.style.marginLeft = '5px';
                     if (lib.config.asset_font) {
                        span4_check.checked = true;
                     }
                     span4_check.onchange = function () {
                        game.saveConfig('asset_font', this.checked);
                     }
                     li2.lastChild.appendChild(span4_check);
                     var span3_br = ui.create.node('br');
                     li2.lastChild.appendChild(span3_br);

                     var span3 = ui.create.div('', '音效素材（172MB）');
                     span3.style.fontSize = 'small';
                     span3.style.lineHeight = '16px';
                     li2.lastChild.appendChild(span3);
                     var span3_check = document.createElement('input');
                     span3_check.type = 'checkbox';
                     span3_check.style.marginLeft = '5px';
                     if (lib.config.asset_audio) {
                        span3_check.checked = true;
                     }
                     span3_check.onchange = function () {
                        game.saveConfig('asset_audio', this.checked);
                     }
                     li2.lastChild.appendChild(span3_check);
                     var span4_br = ui.create.node('br');
                     li2.lastChild.appendChild(span4_br);

                     var span2 = ui.create.div('', '皮肤素材（261MB）');
                     span2.style.fontSize = 'small';
                     span2.style.lineHeight = '16px';
                     li2.lastChild.appendChild(span2);
                     var span2_check = document.createElement('input');
                     span2_check.type = 'checkbox';
                     span2_check.style.marginLeft = '5px';
                     if (lib.config.asset_skin) {
                        span2_check.checked = true;
                     }
                     span2_check.onchange = function () {
                        game.saveConfig('asset_skin', this.checked);
                     }
                     li2.lastChild.appendChild(span2_check);
                     var span5_br = ui.create.node('br');
                     li2.lastChild.appendChild(span5_br);


                     li2.lastChild.appendChild(span5);
                     li2.lastChild.appendChild(span5_check);
                     li2.lastChild.appendChild(span2_br);

                     var span6 = ui.create.div('', '图片素材（完整，569MB）');
                     span6.style.fontSize = 'small';
                     span6.style.lineHeight = '16px';
                     li2.lastChild.appendChild(span6);
                     var span6_check = document.createElement('input');
                     span6_check.type = 'checkbox';
                     span6_check.style.marginLeft = '5px';
                     if (lib.config.asset_full) {
                        span6_check.checked = true;
                     }
                     span6_check.onchange = function () {
                        game.saveConfig('asset_full', this.checked);
                     }
                     li2.lastChild.appendChild(span6_check);

                     span2.style.display = 'none';
                     span2_br.style.display = 'none';
                     span2_check.style.display = 'none';
                     span3.style.display = 'none';
                     span3_br.style.display = 'none';
                     span3_check.style.display = 'none';
                     span4.style.display = 'none';
                     span4_br.style.display = 'none';
                     span4_check.style.display = 'none';
                     span5.style.display = 'none';
                     span5_br.style.display = 'none';
                     span5_check.style.display = 'none';
                     span6.style.display = 'none';
                     span6_br.style.display = 'none';
                     span6_check.style.display = 'none';

                     ul.appendChild(li1);
                     ul.appendChild(li2);
                     ul.appendChild(li3);
                     page.appendChild(ul);


                     if (!lib.config.asset_toggle_off) {
                        span1.toggle();
                     }
                  }());
                  (function () {
                     var norow2 = function () {
                        var node = currentrow1;
                        if (!node) return false;
                        return node.innerHTML == '横置' || node.innerHTML == '翻面' || node.innerHTML == '换人' || node.innerHTML == '复活';
                     };
                     var checkCheat = function () {
                        if (norow2()) {
                           for (var i = 0; i < row2.childElementCount; i++) {
                              row2.childNodes[i].classList.remove('selectedx');
                              row2.childNodes[i].classList.add('unselectable');
                           }
                        }
                        else {
                           for (var i = 0; i < row2.childElementCount; i++) {
                              row2.childNodes[i].classList.remove('unselectable');
                           }
                        }
                        if (currentrow1 && currentrow1.innerHTML == '复活') {
                           for (var i = 0; i < row3.childNodes.length; i++) {
                              if (row3.childNodes[i].dead) {
                                 row3.childNodes[i].style.display = '';
                              }
                              else {
                                 row3.childNodes[i].style.display = 'none';
                                 row3.childNodes[i].classList.remove('glow');
                              }
                              row3.childNodes[i].classList.remove('unselectable');
                           }
                        }
                        else {
                           for (var i = 0; i < row3.childElementCount; i++) {
                              if (currentrow1 && currentrow1.innerHTML == '换人' && row3.childNodes[i].link == game.me) {
                                 row3.childNodes[i].classList.add('unselectable');
                              }
                              else {
                                 row3.childNodes[i].classList.remove('unselectable');
                              }
                              if (!row3.childNodes[i].dead) {
                                 row3.childNodes[i].style.display = '';
                              }
                              else {
                                 row3.childNodes[i].style.display = 'none';
                                 row3.childNodes[i].classList.remove('glow');
                              }
                           }
                        }
                        if (currentrow1 && (currentrow2 || norow2()) && row3.querySelector('.glow')) {
                           cheatButton.classList.add('glowing');
                           return true;
                        }
                        else {
                           cheatButton.classList.remove('glowing');
                           return false;
                        }
                     }
                     cheatButton.listen(function () {
                        if (checkCheat()) {
                           var num;
                           if (currentrow2) {
                              switch (currentrow2.innerHTML) {
                                 case '一': num = 1; break;
                                 case '二': num = 2; break;
                                 case '三': num = 3; break;
                                 case '四': num = 4; break;
                                 case '五': num = 5; break;
                              }
                           }
                           var targets = [];
                           var buttons = row3.querySelectorAll('.glow');
                           for (var i = 0; i < buttons.length; i++) {
                              targets.push(buttons[i].link);
                           }
                           while (targets.length) {
                              var target = targets.shift();
                              switch (currentrow1.innerHTML) {
                                 case '伤害': target.damage(num, 'nosource'); break;
                                 case '回复': target.recover(num, 'nosource'); break;
                                 case '摸牌': target.draw(num); break;
                                 case '弃牌': target.discard(target.getCards('he').randomGets(num)); break;
                                 case '横置': target.link(); break;
                                 case '翻面': target.turnOver(); break;
                                 case '复活': target.revive(target.maxHp); break;
                                 case '换人': {
                                    if (_status.event.isMine()) {
                                       if (!ui.auto.classList.contains('hidden')) {
                                          setTimeout(function () {
                                             ui.click.auto();
                                             setTimeout(function () {
                                                ui.click.auto();
                                                game.swapPlayer(target);
                                             }, 500);
                                          });
                                       }
                                    }
                                    else {
                                       game.swapPlayer(target);
                                    }
                                    break;
                                 }
                              }
                           }
                           if (ui.coin) {
                              game.changeCoin(-20);
                           }
                           clickContainer.call(menuContainer);
                        }
                     });

                     var page = ui.create.div('');
                     var node = ui.create.div('.menubutton.large', '控制', start.firstChild, clickMode);
                     node.link = page;
                     node.type = 'cheat';
                     page.classList.add('menu-sym');

                     var currentrow1 = null;
                     var row1 = ui.create.div('.menu-cheat', page);
                     var clickrow1 = function () {
                        if (this.classList.contains('unselectable')) return;
                        if (currentrow1 == this) {
                           this.classList.remove('selectedx');
                           currentrow1 = null;
                        }
                        else {
                           this.classList.add('selectedx');
                           if (currentrow1) {
                              currentrow1.classList.remove('selectedx');
                           }
                           currentrow1 = this;
                           if (this.innerHTML == '换人') {
                              for (var i = 0; i < row3.childNodes.length; i++) {
                                 row3.childNodes[i].classList.remove('glow');
                              }
                           }
                        }
                        checkCheat();
                     };
                     var nodedamage = ui.create.div('.menubutton', '伤害', row1, clickrow1);
                     var noderecover = ui.create.div('.menubutton', '回复', row1, clickrow1);
                     var nodedraw = ui.create.div('.menubutton', '摸牌', row1, clickrow1);
                     var nodediscard = ui.create.div('.menubutton', '弃牌', row1, clickrow1);
                     var nodelink = ui.create.div('.menubutton', '横置', row1, clickrow1);
                     var nodeturnover = ui.create.div('.menubutton', '翻面', row1, clickrow1);
                     var noderevive = ui.create.div('.menubutton', '复活', row1, clickrow1);
                     var nodereplace = ui.create.div('.menubutton', '换人', row1, clickrow1);
                     if (lib.config.mode != 'identity' && lib.config.mode != 'guozhan' && lib.config.mode != 'doudizhu') {
                        nodereplace.classList.add('unselectable');
                     }

                     var currentrow2 = null;
                     var row2 = ui.create.div('.menu-cheat', page);
                     var clickrow2 = function () {
                        if (this.classList.contains('unselectable')) return;
                        if (currentrow2 == this) {
                           this.classList.remove('selectedx');
                           currentrow2 = null;
                        }
                        else {
                           this.classList.add('selectedx');
                           if (currentrow2) {
                              currentrow2.classList.remove('selectedx');
                           }
                           currentrow2 = this;
                        }
                        checkCheat();
                     };
                     var nodex1 = ui.create.div('.menubutton', '一', row2, clickrow2);
                     var nodex2 = ui.create.div('.menubutton', '二', row2, clickrow2);
                     var nodex3 = ui.create.div('.menubutton', '三', row2, clickrow2);
                     var nodex4 = ui.create.div('.menubutton', '四', row2, clickrow2);
                     var nodex5 = ui.create.div('.menubutton', '五', row2, clickrow2);

                     var row3 = ui.create.div('.menu-buttons.leftbutton.commandbutton', page);
                     row3.style.marginTop = '3px';
                     var clickrow3 = function () {
                        if (this.classList.contains('unselectable')) return;
                        this.classList.toggle('glow');
                        if (currentrow1 && currentrow1.innerHTML == '换人' && this.classList.contains('glow')) {
                           if (this.link == game.me) {
                              this.classList.remove('glow');
                           }
                           for (var i = 0; i < row3.childElementCount; i++) {
                              if (row3.childNodes[i] != this) {
                                 row3.childNodes[i].classList.remove('glow');
                              }
                           }
                        }
                        checkCheat();
                     };
                     menuUpdates.push(function () {
                        if (_status.video || _status.connectMode || _status.yindao) {
                           node.classList.add('off');
                           if (node.classList.contains('active')) {
                              node.classList.remove('active');
                              node.link.remove();
                              active = start.firstChild.firstChild;
                              active.classList.add('active');
                              rightPane.appendChild(active.link);
                           }

                           page.remove();
                           cheatButton.remove();
                           if (_status.video) node.remove();
                           return;
                        }
                        var list = [];
                        for (var i = 0; i < game.players.length; i++) {
                           if (lib.character[game.players[i].name] || game.players[i].name1) {
                              list.push(game.players[i]);
                           }
                        }
                        for (var i = 0; i < game.dead.length; i++) {
                           if (lib.character[game.dead[i].name] || game.dead[i].name1) {
                              list.push(game.dead[i]);
                           }
                        }
                        if (list.length) {
                           row1.show();
                           row2.show();
                           row3.innerHTML = '';
                           var buttons = ui.create.buttons(list, 'player', row3, true);
                           for (var i = 0; i < buttons.length; i++) {
                              buttons[i].listen(clickrow3);
                              if (game.dead.contains(buttons[i].link)) {
                                 buttons[i].dead = true;
                              }
                           }
                           checkCheat();
                        }
                        else {
                           row1.hide();
                           row2.hide();
                        }
                        if (lib.config.mode == 'identity' || lib.config.mode == 'guozhan' || lib.config.mode == 'doudizhu') {
                           if (game.notMe || (game.me && (game.me._trueMe || game.hasPlayer(function (current) {
                              return current._trueMe == game.me;
                           }))) || !game.phaseNumber || _status.qianlidanji) {
                              nodereplace.classList.add('unselectable');
                           }
                           else if (_status.event.isMine() && ui.auto.classList.contains('hidden')) {
                              nodereplace.classList.add('unselectable');
                           }
                           else {
                              nodereplace.classList.remove('unselectable');
                           }
                        }
                        if (game.dead.length == 0) {
                           noderevive.classList.add('unselectable');
                        }
                        else {
                           noderevive.classList.remove('unselectable');
                        }
                        checkCheat();
                     });
                  }());
                  (function () {
                     var page = ui.create.div('');
                     var node = ui.create.div('.menubutton.large', '命令', start.firstChild, clickMode);
                     ui.commandnode = node;
                     node.type = 'cmd';
                     node.link = page;
                     page.classList.add('menu-sym');
                     menuUpdates.push(function () {
                        if (_status.connectMode) {
                           node.classList.add('off');
                           if (node.classList.contains('active')) {
                              node.classList.remove('active');
                              node.link.remove();
                              active = start.firstChild.firstChild;
                              active.classList.add('active');
                              rightPane.appendChild(active.link);
                           }
                        }
                     });
                     var text = document.createElement('div');
                     text.style.width = '194px';
                     text.style.height = '124px';
                     text.style.padding = '3px';
                     text.style.borderRadius = '2px';
                     text.style.boxShadow = 'rgba(0, 0, 0, 0.2) 0 0 0 1px';
                     text.style.textAlign = 'left';
                     text.style.webkitUserSelect = 'initial';
                     text.style.overflow = 'scroll';
                     text.style.position = 'absolute';
                     text.style.left = '30px';
                     text.style.top = '50px';
                     text.style.wordBreak = 'break-all';
                     var pre = ui.create.node('pre.fullsize', text);
                     pre.style.margin = 0;
                     pre.style.padding = 0;
                     pre.style.position = 'relative';
                     lib.setScroll(pre);
                     page.appendChild(text);

                     var text2 = document.createElement('input');
                     text2.style.width = '200px';
                     text2.style.height = '20px';
                     text2.style.padding = '0';
                     text2.style.position = 'absolute';
                     text2.style.top = '15px';
                     text2.style.left = '30px';
                     text2.style.resize = 'none';
                     text2.style.border = 'none';
                     text2.style.borderRadius = '2px';
                     text2.style.boxShadow = 'rgba(0, 0, 0, 0.2) 0 0 0 1px';
                     var g = {};
                     var logs = [];
                     var logindex = -1;
                     var cheat = lib.cheat;
                     var runCommand = function (e) {
                        if (text2.value && !['up', 'down'].contains(text2.value)) {
                           logindex = -1;
                           logs.unshift(text2.value);
                        }
                        if (text2.value == 'cls') {
                           pre.innerHTML = '';
                           text2.value = '';
                        }
                        else if (text2.value == 'up') {
                           if (logindex + 1 < logs.length) {
                              text2.value = logs[++logindex];
                           }
                           else {
                              text2.value = '';
                           }
                        }
                        else if (text2.value == 'down') {
                           if (logindex >= 0) {
                              logindex--;
                              if (logindex < 0) {
                                 text2.value = '';
                              }
                              else {
                                 text2.value = logs[logindex];
                              }
                           }
                           else {
                              text2.value = '';
                           }
                        }
                        else if (text2.value.indexOf('无天使') != -1 && (text2.value.indexOf('无神佛') != -1 || text2.value.indexOf('无神') != -1 && text2.value.indexOf('无佛') != -1)) {
                           game.print('密码正确！欢迎来到死后世界战线！');
                           _status.keyVerified = true;
                           text2.value = '';
                        }
                        else {
                           if (!game.observe && !game.online) {
                              try {
                                 var result = eval(text2.value);
                                 game.print(result);
                              }
                              catch (e) {
                                 game.print(e);
                              }
                           }
                           text2.value = '';
                        }
                     }
                     text2.addEventListener('keydown', function (e) {
                        if (e.keyCode == 13) {
                           runCommand();
                        }
                        else if (e.keyCode == 38) {
                           if (logindex + 1 < logs.length) {
                              text2.value = logs[++logindex];
                           }
                        }
                        else if (e.keyCode == 40) {
                           if (logindex >= 0) {
                              logindex--;
                              if (logindex < 0) {
                                 text2.value = '';
                              }
                              else {
                                 text2.value = logs[logindex];
                              }
                           }
                        }
                     });
                     page.appendChild(text2);
                     game.print = function () {
                        var textstr = '';
                        for (var i = 0; i < arguments.length; i++) {
                           if (get.is.object(arguments[i])) {
                              var argi = get.stringify(arguments[i]);
                              if (argi && argi.length < 5000) {
                                 textstr += argi;
                              }
                              else {
                                 textstr += arguments[i].toString();
                              }
                           }
                           else {
                              textstr += arguments[i];
                           }
                           if (i < arguments.length - 1) {
                              textstr += ' ';
                           }
                        }
                        textstr += '<br>';
                        pre.innerHTML += textstr;
                        text.scrollTop = text.scrollHeight;
                     }
                     if (_status.toprint) {
                        for (var i = 0; i < _status.toprint.length; i++) {
                           game.print.apply(this, _status.toprint[i]);
                        }
                        delete _status.toprint;
                     }
                     runButton.listen(runCommand);
                     clearButton.listen(function () {
                        pre.innerHTML = '';
                     });
                  }());
                  (function () {
                     var page = ui.create.div('');
                     var node = ui.create.div('.menubutton.large', '战绩', start.firstChild, clickMode);
                     node.type = 'rec';
                     node.link = page;
                     page.style.paddingBottom = '10px';
                     var reset = function () {
                        if (this.innerHTML == '重置') {
                           this.innerHTML = '确定';
                           setTimeout(() => {
                              this.innerHTML = '重置';
                           }, 1000);
                        }
                        else {
                           this.parentNode.previousSibling.remove();
                           this.parentNode.remove();
                           lib.config.gameRecord[this.parentNode.link] = { data: {} };
                           game.saveConfig('gameRecord', lib.config.gameRecord);
                        }
                     }
                     for (var i = 0; i < lib.config.all.mode.length; i++) {
                        if (!lib.config.gameRecord[lib.config.all.mode[i]]) continue;
                        if (lib.config.gameRecord[lib.config.all.mode[i]].str) {
                           ui.create.div('.config.indent', lib.translate[lib.config.all.mode[i]], page).style.marginBottom = '-5px';
                           var item = ui.create.div('.config.indent', lib.config.gameRecord[lib.config.all.mode[i]].str + '<span>重置</span>', page);
                           item.style.height = 'auto';
                           item.lastChild.addEventListener('click', reset);
                           item.lastChild.classList.add('pointerdiv');
                           item.link = lib.config.all.mode[i];
                        }
                     }
                  }());
                  (function () {
                     if (!window.indexedDB || window.nodb) return;
                     var page = ui.create.div('');
                     var node = ui.create.div('.menubutton.large', '录像', start.firstChild, clickMode);
                     node.type = 'video';
                     node.link = page;

                     var store = lib.db.transaction(['video'], 'readwrite').objectStore('video');
                     lib.videos = [];
                     store.openCursor().onsuccess = function (e) {
                        var cursor = e.target.result;
                        if (cursor) {
                           lib.videos.push(cursor.value);
                           cursor.continue();
                        }
                        else {
                           lib.videos.sort(function (a, b) {
                              return parseInt(b.time) - parseInt(a.time);
                           });
                           var clickcapt = function () {
                              var current = this.parentNode.querySelector('.videonode.active');
                              if (current && current != this) {
                                 current.classList.remove('active');
                              }
                              if (this.classList.toggle('active')) {
                                 playButton.show();
                                 deleteButton.show();
                                 saveButton.show();
                              }
                              else {
                                 playButton.hide();
                                 deleteButton.hide();
                                 saveButton.hide();
                              }
                           };
                           var staritem = function () {
                              this.parentNode.classList.toggle('starred');
                              var store = lib.db.transaction(['video'], 'readwrite').objectStore('video');
                              if (this.parentNode.classList.contains('starred')) {
                                 this.parentNode.link.starred = true;
                              }
                              else {
                                 this.parentNode.link.starred = false;
                              }
                              store.put(this.parentNode.link);
                           }
                           var createNode = function (video, before) {
                              var node = ui.create.div('.videonode.menubutton.large', clickcapt);
                              node.link = video;
                              var nodename1 = ui.create.div('.menubutton.videoavatar', node);
                              nodename1.setBackground(video.name1, 'character');
                              if (video.name2) {
                                 var nodename2 = ui.create.div('.menubutton.videoavatar2', node);
                                 nodename2.setBackground(video.name2, 'character');
                              }
                              var date = new Date(video.time);
                              var str = date.getFullYear() + '.' + (date.getMonth() + 1) + '.' + (date.getDate()) + ' ' +
                                 date.getHours() + ':';
                              var minutes = date.getMinutes();
                              if (minutes < 10) {
                                 str += '0';
                              }
                              str += minutes;
                              ui.create.div('.caption', video.name[0], node);
                              ui.create.div('.text', str + '<br>' + video.name[1], node);
                              if (video.win) {
                                 ui.create.div('.victory', '胜', node);
                              }

                              if (before) {
                                 page.insertBefore(node, page.firstChild);
                              }
                              else {
                                 page.appendChild(node);
                              }
                              ui.create.div('.video_star', '★', node, staritem);
                              if (video.starred) {
                                 node.classList.add('starred');
                              }
                           }
                           for (var i = 0; i < lib.videos.length; i++) {
                              createNode(lib.videos[i]);
                           }
                           ui.create.videoNode = createNode;
                           var importVideoNode = ui.create.div('.config.switcher.pointerspan',
                              '<span class="underlinenode slim ">导入录像...</span>', function () {
                                 this.nextSibling.classList.toggle('hidden');
                              }, page);
                           importVideoNode.style.marginLeft = '12px';
                           importVideoNode.style.marginTop = '3px';
                           var importVideo = ui.create.div('.config.hidden', page);
                           importVideo.style.whiteSpace = 'nowrap';
                           importVideo.style.marginBottom = '80px';
                           importVideo.style.marginLeft = '13px';
                           importVideo.style.width = 'calc(100% - 30px)';
                           importVideo.innerHTML = '<input type="file" style="width:calc(100% - 40px)">' +
                              '<button style="width:40px">确定</button>';
                           importVideo.lastChild.onclick = function () {
                              var fileToLoad = importVideo.firstChild.files[0];
                              var fileReader = new FileReader();
                              fileReader.onload = function (fileLoadedEvent) {
                                 var data = fileLoadedEvent.target.result;
                                 if (!data) return;
                                 try {
                                    data = JSON.parse(lib.init.decode(data));
                                 }
                                 catch (e) {
                                    console.log(e);
                                    alert('导入失败');
                                    return;
                                 }
                                 var store = lib.db.transaction(['video'], 'readwrite').objectStore('video');
                                 var videos = lib.videos.slice(0);
                                 for (var i = 0; i < videos.length; i++) {
                                    if (videos[i].starred) {
                                       videos.splice(i--, 1);
                                    }
                                 }
                                 for (var deletei = 0; deletei < 5; deletei++) {
                                    if (videos.length >= parseInt(lib.config.video) && videos.length) {
                                       var toremove = videos.pop();
                                       lib.videos.remove(toremove);
                                       store.delete(toremove.time);
                                       for (var i = 0; i < page.childNodes.length; i++) {
                                          if (page.childNodes[i].link == toremove) {
                                             page.childNodes[i].remove();
                                             break;
                                          }
                                       }
                                    }
                                    else {
                                       break;
                                    }
                                 }
                                 for (var i = 0; i < lib.videos.length; i++) {
                                    if (lib.videos[i].time == data.time) {
                                       alert('录像已存在');
                                       return;
                                    }
                                 }
                                 lib.videos.unshift(data);
                                 store.put(data);
                                 createNode(data, true);
                              };
                              fileReader.readAsText(fileToLoad, "UTF-8");
                           }

                           playButton.listen(function () {
                              var current = this.parentNode.querySelector('.videonode.active');
                              if (current) {
                                 game.playVideo(current.link.time, current.link.mode);
                              }
                           });
                           deleteButton.listen(function () {
                              var current = this.parentNode.querySelector('.videonode.active');
                              if (current) {
                                 lib.videos.remove(current.link);
                                 var store = lib.db.transaction(['video'], 'readwrite').objectStore('video');
                                 store.delete(current.link.time);
                                 current.remove();
                              }
                           });
                           saveButton.listen(function () {
                              var current = this.parentNode.querySelector('.videonode.active');
                              if (current) {
                                 game.export(lib.init.encode(JSON.stringify(current.link)),
                                    '无名杀 - 录像 - ' + current.link.name[0] + ' - ' + current.link.name[1]);
                              }
                           });

                           ui.updateVideoMenu = function () {
                              var active = start.firstChild.querySelector('.active');
                              if (active) {
                                 active.classList.remove('active');
                                 active.link.remove();
                              }
                              node.classList.add('active');
                              rightPane.appendChild(page);
                              playButton.style.display = '';
                              deleteButton.style.display = '';
                              saveButton.style.display = '';
                           }
                        }
                     };
                  }());


                  for (var i in lib.help) {
                     var page = ui.create.div('');
                     var node = ui.create.div('.menubutton.large', i, start.firstChild, clickMode);
                     node.type = 'help';
                     node.link = page;
                     node.style.display = 'none';
                     page.classList.add('menu-help');
                     page.innerHTML = lib.help[i];
                  }

                  if (!connectMenu) {
                     var node = ui.create.div('.menubutton.large', '帮助', start.firstChild, function () {
                        var activex = start.firstChild.querySelector('.active');
                        if (this.innerHTML == '帮助') {
                           cheatButton.style.display = 'none';
                           runButton.style.display = 'none';
                           clearButton.style.display = 'none';
                           playButton.style.display = 'none';
                           saveButton.style.display = 'none';
                           deleteButton.style.display = 'none';

                           this.innerHTML = '返回';
                           for (var i = 0; i < start.firstChild.childElementCount; i++) {
                              var nodex = start.firstChild.childNodes[i];
                              if (nodex == node) continue;
                              if (nodex.type == 'help') {
                                 nodex.style.display = '';
                                 if (activex && activex.type != 'help') {
                                    activex.classList.remove('active');
                                    activex.link.remove();
                                    activex = null;
                                    nodex.classList.add('active');
                                    rightPane.appendChild(nodex.link);
                                 }
                              }
                              else {
                                 nodex.style.display = 'none';
                              }
                           }
                        }
                        else {
                           this.innerHTML = '帮助';
                           for (var i = 0; i < start.firstChild.childElementCount; i++) {
                              var nodex = start.firstChild.childNodes[i];
                              if (nodex == node) continue;
                              if (nodex.type != 'help') {
                                 nodex.style.display = '';
                                 if (activex && activex.type == 'help') {
                                    activex.classList.remove('active');
                                    activex.link.remove();
                                    activex = null;
                                    clickMode.call(nodex);
                                 }
                              }
                              else {
                                 nodex.style.display = 'none';
                              }
                           }
                        }
                     });
                  }

                  var active = start.firstChild.querySelector('.active');
                  if (!active) {
                     active = start.firstChild.firstChild;
                     active.classList.add('active');
                  }
                  rightPane.appendChild(active.link);
               }());

               if (menuTimeout) {
                  clearTimeout(menuTimeout);
                  delete window.resetExtension;
                  localStorage.removeItem(lib.configprefix + 'disable_extension', true);
               }
            },
            table: function () {
               var str, row, col, position, position2, fixed, style, divposition;
               for (var i = 0; i < arguments.length; i++) {
                  if (typeof arguments[i] == 'string') str = arguments[i];
                  else if (typeof arguments[i] == 'number') {
                     if (typeof row == 'number') {
                        if (typeof col == 'number') position2 = arguments[i];
                        else col = arguments[i];
                     }
                     else row = arguments[i];
                  }
                  else if (get.objtype(arguments[i]) == 'div' ||
                     get.objtype(arguments[i]) == 'table' ||
                     get.objtype(arguments[i]) == 'tr' ||
                     get.objtype(arguments[i]) == 'td' ||
                     get.objtype(arguments[i]) == 'body') position = arguments[i];
                  else if (typeof arguments[i] == 'boolean') fixed = arguments[i];
                  else if (get.itemtype(arguments[i]) == 'divposition') divposition = arguments[i];
                  else if (typeof arguments[i] == 'object') style = arguments[i];
               }
               if (str == undefined) str = '';
               var node = document.createElement('table');
               for (var i = 0; i < str.length; i++) {
                  if (str[i] == '.') {
                     if (node.className.length != 0) {
                        node.className += ' ';
                     }
                     while (str[i + 1] != '.' && str[i + 1] != '#' && i + 1 < str.length) {
                        node.className += str[i + 1];
                        i++;
                     }
                  }
                  else if (str[i] == '#') {
                     while (str[i + 1] != '.' && str[i + 1] != '#' && i + 1 < str.length) {
                        node.id += str[i + 1];
                        i++;
                     }
                  }
               }
               var tr, td;
               for (var i = 0; i < row; i++) {
                  tr = document.createElement('tr');
                  if (fixed) tr.style.height = (100 / row) + '%';
                  node.appendChild(tr);
                  for (var j = 0; j < col; j++) {
                     td = document.createElement('td');
                     tr.appendChild(td);
                  }
               }
               if (position) {
                  if (typeof position2 == 'number' && position.childNodes.length > position2) {
                     position.insertBefore(node, position.childNodes[position2]);
                  }
                  else {
                     position.appendChild(node);
                  }
               }
               return node;
            },
            giveup: function () {
               if (ui.giveup) return;
               if (!lib.config.show_giveup) return;
               ui.giveup = ui.create.system('投降', function () {
                  var player = game.me;
                  this.remove();
                  if (game.online) {
                     game.send('giveup', player);
                  }
                  else {
                     _status.event.next.length = 0;
                     game.createEvent('giveup', false).setContent(function () {
                        game.log(player, '投降');
                        player.popup('投降');
                        player.die('nosource');
                     }).player = player;
                  }
                  if (_status.paused && _status.imchoosing && !_status.auto) {
                     ui.click.auto();
                  }
               }, true, true);
            },
            groupControl: function (dialog) {
               return ui.create.control(...lib.group2, function (link, node) {//'wei','shu','wu','western','key',
                  if (link == '全部') {
                     dialog.currentcapt = '';
                     dialog.currentgroup = '';
                     for (var i = 0; i < dialog.buttons.length; i++) {
                        dialog.buttons[i].style.display = '';
                     }
                  }
                  else {
                     if (node.classList.contains('thundertext')) {
                        dialog.currentgroup = null;
                        dialog.currentgroupnode = null;
                        node.classList.remove('thundertext');
                        for (var i = 0; i < dialog.buttons.length; i++) {
                           if (dialog.currentcapt && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt)) {
                              dialog.buttons[i].classList.add('nodisplay');
                           }
                           else {
                              dialog.buttons[i].classList.remove('nodisplay');
                           }
                        }
                     }
                     else {
                        if (dialog.currentgroupnode) {
                           dialog.currentgroupnode.classList.remove('thundertext');
                        }
                        dialog.currentgroup = link;
                        dialog.currentgroupnode = node;
                        node.classList.add('thundertext');
                        for (var i = 0; i < dialog.buttons.length; i++) {
                           if (dialog.buttons[i].group != link ||
                              (dialog.currentcapt && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt))) {
                              dialog.buttons[i].classList.add('nodisplay');
                           }
                           else {
                              dialog.buttons[i].classList.remove('nodisplay');
                           }
                        }
                     }
                  }
               });
            },
            /**
             * 生成带有卡牌按钮的弹窗
             * @function
             * @returns {HTMLDivElement} 返回生成的弹窗
             * @see {@link ui.create.characterDialog}
             */
            cardDialog: function () {
               var args = ['thisiscard'];
               for (var i = 0; i < arguments.length; i++) {
                  args.push(arguments[i]);
               }
               return ui.create.characterDialog.apply(this, args);
            },
            characterDialog2: function (filter) {
               var list = [];
               for (var i in lib.character) {
                  if (lib.character[i][4].contains('minskin')) continue;
                  if (lib.character[i][4].contains('boss') || lib.character[i][4].contains('hiddenboss')) {
                     if (lib.config.mode == 'boss') continue;
                     if (!lib.character[i][4].contains('bossallowed')) continue;
                  }

                  if (lib.character[i][4].contains('stonehidden')) continue;
                  if (lib.config.banned.contains(i)) continue;
                  if (filter && filter(i)) continue;
                  list.push(i);
               }
               var dialog = ui.create.dialog('hidden');
               dialog.classList.add('noupdate');
               dialog.classList.add('scroll1');
               dialog.classList.add('scroll2');
               dialog.classList.add('scroll3');
               list.sort(lib.sort.character);
               dialog.classList.add('character');
               dialog.classList.add('choose-character');
               var getPack = function (name) {
                  for (var i in lib.characterPack) {
                     if (lib.characterPack[i][name]) return i;
                  }
                  return null;
               }
               var packs = {};
               var packnode = ui.create.div('.packnode', dialog);
               lib.setScroll(packnode);
               var clickCapt = function () {
                  var active = this.parentNode.querySelector('.active');
                  if (active) {
                     active.classList.remove('active');
                  }
                  this.classList.add('active');
                  for (var i = 0; i < dialog.buttons.length; i++) {
                     if (this.pack && !this.pack.contains(dialog.buttons[i].link)) {
                        dialog.buttons[i].classList.add('nodisplay');
                     }
                     else {
                        dialog.buttons[i].classList.remove('nodisplay');
                     }
                  }
               }
               var createNode = function (packname) {
                  var translate;
                  var pack = null;
                  if (packname == '最近') {
                     pack = get.config('recentCharacter') || [];
                  }
                  else if (packname == '收藏') {
                     pack = lib.config.favouriteCharacter;
                  }
                  var node = ui.create.div('.dialogbutton.menubutton.large', packname, packnode, clickCapt);
                  node.pack = pack;
                  return node;
               }
               dialog.add([list, 'character']);
               var bool = true;
               var node;
               var recent = get.config('recentCharacter');
               if (recent && recent.length) {
                  node = createNode('最近');
                  if (lib.config.character_dialog_tool == '最近') {
                     clickCapt.call(node);
                     bool = false;
                  }
               }
               if (lib.config.favouriteCharacter.length) {
                  node = createNode('收藏');
                  if (lib.config.character_dialog_tool == '收藏') {
                     clickCapt.call(node);
                     bool = false;
                  }
               }
               var node = createNode('全部');
               if (lib.config.character_dialog_tool == 'all') {
                  clickCapt.call(node);
                  bool = false;
               }
               if (bool) {
                  clickCapt.call(packnode.firstChild);
               }

               var node = ui.create.div('.dialogbutton.menubutton.large', '筛选', packnode);
               return dialog;
            },
            /**
             * 生成带有卡牌或角色按钮的弹窗
             * @function
             * @param {?string} thisiscard 是否是卡牌
             * @param {?string} heightset 是否是大弹窗
             * @param {?string} characterx 同一角色是否可替换武将牌（例如在标准和界限突破间切换）
             * @param {?function} filter 卡牌或角色的筛选条件
             * @param {?boolean} noclick 按钮是否可以被点击
             * @returns {HTMLDivElement} 返回生成的弹窗
             */
            characterDialog: function () {
               // if(lib.config.character_dialog_style=='newstyle'){
               //     for(var i=0;i<arguments.length;i++){
               //                  if(arguments[i]=='thisiscard'){
               //                               break;
               //                  }
               //     }
               //     if(i==arguments.length){
               //                  return ui.create.characterDialog2.apply(this,arguments);
               //     }
               // }
               var filter, str, noclick, thisiscard, seperate, expandall, onlypack, heightset, precharacter, characterx;
               for (var i = 0; i < arguments.length; i++) {
                  if (arguments[i] === 'thisiscard') {
                     thisiscard = true;
                  }
                  else if (arguments[i] === 'expandall') {
                     expandall = true;
                  }
                  else if (arguments[i] === 'heightset') {
                     heightset = true;
                  }
                  else if (arguments[i] == 'precharacter') {
                     precharacter = true;
                  }
                  else if (arguments[i] == 'characterx') {
                     characterx = true;
                  }
                  else if (typeof arguments[i] == 'string' && arguments[i].indexOf('onlypack:') == 0) {
                     onlypack = arguments[i].slice(9);
                  }
                  else if (typeof arguments[i] == 'object' && typeof arguments[i].seperate == 'function') {
                     seperate = arguments[i].seperate;
                  }
                  else if (typeof arguments[i] === 'string') {
                     str = arguments[i];
                  }
                  else if (typeof arguments[i] === 'function') {
                     filter = arguments[i];
                  }
                  else if (typeof arguments[i] == 'boolean') {
                     noclick = arguments[i];
                  }
               }
               var list = [];
               var dialog;
               var node = ui.create.div('.caption.pointerspan');
               if (get.is.phoneLayout()) {
                  node.style.fontSize = '30px';
               }
               var namecapt = [];
               var getCapt = function (str) {
                  var capt;
                  if (str.indexOf('_') == -1) {
                     capt = str[0];
                  }
                  else {
                     capt = str[str.lastIndexOf('_') + 1];
                  }
                  capt = capt.toLowerCase();
                  if (!/[a-z]/i.test(capt)) {
                     capt = '自定义';
                  }
                  return capt;
               }
               if (thisiscard) {
                  for (var i in lib.card) {
                     if (!lib.translate[i + '_info']) continue;
                     if (filter && filter(i)) continue;
                     list.push(['', get.translation(lib.card[i].type), i]);
                     if (namecapt.indexOf(getCapt(i)) == -1) {
                        namecapt.push(getCapt(i));
                     }
                  }
               }
               else {
                  for (var i in lib.character) {
                     if (lib.character[i][4].contains('minskin')) continue;
                     if (lib.character[i][4].contains('boss') || lib.character[i][4].contains('hiddenboss')) {
                        if (lib.config.mode == 'boss') continue;
                        if (!lib.character[i][4].contains('bossallowed')) continue;
                     }

                     if (lib.character[i][4].contains('stonehidden')) continue;
                     if (lib.character[i][4].contains('unseen')) continue;
                     if (lib.config.banned.contains(i)) continue;
                     if (lib.characterFilter[i] && !lib.characterFilter[i](get.mode())) continue;
                     if (filter && filter(i)) continue;
                     list.push(i);
                     if (namecapt.indexOf(getCapt(i)) == -1) {
                        namecapt.push(getCapt(i));
                     }
                  }
               }
               namecapt.sort(function (a, b) {
                  return a > b ? 1 : -1;
               });
               if (!thisiscard) {
                  namecapt.remove('自定义');
                  namecapt.push('newline');
                  for (var i in lib.characterDialogGroup) {
                     namecapt.push(i);
                  }
               }
               var newlined = false;
               var newlined2;
               var packsource;
               var clickCapt = function (e) {
                  if (_status.dragged) return;
                  if (dialog.currentcapt2 == '最近' && dialog.currentcaptnode2 != this && !dialog.currentcaptnode2.inited) {
                     dialog.currentcapt2 = null;
                     dialog.currentcaptnode2.classList.remove('thundertext');
                     dialog.currentcaptnode2.inited = true;
                     dialog.currentcaptnode2 = null;
                  }
                  if (this.alphabet) {
                     if (this.classList.contains('thundertext')) {
                        dialog.currentcapt = null;
                        dialog.currentcaptnode = null;
                        this.classList.remove('thundertext');
                        if (this.touchlink) {
                           this.touchlink.classList.remove('active');
                        }
                        for (var i = 0; i < dialog.buttons.length; i++) {
                           if (dialog.currentgroup && dialog.buttons[i].group != dialog.currentgroup) {
                              dialog.buttons[i].classList.add('nodisplay');
                           }
                           else if (dialog.currentcapt2 && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt, true)) {
                              dialog.buttons[i].classList.add('nodisplay');
                           }
                           else {
                              dialog.buttons[i].classList.remove('nodisplay');
                           }
                        }
                     }
                     else {
                        if (dialog.currentcaptnode) {
                           dialog.currentcaptnode.classList.remove('thundertext');
                           if (dialog.currentcaptnode.touchlink) {
                              dialog.currentcaptnode.touchlink.classList.remove('active');
                           }
                        }
                        dialog.currentcapt = this.link;
                        dialog.currentcaptnode = this;
                        this.classList.add('thundertext');
                        if (this.touchlink) {
                           this.touchlink.classList.add('active');
                        }
                        for (var i = 0; i < dialog.buttons.length; i++) {
                           if (dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt)) {
                              dialog.buttons[i].classList.add('nodisplay');
                           }
                           else if (dialog.currentcapt2 && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt, true)) {
                              dialog.buttons[i].classList.add('nodisplay');
                           }
                           else if (dialog.currentgroup && dialog.buttons[i].group != dialog.currentgroup) {
                              dialog.buttons[i].classList.add('nodisplay');
                           }
                           else {
                              dialog.buttons[i].classList.remove('nodisplay');
                           }
                        }
                     }
                  }
                  else {
                     if (newlined2) {
                        newlined2.style.display = 'none';
                        if (!packsource.onlypack) {
                           packsource.classList.remove('thundertext');
                           if (!get.is.phoneLayout() || !lib.config.filternode_button) {
                              packsource.innerHTML = '武将包';
                           }
                        }
                     }
                     if (this.classList.contains('thundertext')) {
                        dialog.currentcapt2 = null;
                        dialog.currentcaptnode2 = null;
                        this.classList.remove('thundertext');
                        if (this.touchlink) {
                           this.touchlink.classList.remove('active');
                        }
                        for (var i = 0; i < dialog.buttons.length; i++) {
                           if (dialog.currentgroup && dialog.buttons[i].group != dialog.currentgroup) {
                              dialog.buttons[i].classList.add('nodisplay');
                           }
                           else if (dialog.currentcapt && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt)) {
                              dialog.buttons[i].classList.add('nodisplay');
                           }
                           else {
                              dialog.buttons[i].classList.remove('nodisplay');
                           }
                        }
                     }
                     else {
                        if (dialog.currentcaptnode2) {
                           dialog.currentcaptnode2.classList.remove('thundertext');
                           if (dialog.currentcaptnode2.touchlink) {
                              dialog.currentcaptnode2.touchlink.classList.remove('active');
                           }
                        }
                        dialog.currentcapt2 = this.link;
                        dialog.currentcaptnode2 = this;
                        this.classList.add('thundertext');
                        if (this.touchlink) {
                           this.touchlink.classList.add('active');
                        }
                        else if (this.parentNode == newlined2) {
                           packsource.innerHTML = this.innerHTML;
                           packsource.classList.add('thundertext');
                        }
                        for (var i = 0; i < dialog.buttons.length; i++) {
                           if (dialog.currentcapt && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt)) {
                              dialog.buttons[i].classList.add('nodisplay');
                           }
                           else if (dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt, true)) {
                              dialog.buttons[i].classList.add('nodisplay');
                           }
                           else if (dialog.currentgroup && dialog.buttons[i].group != dialog.currentgroup) {
                              dialog.buttons[i].classList.add('nodisplay');
                           }
                           else {
                              if (dialog.buttons[i].activate) {
                                 dialog.buttons[i].activate();
                              }
                              dialog.buttons[i].classList.remove('nodisplay');
                           }
                        }
                     }
                  }
                  if (dialog.seperate) {
                     for (var i = 0; i < dialog.seperate.length; i++) {
                        if (!dialog.seperate[i].nextSibling.querySelector('.button:not(.nodisplay)')) {
                           dialog.seperate[i].style.display = 'none';
                           dialog.seperate[i].nextSibling.style.display = 'none';
                        }
                        else {
                           dialog.seperate[i].style.display = '';
                           dialog.seperate[i].nextSibling.style.display = '';
                        }
                     }
                  }
                  if (filternode) {
                     if (filternode.querySelector('.active')) {
                        packsource.classList.add('thundertext');
                     }
                     else {
                        packsource.classList.remove('thundertext');
                     }
                  }
                  if (e) e.stopPropagation();
               };
               for (i = 0; i < namecapt.length; i++) {
                  if (namecapt[i] == 'newline') {
                     newlined = document.createElement('div');
                     newlined.style.marginTop = '5px';
                     newlined.style.display = 'block';
                     // newlined.style.fontFamily='xinwei';
                     if (get.is.phoneLayout()) {
                        newlined.style.fontSize = '32px';
                     }
                     else {
                        newlined.style.fontSize = '22px';
                     }
                     newlined.style.textAlign = 'center';
                     node.appendChild(newlined);
                  }
                  else if (newlined) {
                     var span = ui.create.div('.tdnode.pointerdiv.shadowed.reduce_radius');
                     span.style.margin = '3px';
                     span.style.width = 'auto';
                     span.innerHTML = ' ' + namecapt[i].toUpperCase() + ' ';
                     span.link = namecapt[i];
                     span.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', clickCapt);
                     newlined.appendChild(span);
                     node[namecapt[i]] = span;
                     if (namecapt[i] == '收藏') {
                        span._nature = 'fire';
                     }
                     else {
                        span._nature = 'wood';
                     }
                  }
                  else {
                     var span = document.createElement('span');
                     span.innerHTML = ' ' + namecapt[i].toUpperCase() + ' ';
                     span.link = namecapt[i];
                     span.alphabet = true;
                     span.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', clickCapt);
                     node.appendChild(span);
                  }
               }
               if (!thisiscard) {
                  var groups = lib.group.slice(0).removeArray(['wei', 'shu', 'wu', 'jin', 'western', 'key', 'vtuber', 'clubs']);
                  if (get.mode() == 'guozhan' || (get.mode() == 'versus' && _status.mode != 'jiange')) groups = ['holo', 'nijisanji', 'vtuber', 'clubs'];
                  var bool1 = false;
                  var bool2 = false;
                  var bool3 = (get.mode() == 'guozhan' && _status.forceKey != true && get.config('onlyguozhan'));
                  var bool4 = false;
                  var boolVC = false;
                  for (var i in lib.character) {
                     if (lib.character[i][1] == 'shen') {
                        bool1 = true;
                     }
                     if (bool3 || lib.character[i][1] == 'key') {
                        bool2 = true;
                     }
                     if (!bool4 && get.is.double(i)) bool4 = true;
                     if (['vtuber', 'clubs'].includes(lib.character[i][1])) boolVC = true
                     if (bool1 && bool2 && bool4) break;
                  }
                  if (bool1) groups.add('shen');
                  if (bool2 && !bool3) groups.add('key');
                  if (bool4) groups.add('double');
                  if (boolVC) groups.addArray(['vtuber', 'clubs'])
                  var natures = ['water', 'soil', 'wood', 'metal'];
                  var span = document.createElement('span');
                  newlined.appendChild(span);
                  span.style.margin = '8px';
                  var clickGroup = function () {
                     if (_status.dragged) return;
                     if (dialog.currentcapt2 == '最近' && dialog.currentcaptnode2 != this && !dialog.currentcaptnode2.inited) {
                        dialog.currentcapt2 = null;
                        dialog.currentcaptnode2.classList.remove('thundertext');
                        dialog.currentcaptnode2.inited = true;
                        dialog.currentcaptnode2 = null;
                     }
                     var node = this, link = this.link;
                     if (node.classList.contains('thundertext')) {
                        dialog.currentgroup = null;
                        dialog.currentgroupnode = null;
                        node.classList.remove('thundertext');
                        for (var i = 0; i < dialog.buttons.length; i++) {
                           if (dialog.currentcapt && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt)) {
                              dialog.buttons[i].classList.add('nodisplay');
                           }
                           else if (dialog.currentcapt2 && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt, true)) {
                              dialog.buttons[i].classList.add('nodisplay');
                           }
                           else {
                              dialog.buttons[i].classList.remove('nodisplay');
                           }
                        }
                     }
                     else {
                        if (dialog.currentgroupnode) {
                           dialog.currentgroupnode.classList.remove('thundertext');
                        }
                        dialog.currentgroup = link;
                        dialog.currentgroupnode = node;
                        node.classList.add('thundertext');
                        for (var i = 0; i < dialog.buttons.length; i++) {
                           if (dialog.currentcapt && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt)) {
                              dialog.buttons[i].classList.add('nodisplay');
                           }
                           else if (dialog.currentcapt2 && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt, true)) {
                              dialog.buttons[i].classList.add('nodisplay');
                           }
                           else if (dialog.currentgroup == 'double') {
                              if (dialog.buttons[i]._changeGroup || dialog.buttons[i].group == 'ye') dialog.buttons[i].classList.remove('nodisplay');
                              else dialog.buttons[i].classList.add('nodisplay');
                           }
                           else {
                              if (dialog.buttons[i]._changeGroup || dialog.buttons[i].group == 'ye' || dialog.buttons[i].group != dialog.currentgroup) {
                                 dialog.buttons[i].classList.add('nodisplay');
                              }
                              else {
                                 dialog.buttons[i].classList.remove('nodisplay');
                              }
                           }
                        }
                     }
                  };
                  for (var i = 0; i < groups.length; i++) {
                     var span = ui.create.div('.tdnode.pointerdiv.shadowed.reduce_radius.reduce_margin');
                     span.style.margin = '3px';
                     newlined.appendChild(span);
                     span.innerHTML = lib.translate[groups[i] + '2'] ? get.translation(groups[i] + '2') : get.translation(groups[i]);
                     span.link = groups[i];
                     span._nature = natures[i];
                     span.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', clickGroup);
                  }

                  var span = document.createElement('span');
                  newlined.appendChild(span);
                  span.style.margin = '8px';

                  packsource = ui.create.div('.tdnode.pointerdiv.shadowed.reduce_radius.reduce_margin');
                  packsource.style.margin = '3px';
                  newlined.appendChild(packsource);
                  var filternode = null;
                  var clickCaptNode = function (e) {
                     delete _status.filterCharacter;
                     ui.window.classList.remove('shortcutpaused');
                     filternode.delete();
                     filternode.classList.remove('shown');
                     clickCapt.call(this.link, e);
                  };
                  if (get.is.phoneLayout() && lib.config.filternode_button) {
                     newlined.style.marginTop = '';
                     packsource.innerHTML = '筛选';
                     filternode = ui.create.div('.popup-container.filter-character.modenopause');
                     ui.create.div(filternode);
                     filternode.listen(function (e) {
                        if (this.classList.contains('removing')) return;
                        delete _status.filterCharacter;
                        ui.window.classList.remove('shortcutpaused');
                        this.delete();
                        this.classList.remove('shown');
                        e.stopPropagation();
                     });
                     for (var i = 0; i < node.childElementCount; i++) {
                        if (node.childNodes[i].tagName.toLowerCase() == 'span') {
                           node.childNodes[i].style.display = 'none';
                           node.childNodes[i].touchlink = ui.create.div(filternode.firstChild, clickCaptNode, '.menubutton.large.capt', node.childNodes[i].innerHTML);
                           node.childNodes[i].touchlink.link = node.childNodes[i];
                        }
                     }
                     ui.create.node('br', filternode.firstChild);
                  }
                  else {
                     if (onlypack) {
                        packsource.onlypack = true;
                        packsource.innerHTML = get.translation(onlypack + '_character_config');
                        packsource.style.display = 'none';
                        packsource.previousSibling.style.display = 'none';
                     }
                     else {
                        packsource.innerHTML = '武将包';
                     }
                  }

                  newlined2 = document.createElement('div');
                  newlined2.style.marginTop = '5px';
                  newlined2.style.display = 'none';
                  newlined2.style.fontFamily = 'xinwei';
                  newlined2.classList.add('pointernode');
                  if (get.is.phoneLayout()) {
                     newlined2.style.fontSize = '32px';
                  }
                  else {
                     newlined2.style.fontSize = '22px';
                  }
                  newlined2.style.textAlign = 'center';
                  node.appendChild(newlined2);

                  packsource.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', function () {
                     if (packsource.onlypack) return;
                     if (_status.dragged) return;
                     if (get.is.phoneLayout() && lib.config.filternode_button && filternode) {
                        _status.filterCharacter = true;
                        ui.window.classList.add('shortcutpaused');
                        ui.window.appendChild(filternode);
                        ui.refresh(filternode);
                        filternode.classList.add('shown');
                        var dh = filternode.offsetHeight - filternode.firstChild.offsetHeight;
                        if (dh > 0) {
                           filternode.firstChild.style.top = (dh / 2) + 'px';
                        }
                        else {
                           filternode.firstChild.style.top = '';
                        }
                     }
                     else {
                        if (newlined2.style.display == 'none') {
                           newlined2.style.display = 'block';
                        }
                        else {
                           newlined2.style.display = 'none';
                        }
                     }
                  });
                  var packlist = [];
                  for (var i = 0; i < lib.config.all.characters.length; i++) {
                     if (!lib.config.characters.contains(lib.config.all.characters[i])) continue;
                     packlist.push(lib.config.all.characters[i]);
                  }
                  for (var i in lib.characterPack) {
                     if (!lib.config.all.characters.contains(i) && lib.translate[`${i}_character_config`] !== undefined) {
                        packlist.push(i);
                     }
                  }
                  for (var i = 0; i < packlist.length; i++) {
                     var span = document.createElement('div');
                     span.style.display = 'inline-block';
                     span.style.width = 'auto';
                     span.style.margin = '5px';
                     if (get.is.phoneLayout()) {
                        span.style.fontSize = '32px';
                     }
                     else {
                        span.style.fontSize = '22px';
                     }
                     span.innerHTML = lib.translate[packlist[i] + '_character_config'];
                     span.link = packlist[i];
                     span.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', clickCapt);
                     newlined2.appendChild(span);
                     if (filternode && !onlypack) {
                        span.touchlink = ui.create.div(filternode.firstChild, clickCaptNode, '.menubutton.large', span.innerHTML);
                        span.touchlink.link = span;
                     }
                  }
               }

               var groupSort;
               if (thisiscard) {
                  groupSort = function (name) {
                     var type = lib.card[name[2]].type;
                     if (lib.cardType[type]) {
                        return lib.cardType[type];
                     }
                     switch (type) {
                        case 'basic': return 0;
                        case 'chess': return 1.5;
                        case 'trick': return 2;
                        case 'delay': return 3;
                        case 'equip': return 4;
                        case 'zhenfa': return 5;
                        default: return 6;
                     }
                  };
               }
               else {
                  var getGroup = function (name) {
                     var group = get.is.double(name, true);
                     if (group) return group[0];
                     return lib.character[name][1];
                  },
                     groupSort = function (name) {
                        if (!lib.character[name]) return 50;
                        var group = getGroup(name);
                        if (group == 'vtuber') return 40;
                        if (group == 'clubs') return 41;
                        var list = get.groups();
                        if (list.contains(group)) return list.indexOf(group);
                        return 49;
                     };
               }
               list.sort(function (a, b) {
                  var del = groupSort(a) - groupSort(b);
                  if (del != 0) return del;
                  var aa = a, bb = b;
                  if (a.indexOf('_') != -1) {
                     a = a.slice(a.lastIndexOf('_') + 1);
                  }
                  if (b.indexOf('_') != -1) {
                     b = b.slice(b.lastIndexOf('_') + 1);
                  }
                  if (a != b) {
                     return a > b ? 1 : -1;
                  }
                  return aa > bb ? 1 : -1;
               });
               dialog = ui.create.dialog('hidden');
               dialog.classList.add('noupdate');
               dialog.classList.add('scroll1');
               dialog.classList.add('scroll2');
               dialog.classList.add('scroll3');
               dialog.addEventListener(lib.config.touchscreen ? 'touchend' : 'mouseup', function () {
                  _status.clicked2 = true;
               });
               if (heightset) {
                  dialog.style.height = ((game.layout == 'long2' || game.layout == 'nova') ? 380 : 350) + 'px';
                  dialog._scrollset = true;
               }
               dialog.getCurrentCapt = function (link, capt, noalph) {
                  var currentcapt = noalph ? this.currentcapt2 : this.currentcapt;
                  if (this.seperatelist && noalph) {
                     if (this.seperatelist[currentcapt].contains(link)) return capt;
                     return null;
                  }
                  if (lib.characterDialogGroup[currentcapt]) {
                     return lib.characterDialogGroup[currentcapt](link, capt);
                  }
                  if (lib.characterPack[currentcapt]) {
                     if (lib.characterPack[currentcapt][link]) {
                        return capt;
                     }
                     return null;
                  }
                  return this.currentcapt;
               }
               if (str) {
                  dialog.add(str);
               }
               dialog.add(node);
               if (thisiscard) {
                  if (seperate) {
                     seperate = seperate(list);
                     dialog.seperate = [];
                     dialog.seperatelist = seperate.list;
                     if (dialog.seperatelist) {
                        newlined = document.createElement('div');
                        newlined.style.marginTop = '5px';
                        newlined.style.display = 'block';
                        newlined.style.fontFamily = 'xinwei';
                        if (get.is.phoneLayout()) {
                           newlined.style.fontSize = '32px';
                        }
                        else {
                           newlined.style.fontSize = '22px';
                        }
                        newlined.style.textAlign = 'center';
                        node.appendChild(newlined);
                        for (var i in dialog.seperatelist) {
                           var span = document.createElement('span');
                           span.style.margin = '3px';
                           span.innerHTML = i;
                           span.link = i;
                           span.seperate = true;
                           span.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', clickCapt);
                           newlined.appendChild(span);
                        }
                     }
                     for (var i in seperate) {
                        if (i == 'list') continue;
                        var link = '';
                        var linkcontent = seperate[i];
                        if (i.indexOf('_link:') != -1) {
                           link = i.slice(i.indexOf('_link:') + 6);
                           i = i.slice(0, i.indexOf('_link:'));
                        }
                        var nodesep = dialog.add(i);
                        nodesep.link = link;
                        dialog.seperate.push(nodesep);
                        dialog.add([linkcontent, 'vcard'], noclick);
                     }
                  }
                  else {
                     dialog.add([list, 'vcard'], noclick);
                  }
               }
               else {
                  if (precharacter) {
                     dialog.add([list, 'precharacter'], noclick);
                  }
                  else if (characterx) {
                     dialog.add([list, 'characterx'], noclick);
                  }
                  else {
                     dialog.add([list, 'character'], noclick);
                  }
               }
               dialog.add(ui.create.div('.placeholder'));
               for (i = 0; i < dialog.buttons.length; i++) {
                  if (thisiscard) {
                     dialog.buttons[i].capt = getCapt(dialog.buttons[i].link[2]);
                  }
                  else {
                     dialog.buttons[i].group = lib.character[dialog.buttons[i].link][1];
                     dialog.buttons[i].capt = getCapt(dialog.buttons[i].link);
                  }
               }
               if (!expandall) {
                  if (!thisiscard && (lib.characterDialogGroup[lib.config.character_dialog_tool] ||
                     lib.config.character_dialog_tool == '自创')) {
                     clickCapt.call(node[lib.config.character_dialog_tool]);
                  }
               }
               return dialog;
            },
            dialog: function (...args) {
               let small = null, hidden = notouchscroll = forcebutton = promotionbutton = false;
               let dialog = ui.create.div('.dialog');
               dialog.contentContainer = ui.create.div('.content-container', dialog);
               dialog.content = ui.create.div('.content', dialog.contentContainer);
               dialog.bar1 = ui.create.div('.bar.top', dialog);
               dialog.bar2 = ui.create.div('.bar.bottom', dialog);
               dialog.buttons = [];
               for (let i in lib.element.dialog) {
                  dialog[i] = lib.element.dialog[i];
               }
               for (let i of args) {
                  if (typeof i == 'boolean') dialog.static = i;
                  else if (i == 'hidden') hidden = true;
                  else if (i == 'notouchscroll') notouchscroll = true;
                  else if (i == 'forcebutton') forcebutton = true;
                  else if (i == 'promotionbutton') promotionbutton = true;
                  else if (i == 'small') small = true;
                  else {
                     dialog.add(i, small, small);
                  }
               }
               if (!hidden) {
                  dialog.open();
               }
               if (!lib.config.touchscreen) dialog.contentContainer.onscroll = ui.update;
               if (!notouchscroll) {
                  dialog.contentContainer.ontouchstart = ui.click.dialogtouchStart;
                  dialog.contentContainer.ontouchmove = ui.click.touchScroll;
                  dialog.contentContainer.style.WebkitOverflowScrolling = 'touch';
                  dialog.ontouchstart = ui.click.dragtouchdialog;
               }
               if (forcebutton) {
                  dialog.forcebutton = true;
                  dialog.classList.add('forcebutton');
               }
               if (promotionbutton) {
                  dialog.promotionbutton = true;
                  dialog.classList.add('promotionbutton');
               }
               return dialog;
            },
            line2: function () {
               var node = ui.create.line.apply(this, arguments);
               node.classList.add('line2');
               return node;
            },
            line: function () {
               var two = false, func;
               var node = ui.create.div('.config');
               for (var i = 0; i < arguments.length; i++) {
                  if (typeof arguments[i] == 'string' || typeof arguments[i] == 'number') {
                     if (two) ui.create.div('.toggle', node).innerHTML = arguments[i];
                     else {
                        ui.create.div(node).innerHTML = arguments[i];
                        two = true;
                     }
                  }
                  else if (typeof arguments[i] == 'function') func = arguments[i];
               }
               if (func) {
                  for (var i = 0; i < node.childNodes.length; i++) node.childNodes[i].listen(func);
               }
               return node;
            },
            switcher: function (name, current, current2) {
               var func;
               var node = ui.create.div('.config');
               ui.create.div(node).innerHTML = get.translation(name + '_config');
               var switcher = ui.create.div('.toggle.pointerdiv', node);
               switcher.name = name;
               for (var i = 0; i < arguments.length; i++) {
                  if (typeof arguments[i] == 'function') {
                     func = arguments[i]; break;
                  }
               }
               if (typeof current == 'string') {
                  switcher.link = current;
                  switcher.innerHTML = get.translation(current);
                  switcher.contentEditable = true;
                  switcher.style.webkitUserSelect = 'text';
                  switcher.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.editor);
               }
               else if (typeof current == 'object') {
                  switcher.link = current2 || current[0];
                  switcher.innerHTML = get.translation(switcher.link);
                  switcher.choice = current;
                  switcher.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.switcher);
               }
               else {
                  if (current) {
                     switcher.classList.add('on');
                  }
                  switcher.classList.add('onoff');
                  ui.create.div(ui.create.div(switcher));
                  switcher.link = current ? true : false;
                  switcher.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.toggle);
               }
               if (func) switcher.additionalCommand = func;
               return node;
            },
            caption: function (str, position) {
               var caption = ui.create.div('.caption', position);
               caption.innerHTML = str;
               return caption;
            },
            /**
             * 生成底部控制按钮
             * @function
             * @param {?Array} controls 控制按钮列表
             * @param {?string} stayleft 控制按钮是否靠左侧
             * @param {?function} clickCallback 点击回调函数
             * @returns {HTMLDivElement} 反正生成的按钮
             */
            control: function () {
               var nc = !ui.control.querySelector('div:not(.removing):not(.stayleft)');
               var i, controls;
               var nozoom = false;
               if (Array.isArray(arguments[0])) controls = arguments[0];
               else controls = arguments;
               var control = ui.create.div('.control');
               ui.control.insertBefore(control, _status.createControl || ui.confirm);
               for (i in lib.element.control) {
                  control[i] = lib.element.control[i];
               }
               for (i = 0; i < controls.length; i++) {
                  if (typeof controls[i] == 'function') {
                     control.custom = controls[i];
                  }
                  else if (controls[i] == 'nozoom') {
                     nozoom = true;
                  }
                  else if (controls[i] == 'stayleft') {
                     control.stayleft = true;
                     control.classList.add('stayleft');
                  }
                  else {
                     control.add(controls[i]);
                  }
               }
               ui.controls.unshift(control);
               if (nc) {
                  ui.control.animate('nozoom', 100);
               }
               // if(ui.control.classList.contains('nozoom')){
               //     nozoom=true;
               // }
               // if(nozoom){
               //     control.classList.add('nozoom');
               // }
               if (control.childNodes.length) {
                  // if(nozoom||true){
                  control.style.transition = 'opacity 0.5s';
                  control.animate('controlpressdownx', 500);
                  // }
                  // else{
                  //     control.style.transition='';
                  //     control.style.transform='scale(0.8)';
                  // }
                  ui.refresh(control);
                  if (!control.stayleft) {
                     control.style.transform = 'translateX(-' + (control.offsetWidth / 2) + 'px)';
                  }
                  control.style.opacity = 1;
                  ui.refresh(control);
                  control.style.transition = '';
               }

               control.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.control2);

               if (true) {
                  control.addEventListener(lib.config.touchscreen ? 'touchstart' : 'mousedown', function () {
                     if (this.classList.contains('disabled')) return;
                     this.classList.add('controlpressdown');
                     if (typeof this._offset == 'number') {
                        this.style.transform = 'translateX(' + this._offset + 'px) scale(0.97)';
                     }
                  });
                  control.addEventListener(lib.config.touchscreen ? 'touchend' : 'mouseup', function () {
                     this.classList.remove('controlpressdown');
                     if (typeof this._offset == 'number') {
                        this.style.transform = 'translateX(' + this._offset + 'px)';
                     }
                  });
               }

               ui.updatec();
               return control;
            },
            confirm: function (str, func) {
               if (ui.confirm && ui.confirm.str == str) {
                  return;
               }
               if (str == 'o') {
                  if (ui.confirm) {
                     ui.confirm.replace('ok');
                  }
                  else {
                     ui.confirm = ui.create.control('ok');
                  }
               }
               else if (str == 'oc' || str == 'co') {
                  if (ui.confirm) {
                     ui.confirm.replace('ok', 'cancel');
                  }
                  else {
                     ui.confirm = ui.create.control('ok', 'cancel');
                  }
               }
               else if (str == 'c') {
                  if (ui.confirm) {
                     ui.confirm.replace('cancel');
                  }
                  else {
                     ui.confirm = ui.create.control('cancel');
                  }
               }
               else if (ui.confirm) {
                  ui.confirm.close();
                  delete ui.confirm;
               }
               if (ui.confirm) {
                  ui.confirm.str = str;
                  if (func) ui.confirm.custom = func;
                  else delete ui.confirm.custom;
               }
            },
            skills: function (skills) {
               var i, same;
               if (ui.skills) {
                  if (ui.skills.skills.length == skills.length && ui.skills.style.display != 'none') {
                     same = true;
                     for (i = 0; i < skills.length; i++) {
                        if (ui.skills.skills.contains(skills[i]) == false) {
                           same = false;
                           break;
                        }
                     }
                  }
                  if (same) return;
                  ui.skills.close();
                  delete ui.skills;
               }
               if (skills == undefined || skills.length == 0) return;
               if (!_status.event.isMine()) {
                  _status.noupdatec = true;
               }
               ui.skills = ui.create.control(skills.concat([ui.click.skill]));
               for (var i = 0; i < ui.skills.childNodes.length; i++) {
                  ui.skills.childNodes[i].innerHTML = get.skillTranslation(ui.skills.childNodes[i].link, _status.event.player);
               }
               if (!_status.event.isMine()) {
                  ui.skills.style.display = 'none';
               }
               else {
                  ui.updatec();
               }
               _status.noupdatec = false;
               ui.skills.skills = skills;
               return ui.skills;
            },
            skills2: function (skills) {
               var i, same;
               if (ui.skills2) {
                  if (ui.skills2.skills.length == skills.length && ui.skills2.style.display != 'none') {
                     same = true;
                     for (i = 0; i < skills.length; i++) {
                        if (ui.skills2.skills.contains(skills[i]) == false) {
                           same = false;
                           break;
                        }
                     }
                  }
                  if (same) return;
                  ui.skills2.close();
                  delete ui.skills2;
               }
               if (skills == undefined || skills.length == 0) return;
               if (!_status.event.isMine()) {
                  _status.noupdatec = true;
               }
               ui.skills2 = ui.create.control(skills.concat([ui.click.skill]));
               for (var i = 0; i < ui.skills2.childNodes.length; i++) {
                  ui.skills2.childNodes[i].innerHTML = get.skillTranslation(ui.skills2.childNodes[i].link, _status.event.player);
               }
               if (!_status.event.isMine()) {
                  ui.skills2.style.display = 'none';
               }
               else {
                  ui.updatec();
               }
               _status.noupdatec = false;
               ui.skills2.skills = skills;
               return ui.skills2;
            },
            skills3: function (skills) {
               var i, same;
               if (ui.skills3) {
                  if (ui.skills3.skills.length == skills.length && ui.skills3.style.display != 'none') {
                     same = true;
                     for (i = 0; i < skills.length; i++) {
                        if (ui.skills3.skills.contains(skills[i]) == false) {
                           same = false;
                           break;
                        }
                     }
                  }
                  if (same) return;
                  ui.skills3.close();
                  delete ui.skills3;
               }
               if (skills == undefined || skills.length == 0) return;
               if (!_status.event.isMine()) {
                  _status.noupdatec = true;
               }
               ui.skills3 = ui.create.control(skills.concat([ui.click.skill]));
               for (var i = 0; i < ui.skills3.childNodes.length; i++) {
                  ui.skills3.childNodes[i].innerHTML = get.skillTranslation(ui.skills3.childNodes[i].link, _status.event.player);
               }
               if (!_status.event.isMine()) {
                  ui.skills3.style.display = 'none';
               }
               else {
                  ui.updatec();
               }
               _status.noupdatec = false;
               ui.skills3.skills = skills;
               return ui.skills3;
            },
            arena: function () {
               if (!lib.config.low_performance) game.clickCanvas.changeCanvas({ size: [4, 10], particles: 10 })
               ui.window = ui.create.div('#window.hidden', document.body);
               ui.create.div('#statusbg', document.body);
               ui.refresh(ui.window);
               if (!localStorage.getItem(lib.configprefix + 'playback')) {
                  ui.window.show();
               }
               else {
                  setTimeout(function () {
                     ui.window.show();
                  }, 1000);
               }
               // lib.setPressure(ui.window,ui.click.pressurepause);
               if (window.isNonameServer) {
                  ui.window.classList.add('server');
                  var serverinfo = ui.create.div('.serverinfo', ui.window);
                  ui.create.div('', '服务器正在运行', serverinfo);
                  var serverinfotable = ui.create.table(2, 2, ui.create.div(serverinfo));
                  serverinfotable.style.display = 'inline-block';
                  serverinfotable.firstChild.firstChild.innerHTML = '房间人数：';
                  serverinfotable.firstChild.lastChild.id = 'server_count';
                  serverinfotable.firstChild.lastChild.innerHTML = '0';
                  serverinfotable.lastChild.firstChild.innerHTML = '房间状态：';
                  serverinfotable.lastChild.lastChild.id = 'server_status';
                  serverinfotable.lastChild.lastChild.innerHTML = '空闲';
                  ui.create.div('.menubutton.large', '关闭服务器', function () {
                     if (_status.gameStarted && !confirm('关闭服务器当前进行的游戏将终止且不可恢复，是否确定关闭？')) {
                        return;
                     }
                     localStorage.removeItem(lib.configprefix + 'asserver');
                     game.reload();
                  }, ui.create.div('', serverinfo));
               }

               ui.window.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.window);
               ui.system = ui.create.div("#system.", ui.window);
               ui.arena = ui.create.div('#arena.nome', ui.window);
               if (lib.device == 'ios' && !get.is.phoneLayout()) {
                  ui.arena.classList.add('ipad');
               }
               ui.arena.setNumber = function (num) {
                  this.dataset.number = num;
                  // if(game.layout=='nova'&&parseInt(num)<7){
                  //     ui.arena.classList.add('player_autolong');
                  // }
                  // else if(lib.config.player_height_nova!='long'){
                  //     ui.arena.classList.remove('player_autolong');
                  // }
                  // if(game.layout=='long'&&parseInt(num)<parseInt(lib.config.fewplayer)){
                  //     this.classList.add('fewplayer');
                  // }
                  // else{
                  //     this.classList.remove('fewplayer');
                  // }
               }

               if (lib.config.low_performance) {
                  ui.window.classList.add('low_performance');
               }
               if (game.layout == 'mobile' || game.layout == 'long') {
                  ui.arena.classList.add('mobile');
               }
               if (game.layout == 'long' || game.layout == 'long2') {
                  ui.arena.classList.add('long');
               }
               if (game.layout == 'default') {
                  ui.arena.classList.add('oldlayout');
               }
               if (lib.config.player_border != 'wide' || game.layout == 'long' || game.layout == 'long2') {
                  ui.arena.classList.add('slim_player');
               }
               if (lib.config.player_border == 'slim') {
                  ui.arena.classList.add('uslim_player');
               }
               if (lib.config.player_border == 'narrow') {
                  ui.arena.classList.add('mslim_player');
               }
               if (lib.config.player_border == 'normal' && lib.config.mode != 'brawl' && (game.layout == 'long' || game.layout == 'long2')) {
                  ui.arena.classList.add('lslim_player');
               }
               ui.window.dataset.player_border = lib.config.player_border;
               if (lib.config.compatiblemode) {
                  ui.window.classList.add('compatiblemode');
               }
               ui.window.dataset.radius_size = lib.config.radius_size || 'default';
               // if (game.layout == 'long' || game.layout == 'mobile') {
               //    if (lib.config.textequip == 'text') ui.arena.classList.add('textequip');
               // }
               if (game.layout == 'long' || game.layout == 'long2' || game.layout == 'mobile' || game.layout == 'nova') {
                  if (lib.config.cardshape == 'oblong') {
                     ui.window.classList.add('oblongcard');
                     ui.arena.classList.add('oblongcard');
                  }
               }
               if (lib.config.blur_ui) {
                  ui.window.classList.add('blur_ui');
               }
               if (lib.config.glass_ui) {
                  ui.window.classList.add('glass_ui');
               }
               if (lib.config.custom_button) {
                  lib.configMenu.appearence.config.custom_button.onclick('skip');
               }

               if (lib.config.show_statusbar_ios == 'overlay') {
                  document.body.classList.add('statusbar');
               }
               if (lib.config.keep_awake) {
                  if (window.plugins && window.plugins.insomnia) window.plugins.insomnia.keepAwake();
                  else {
                     let NoSleep = __webpack_require__(4978)
                     let noSleep = new NoSleep();
                     document.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', function enableNoSleep() {
                        document.removeEventListener(lib.config.touchscreen ? 'touchend' : 'click', enableNoSleep, false);
                        noSleep.enable();
                        window.noSleep = noSleep;
                     }, false);
                  }
               }

               lib.updateURL = lib.updateURLS[lib.config.update_link] || lib.updateURLS.coding;

               lib.init.cssstyles();

               ui.arena.dataset.player_height = lib.config.player_height || 'default';
               ui.arena.dataset.player_height_nova = lib.config.player_height_nova || 'default';
               // if(lib.config.player_height_nova=='long') ui.arena.classList.add('player_autolong');
               ui.arena.dataset.target_shake = lib.config.target_shake || 'off';
               ui.backgroundMusic = document.createElement('audio');
               ui.backgroundMusic.volume = lib.config.volumn_background / 8;
               game.playBackgroundMusic();
               ui.backgroundMusic.autoplay = true;
               ui.backgroundMusic.addEventListener('ended', game.playBackgroundMusic);
               ui.window.appendChild(ui.backgroundMusic);
               if (lib.config.turned_style == false) {
                  ui.arena.classList.add('hide_turned');
               }
               if (lib.config.link_style2 != 'chain') {
                  ui.arena.classList.add('nolink');
               }
               if (lib.config.show_name == false) {
                  ui.arena.classList.add('hide_name');
               }
               if (lib.config.change_skin_auto != 'off') {
                  _status.skintimeout = setTimeout(ui.click.autoskin, parseInt(lib.config.change_skin_auto));
               }
               if (lib.config.border_style && lib.config.border_style.indexOf('dragon_') == 0) {
                  ui.arena.dataset.framedecoration = lib.config.border_style.slice(7);
               }

               ui.gameinfo = ui.create.div('#time', ui.window);

               ui.arenalog = ui.create.div('#arenalog', ui.arena);
               if (lib.config.show_log == 'off') {
                  ui.arenalog.style.display = 'none';
               }
               else {
                  ui.arenalog.dataset.position = lib.config.show_log;
               }
               ui.historybar = ui.create.div('#historybar.shadowed', ui.window);
               lib.setScroll(ui.historybar);

               ui.roundmenu = ui.create.div('#roundmenu.roundarenabutton.menubutton.round', ui.arena);
               ui.roundmenu._position = [180, 210];
               ui.create.div(ui.roundmenu);
               ui.create.div(ui.roundmenu);
               ui.create.div(ui.roundmenu);
               ui.create.div(ui.roundmenu);
               ui.create.div(ui.roundmenu);
               ui.create.div(ui.roundmenu);

               ui.create.div(ui.roundmenu);
               ui.create.div(ui.roundmenu);
               ui.create.div(ui.roundmenu);
               ui.create.div(ui.roundmenu);
               ui.create.div(ui.roundmenu);
               ui.create.div(ui.roundmenu);

               ui.create.div(ui.roundmenu);
               ui.create.div(ui.roundmenu);

               ui.create.div(ui.roundmenu);

               if (lib.config.show_time2) {
                  ui.roundmenu.classList.add('clock');
               }
               ui.roundmenu.dataset.watchface = lib.config.watchface || 'none';
               if (get.is.phoneLayout()) {
                  if (lib.config.show_time3) {
                     ui.time3 = ui.create.div('.touchinfo.left', ui.window);
                  }
                  ui.cardPileNumber = ui.create.div('.touchinfo.right', ui.window);
               }
               else {
                  if (lib.config.show_time3) {
                     ui.time3 = ui.create.div(ui.gameinfo);
                  }
                  ui.cardPileNumber = ui.create.div(ui.gameinfo);
               }
               if (!lib.config.show_cardpile_number) {
                  ui.cardPileNumber.style.display = 'none';
               }
               if (ui.time3) {
                  ui.time3.starttime = get.utc();
                  ui.time3.interval = setInterval(function () {
                     var num = Math.round((get.utc() - ui.time3.starttime) / 1000);
                     if (num >= 3600) {
                        var num1 = Math.floor(num / 3600);
                        var num2 = Math.floor((num - num1 * 3600) / 60);
                        if (num2 < 10) {
                           num2 = '0' + num2.toString();
                        }
                        var num3 = num - num1 * 3600 - parseInt(num2) * 60;
                        if (num3 < 10) {
                           num3 = '0' + num3.toString();
                        }
                        ui.time3.innerHTML = num1 + ':' + num2 + ':' + num3;
                     }
                     else {
                        var num1 = Math.floor(num / 60);
                        var num2 = num - num1 * 60;
                        if (num2 < 10) {
                           num2 = '0' + num2.toString();
                        }
                        ui.time3.innerHTML = num1 + ':' + num2;
                     }
                  }, 1000);
               }
               if (get.is.nomenu()) {
                  if (!['menu', 'system'].contains(lib.config.round_menu_func)) {
                     lib.config.round_menu_func = 'system';
                  }
               }
               else if (!lib.config.show_round_menu) {
                  ui.roundmenu.style.display = 'none';
               }

               var resetround = function (e) {
                  _status.draggingroundmenu = false;
                  ui.roundmenu.style.transform = '';
                  ui.roundmenu._dragtransform = [0, 0];
                  ui.roundmenu.style.transition = 'all 0.3s';
                  delete ui.roundmenu._dragtouches;
                  delete ui.roundmenu._dragorigin;
                  delete ui.roundmenu._dragorigintransform;
                  setTimeout(function () {
                     ui.roundmenu.style.transition = '';
                  }, 500);
                  game.saveConfig('roundmenu_transform', [0, 0]);
                  if (e) e.stopPropagation();
                  return false;
               };
               ui.click.resetround = resetround;
               if (lib.config.touchscreen) {
                  ui.roundmenu.addEventListener('touchstart', function (e) {
                     _status.draggingroundmenu = true;
                     ui.roundmenu._dragorigin = {
                        clientX: e.touches[0].clientX,
                        clientY: e.touches[0].clientY,
                     };
                     if (!ui.roundmenu._dragtransform) {
                        ui.roundmenu._dragtransform = [0, 0];
                     }
                     ui.roundmenu._dragorigintransform = ui.roundmenu._dragtransform.slice(0);
                     ui.roundmenu._resetTimeout = setTimeout(function () {
                        resetround();
                        delete ui.roundmenu._resetTimeout;
                     }, 1000);
                  });
               }
               else {
                  ui.roundmenu.oncontextmenu = resetround;
               }
               if (!lib.config.remember_round_button) {
                  game.saveConfig('roundmenu_transform');
               }
               if (lib.config.roundmenu_transform) {
                  var translate = lib.config.roundmenu_transform;
                  ui.roundmenu._dragtransform = translate;
                  ui.roundmenu.style.transform = 'translate(' + translate[0] + 'px,' + translate[1] + 'px)';
                  ui.click.checkroundtranslate();
               }
               if (get.is.phoneLayout()) {
                  ui.arena.classList.add('phone');
               }

               ui.sidebar = ui.create.div('#sidebar');
               ui.sidebar3 = ui.create.div('#sidebar3');
               ui.canvas = document.createElement('canvas');

               ui.arena.appendChild(ui.canvas);
               ui.canvas.id = 'canvas';
               ui.ctx = ui.canvas.getContext('2d');

               ui.sidebar.ontouchstart = ui.click.touchStart;
               ui.sidebar.ontouchmove = ui.click.touchScroll;
               ui.sidebar.style.WebkitOverflowScrolling = 'touch';

               var zoom;
               switch (lib.config.ui_zoom) {
                  case 'esmall': zoom = 0.8; break;
                  case 'vsmall': zoom = 0.9; break;
                  case 'small': zoom = 0.93; break;
                  case 'big': zoom = 1.05; break;
                  case 'vbig': zoom = 1.1; break;
                  case 'ebig': zoom = 1.2; break;
                  default: zoom = 1;
               }
               game.documentZoom = game.deviceZoom * zoom;
               if (zoom != 1) {
                  ui.updatez();
               }

               ui.system1 = ui.create.div('#system1', ui.system);
               ui.system2 = ui.create.div('#system2', ui.system);

               ui.replay = ui.create.system('重来', game.reload, true);
               ui.replay.id = 'restartbutton';
               ui.config2 = ui.create.system('选项', ui.click.config);
               ui.pause = ui.create.system('暂停', ui.click.pause);
               ui.pause.id = 'pausebutton';
               if (!_status.video) {
                  ui.pause.hide();
               }
               if (!lib.config.touchscreen) {
                  lib.setPopped(ui.pause, ui.click.pausehistory, 220, 400, null, true);
               }
               if (!lib.config.show_pause) {
                  ui.pause.style.display = 'none';
               }
               ui.cardPileButton = ui.create.system('牌堆', null, true);
               ui.cardPileButton.style.display = 'none';
               lib.setPopped(ui.cardPileButton, ui.click.cardPileButton, 220);
               ui.wuxie = ui.create.system('不询问无懈', ui.click.wuxie, true);
               if (!lib.config.touchscreen) {
                  lib.setPopped(ui.config2, ui.click.pauseconfig, 170);
               }
               ui.auto = ui.create.system('托管', ui.click.auto);
               if (!game.syncMenu) {
                  ui.config2.classList.add('hidden');
                  ui.config2.style.transition = 'all 0.5s';
                  ui.roundmenu.classList.add('transparent2');

                  ui.auto.style.opacity = 0.5;
                  ui.auto.style.transition = 'all 0.5s';
                  lib.onfree.push(function () {
                     ui.auto.style.opacity = '';
                     setTimeout(function () {
                        ui.auto.style.transition = '';
                     }, 500);
                  });
               }
               ui.auto.id = 'autobutton';
               ui.autonode = ui.create.div('#autonode', '<div>托管中...</div>', ui.arena);
               ui.autonode.listen(ui.click.auto);
               if (lib.config.mode == 'connect') {
                  ui.auto.hide();
                  ui.pause.hide();
               }

               if (lib.forcehide) {
                  if (lib.forcehide.contains('replay')) ui.replay.classList.add('forcehide');
                  if (lib.forcehide.contains('auto')) ui.auto.classList.add('forcehide');
                  if (lib.forcehide.contains('pause')) ui.pause.classList.add('forcehide');
                  if (lib.forcehide.contains('wuxie')) ui.wuxie.classList.add('forcehide');
                  if (lib.forcehide.contains('cardPileButton')) ui.cardPileButton.classList.add('forcehide');
               }
               ui.volumn = ui.create.system('♫');
               lib.setPopped(ui.volumn, ui.click.volumn, 200);
               // if(lib.config.show_pause) ui.auto.style.marginLeft='10px';
               if (!lib.config.show_volumn) {
                  ui.volumn.style.display = 'none';
               }
               if (!lib.config.show_auto) {
                  ui.auto.style.display = 'none';
               }
               if (!lib.config.show_wuxie) {
                  ui.wuxie.style.display = 'none';
               }
               // if(!lib.config.show_cardpile||_status.connectMode){
               //     ui.cardPileButton.style.display='none';
               // }

               ui.sortCard = ui.create.system('整理手牌', function () {
                  if (!game.me) return;
                  var hs = game.me.getCards('h');
                  if (!hs.length) return;
                  game.addVideo('lose', game.me, [get.cardsInfo(hs), [], [], []]);
                  for (var i = 0; i < hs.length; i++) {
                     hs[i].goto(ui.special);
                  }
                  hs.sort(function (b, a) {
                     if (a.name != b.name) return lib.sort.card(a.name, b.name);
                     else if (a.suit != b.suit) return lib.suit.indexOf(a) - lib.suit.indexOf(b);
                     else return a.number - b.number;
                  });
                  game.me.directgain(hs, false);
               });
               if (!lib.config.show_sortcard) {
                  ui.sortCard.style.display = 'none';
               }
               if (lib.config.mode != 'yindao') {
                  ui.playerids = ui.create.system('显示身份', function () {
                     if (game.showIdentity) {
                        game.showIdentity();
                        _status.identityShown = true;
                     }
                  }, true);
                  if (!lib.config.show_playerids || !game.showIdentity) {
                     ui.playerids.style.display = 'none';
                  }
               }
               if (!lib.config.show_replay) {
                  ui.replay.style.display = 'none';
               }
               ui.control = ui.create.div('#control', ui.arena).animate('nozoom');
               ui.cardPile = ui.create.div('#cardPile');
               ui.discardPile = ui.create.div('#discardPile');
               ui.special = ui.create.div('#special');
               ui.ordering = ui.create.div('#ordering');
               ui.dialogs = [];
               ui.controls = [];
               ui.style = {};

               ui.time = ui.create.div(ui.gameinfo);
               var timeInterval = function () {
                  var date = new Date();
                  var hours = date.getHours();
                  var minutes = date.getMinutes();
                  if (lib.config.watchface == 'simple') {
                     ui.roundmenu.childNodes[13].style.transform = 'rotate(' + get.round((hours + 9) * 30, 2) + 'deg)';
                  }
                  else {
                     ui.roundmenu.childNodes[13].style.transform = 'rotate(' + get.round((hours + minutes / 60 + 9) * 30, 2) + 'deg)';
                  }
                  ui.roundmenu.childNodes[12].style.transform = 'rotate(' + (minutes + 45) * 6 + 'deg)';
                  if (minutes < 10) {
                     minutes = '0' + minutes.toString();
                  }
                  ui.time.innerHTML = hours + ':' + minutes;
               };
               _status.timeInterval = setInterval(timeInterval, 30000);
               timeInterval();
               if (!lib.config.show_time) {
                  ui.time.style.display = 'none';
               }

               ui.timer = ui.create.div('.skillbar.shadowed.playerbg.hidden');
               ui.timer.id = 'timer';
               ui.create.div('.skillbarshadow', ui.timer);
               ui.create.div('.skillbarfill', ui.timer);
               ui.timer.fillnode = ui.create.div(ui.timer.lastChild);
               ui.timer.popnode = ui.create.div('.skillbartext', ui.timer);
               ui.timer.popnode.style.opacity = 1;
               ui.timer.position = 4;
               ui.timer.style.zIndex = 5;
               ui.timer.set = function (text, percentage) {
                  if (typeof text == 'string' || typeof text == 'number') {
                     ui.timer.popnode.innerHTML = text;
                  }
                  ui.timer.fillnode.style.top = ((1 - percentage) * 100) + '%';
               }
               var setTimerPosition = function (e) {
                  this.position++;
                  if (this.position > 4) {
                     this.position = 1;
                  }
                  var left1 = '180px';
                  var left2 = 'calc(100% - 245px)';
                  var top1 = '210px';
                  var top2 = 'calc(100% - 245px)';
                  if (game.layout == 'default') {
                     left1 = '265px';
                     top1 = '160px';
                     left2 = 'calc(100% - 330px)';
                     top2 = 'calc(100% - 235px)';
                  }
                  if (this.position == 1 || this.position == 2) {
                     this.style.top = top2;
                  }
                  else {
                     this.style.top = top1;
                  }
                  if (this.position == 1 || this.position == 4) {
                     this.style.left = left2;
                  }
                  else {
                     this.style.left = left1;
                  }
               }
               ui.timer.listen(setTimerPosition);

               ui.shortcut = ui.create.div('#shortcut.hidden', ui.window);
               ui.shortcut.listen(ui.click.shortcut);
               ui.create.div(ui.shortcut, function (e) { e.stopPropagation() });
               ui.create.div('.menubutton.round', '<span>重来</span>', ui.shortcut, game.reload).dataset.position = 1;
               ui.create.div('.menubutton.round', '<span>退出</span>', ui.shortcut, game.exit).dataset.position = 3;
               ui.create.div('.menubutton.round', '<span>记录</span>', ui.shortcut, ui.click.pause).dataset.position = 4;
               ui.shortcut.autobutton = ui.create.div('.menubutton.round', '<span>托管</span>', ui.shortcut, ui.click.auto);
               ui.shortcut.autobutton.dataset.position = 2;
               ui.favmodelist = ui.create.div('.favmodelist', ui.shortcut);
               ui.favmodelist.update = function () {
                  this.innerHTML = '';
                  var num = Math.min(6, lib.config.favouriteMode.length);
                  for (var i = 0; i < num; i++) {
                     this.add(lib.config.favouriteMode[i], i);
                  }
                  var mode = get.mode();
                  if (typeof get.config(mode + '_mode') == 'string') {
                     mode += '|' + get.config(mode + '_mode');
                  }
                  if (lib.config.favouriteMode.contains(mode)) {
                     ui.favmode.classList.add('glow');
                  }
                  else {
                     ui.favmode.classList.remove('glow');
                  }
               };
               ui.favmodelist.add = function (name, index) {
                  var info = name.split('|');
                  var mode = info[0];
                  var submode = info[1];
                  var node = ui.create.div('.menubutton.large', this);
                  var num = Math.min(6, lib.config.favouriteMode.length);
                  node.dataset.type = num % 2 == 0 ? 'even' : 'odd';
                  node.dataset.position = index;
                  var str = lib.translate[name] || lib.translate[mode] || '';
                  if (str.length == 2) {
                     str += '模式';
                  }
                  node.innerHTML = str;
                  node.listen(function () {
                     game.saveConfig('mode', mode);
                     if (submode) {
                        game.saveConfig(mode + '_mode', submode, mode);
                     }
                     game.reload();
                  });
               };
               ui.favmode = ui.create.system('收藏', function () {
                  var mode = get.mode();
                  if (typeof _status.mode == 'string') {
                     mode += '|' + _status.mode;
                  }
                  if (this.classList.contains('glow')) {
                     this.classList.remove('glow');
                     lib.config.favouriteMode.remove(mode);
                  }
                  else {
                     this.classList.add('glow');
                     lib.config.favouriteMode.add(mode);
                  }
                  game.saveConfig('favouriteMode', lib.config.favouriteMode);
                  ui.favmodelist.update();
                  _status.clicked = true;
               });
               ui.favmode.style.display = 'none';
               ui.favmodelist.update();
               // ui.create.div('.menubutton.round','<span>菜单</span>',ui.shortcut,ui.click.config).dataset.position=5;


               if (_status.connectMode) {
                  ui.playerids.remove();
                  ui.pause.innerHTML = '记录';
               }
               setTimerPosition.call(ui.timer);
               ui.arena.appendChild(ui.timer);

               if (!game.syncMenu) {
                  lib.onfree.push(function () {
                     ui.create.menu();
                     ui.config2.classList.remove('hidden');
                     ui.roundmenu.classList.remove('transparent2');
                     setTimeout(function () {
                        ui.config2.style.transition = '';
                     }, 500);
                  });
               }
               else {
                  ui.create.menu();
               }

               lib.status.date = new Date();
               lib.status.dateDelayed = 0;

               while (lib.arenaReady.length) {
                  (lib.arenaReady.shift())();
               }
               delete lib.arenaReady;
               if (lib.config.auto_check_update) {
                  setTimeout(() => {
                     game.checkForUpdate(false);
                  }, 3000);
               }
               if (!lib.config.asset_version) {
                  lib.onfree.push(function () {
                     setTimeout(() => {
                        if (!game.download) {
                           game.saveConfig('asset_version', '无');
                        }
                        else {
                           var func = () => {
                              if (confirm('是否下载图片和字体素材？（约275MB）')) {
                                 if (!ui.arena.classList.contains('menupaused')) {
                                    ui.click.configMenu();
                                    ui.click.menuTab('其它');
                                 }
                                 setTimeout(game.checkForAssetUpdate, 500);
                              }
                              else {
                                 game.saveConfig('asset_version', '无');
                              }
                           };
                           if (_status.new_tutorial) {
                              _status.new_tutorial = func;
                           }
                           else {
                              func();
                           }
                        }
                     }, 3000);
                  });
               }
               if (localStorage.getItem(lib.configprefix + 'playback')) {
                  setTimeout(lib.init.onfree);
               }

               if (lib.config.test_game) {
                  ui.window.classList.add('testing');
                  lib.config.game_speed = 'vfast';
                  lib.config.low_performance = true;
                  lib.config.animation = false;
                  _status.auto = true;
                  ui.auto.classList.add('glow');
                  setTimeout(function () {
                     var node = ui.create.pause().animate('start');
                     node.appendChild(ui.sidebar);
                     node.firstChild.innerHTML = '正在测试';
                     node.removeEventListener('click', ui.click.resume);
                  }, 500);
               }
            },
            system: function (str, func, right, before) {
               var parent = right ? ui.system2 : ui.system1;
               var node = ui.create.div();
               if (before) {
                  parent.insertBefore(node, parent.firstChild);
               }
               else {
                  parent.appendChild(node);
               }
               node.innerHTML = str;
               if (func) {
                  node.listen(func);
               }
               if (true) {
                  node.addEventListener(lib.config.touchscreen ? 'touchstart' : 'mousedown', function (e) {
                     if (!node.classList.contains('hidden')) node.classList.add('pressdown');
                  });
                  node.addEventListener(lib.config.touchscreen ? 'touchend' : 'mouseup', function (e) {
                     node.classList.remove('pressdown');
                  });
                  node.addEventListener(lib.config.touchscreen ? 'touchmove' : 'mousemove', function (e) {
                     node.classList.remove('pressdown');
                  });
               }
               return node;
            },
            pause: function () {
               if (_status.pausing) return;
               ui.click.shortcut(false);
               var node = ui.create.div(".pausedbg", ui.window);
               _status.pausing = true;
               setTimeout(function () {
                  _status.pausing = false;
               }, 500);
               if (lib.config.touchscreen) {
                  setTimeout(function () {
                     node.addEventListener('touchend', ui.click.resume);
                  }, 500);
               }
               else {
                  node.addEventListener('click', ui.click.resume);
               }
               if (!lib.config.touchscreen) {
                  node.oncontextmenu = ui.click.resume;
               }

               var node2 = ui.create.div(node);
               if (_status.connectMode) {
                  node2.innerHTML = '';
               }
               else {
                  node2.innerHTML = '已暂停';
               }

               // node2.listen(function(){
               //     _status.clicked=true;
               //     if(ui.sidebar.classList.contains('hidden')){
               //         ui.sidebar.show();
               //         ui.sidebar3.show();
               //     }
               //     else{
               //         ui.sidebar.hide();
               //         ui.sidebar3.hide();
               //     }
               // });
               return node;
            },
            prebutton: function (item, type, position, noclick) {
               var node = ui.create.div(position);
               node.style.display = 'none';
               node.link = item;
               node.activate = function () {
                  ui.create.button(item, type, position, noclick, node);
                  delete node.activate;
               }
               _status.prebutton.push(node);
               return node;
            },
            /**
             * 生成一个按钮
             * @function
             * @param {!Object} item 按钮link指向的物件
             * @param {!string} type 按钮类型（'blank'空按钮；'card'卡牌；'vcard'虚拟卡牌
             * @param {!HTMLElement} position 按钮添加的位置，参考{@link ui.create.div}的父元素
             * @param {?boolean} noclick 按钮是否可以被点击
             * @returns {HTMLDivElement} 返回生成的生成一个按钮
             */
            button: function (item, type, position, noclick, node) {
               switch (type) {
                  case 'blank':
                     node = ui.create.div('.button.card', position);
                     node.link = item;
                     break;

                  case 'card':
                     if (typeof item.copy == 'function') {
                        node = item.copy(false);
                     }
                     else {
                        node = item.cloneNode(true);
                     }
                     node.classList.add('button');
                     if (position) position.appendChild(node);
                     node.link = item;
                     if (item.style.backgroundImage) {
                        node.style.backgroundImage = item.style.backgroundImage;
                        node.style.backgroundSize = 'cover';
                     }
                     if (item.style.color) {
                        node.style.color = item.style.color;
                     }
                     if (item.nature) {
                        node.classList.add(item.nature);
                     }
                     if (!noclick) {
                        lib.setIntro(node);
                     }
                     if (get.position(item) == 'j' && item.viewAs && item.viewAs != item.name && lib.config.cardtempname != 'off') {
                        node._tempName = ui.create.div('.tempname', node);
                        var tempname = get.translation(item.viewAs);
                        node._tempName.dataset.nature = 'wood';
                        node._tempName.innerHTML = lib.config.cardtempname == 'default' ? get.verticalStr(tempname) : tempname;
                        node._tempName.tempname = tempname;
                     }
                     break;

                  case 'vcard':
                     if (typeof item == 'string') {
                        item = [get.type(item), '', item];
                     }
                     node = ui.create.card(position, 'noclick', noclick);
                     node.classList.add('button');
                     node.init(item);
                     node.link = item;
                     break;

                  case 'character': case 'player': case 'characterx':
                     if (node) {
                        node.classList.add('button');
                        node.classList.add('character');
                        node.style.display = '';
                     }
                     else {
                        node = ui.create.div('.button.character', position);
                     }
                     node._link = item;
                     if (_status.noReplaceCharacter && type == 'characterx') type = 'character';
                     if (type == 'characterx') {
                        if (lib.characterReplace[item] && lib.characterReplace[item].length) item = lib.characterReplace[item][0];
                     }
                     node.link = item;
                     if (type == 'character' || type == 'characterx') {
                        var double = get.is.double(node._link, true);
                        if (double) node._changeGroup = true;
                        if (type == 'characterx' && lib.characterReplace[node._link] && lib.characterReplace[node._link].length > 1) node._replaceButton = true;
                        var func = function (node, item) {
                           node.setBackground(item, 'character');
                           if (node.node) {
                              node.node.name.remove();
                              node.node.hp.remove();
                              node.node.group.remove();
                              node.node.intro.remove();
                              if (node.node.replaceButton) node.node.replaceButton.remove();
                           }
                           node.node = {
                              name: ui.create.div('.name', node),
                              hp: ui.create.div('.hp', node),
                              group: ui.create.div('.identity', node),
                              intro: ui.create.div('.intro', node),
                           };
                           var infoitem = lib.character[item];
                           if (!infoitem) {
                              for (var itemx in lib.characterPack) {
                                 if (lib.characterPack[itemx][item]) {
                                    infoitem = lib.characterPack[itemx][item]; break;
                                 }
                              }
                           }
                           node.node.name.innerHTML = get.slimName(item);
                           if (lib.config.buttoncharacter_style == 'default' || lib.config.buttoncharacter_style == 'simple') {
                              if (lib.config.buttoncharacter_style == 'simple') {
                                 node.node.group.style.display = 'none';
                              }
                              node.node.name.dataset.nature = get.groupnature(infoitem[1]);
                              node.node.group.dataset.nature = get.groupnature(infoitem[1], 'raw');
                              node.classList.add('newstyle');
                              if (double && double.length) {
                                 node.node.name.dataset.nature = get.groupnature(double[0]);
                                 node.node.group.dataset.nature = get.groupnature(double[double.length == 2 ? 1 : 0]);
                              }
                              ui.create.div(node.node.hp);
                              var textnode = ui.create.div('.text', get.numStr(infoitem[2]), node.node.hp);
                              if (infoitem[2] == 0) {
                                 node.node.hp.hide();
                              }
                              else if (get.infoHp(infoitem[2]) <= 3) {
                                 node.node.hp.dataset.condition = 'mid';
                              }
                              else {
                                 node.node.hp.dataset.condition = 'high';
                              }
                           }
                           else {
                              var hp = get.infoHp(infoitem[2]);
                              var maxHp = get.infoMaxHp(infoitem[2]);
                              if (maxHp > 14 || hp < 0) {
                                 if (typeof infoitem[2] == 'string') node.node.hp.innerHTML = infoitem[2];
                                 else node.node.hp.innerHTML = get.numStr(infoitem[2]);
                                 node.node.hp.classList.add('text');
                              }
                              else {
                                 for (var i = 0; i < maxHp; i++) {
                                    var next = ui.create.div('', node.node.hp);
                                    if (i >= hp) next.classList.add('exclude');
                                 }
                              }
                           }
                           if (node.node.hp.childNodes.length == 0) {
                              node.node.name.style.top = '8px';
                           }
                           if (node.node.name.querySelectorAll('br').length >= 4) {
                              node.node.name.classList.add('long');
                              if (lib.config.buttoncharacter_style == 'old') {
                                 node.addEventListener('mouseenter', ui.click.buttonnameenter);
                                 node.addEventListener('mouseleave', ui.click.buttonnameleave);
                              }
                           }
                           node.node.intro.innerHTML = lib.config.intro;
                           if (!noclick) {
                              lib.setIntro(node);
                           }
                           if (infoitem[1]) {
                              if (double) {
                                 var str = '<div>';
                                 if (double.length == 2) {
                                    for (var i of double) {
                                       str += get.translation(i);
                                    }
                                 }
                                 else str += get.translation(double[0]);
                                 str += '</div>';
                                 node.node.group.innerHTML = str;
                              }
                              else node.node.group.innerHTML = '<div>' + get.translation(infoitem[1]) + '</div>';
                              node.node.group.style.backgroundColor = get.translation(infoitem[1] + 'Color');
                           }
                           else {
                              node.node.group.style.display = 'none';
                           }
                           if (node._replaceButton) {
                              var intro = ui.create.div('.button.replaceButton', node);
                              node.node.replaceButton = intro;
                              intro.innerHTML = '切换';
                              intro._node = node;
                              intro.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', function () {
                                 _status.tempNoButton = true;
                                 var node = this._node;
                                 var list = lib.characterReplace[node._link];
                                 var link = node.link;
                                 var index = list.indexOf(link);
                                 if (index == list.length - 1) index = 0;
                                 else index++;
                                 link = list[index];
                                 node.link = link;
                                 node.refresh(node, link);
                                 setTimeout(function () {
                                    delete _status.tempNoButton;
                                 }, 200);
                              });
                           }
                        };
                        node.refresh = func;
                        node.refresh(node, item);
                     }
                     else {
                        node.node = {
                           name: ui.create.div('.name', node),
                           intro: ui.create.div('.intro', node)
                        }
                        if (item.name && item.name.indexOf('unknown') == 0) {
                           if (item.node && item.node.name_seat) {
                              node.classList.add('cardbg');
                              ui.create.div('.avatar_name', node, get.translation(item.name));
                           }
                           else {
                              node.setBackground(item.name1, 'character');
                           }
                        }
                        else {
                           node.setBackground(item.name, 'character');
                        }
                     }
                     break;

                  case 'text':
                     node = ui.create.div('.button.text', position);
                     node.link = item;
                     node.innerHTML = item;
                     break;

                  case 'textButton':
                     node = ui.create.div('.caption', position);
                     node.link = item;
                     node.innerHTML = item;
                     break;
               }
               if (!noclick) {
                  node.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.button);
               }
               else {
                  node.classList.add('noclick');
                  if (node.querySelector('.intro')) {
                     node.querySelector('.intro').remove();
                  }
               }
               for (var i in lib.element.button) {
                  node[i] = lib.element.button[i];
               }
               return node;
            },
            /**
             * 生成一组按钮
             * @function
             * @param {!Array} list 按钮列表
             * @param {!string} type 按钮类型
             * @returns {HTMLDivElement} 返回生成的一组按钮
             * @see {@link ui.create.button}
             */
            buttons: function (list, type, position, noclick, zoom) {
               var buttons = [];
               var pre = (type.slice(0, 3) == 'pre');
               if (pre) {
                  if (!_status.prebutton) {
                     _status.prebutton = [];
                     lib.onfree.push(function () {
                        for (var i = 0; i < _status.prebutton.length; i++) {
                           if (_status.prebutton[i].activate) {
                              _status.prebutton[i].activate();
                           }
                        }
                        delete _status.prebutton;
                     });
                  }
               }
               for (var i = 0; i < list.length; i++) {
                  if (pre) {
                     buttons.push(ui.create.prebutton(list[i], type.slice(3), position, noclick));
                  }
                  else {
                     buttons.push(ui.create.button(list[i], type, position, noclick));
                  }
               }
               return buttons;
            },
            /**
             * 创建角色
             * @function
             * @param {HTMLDivElement} parent 父节点
             * @param {?boolean} noclick 是否可点击，如果为true，表示**不可点击**；如果为false或未指定，表示**可点击**
             */
            player: function (position, noclick) {
               /**
                * 角色对象
                * 创建角色对象，见{@link ui.create.player}
                * @namespace GameCores.GameObjects.Player
                * @mixes lib.element.player
                */
               var node = ui.create.div('.player', position);
               /**
                * 角色的子节点
                * @name node
                * @memberof GameCores.GameObjects.Player
                * @property {HTMLDivElement} avatar (主将)头像
                * @property {HTMLDivElement} avatar2 副将头像
                * @property {HTMLDivElement} turnover 翻面
                * @property {HTMLDivElement} framebg 背景
                * @property {HTMLDivElement} intro 介绍
                * @property {HTMLDivElement} identity 身份
                * @property {HTMLDivElement} hp 当前血量
                * @property {HTMLDivElement} name (主将)姓名
                * @property {HTMLDivElement} name2 副将姓名
                * @property {HTMLDivElement} nameol 姓名OL
                * @property {HTMLDivElement} count 数量
                * @property {HTMLDivElement} equips 装备栏
                * @property {HTMLDivElement} judges 判定栏
                * @property {HTMLDivElement} marks 标记
                * @property {HTMLDivElement} chain 连环
                * @property {HTMLDivElement} handcards1 手牌1
                * @property {HTMLDivElement} handcards2 手牌2
                * @property {HTMLDivElement} action action
                * @property {HTMLDivElement} link 铁索(横置)
                */
               let displayer = ui.create.div('.displayer', node)
               node.node = {
                  displayer,
                  turnedover: ui.create.div('.turned', '<div>翻<br>面<div>', node),
                  framebg: ui.create.div('.framebg', node),
                  intro: ui.create.div('.intro', node),
                  identity: ui.create.div('.identity', node),
                  hp: ui.create.div('.hp', node),
                  name: ui.create.div('.name', node),
                  name2: ui.create.div('.name.name2', node),
                  nameol: ui.create.div('.nameol', node),
                  count: ui.create.div('.count', node).hide(),
                  equips: ui.create.div('.equips', node).hide(),
                  judges: ui.create.div('.judges', node),
                  marks: ui.create.div('.marks', node),
                  chain: ui.create.div('.chain', '<div></div>', node),
                  handcards1: ui.create.div('.handcards'),
                  handcards2: ui.create.div('.handcards'),
               };
               let avatar = ui.create.div('.avatar', displayer, ui.click.avatar).hide()
               let avatar2 = ui.create.div('.avatar2', displayer, ui.click.avatar2).hide()
               avatar2.playerEle = avatar.playerEle = node
               node.node = {
                  ...node.node,
                  avatar,
                  avatar2,
               }
               var chainlength = game.layout == 'default' ? 64 : 40;
               for (var i = 0; i < chainlength; i++) {
                  ui.create.div(node.node.chain.firstChild, '.cardbg').style.transform = 'translateX(' + (i * 5 - 5) + 'px)';
               }
               node.node.action = ui.create.div('.action', node.node.avatar);//特殊行动标识：在战棋模式中显示当前正在行动的角色与角色间距离
               /**
                * 回合计数，初始为0，每回合开始则加1
                * @name phaseNumber
                * @type {!number}
                * @memberof GameCores.GameObjects.Player
                */
               node.phaseNumber = 0;
               /**
                * 事件跳过列表，如果一个事件e的事件名在该列表中存在X个，则接下来的X个事件e会被直接跳过，不执行；每跳过一个事件，列表中就会相应移除一个事件名
                * @name skipList
                * @type {!Array<string>}
                * @memberof GameCores.GameObjects.Player
                */
               node.skipList = [];
               /**
                * 技能列表
                * @name skills
                * @type {!Array<any>}
                * @memberof GameCores.GameObjects.player
                */
               node.skills = [];
               /**
                * ??
                * @name initedSkills
                * @type {!Array<any>}
                * @memberof GameCores.GameObjects.Player
                */
               node.initedSkills = [];
               node.additionalSkills = {};
               node.disabledSkills = {};
               node.hiddenSkills = [];
               node.awakenedSkills = [];
               node.forbiddenSkills = {};
               node.popups = [];
               node.damagepopups = [];
               node.judging = [];
               node.stat = [{ card: {}, skill: {} }];
               node.actionHistory = [JSON.parse(JSON.stringify({ ...lib.historyRecorder }))];
               node.tempSkills = {};
               let storage = {}
               node.$ = node.storage = storage;
               node.marks = {};
               node.ai = { friend: [], enemy: [], neutral: [], handcards: { global: [], source: [], viewed: [] } };
               node.queueCount = 0;
               node.outCount = 0;

               for (var i in lib.element.player) {
                  node[i] = lib.element.player[i];
               }
               node.node.link = node.mark(' ', { mark: get.linkintro });
               node.node.link.firstChild.setBackgroundImage('image/card/tiesuo_mark.png')
               node.node.link.firstChild.style.backgroundSize = 'cover';
               ui.create.div(node.node.identity);//??
               if (!noclick) {
                  node.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.target);
                  node.node.identity.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.identity);
                  if (lib.config.touchscreen) {
                     node.addEventListener('touchstart', ui.click.playertouchstart);
                  }
               }
               else node.noclick = true;

               return node;
            },
            connectPlayers: function (ip) {
               game.connectPlayers = [];
               for (var i = 0; i < 8; i++) {
                  var player = ui.create.player(ui.window);
                  player.dataset.position = i;
                  player.classList.add('connect');
                  game.connectPlayers.push(player);
                  if (i >= lib.configOL.number) {
                     player.classList.add('unselectable2');
                  }
               }

               var bar = ui.create.div(ui.window);
               bar.style.height = '20px';
               bar.style.width = '80%';
               bar.style.left = '10%';
               bar.style.top = 'calc(200% / 7 - 120px + 5px)';
               bar.style.textAlign = 'center';
               var ipbar = ui.create.div('.shadowed', ip, bar);
               ipbar.style.padding = '4px';
               ipbar.style.borderRadius = '2px';
               ipbar.style.position = 'relative';

               var button = ui.create.div('.menubutton.large.highlight.connectbutton.pointerdiv', game.online ? '退出联机' : '开始游戏', ui.window, function () {
                  if (button.clicked) return;
                  if (game.online) {
                     if (game.onlinezhu) {
                        game.send('startGame');
                     }
                     else {
                        game.saveConfig('tmp_owner_roomId');
                        game.saveConfig('tmp_user_roomId');
                        game.saveConfig('reconnect_info');
                        game.reload();
                     }
                  }
                  else {
                     var num = 0;
                     for (var i of game.connectPlayers) {
                        if (!i.nickname && !i.classList.contains('unselectable2')) num++;
                     }
                     // if (num >= lib.configOL.number - 1) {
                     //     alert('至少要有两名玩家才能开始游戏！');
                     //     return;
                     // }
                     game.resume();
                  }
                  button.delete();
                  bar.delete();
                  delete ui.connectStartButton;
                  delete ui.connectStartBar;
                  button.clicked = true;
               });

               ui.connectStartButton = button;
               ui.connectStartBar = bar;
            },
            players: function (num) {
               if (num === 0) {
                  return;
               }
               if (num == undefined) num = lib.configOL.number;
               if (num == undefined) num = get.playerNumber();
               if (typeof num == 'string') {
                  num = parseInt(num);
               }
               if (!num) num = 5;
               for (var i = 0; i < num; i++) {
                  var player = ui.create.player().animate('start');
                  game.players.push(player);
                  player.dataset.position = i;
               }
               var players = game.players;
               for (var i = 0; i < players.length; i++) {
                  if (i > 0) {
                     players[i].previous = players[i - 1];
                     players[i].previousSeat = players[i - 1];
                  }
                  if (i < players.length - 1) {
                     players[i].next = players[i + 1];
                     players[i].nextSeat = players[i + 1];
                  }
               }
               players[0].previous = players[players.length - 1];
               players[0].previousSeat = players[players.length - 1];
               players[players.length - 1].next = players[0];
               players[players.length - 1].nextSeat = players[0];
               ui.arena.setNumber(num);
               for (var i = 0; i < num; i++) {
                  ui.arena.appendChild(players[i]);
               }
               // ui.arena.classList.add('glass');
               // for(var i=0;i<num;i++){
               //     var bg=ui.create.div('.glassbg');
               //     var bg2=ui.create.div(bg);
               //     ui.create.div(bg);
               //     var rect=players[i].getBoundingClientRect();
               //     bg2.style.backgroundImage='url("image/background/huangtian_bg.jpg")';
               //     bg2.style.width=ui.window.offsetWidth+'px';
               //     bg2.style.height=ui.window.offsetHeight+'px';
               //     bg2.style.transform='translate('+(-rect.left)+'px,'+(-rect.top)+'px)';
               //     players[i].insertBefore(bg,players[i].firstChild);
               // }
               return players;
            },
            me: function (hasme) {
               ui.mebg = ui.create.div('#mebg', ui.arena);
               ui.me = ui.create.div('#me', ui.arena).animate('start');
               ui.handcards1Container = ui.create.div('#handcards1', ui.me);
               ui.handcards2Container = ui.create.div('#handcards2', ui.me);
               ui.arena.classList.remove('nome');
               if (lib.config.mousewheel && !lib.config.touchscreen) {
                  ui.handcards1Container.onmousewheel = ui.click.mousewheel;
                  ui.handcards2Container.onmousewheel = ui.click.mousewheel;
               }
               ui.handcards1Container.ontouchstart = ui.click.touchStart;
               ui.handcards2Container.ontouchstart = ui.click.touchStart;
               ui.handcards1Container.ontouchmove = ui.click.touchScroll;
               ui.handcards2Container.ontouchmove = ui.click.touchScroll;
               ui.handcards1Container.style.WebkitOverflowScrolling = 'touch';
               ui.handcards2Container.style.WebkitOverflowScrolling = 'touch';

               if (hasme && game.me) {
                  ui.handcards1 = game.me.node.handcards1;
                  ui.handcards2 = game.me.node.handcards2;
                  ui.handcards1Container.appendChild(ui.handcards1);
                  ui.handcards2Container.appendChild(ui.handcards2);
                  // ui.updatehl();
               }
               else if (game.players.length) {
                  game.me = game.players[0];
                  ui.handcards1 = game.me.node.handcards1;
                  ui.handcards2 = game.me.node.handcards2;
                  ui.handcards1Container.appendChild(ui.handcards1);
                  ui.handcards2Container.appendChild(ui.handcards2);
                  // ui.updatehl();
               }
            },
            /**
             * 创建游戏牌对象
             * @param {HTMLDivElement} parent 父节点，即初始位置(手牌|牌堆|弃牌堆等) 
             * @param {?'noclick'} [noclick] 是否可点击，如果为'noclick'表示**不可点击**，如果为false或未指定，表示可点击
             * @param {?boolean} [nodialog] 是否可弹窗，如果为true表示**不可弹窗**，如果为false或未指定，表示可弹窗
             * @returns {!GameCores.GameObjects.Card} 创建的游戏牌对象
             */
            card: function (position, info, noclick) {
               /**
                * 游戏牌
                * @namespace GameCores.GameObjects.Card
                */
               var node = ui.create.div('.card', position);
               /**
                * @name node
                * @memberof GameCores.GameObjects.Card
                * @property {HTMLDivElement} image 图片
                * @property {HTMLDivElement} info 花色和点数信息
                * ```
                * info.innerHTML = "花色<span> </span>点数"
                * ```
                * @property {HTMLDivElement} name 
                */
               node.node = {
                  displayer: ui.create.div('.displayer', node),
                  image: ui.create.div('.image', node),
                  info: ui.create.div('.info', node),
                  name: ui.create.div('.name', node),
                  name2: ui.create.div('.name2', node),
                  background: ui.create.div('.background', node),
                  intro: ui.create.div('.intro', node),
                  range: ui.create.div('.range', node),
                  gaintag: ui.create.div('.gaintag', node),
               }
               for (var i in lib.element.card) {
                  node[i] = lib.element.card[i];
               }
               node.node.intro.innerHTML = lib.config.intro;
               if (!noclick) {
                  lib.setIntro(node);
               }
               node.storage = {};
               node.vanishtag = [];
               node.gaintag = [];
               node._uncheck = [];
               if (info != 'noclick') {
                  node.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.card);
                  if (lib.config.touchscreen) {
                     node.addEventListener('touchstart', ui.click.cardtouchstart);
                     node.addEventListener('touchmove', ui.click.cardtouchmove);
                  }
                  if (lib.cardSelectObserver) {//?? [never used]
                     lib.cardSelectObserver.observe(node, { attributes: true });
                  }
               }
               return node;
            },
            cardsAsync: function () {
               if (lib.onfree) {
                  _status.waitingForCards = Array.from(arguments);
                  lib.onfree.push(function () {
                     if (_status.waitingForCards) {
                        ui.create.cards.apply(ui.create, _status.waitingForCards);
                        delete _status.waitingForCards;
                     }
                  });
               }
               else {
                  ui.create.cards.apply(ui.create, arguments);
               }
            },
            cards: function (ordered) {
               if (_status.brawl) {
                  if (_status.brawl.cardPile) {
                     lib.card.list = _status.brawl.cardPile(lib.card.list);
                  }
                  if (_status.brawl.orderedPile) {
                     ordered = true;
                  }
               }
               if (!ordered) {
                  lib.card.list.randomSort();
               }
               for (var i = 0; i < lib.card.list.length; i++) {
                  if (lib.card[lib.card.list[i][2]]) {
                     if (!lib.card.list[i]._replaced) {
                        if (!_status.connectMode) {
                           if (lib.config.bannedcards.contains(lib.card.list[i][2])) continue;
                        }
                        else {
                           if (lib.configOL.protect_beginner && get.is.banForBeginner(lib.card.list[i][2])) continue;
                           if (lib.configOL.bannedcards.contains(lib.card.list[i][2])) continue;
                        }
                        if (game.bannedcards && game.bannedcards.contains(lib.card.list[i][2])) continue;
                     }
                     lib.inpile.add(lib.card.list[i][2]);
                     ui.create.card(ui.cardPile).init(lib.card.list[i]);
                  }
               }
               lib.inpile.sort(lib.sort.card);
               for (var i in _status.cardtag) {
                  if (!_status.cardtag[i].length) delete _status.cardtag[i];
               }
               game.broadcastAll(function (num, pile, top, cardtag) {
                  if (ui.cardPileNumber) ui.cardPileNumber.innerHTML = '0轮 剩余牌: ' + num;
                  lib.inpile = pile;
                  _status.pileTop = top;
                  _status.cardtag = cardtag;
               }, ui.cardPile.childNodes.length, lib.inpile, ui.cardPile.firstChild, _status.cardtag);
            },
         },
         /**
          * HTML 事件
          * @namespace
          */
         click: {
            identitycircle: function () {
               var list = [];
               this.classList.toggle('transparent');
               for (var i = 0; i < this.parentNode.childNodes.length; i++) {
                  if (!this.parentNode.childNodes[i].classList.contains('transparent')) {
                     list.add(this.parentNode.childNodes[i].link[2]);
                  }
               }
               var info = this.link;
               if (list.length == 1) {
                  for (var i = 0; i < this.parentNode.childNodes.length; i++) {
                     if (!this.parentNode.childNodes[i].classList.contains('transparent')) {
                        var info2 = this.parentNode.childNodes[i].link;
                        info[0].firstChild.innerHTML = info2[1];
                        info[0].dataset.color = info2[2];
                     }
                  }
               }
               else {
                  info[0].firstChild.innerHTML = '';
                  info[0].dataset.color = '';
                  ui.create.identitycircle(list, info[0].firstChild);
               }
               this._source._guozhanguess = list;
            },
            connectEvents: function () {
               if (this.info) {
                  var button = this;
                  var layer = ui.create.div('.poplayer', ui.window);
                  var uiintro = ui.create.dialog('hidden', 'notouchscroll');
                  this.classList.add('active');
                  if (lib.config.touchscreen) {
                     lib.setScroll(uiintro.contentContainer);
                  }
                  layer.listen(function () {
                     if (this.clicked) {
                        this.clicked = false;
                        return;
                     }
                     button.classList.remove('active');
                     uiintro.delete();
                     this.delete();
                  });
                  uiintro.listen(function () {
                     _status.clicked = true;
                  });
                  uiintro.style.zIndex = 21;
                  uiintro.classList.add('popped');
                  uiintro.classList.add('static');
                  uiintro.classList.add('onlineclient');
                  uiintro.style.width = '180px';
                  uiintro.style.height = '300px';
                  uiintro.style.left = 'auto';
                  uiintro.style.right = '20px';
                  uiintro.style.top = 'auto';
                  uiintro.style.bottom = '75px';

                  uiintro.refresh = function () {
                     if (button.focused) return;
                     uiintro.content.innerHTML = '';
                     uiintro.addText('创建约战');
                     button.textnode = uiintro.content.lastChild.lastChild;
                     uiintro.add('<input type="text" style="width:calc(100% - 10px);resize: none;border: none;border-radius: 2px;box-shadow: rgba(0, 0, 0, 0.2) 0px 0px 0px 1px;margin-top: -2px;margin-bottom: 2px;">');
                     uiintro.content.lastChild.style.paddingTop = 0;
                     button.input = uiintro.content.lastChild.lastChild;
                     button.input.onfocus = function () {
                        button.focused = true;
                     }
                     button.input.onblur = function () {
                        delete button.focused;
                     }
                     if (button.interval) {
                        button.input.disabled = true;
                        button.input.style.opacity = 0.6;
                        if (button.intervaltext) {
                           button.textnode.innerHTML = button.intervaltext;
                        }
                     }
                     var datenode = ui.create.div(uiintro.content);
                     datenode.style.marginTop = 0;
                     datenode.style.whiteSpace = 'nowrap';
                     var date = new Date();
                     var days = [];
                     var currentDay = date.getDay();
                     if (currentDay == 0) currentDay = 7;
                     for (var i = 1; i <= 7; i++) {
                        if (i < currentDay) {
                           days.push([i.toString(), '下周' + get.cnNumber(i, true)]);
                        }
                        else if (i == 7) {
                           days.push([i.toString(), '周日']);
                        }
                        else if (i == currentDay) {
                           days.push([i.toString(), '今天']);
                        }
                        else {
                           days.push([i.toString(), '周' + get.cnNumber(i, true)]);
                        }
                     }
                     days = days.concat(days.splice(0, currentDay - 1));
                     var initday = currentDay + 1;
                     if (initday > 7) {
                        initday -= 7;
                     }
                     var daysselect = ui.create.selectlist(days, initday.toString(), datenode);
                     daysselect.style.width = '55px';
                     var hours = [];
                     for (var i = 0; i < 24; i++) {
                        hours.push([i.toString(), i.toString() + '点']);
                     }
                     var hoursselect = ui.create.selectlist(hours, date.getHours().toString(), datenode);
                     hoursselect.style.marginLeft = '5px';
                     hoursselect.style.width = '55px';
                     var timeconfirm = ui.create.node('button', '确定', datenode);
                     timeconfirm.style.marginLeft = '5px';
                     timeconfirm.onclick = function () {
                        if (!button.input.value) {
                           alert('请填写约战标题');
                           return;
                        }
                        var date2 = new Date();
                        date2.setHours(parseInt(hoursselect.value));
                        date2.setMinutes(0);
                        date2.setSeconds(0);
                        var deltaday = parseInt(daysselect.value) - currentDay;
                        if (deltaday < 0) {
                           deltaday += 7;
                        }
                        var utc = date2.getTime() + deltaday * 24 * 3600000;
                        if (utc < date.getTime()) {
                           alert('创建失败，时间已过');
                           return;
                        }
                        if (get.is.banWords(button.input.value)) {
                           var eventnode = ui.create.div('.menubutton.videotext.onlineEvt.pointerdiv', function () {
                              setTimeout(() => {
                                 if (this.classList.contains('active')) {
                                    if (confirm('确定要离开' + this.info.content + '？')) {
                                       this.classList.remove('active');
                                    }
                                 }
                                 else {
                                    if (confirm('确定要加入' + this.info.content + '？')) {
                                       this.classList.add('active');
                                    }
                                 }
                              });
                           }, uiintro.content, 4);
                           var fakeinfo = {
                              utc: utc,
                              day: parseInt(daysselect.value),
                              hour: parseInt(hoursselect.value),
                              nickname: get.connectNickname(),
                              avatar: lib.config.connect_avatar,
                              content: button.input.value,
                              create: game.onlineKey,
                              members: [game.onlineKey],
                           };
                           eventnode.info = fakeinfo;
                           ui.create.div('.title', fakeinfo.content, eventnode);
                           var str;
                           if (fakeinfo.day < currentDay) {
                              str = '下周';
                           }
                           else {
                              str = '周';
                           }
                           if (fakeinfo.day == 7) {
                              str += '日'
                           }
                           else {
                              str += get.cnNumber(fakeinfo.day, true);
                           }
                           str += ' ';
                           var hour = fakeinfo.hour;
                           if (hour <= 12) {
                              if (hour <= 5) {
                                 str += '凌晨';
                              }
                              else if (hour < 12) {
                                 str += '上午';
                              }
                              else {
                                 str += '中午';
                              }
                              str += fakeinfo.hour + '点';
                           }
                           else {
                              if (hour <= 17) {
                                 str += '下午';
                              }
                              else {
                                 str += '晚上';
                              }
                              str += (fakeinfo.hour - 12) + '点';
                           }
                           ui.create.div('', '已有' + (fakeinfo.members.length) + '人加入', eventnode);
                           ui.create.div('', '时间：' + str, eventnode);
                           if (fakeinfo.members.contains(game.onlineKey)) {
                              eventnode.classList.add('active');
                           }
                           button.input.value = '';
                           return;
                        }
                        game.send('server', 'events', {
                           utc: utc,
                           day: parseInt(daysselect.value),
                           hour: parseInt(hoursselect.value),
                           nickname: get.connectNickname(),
                           avatar: lib.config.connect_avatar,
                           content: button.input.value
                        }, game.onlineKey);
                     };

                     var num = 0;
                     for (var i = 0; i < button.info.length; i++) {
                        if (typeof button.info[i].creator == 'string' && button.info[i].creator != game.onlineKey && get.is.banWords(button.info[i].content)) continue;
                        if (button.info[i].creator == game.onlineKey) {
                           num++;
                        }
                        var eventnode = ui.create.div('.menubutton.videotext.onlineEvt.pointerdiv', function () {
                           if (typeof this.info.creator != 'string') return;
                           setTimeout(() => {
                              if (this.classList.contains('active')) {
                                 if (confirm('确定要离开' + this.info.content + '？')) {
                                    game.send('server', 'events', this.info.id, game.onlineKey, 'leave');
                                 }
                              }
                              else {
                                 if (confirm('确定要加入' + this.info.content + '？')) {
                                    game.send('server', 'events', this.info.id, game.onlineKey, 'join');
                                 }
                              }
                           });
                        }, uiintro.content);
                        eventnode.info = button.info[i];
                        if (typeof button.info[i].creator == 'string') {
                           ui.create.div('.title', button.info[i].content, eventnode);
                           var str;
                           if (button.info[i].day < currentDay) {
                              str = '下周';
                           }
                           else {
                              str = '周';
                           }
                           if (button.info[i].day == 7) {
                              str += '日'
                           }
                           else {
                              str += get.cnNumber(button.info[i].day, true);
                           }
                           str += ' ';
                           var hour = button.info[i].hour;
                           if (hour <= 12) {
                              if (hour <= 5) {
                                 str += '凌晨';
                              }
                              else if (hour < 12) {
                                 str += '上午';
                              }
                              else {
                                 str += '中午';
                              }
                              str += button.info[i].hour + '点';
                           }
                           else {
                              if (hour <= 17) {
                                 str += '下午';
                              }
                              else {
                                 str += '晚上';
                              }
                              str += (button.info[i].hour - 12) + '点';
                           }
                           ui.create.div('', '创建者：' + (button.info[i].nickname), eventnode);
                           //ui.create.div('','创建者：'+(button.info[i].nickname)+'<br>ID：'+button.info[i].creator,eventnode);
                           ui.create.div('', '已有' + (button.info[i].members.length) + '人加入', eventnode);
                           ui.create.div('', '时间：' + str, eventnode);
                           if (button.info[i].members.contains(game.onlineKey)) {
                              eventnode.classList.add('active');
                           }
                        }
                        else {
                           ui.create.div('.title', button.info[i].title, eventnode);
                           ui.create.div('', button.info[i].content, eventnode);
                           ui.create.div('', '创建者：' + (button.info[i].nickname), eventnode);
                        }
                     }
                     if (num >= 3) {
                        button.input.disabled = true;
                        button.input.style.opacity = 0.6;
                        hoursselect.disabled = true;
                        daysselect.disabled = true;
                        timeconfirm.disabled = true;
                     }
                  }
                  uiintro.refresh();
                  ui.window.appendChild(uiintro);
                  _status.connectEventsCallback = function () {
                     if (uiintro.parentNode == ui.window) {
                        uiintro.refresh();
                     }
                  };
               }
            },
            connectClients: function () {
               if (this.info) {
                  var button = this;
                  var layer = ui.create.div('.poplayer', ui.window);
                  var uiintro = ui.create.dialog('hidden', 'notouchscroll');
                  this.classList.add('active');
                  if (lib.config.touchscreen) {
                     lib.setScroll(uiintro.contentContainer);
                  }
                  layer.listen(function () {
                     if (this.clicked) {
                        this.clicked = false;
                        return;
                     }
                     button.classList.remove('active');
                     uiintro.delete();
                     this.delete();
                  });
                  uiintro.listen(function () {
                     _status.clicked = true;
                  });
                  uiintro.style.zIndex = 21;
                  uiintro.classList.add('popped');
                  uiintro.classList.add('static');
                  uiintro.classList.add('onlineclient');
                  uiintro.style.width = '180px';
                  uiintro.style.height = '300px';
                  uiintro.style.left = 'auto';
                  uiintro.style.right = '20px';
                  uiintro.style.top = 'auto';
                  uiintro.style.bottom = '75px';

                  uiintro.refresh = function () {
                     if (button.focused) return;
                     uiintro.content.innerHTML = '';
                     uiintro.addText('发状态');
                     button.textnode = uiintro.content.lastChild.lastChild;
                     uiintro.add('<input type="text" style="width:calc(100% - 10px);resize: none;border: none;border-radius: 2px;box-shadow: rgba(0, 0, 0, 0.2) 0px 0px 0px 1px;margin-top: -2px;margin-bottom: 2px;">');
                     uiintro.content.lastChild.style.paddingTop = 0;
                     button.input = uiintro.content.lastChild.lastChild;
                     button.input.onfocus = function () {
                        button.focused = true;
                     }
                     button.input.onblur = function () {
                        delete button.focused;
                     }
                     if (button.interval) {
                        button.input.disabled = true;
                        button.input.style.opacity = 0.6;
                        if (button.intervaltext) {
                           button.textnode.innerHTML = button.intervaltext;
                        }
                     }
                     button.input.onkeydown = function (e) {
                        if (e.keyCode == 13 && !this.disabled) {
                           game.send('server', 'status', this.value);
                           this.blur();
                           this.disabled = true;
                           this.style.opacity = 0.6;
                           button.textnode.innerHTML = '发状态(10)';
                           button.intervaltext = button.textnode.innerHTML;
                           var num = 10;
                           button.input.disabled = true;
                           button.input.style.opacity = 0.6;
                           this.value = '';
                           button.interval = setInterval(() => {
                              num--;
                              if (num > 0) {
                                 button.textnode.innerHTML = '发状态(' + num + ')';
                                 button.intervaltext = button.textnode.innerHTML;
                              }
                              else {
                                 button.textnode.innerHTML = '发状态';
                                 button.input.disabled = false;
                                 button.input.style.opacity = '';
                                 clearInterval(button.interval);
                                 delete button.interval;
                                 delete button.intervaltext;
                              }
                           }, 1000);
                        }
                     }

                     for (var i = 0; i < button.info.length; i++) {
                        var node = ui.create.div('.menubutton.videonode.pointerdiv', uiintro.content);
                        ui.create.div('.menubutton.videoavatar', node).setBackground(button.info[i][1] || 'KizunaAI', 'character');
                        if (button.info[i][4] == game.wsid) {
                           ui.create.div('.name', '<span class="thundertext thunderauto">' + (button.info[i][0] || '无名玩家'), node); node.isme = true;
                        }
                        else if (button.info[i][2]) {
                           ui.create.div('.name', (button.info[i][0] || '无名玩家'), node);
                        }
                        else {
                           ui.create.div('.name', '<span style="opacity:0.6">' + (button.info[i][0] || '无名玩家'), node);
                        }
                        //ui.create.div('.videostatus',node,button.info[i][5]);
                        //node.classList.add('videonodestatus');
                        if (button.info[i][3]) {
                           ui.create.div('.videostatus', node, button.info[i][3].slice(0, 80));
                           node.classList.add('videonodestatus')
                        }
                     }
                  };

                  uiintro.refresh();
                  ui.window.appendChild(uiintro);
                  _status.connectClientsCallback = function () {
                     if (uiintro.parentNode == ui.window) {
                        uiintro.refresh();
                     }
                  };
               }
            },
            autoskin: function () {
               if (!lib.config.change_skin) return;
               var players = game.filterPlayer();
               var change = function (player, num, callback) {
                  if (num == '1') {
                     ui.click.skin(player.node.avatar, player.name, callback);
                  }
                  else {
                     ui.click.skin(player.node.avatar2, player.name2, callback);
                  }
               };
               var finish = function () {
                  if (lib.config.change_skin_auto != 'off') {
                     _status.skintimeout = setTimeout(ui.click.autoskin, parseInt(lib.config.change_skin_auto));
                  }
               };
               var autoskin = function () {
                  if (players.length) {
                     var player = players.randomRemove();
                     var list = [];
                     if (player.name && !player.isUnseen(0)) {
                        list.push('1');
                     }
                     if (player.name2 && !player.isUnseen(1)) {
                        list.push('2');
                     }
                     if (list.length) {
                        change(player, list.randomRemove(), function (bool) {
                           if (bool) {
                              finish();
                           }
                           else if (list.length) {
                              change(player, list[0], function (bool) {
                                 if (bool) {
                                    finish();
                                 }
                                 else {
                                    autoskin();
                                 }
                              });
                           }
                           else {
                              autoskin();
                           }
                        });
                     }
                     else {
                        autoskin();
                     }
                  }
               }
               autoskin();
            },
            skin: function (avatar, name, callback) {
               var num = 1;
               if (name.indexOf('gz_') == 0) {
                  name = name.slice(3);
               }
               if (lib.config.skin[name]) {
                  num = lib.config.skin[name] + 1;
               }
               var fakeavatar = avatar.cloneNode(true);
               var finish = function (bool) {
                  var player = avatar.parentNode;
                  if (bool) {
                     fakeavatar.style.boxShadow = 'none';
                     player.insertBefore(fakeavatar, avatar.nextSibling);
                     setTimeout(function () {
                        fakeavatar.delete();
                     }, 100);
                  }
                  if (bool && lib.config.animation && !lib.config.low_performance) {
                     player.$rare();
                  }
                  if (callback) {
                     callback(bool);
                  }
               }
               var img = new Image();
               img.onload = function () {
                  lib.config.skin[name] = num;
                  game.saveConfig('skin', lib.config.skin);
                  avatar.style.backgroundImage = 'url("' + img.src + '")';
                  finish(true);
               }
               img.onerror = function () {
                  if (lib.config.skin[name]) {
                     finish(true);
                  }
                  else {
                     finish(false);
                  }
                  delete lib.config.skin[name];
                  game.saveConfig('skin', lib.config.skin);
                  avatar.setBackground(name, 'character');
               }
               img.src = lib.assetURL + 'image/skin/' + name + '/' + num + '.jpg';
            },
            touchpop: function (forced) {
               if (lib.config.touchscreen || forced) {
                  _status.touchpopping = true;
                  clearTimeout(_status.touchpoppingtimeout);
                  _status.touchpoppingtimeout = setTimeout(function () {
                     _status.touchpopping = false;
                  }, 600);
               }
            },
            exit: function () {
               if (game.servermode && lib.config.reconnect_info && _status.over) {
                  if (!_status.roomtimeout) {
                     lib.config.reconnect_info[2] = game.roomId;
                     game.saveConfig('reconnect_info', lib.config.reconnect_info);
                  }
                  game.reload();
                  return;
               }
               else {
                  if (typeof game.roomId != 'string') {
                     game.saveConfig('reconnect_info');
                  }
               }
               if (!ui.exit || !ui.exit.stay) {
                  if (lib.config.reconnect_info) {
                     lib.config.reconnect_info.length = 1;
                     game.saveConfig('reconnect_info', lib.config.reconnect_info);
                  }
                  game.saveConfig('tmp_user_roomId', undefined, false, function () {
                     game.reload();
                  });
               }
               else {
                  game.reload();
               }
            },
            shortcut: function (show) {
               if (show === false) {
                  ui.shortcut.classList.add('hidden');
               }
               else {
                  ui.shortcut.classList.toggle('hidden');
               }
               if (ui.shortcut.classList.contains('hidden')) {
                  ui.favmode.style.display = 'none';
                  if (window.StatusBar && lib.config.show_statusbar_ios == 'auto') {
                     document.body.classList.remove('statusbar');
                     window.StatusBar.hide();
                  }
                  ui.window.classList.remove('shortcutpaused');
               }
               else {
                  if (lib.config.show_favmode) {
                     ui.favmode.style.display = '';
                  }
                  if (window.StatusBar && lib.config.show_statusbar_ios == 'auto') {
                     document.body.classList.add('statusbar');
                     window.StatusBar.overlaysWebView(true);
                     window.StatusBar.backgroundColorByName('black');
                     window.StatusBar.show();
                  }
                  if (_status.auto) {
                     ui.shortcut.autobutton.classList.add('active');
                  }
                  else {
                     ui.shortcut.autobutton.classList.remove('active');
                  }
                  ui.window.classList.add('shortcutpaused');
               }
            },
            favouriteCharacter: function (e) {
               if (typeof this.link == 'string') {
                  if (this.innerHTML == '添加收藏') {
                     this.innerHTML = '移除收藏';
                     lib.config.favouriteCharacter.add(this.link);
                  }
                  else {
                     this.innerHTML = '添加收藏';
                     lib.config.favouriteCharacter.remove(this.link);
                  }
                  if (ui.favouriteCharacter) {
                     if (lib.config.favouriteCharacter.contains(this.link)) {
                        for (var i = 0; i < ui.favouriteCharacter.childElementCount; i++) {
                           if (ui.favouriteCharacter.childNodes[i].link == this.link) {
                              break;
                           }
                        }
                        if (i == ui.favouriteCharacter.childElementCount) {
                           ui.create.button(this.link, 'character', ui.favouriteCharacter).listen(function (e) {
                              this._banning = 'offline';
                              ui.click.touchpop();
                              ui.click.intro.call(this, e);
                              _status.clicked = false;
                              delete this._banning;
                           }).classList.add('noclick');
                        }
                     }
                     else {
                        for (var i = 0; i < ui.favouriteCharacter.childElementCount; i++) {
                           if (ui.favouriteCharacter.childNodes[i].link == this.link) {
                              ui.favouriteCharacter.childNodes[i].remove();
                              break;
                           }
                        }
                     }
                     var shownode = false;
                     for (var i = 0; i < lib.config.favouriteCharacter.length; i++) {
                        var favname = lib.config.favouriteCharacter[i];
                        if (lib.character[favname]) {
                           shownode = true; break;
                        }
                     }
                     if (shownode) {
                        ui.favouriteCharacter.node.style.display = '';
                     }
                     else {
                        ui.favouriteCharacter.node.style.display = 'none';
                     }
                  }
                  game.saveConfig('favouriteCharacter', lib.config.favouriteCharacter);
               }
               e.stopPropagation();
            },
            buttonnameenter: function () {
               if (this.buttonscrollinterval) {
                  clearInterval(this.buttonscrollinterval);
               }
               var node = this.node.name;
               if (node.offsetHeight < node.scrollHeight) {
                  var num = 40;
                  this.buttonscrollinterval = setInterval(() => {
                     if (node.scrollTop + node.offsetHeight >= node.scrollHeight) {
                        clearInterval(this.buttonscrollinterval);
                        delete this.buttonscrollinterval;
                     }
                     else {
                        if (num > 0) {
                           num--;
                        }
                        else {
                           node.scrollTop += 2;
                        }
                     }
                  }, 16);
               }
            },
            buttonnameleave: function () {
               if (this.buttonscrollinterval) {
                  clearInterval(this.buttonscrollinterval);
               }
               var node = this.node.name;
               if (node.offsetHeight < node.scrollHeight) {
                  this.buttonscrollinterval = setInterval(() => {
                     if (node.scrollTop == 0) {
                        clearInterval(this.buttonscrollinterval);
                        delete this.buttonscrollinterval;
                     }
                     else {
                        node.scrollTop -= 2;
                     }
                  }, 16);
               }
            },
            dragtouchdialog: function (e) {
               if (e.touches.length > 1 &&
                  !this.classList.contains('popped') &&
                  !this.classList.contains('fixed')) {
                  _status.draggingtouchdialog = this;
                  this._dragorigin = {
                     clientX: e.touches[0].clientX,
                     clientY: e.touches[0].clientY,
                  };
                  if (!this._dragtransform) {
                     this._dragtransform = [0, 0];
                  }
                  this._dragorigintransform = this._dragtransform.slice(0);
                  e.preventDefault();
                  e.stopPropagation();
               }
            },
            identity: function (e) {
               if (_status.dragged) return;
               _status.clicked = true;
               if (!game.getIdentityList) return;
               if (_status.video) return;
               if (this.parentNode.forceShown) return;
               if (_status.clickingidentity) {
                  for (var i = 0; i < _status.clickingidentity[1].length; i++) {
                     _status.clickingidentity[1][i].delete();
                     _status.clickingidentity[1][i].style.transform = '';
                  }
                  if (_status.clickingidentity[0] == this.parentNode) {
                     delete _status.clickingidentity;
                     return;
                  }
               }
               var list = game.getIdentityList(this.parentNode);
               if (!list) return;
               if (lib.config.mark_identity_style == 'click') {
                  var list2 = [];
                  for (var i in list) {
                     list2.push(i);
                  }
                  list2.push(list2[0]);
                  for (var i = 0; i < list2.length; i++) {
                     if (this.firstChild.innerHTML == list[list2[i]]) {
                        this.firstChild.innerHTML = list[list2[i + 1]];
                        this.dataset.color = list2[i + 1];
                        break;
                     }
                  }
               }
               else {
                  if (get.mode() == 'guozhan') {
                     list = { holo: '杏', nijisanji: '虹', vtuber: '企', clubs: '社' };
                  }
                  var list2 = get.copy(list);
                  if (game.getIdentityList2) {
                     game.getIdentityList2(list2);
                  }
                  var rect = this.parentNode.getBoundingClientRect();
                  this._customintro = function (uiintro) {
                     if (get.mode() == 'guozhan') {
                        uiintro.clickintro = true;
                     }
                     else {
                        uiintro.touchclose = true;
                     }
                     // if(lib.config.theme!='woodden'){
                     uiintro.classList.add('woodbg');
                     // }
                     if (get.is.phoneLayout()) {
                        uiintro.style.width = '100px';
                     }
                     else {
                        uiintro.style.width = '85px';
                     }
                     var source = this.parentNode;
                     for (var i in list) {
                        var node = ui.create.div();
                        node.classList.add('guessidentity');
                        node.classList.add('pointerdiv');
                        ui.create.div('.menubutton.large', list2[i], node);
                        if (!get.is.phoneLayout()) {
                           node.firstChild.style.fontSize = '24px';
                           node.firstChild.style.lineHeight = '24px';
                        }
                        if (get.mode() == 'guozhan') {
                           if (source._guozhanguess) {
                              if (!source._guozhanguess.contains(i)) {
                                 node.classList.add('transparent');
                              }
                           }
                           node._source = source;
                           node.listen(ui.click.identitycircle);
                        }
                        else {
                           node.listen(function () {
                              var info = this.link;
                              info[0].firstChild.innerHTML = info[1];
                              info[0].dataset.color = info[2];
                              _status.clicked = false;
                           });
                        }

                        node.link = [this, list[i], i];
                        uiintro.add(node);
                     }
                  };
                  ui.click.touchpop();
                  ui.click.intro.call(this, {
                     clientX: (rect.left + rect.width),
                     clientY: (rect.top)
                  });
                  // var nodes=[];
                  // _status.clickingidentity=[this.parentNode,nodes];
                  // var num=1;
                  // var dy=30;
                  // if(get.is.phoneLayout()){
                  //     dy=45;
                  // }
                  // for(var i in list){
                  //     if(this.firstChild.innerHTML!=list[i]){
                  //         var node=ui.create.div('.identity.hidden.pointerdiv',this.parentNode,ui.click.identity2);
                  //         ui.create.div(node).innerHTML=list[i];
                  //         node.dataset.color=i;
                  //         ui.refresh(node);
                  //         node.show();
                  //         var transstr='translateY('+((num++)*dy)+'px)';
                  //         if(get.is.phoneLayout()){
                  //             transstr+=' scale(1.3)';
                  //         }
                  //         if(get.is.newLayout()&&this.parentNode.classList.contains('linked')){
                  //             transstr+=' rotate(90deg)';
                  //         }
                  //         node.style.transform=transstr;
                  //         nodes.push(node);
                  //     }
                  // }
               }
            },
            identity2: function () {
               if (_status.clickingidentity) {
                  _status.clicked = true;
                  var player = _status.clickingidentity[0];
                  var nodes = _status.clickingidentity[1];
                  player.node.identity.dataset.color = this.dataset.color;
                  player.node.identity.firstChild.innerHTML = this.firstChild.innerHTML;
                  for (var i = 0; i < nodes.length; i++) {
                     nodes[i].delete();
                     nodes[i].style.transform = '';
                  }
                  delete _status.clickingidentity;
               }
            },
            roundmenu: function () {
               game.closeConnectMenu();
               switch (lib.config.round_menu_func) {
                  case 'system':
                     game.closePopped();
                     ui.system1.classList.add('shown');
                     ui.system2.classList.add('shown');
                     game.closeMenu();
                     ui.click.shortcut();
                     break;
                  case 'menu':
                     if (ui.click.configMenu) {
                        game.closePopped();
                        game.pause2();
                        ui.click.configMenu();
                        ui.system1.classList.remove('shown');
                        ui.system2.classList.remove('shown');
                     }
                     break;
                  case 'pause':
                     ui.click.pause();
                     break;
                  case 'auto':
                     ui.click.auto();
                     break;
               }
               _status.clicked = true;
            },
            pausehistory: function () {
               if (!lib.config.auto_popped_history) return;
               if (!ui.sidebar.childNodes.length) return;
               var uiintro = ui.create.dialog('hidden');
               uiintro.style.maxHeight = '400px';
               uiintro.add(ui.sidebar);
               return uiintro;
            },
            pauseconfig: function () {
               if (!lib.config.auto_popped_config) return;
               if (get.is.phoneLayout()) return;
               var uiintro = ui.create.dialog('hidden');
               uiintro.listen(function (e) {
                  e.stopPropagation();
               });

               var rows = Math.floor(lib.config.all.mode.length / 3);
               uiintro.type = 'config';
               var modes = lib.config.modeorder || lib.config.all.mode.slice(0);
               for (var i = 0; i < modes.length; i++) {
                  if (!lib.config.all.mode.contains(modes[i])) {
                     modes.splice(i--, 1);
                  }
               }
               for (var k = 0; k < rows; k++) {
                  var node = ui.create.div('.newgame.pointernode');
                  for (var i = 0; i < 3 && i + k * 3 < modes.length; i++) {
                     var thismode = modes[i + k * 3];
                     var div = ui.create.div(thismode == (_status.sourcemode || lib.config.mode) ? '.underlinenode.on' : '.underlinenode', node);
                     div.innerHTML = lib.translate[thismode];
                     div.link = thismode;
                     div.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', function () {
                        game.saveConfig('mode', this.link);
                        localStorage.setItem(lib.configprefix + 'directstart', true);
                        game.reload();
                     });
                  }
                  uiintro.add(node);
               }

               return uiintro;
            },
            cardPileButton: function () {
               var uiintro = ui.create.dialog('hidden');
               uiintro.listen(function (e) {
                  e.stopPropagation();
               });
               var num;
               if (game.online) {
                  num = _status.cardPileNum || 0;
               }
               else {
                  num = ui.cardPile.childNodes.length;
               }
               uiintro.add('剩余 <span style="font-family:' + 'xinwei' + '">' + num);

               if (_status.connectMode) return uiintro;
               uiintro.add('<div class="text center">轮数 <span style="font-family:xinwei">' + game.roundNumber + '</span>&nbsp;&nbsp;&nbsp;&nbsp;洗牌 <span style="font-family:xinwei">' + game.shuffleNumber + '</div>');
               uiintro.add('<div class="text center">弃牌堆</div>');
               if (ui.discardPile.childNodes.length) {
                  var list = [];
                  for (var i = 0; i < ui.discardPile.childNodes.length; i++) {
                     list.unshift(ui.discardPile.childNodes[i]);
                  }
                  uiintro.addSmall([list, 'card']);
               }
               else {
                  uiintro.add('<div class="text center" style="padding-bottom:3px">无</div>');
               }
               return uiintro;
            },
            chat: function () {
               ui.system1.classList.add('shown');
               ui.system2.classList.add('shown');

               var uiintro = ui.create.dialog('hidden');
               uiintro.listen(function (e) {
                  e.stopPropagation();
               });

               var list = ui.create.div('.caption');
               if (get.is.phoneLayout()) {
                  list.style.maxHeight = '110px';
               }
               else {
                  list.style.maxHeight = '220px';
               }
               list.style.overflow = 'scroll';
               lib.setScroll(list);
               uiintro.contentContainer.style.overflow = 'hidden';

               var input;
               var addEntry = function (info, clear) {
                  if (list._chatempty) {
                     list.innerHTML = '';
                     delete list._chatempty;
                  }
                  var node = ui.create.div('.text.chat');
                  node.innerHTML = info[0] + ': ' + info[1];
                  list.appendChild(node);
                  list.scrollTop = list.scrollHeight;
                  uiintro.style.height = uiintro.content.scrollHeight + 'px';
               }
               _status.addChatEntry = addEntry;
               _status.addChatEntry._origin = uiintro;
               if (lib.chatHistory.length) {
                  for (var i = 0; i < lib.chatHistory.length; i++) {
                     addEntry(lib.chatHistory[i]);
                  }
               }
               else {
                  list._chatempty = true;
                  list.appendChild(ui.create.div('.text.center', '无聊天记录'))
               }
               uiintro.add(list);
               uiintro.style.height = uiintro.content.offsetHeight + 'px';
               list.scrollTop = list.scrollHeight;

               if (!_status.chatValue) _status.chatValue = '';
               var node = uiintro.add('<input type="text" value="' + _status.chatValue + '">');
               node.style.paddingTop = 0;
               node.style.marginBottom = '16px';
               input = node.firstChild;
               input.style.width = 'calc(100% - 20px)';
               input.onchange = function () {
                  _status.chatValue = input.value;
               }
               input.onkeydown = function (e) {
                  if (e.keyCode == 13 && input.value) {
                     var player = game.me;
                     var str = input.value;
                     if (!player) {
                        if (game.connectPlayers) {
                           if (game.online) {
                              for (var i = 0; i < game.connectPlayers.length; i++) {
                                 if (game.connectPlayers[i].playerid == game.onlineID) {
                                    player = game.connectPlayers[i]; break;
                                 }
                              }
                           }
                           else {
                              player = game.connectPlayers[0];
                           }
                        }
                     }
                     if (!player) return;
                     if (get.is.banWords(input.value)) {
                        player.say(input.value);
                        input.value = '';
                        _status.chatValue = '';
                     }
                     else {
                        if (game.online) {
                           game.send('chat', game.onlineID, str);
                        }
                        else {
                           lib.element.player.chat.call(player, str);
                        }
                        input.value = '';
                        _status.chatValue = '';
                     }
                  }
                  e.stopPropagation();
               }
               uiintro._onopen = function () {
                  input.focus();
                  list.scrollTop = list.scrollHeight;
               };
               uiintro._heightfixed = true;
               var emotionTitle = ui.create.div('.text.center', '聊天表情', function () {
                  if (emotionTitle.innerHTML == '快捷语音') {
                     emotionTitle.innerHTML = '聊天表情';
                     list2.remove();
                     list3.remove();
                     uiintro.add(list1);
                     while (list2.childNodes.length) {
                        list2.firstChild.remove();
                     }
                  }
                  else {
                     emotionTitle.innerHTML = '快捷语音';
                     list1.remove();
                     list2.remove();
                     uiintro.add(list3);
                  }
               });
               uiintro.add(emotionTitle);
               var list1 = ui.create.div('');
               if (get.is.phoneLayout()) {
                  list1.style.height = '110px';
               }
               else {
                  list1.style.height = '150px';
               }
               list1.style.overflow = 'scroll';
               lib.setScroll(list1);
               uiintro.add(list1);
               uiintro.style.height = uiintro.content.scrollHeight + 'px';
               var list2 = ui.create.div('');
               if (get.is.phoneLayout()) {
                  list2.style.height = '110px';
               }
               else {
                  list2.style.height = '150px';
               }
               list2.style.overflow = 'scroll';
               lib.setScroll(list2);
               //uiintro.add(list2);
               for (var i in lib.emotionList) {
                  var emotionPack = ui.create.div('.card.fullskin', '<img src="' + lib.assetURL + 'image/emotion/' + i + '/1.gif" width="50" height="50">', function () {
                     emotionTitle.innerHTML = get.translation(this.pack);
                     for (var j = 1; j <= lib.emotionList[this.pack]; j++) {
                        var emotionButton = ui.create.div('.card.fullskin', '<img src="' + lib.assetURL + 'image/emotion/' + this.pack + '/' + j + '.gif" width="50" height="50">', function () {
                           var player = game.me;
                           if (!player) {
                              if (game.connectPlayers) {
                                 if (game.online) {
                                    for (var i = 0; i < game.connectPlayers.length; i++) {
                                       if (game.connectPlayers[i].playerid == game.onlineID) {
                                          player = game.connectPlayers[i]; break;
                                       }
                                    }
                                 }
                                 else {
                                    player = game.connectPlayers[0];
                                 }
                              }
                           }
                           if (!player) return;
                           if (game.online) {
                              game.send('emotion', game.onlineID, this.pack, this.emotionID);
                           }
                           else {
                              lib.element.player.emotion.apply(player, [this.pack, this.emotionID]);
                           }
                        });
                        emotionButton.emotionID = j;
                        emotionButton.pack = this.pack;
                        emotionButton.style.height = '50px';
                        emotionButton.style.width = '50px';
                        list2.appendChild(emotionButton);
                     }
                     list1.remove();
                     uiintro.add(list2);
                  });
                  emotionPack.pack = i;
                  emotionPack.style.height = '50px';
                  emotionPack.style.width = '50px';
                  list1.appendChild(emotionPack);
               }
               list1.scrollTop = list1.scrollHeight;
               uiintro.style.height = uiintro.content.scrollHeight + 'px';
               var list3 = ui.create.div('.caption');
               if (get.is.phoneLayout()) {
                  list3.style.height = '110px';
               }
               else {
                  list3.style.height = '150px';
               }
               list3.style.overflow = 'scroll';
               lib.setScroll(list3);
               for (var i = 0; i < lib.quickVoice.length; i++) {
                  var node = ui.create.div('.text.chat', function () {
                     var player = game.me;
                     var str = this.innerHTML;
                     if (!player) {
                        if (game.connectPlayers) {
                           if (game.online) {
                              for (var i = 0; i < game.connectPlayers.length; i++) {
                                 if (game.connectPlayers[i].playerid == game.onlineID) {
                                    player = game.connectPlayers[i]; break;
                                 }
                              }
                           }
                           else {
                              player = game.connectPlayers[0];
                           }
                        }
                     }
                     if (!player) return;
                     if (game.online) {
                        game.send('chat', game.onlineID, str);
                     }
                     else {
                        lib.element.player.chat.call(player, str);
                     }
                  });
                  node.innerHTML = lib.quickVoice[i];
                  list3.appendChild(node);
               }
               list3.scrollTop = list1.scrollHeight;
               return uiintro;
            },
            volumn: function () {
               var uiintro = ui.create.dialog('hidden');
               uiintro.listen(function (e) {
                  e.stopPropagation();
               });
               uiintro.add('背景音乐');
               var vol1 = ui.create.div('.volumn');
               uiintro.add(vol1);
               for (var i = 0; i < 8; i++) {
                  var span = document.createElement('span');
                  span.link = i + 1;
                  span.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.volumn_background);
                  if (i < lib.config.volumn_background) {
                     span.innerHTML = '●';
                  }
                  else {
                     span.innerHTML = '○';
                  }
                  vol1.appendChild(span);
               }
               uiintro.add('游戏音效');

               var vol2 = ui.create.div('.volumn');
               uiintro.add(vol2);
               for (var i = 0; i < 8; i++) {
                  var span = document.createElement('span');
                  span.link = i + 1;
                  span.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.volumn_audio);
                  if (i < lib.config.volumn_audio) {
                     span.innerHTML = '●';
                  }
                  else {
                     span.innerHTML = '○';
                  }
                  vol2.appendChild(span);
               }
               uiintro.add(ui.create.div('.placeholder'));
               return uiintro;
            },
            volumn_background: function (e) {
               if (_status.dragged) return;
               var volume = this.link;
               if (volume === 1 && lib.config.volumn_background === 1) {
                  volume = 0;
               }
               game.saveConfig('volumn_background', volume);
               ui.backgroundMusic.volume = volume / 8;
               for (var i = 0; i < 8; i++) {
                  if (i < lib.config.volumn_background) {
                     this.parentNode.childNodes[i].innerHTML = '●';
                  }
                  else {
                     this.parentNode.childNodes[i].innerHTML = '○';
                  }
               }
               e.stopPropagation();
            },
            volumn_audio: function (e) {
               if (_status.dragged) return;
               var volume = this.link;
               if (volume === 1 && lib.config.volumn_audio === 1) {
                  volume = 0;
               }
               game.saveConfig('volumn_audio', volume);
               for (var i = 0; i < 8; i++) {
                  if (i < lib.config.volumn_audio) {
                     this.parentNode.childNodes[i].innerHTML = '●';
                  }
                  else {
                     this.parentNode.childNodes[i].innerHTML = '○';
                  }
               }
               e.stopPropagation();
            },
            hoverpopped: function () {
               if (this._uiintro) {
                  return;
               }
               if (!this._poppedfunc) {
                  return;
               }
               ui.click.touchpop(this.forceclick);
               var uiintro = this._poppedfunc();
               if (!uiintro) return;
               if (ui.currentpopped && ui.currentpopped._uiintro) {
                  ui.currentpopped._uiintro.delete();
                  delete ui.currentpopped._uiintro;
               }
               ui.currentpopped = this;
               uiintro.classList.add('popped');
               uiintro.classList.add('hoverdialog');
               uiintro.classList.add('static');
               this._uiintro = uiintro;

               ui.window.appendChild(uiintro);
               var width = this._poppedwidth || 330;
               uiintro.style.width = width + 'px';
               if (get.is.phoneLayout()) {
                  width *= 1.3;
               }

               if (uiintro._heightfixed) {
                  uiintro.style.height = uiintro.content.scrollHeight + 'px';
               }
               else {
                  var height = this._poppedheight || uiintro.content.scrollHeight;
                  var height2 = ui.window.offsetHeight - 260;
                  if (get.is.phoneLayout()) {
                     height2 = (ui.window.offsetHeight - 80) / 1.3;
                  }
                  uiintro.style.height = Math.min(height2, height) + 'px';
               }
               if (get.is.phoneLayout()) {
                  uiintro.style.top = '70px';
               }
               else {
                  uiintro.style.top = '50px';
               }
               var left = this.parentNode.offsetLeft + this.offsetLeft + this.offsetWidth / 2 - width / 2;
               if (left < 10) {
                  left = 10;
               }
               else if (left + width > ui.window.offsetWidth - 10) {
                  left = ui.window.offsetWidth - width - 10;
               }
               uiintro.style.left = left + 'px';
               uiintro._poppedorigin = this;
               if (!lib.config.touchscreen) {
                  uiintro.addEventListener('mouseleave', ui.click.leavehoverpopped);
               }
               ui.click.shortcut(false);
               if (uiintro._onopen) {
                  uiintro._onopen();
               }
               if (this._paused2 && !lib.config.touchscreen) {
                  game.pause2();
                  uiintro.classList.add('static');
                  var layer = ui.create.div('.poplayer', ui.window);
                  var clicklayer = function (e) {
                     uiintro.delete();
                     layer.remove();
                     game.resume2();
                     e.stopPropagation();
                     return false;
                  }
                  uiintro.style.zIndex = 21;
                  layer.onclick = clicklayer;
                  layer.oncontextmenu = clicklayer;
                  uiintro.addEventListener('mouseleave', clicklayer);
                  uiintro.addEventListener('click', clicklayer);
               }
            },
            hoverpopped_leave: function () {
               this._poppedalready = false;
            },
            leavehoverpopped: function () {
               if (_status.dragged) return;
               if (this.classList.contains('noleave')) return;
               this.delete();
               var button = this._poppedorigin;

               var uiintro = this;
               setTimeout(function () {
                  if (button._uiintro == uiintro) {
                     delete button._uiintro;
                  }
               }, 500);

            },
            dierevive: function () {
               if (game.me.isDead()) {
                  game.me.revive(Math.max(1, game.me.maxHp));
                  game.me.draw(2);
               }
               else {
                  if (ui.revive) {
                     ui.revive.close();
                     delete ui.revive;
                  }
               }
            },
            dieswap: function () {
               if (game.me.isDead()) {
                  _status.clicked = true;
                  var i, translation, intro, str;
                  if (ui.intro) {
                     ui.intro.close();
                     if (ui.intro.source == 'dieswap') {
                        delete ui.intro;
                        ui.control.show();
                        game.resume2();
                        return;
                     }
                  }
                  game.pause2();
                  ui.control.hide();
                  ui.intro = ui.create.dialog();
                  ui.intro.source = 'dieswap';

                  var players = [];
                  for (var i = 0; i < game.players.length; i++) {
                     if (game.players[i].isAlive()) {
                        players.push(game.players[i]);
                     }
                  }
                  ui.intro.add(players, true);
                  var buttons = ui.intro.querySelectorAll('.button');
                  for (var i = 0; i < buttons.length; i++) {
                     buttons[i].addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.dieswap2);
                  }
               }
               else {
                  if (ui.swap) {
                     ui.swap.close();
                     delete ui.swap;
                  }
               }
            },
            dieswap2: function () {
               if (_status.dragged) return;
               game.swapPlayer(this.link);
            },
            touchconfirm: function () {
               _status.touchconfirmed = true;
               document.removeEventListener('touchstart', ui.click.touchconfirm);
            },
            windowtouchstart: function (e) {
               if (window.inSplash) return;
               if (e.touches[0] && lib.config.swipe && e.touches.length < 2) {
                  _status._swipeorigin = {
                     clientX: e.touches[0].clientX,
                     clientY: e.touches[0].clientY,
                     time: get.utc()
                  }
               }
               // if(window.ForceTouch&&!_status.paused2&&!_status.forcetouchinterval&&lib.config.enable_pressure){
               //     _status.forcetouchinterval=setInterval(ui.click.forcetouch,30);
               // }
            },
            windowtouchmove: function (e) {
               e.preventDefault();
               if (window.inSplash) return;
               if (_status.draggingroundmenu) {
                  delete _status._swipeorigin;
                  if (ui.roundmenu._dragorigin && ui.roundmenu._dragtransform && e.touches.length) {
                     var translate = ui.roundmenu._dragtransform.slice(0);
                     var dx = e.touches[0].clientX / game.documentZoom - ui.roundmenu._dragorigin.clientX / game.documentZoom;
                     var dy = e.touches[0].clientY / game.documentZoom - ui.roundmenu._dragorigin.clientY / game.documentZoom;
                     translate[0] += dx;
                     translate[1] += dy;
                     if (dx * dx + dy * dy > 100) {
                        if (ui.roundmenu._resetTimeout) {
                           clearTimeout(ui.roundmenu._resetTimeout);
                           delete ui.roundmenu._resetTimeout;
                        }
                     }
                     ui.roundmenu._dragtouches = e.touches[0];
                     ui.click.checkroundtranslate(translate);
                  }
                  _status.clicked = true;
               }
               else if (_status.draggingtouchdialog) {
                  delete _status._swipeorigin;
                  if (_status.draggingtouchdialog._dragorigin && _status.draggingtouchdialog._dragtransform && e.touches.length) {
                     var translate = _status.draggingtouchdialog._dragtransform.slice(0);
                     var dx = e.touches[0].clientX / game.documentZoom - _status.draggingtouchdialog._dragorigin.clientX / game.documentZoom;
                     var dy = e.touches[0].clientY / game.documentZoom - _status.draggingtouchdialog._dragorigin.clientY / game.documentZoom;
                     translate[0] += dx;
                     translate[1] += dy;
                     _status.draggingtouchdialog._dragtouches = e.touches[0];
                     ui.click.checkdialogtranslate(translate, _status.draggingtouchdialog);
                  }
                  _status.clicked = true;
               }
               else if (_status._swipeorigin && e.touches[0]) {
                  _status._swipeorigin.touches = e.touches[0];
               }

               if (_status.mousedragging && e.touches.length) {
                  e.preventDefault();
                  var item = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY);
                  if (game.chess && ui.selected.cards.length) {
                     var itemtype = get.itemtype(item);
                     if (itemtype != 'card' && itemtype != 'button') {
                        var ex = e.touches[0].clientX / game.documentZoom - ui.arena.offsetLeft;
                        var ey = e.touches[0].clientY / game.documentZoom - ui.arena.offsetTop;
                        for (var i = 0; i < game.players.length; i++) {
                           var left = -ui.chessContainer.chessLeft + ui.chess.offsetLeft + game.players[i].getLeft();
                           var top = -ui.chessContainer.chessTop + ui.chess.offsetTop + game.players[i].getTop();
                           var width = game.players[i].offsetWidth;
                           var height = game.players[i].offsetHeight;
                           if (ex > left && ex < left + width && ey > top && ey < top + height) {
                              item = game.players[i];
                              break;
                           }
                        }
                     }
                  }
                  while (item) {
                     if (lib.config.enable_touchdragline && _status.mouseleft && !game.chess) {
                        ui.canvas.width = ui.arena.offsetWidth;
                        ui.canvas.height = ui.arena.offsetHeight;
                        var ctx = ui.ctx;
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = 'rgba(0,0,0,0.3)';
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([8, 2]);

                        ctx.beginPath();

                        ctx.moveTo(_status.mousedragging.clientX / game.documentZoom - ui.arena.offsetLeft, _status.mousedragging.clientY / game.documentZoom - ui.arena.offsetTop);

                        if (_status.multitarget) {
                           for (var i = 0; i < _status.lastdragchange.length; i++) {
                              var exy = _status.lastdragchange[i]._lastdragchange;
                              ctx.lineTo(exy[0], exy[1]);
                           }
                        }
                        if (!_status.selectionfull) {
                           ctx.lineTo(e.touches[0].clientX / game.documentZoom - ui.arena.offsetLeft, e.touches[0].clientY / game.documentZoom - ui.arena.offsetTop);
                        }
                        ctx.stroke();
                        if (!_status.multitarget) {
                           for (var i = 0; i < _status.lastdragchange.length; i++) {
                              ctx.moveTo(_status.mousedragging.clientX / game.documentZoom - ui.arena.offsetLeft, _status.mousedragging.clientY / game.documentZoom - ui.arena.offsetTop);
                              var exy = _status.lastdragchange[i]._lastdragchange;
                              ctx.lineTo(exy[0], exy[1]);
                              ctx.stroke();
                           }
                        }
                     }

                     if (item == _status.mousedragorigin) {
                        if (_status.mouseleft) {
                           _status.mousedragging = null;
                           _status.mousedragorigin = null;
                           _status.clicked = false;
                           game.uncheck();
                           game.check();
                           _status.clicked = true;
                        }
                        return;
                     }
                     var itemtype = get.itemtype(item);
                     if (itemtype == 'card' || itemtype == 'button' || itemtype == 'player') {
                        _status.mouseleft = true;
                        if (ui.selected.cards.length) {
                           ui.selected.cards[0].updateTransform(true, 100);
                        }
                        var ex = e.touches[0].clientX / game.documentZoom - ui.arena.offsetLeft;
                        var ey = e.touches[0].clientY / game.documentZoom - ui.arena.offsetTop;
                        var exx = ex, eyy = ey;
                        if (game.chess) {
                           ex -= -ui.chessContainer.chessLeft + ui.chess.offsetLeft;
                           ey -= -ui.chessContainer.chessTop + ui.chess.offsetTop;
                        }
                        if (itemtype != 'player' || game.chess || (ex > item.offsetLeft && ex < item.offsetLeft + item.offsetWidth &&
                           ey > item.offsetTop && ey < item.offsetTop + item.offsetHeight)) {
                           var targetfixed = false;
                           if (itemtype == 'player') {
                              if (get.select(_status.event.selectTarget)[1] == -1) {
                                 targetfixed = true;
                              }
                           }
                           if (!targetfixed && item.classList.contains('selectable') && _status.dragstatuschanged != item) {
                              _status.mouseleft = true;
                              _status.dragstatuschanged = item;
                              _status.clicked = false;
                              _status.dragged = false;
                              var notbefore = itemtype == 'player' && !item.classList.contains('selected');
                              ui.click[itemtype].call(item);
                              if (item.classList.contains('selected')) {
                                 if (notbefore) {
                                    _status.lastdragchange.push(item);
                                    item._lastdragchange = [exx, eyy];
                                    if (lib.falseitem) {
                                       var from = [_status.mousedragging.clientX / game.documentZoom - ui.arena.offsetLeft, _status.mousedragging.clientY / game.documentZoom - ui.arena.offsetTop];
                                       var to = [exx, eyy];
                                       var node = ui.create.div('.linexy.hidden');
                                       node.style.left = from[0] + 'px';
                                       node.style.top = from[1] + 'px';
                                       node.style.transitionDuration = '0.3s';
                                       node.style.backgroundColor = 'white';
                                       var dy = to[1] - from[1];
                                       var dx = to[0] - from[0];
                                       var deg = Math.atan(Math.abs(dy) / Math.abs(dx)) / Math.PI * 180;
                                       if (dx >= 0) {
                                          if (dy <= 0) {
                                             deg += 90;
                                          }
                                          else {
                                             deg = 90 - deg;
                                          }
                                       }
                                       else {
                                          if (dy <= 0) {
                                             deg = 270 - deg;
                                          }
                                          else {
                                             deg += 270;
                                          }
                                       }
                                       node.style.transform = 'rotate(' + (-deg) + 'deg) scaleY(0)';
                                       node.style.height = get.xyDistance(from, to) + 'px';
                                       if (game.chess) {
                                          ui.chess.appendChild(node);
                                       }
                                       else {
                                          ui.arena.appendChild(node);
                                       }
                                       ui.refresh(node);
                                       node.show();
                                       node.style.transform = 'rotate(' + (-deg) + 'deg) scaleY(1)';
                                       ui.touchlines.push(node);
                                       node._origin = item;
                                    }
                                 }
                              }
                              else {
                                 _status.lastdragchange.remove(item);
                                 for (var i = 0; i < ui.touchlines.length; i++) {
                                    if (ui.touchlines[i]._origin == item) {
                                       ui.touchlines[i].delete();
                                       ui.touchlines.splice(i--, 1);
                                    }
                                 }
                              }
                              _status.selectionfull = true;
                              if (_status.event.filterButton && ui.selected.buttons.length < get.select(_status.event.selectButton)[1]) {
                                 _status.selectionfull = false;
                              }
                              else if (_status.event.filterCard && ui.selected.cards.length < get.select(_status.event.selectCard)[1]) {
                                 _status.selectionfull = false;
                              }
                              else if (_status.event.filterTarget && ui.selected.targets.length < get.select(_status.event.selectTarget)[1]) {
                                 _status.selectionfull = false;
                              }
                           }
                        }
                        return;
                     }
                     item = item.parentNode;
                  }
                  _status.mouseleft = true;
                  _status.dragstatuschanged = null;
               }
            },
            windowtouchend: function (e) {
               delete _status.force;
               // if(_status.forcetouchinterval){
               //     clearInterval(_status.forcetouchinterval);
               //     delete _status.forcetouchinterval;
               // }
               if (window.inSplash) return;
               if (e.touches.length == 1 && !_status.dragged && !_status.draggingtouchdialog) {
                  ui.click.pause();
               }
               if (_status.draggingroundmenu) {
                  delete _status._swipeorigin;
                  if (ui.roundmenu._resetTimeout) {
                     clearTimeout(ui.roundmenu._resetTimeout);
                     delete ui.roundmenu._resetTimeout;
                  }
                  var translate;
                  if (ui.roundmenu._dragorigin && ui.roundmenu._dragtransform && ui.roundmenu._dragtouches) {
                     var dx = ui.roundmenu._dragtouches.clientX / game.documentZoom - ui.roundmenu._dragorigin.clientX / game.documentZoom;
                     var dy = ui.roundmenu._dragtouches.clientY / game.documentZoom - ui.roundmenu._dragorigin.clientY / game.documentZoom;
                     if (dx * dx + dy * dy < 1000) {
                        ui.click.roundmenu();
                        ui.roundmenu._dragtransform = ui.roundmenu._dragorigintransform;
                        translate = ui.roundmenu._dragtransform;
                        ui.roundmenu.style.transform = 'translate(' + translate[0] + 'px,' + translate[1] + 'px)';
                     }
                     else {
                        translate = ui.roundmenu._dragtransform;
                        translate[0] += dx;
                        translate[1] += dy;
                        ui.click.checkroundtranslate();
                     }
                     delete ui.roundmenu._dragorigin;
                  }
                  else {
                     ui.click.roundmenu();
                  }
                  _status.clicked = false;
                  game.saveConfig('roundmenu_transform', translate);
                  delete _status.draggingroundmenu;
               }
               else if (_status.draggingtouchdialog) {
                  delete _status._swipeorigin;
                  var translate;
                  if (_status.draggingtouchdialog._dragorigin && _status.draggingtouchdialog._dragtransform && _status.draggingtouchdialog._dragtouches) {
                     var dx = _status.draggingtouchdialog._dragtouches.clientX / game.documentZoom - _status.draggingtouchdialog._dragorigin.clientX / game.documentZoom;
                     var dy = _status.draggingtouchdialog._dragtouches.clientY / game.documentZoom - _status.draggingtouchdialog._dragorigin.clientY / game.documentZoom;
                     translate = _status.draggingtouchdialog._dragtransform;
                     translate[0] += dx;
                     translate[1] += dy;
                     ui.click.checkdialogtranslate(null, _status.draggingtouchdialog);

                     delete _status.draggingtouchdialog._dragorigin;
                  }
                  _status.clicked = false;
                  game.saveConfig('dialog_transform', translate);
                  delete _status.draggingtouchdialog;
                  _status.justdragged = true;
                  setTimeout(function () {
                     _status.justdragged = false;
                  }, 500);
               }
               else if (_status._swipeorigin && !_status.paused2 && !_status.mousedragging && _status._swipeorigin.touches && !_status.filterCharacter) {
                  if (get.utc() - _status._swipeorigin.time < 500) {
                     var dx = _status._swipeorigin.touches.clientX / game.documentZoom - _status._swipeorigin.clientX / game.documentZoom;
                     var dy = _status._swipeorigin.touches.clientY / game.documentZoom - _status._swipeorigin.clientY / game.documentZoom;
                     var goswipe = function (action) {
                        game.closeConnectMenu();
                        switch (action) {
                           case 'system':
                              game.closePopped();
                              ui.system1.classList.add('shown');
                              ui.system2.classList.add('shown');
                              game.closeMenu();
                              ui.click.shortcut();
                              break;
                           case 'menu':
                              if (ui.click.configMenu) {
                                 game.closePopped();
                                 game.pause2();
                                 ui.click.configMenu();
                                 ui.system1.classList.remove('shown');
                                 ui.system2.classList.remove('shown');
                              }
                              break;
                           case 'pause':
                              ui.click.pause();
                              break;
                           case 'auto':
                              ui.click.auto();
                              break;
                           case 'chat':
                              game.closeMenu();
                              if (ui.chatButton) {
                                 ui.click.hoverpopped.call(ui.chatButton);
                              }
                              break;
                        }
                     }
                     if (Math.abs(dx) < 100) {
                        if (dy < -200) {
                           goswipe(lib.config.swipe_up);
                        }
                        else if (dy > 200) {
                           goswipe(lib.config.swipe_down);
                        }
                     }
                     else if (Math.abs(dy) < 100) {
                        if (dx < -200) {
                           goswipe(lib.config.swipe_left);
                        }
                        else if (dx > 200) {
                           goswipe(lib.config.swipe_right);
                        }
                     }
                  }
               }
               var tmpflag = false;
               _status.mousedown = false;
               _status.clicked = false;
               if (_status.mousedragging && _status.mouseleft) {
                  if (game.check()) {
                     if (ui.confirm) {
                        ui.confirm.close();
                     }
                     ui.click.ok();
                     ui.canvas.width = ui.arena.offsetWidth;
                     ui.canvas.height = ui.arena.offsetHeight;
                  }
                  else {
                     game.uncheck();
                     game.check();
                  }
               }
               else if (_status.mousedragging && _status.mousedragorigin) {
                  tmpflag = _status.mousedragorigin;
               }
               _status.lastdragchange.length = 0;
               _status.mousedragging = null;
               _status.mouseleft = false;
               _status.mousedragorigin = null;
               _status.dragstatuschanged = false;
               while (ui.touchlines.length) {
                  ui.touchlines.shift().delete();
               }
               if (tmpflag) {
                  game.check();
               }
               _status.dragged = false;
               _status.clicked = false;
            },
            checkroundtranslate: function (translate) {
               var translate = translate || ui.roundmenu._dragtransform;
               if (translate[1] + ui.roundmenu._position[1] + 50 + ui.arena.offsetTop > ui.window.offsetHeight) {
                  translate[1] = ui.window.offsetHeight - (ui.roundmenu._position[1] + 50) - ui.arena.offsetTop;
               }
               else if (translate[1] + ui.roundmenu._position[1] + ui.arena.offsetTop < 0) {
                  translate[1] = -ui.roundmenu._position[1] - ui.arena.offsetTop;
               }
               if (translate[0] + ui.roundmenu._position[0] + 50 + ui.arena.offsetLeft > ui.window.offsetWidth) {
                  translate[0] = ui.window.offsetWidth - (ui.roundmenu._position[0] + 50) - ui.arena.offsetLeft;
               }
               else if (translate[0] + ui.roundmenu._position[0] + ui.arena.offsetLeft < 0) {
                  translate[0] = -ui.roundmenu._position[0] - ui.arena.offsetLeft;
               }
               ui.roundmenu.style.transform = 'translate(' + translate[0] + 'px,' + translate[1] + 'px)';
            },
            checkdialogtranslate: function (translate, dialog) {
               var translate = translate || dialog._dragtransform;
               if (Math.sqrt(translate[0] * translate[0] + translate[1] * translate[1]) < 10) {
                  translate[0] = 0;
                  translate[1] = 0;
               }
               dialog.style.transform = 'translate(' + translate[0] + 'px,' + translate[1] + 'px)';
            },
            windowmousewheel: function (e) {
               _status.tempunpopup = e;
            },
            windowmousemove: function (e) {
               if (window.inSplash) return;
               if (_status.tempunpopup) {
                  if (get.evtDistance(_status.tempunpopup, e) > 5) {
                     delete _status.tempunpopup;
                  }
               }
               if (e.button == 2) return;
               var dialogs = document.querySelectorAll('#window>.dialog.popped:not(.static)');
               for (var i = 0; i < dialogs.length; i++) {
                  dialogs[i].delete();
               }
               var node = _status.currentmouseenter;
               var sourceitem = document.elementFromPoint(e.clientX, e.clientY);
               if (game.chess && ui.selected.cards.length) {
                  var itemtype = get.itemtype(sourceitem);
                  if (itemtype != 'card' && itemtype != 'button') {
                     for (var i = 0; i < game.players.length; i++) {
                        var ex = e.clientX / game.documentZoom - ui.arena.offsetLeft;
                        var ey = e.clientY / game.documentZoom - ui.arena.offsetTop;
                        var left = -ui.chessContainer.chessLeft + ui.chess.offsetLeft + game.players[i].getLeft();
                        var top = -ui.chessContainer.chessTop + ui.chess.offsetTop + game.players[i].getTop();
                        var width = game.players[i].offsetWidth;
                        var height = game.players[i].offsetHeight;
                        if (ex > left && ex < left + width && ey > top && ey < top + height) {
                           sourceitem = game.players[i];
                           break;
                        }
                     }
                  }
               }
               var item = sourceitem;
               if (_status.mousedragging) {
                  e.preventDefault();
                  if (lib.config.enable_dragline) {
                     // var i=0;
                     // var startPoint0=[_status.mousedragging.clientX/game.documentZoom-ui.arena.offsetLeft,_status.mousedragging.clientY/game.documentZoom-ui.arena.offsetTop];
                     // var startPoint=startPoint0;
                     // var endPoint;
                     // if(_status.multitarget){
                     //     for(;i<_status.lastdragchange.length;i++){
                     //         var exy=_status.lastdragchange[i]._lastdragchange;
                     //         endPoint=[exy[0],exy[1]];
                     //         _status.dragline[i]=game.linexy(startPoint.concat(endPoint),'drag',_status.dragline[i]);
                     //         startPoint=endPoint;
                     //     }
                     // }
                     // if(!_status.selectionfull){
                     //     endPoint=[e.clientX/game.documentZoom-ui.arena.offsetLeft,e.clientY/game.documentZoom-ui.arena.offsetTop];
                     //     _status.dragline[i]=game.linexy(startPoint.concat(endPoint),'drag',_status.dragline[i]);
                     //     startPoint=endPoint;
                     //     i++;
                     // }
                     // if(!_status.multitarget){
                     //     for(var j=0;j<_status.lastdragchange.length;j++){
                     //         i+=j;
                     //         var exy=_status.lastdragchange[j]._lastdragchange;
                     //         _status.dragline[i]=game.linexy(startPoint0.concat([exy[0],exy[1]]),'drag',_status.dragline[i]);
                     //     }
                     // }
                     // var remained=_status.dragline.splice(i+1);
                     // for(var j=0;j<remained.length;j++){
                     //     if(remained[j]) remained[j].remove();
                     // }

                     ui.canvas.width = ui.arena.offsetWidth;
                     ui.canvas.height = ui.arena.offsetHeight;
                     var ctx = ui.ctx;
                     ctx.shadowBlur = 5;
                     ctx.shadowColor = 'rgba(0,0,0,0.3)';
                     ctx.strokeStyle = 'white';
                     ctx.lineWidth = 3;
                     ctx.setLineDash([8, 2]);

                     ctx.beginPath();

                     ctx.moveTo(_status.mousedragging.clientX / game.documentZoom - ui.arena.offsetLeft, _status.mousedragging.clientY / game.documentZoom - ui.arena.offsetTop);
                     if (_status.multitarget) {
                        for (var i = 0; i < _status.lastdragchange.length; i++) {
                           var exy = _status.lastdragchange[i]._lastdragchange;
                           ctx.lineTo(exy[0], exy[1]);
                        }
                     }
                     if (!_status.selectionfull) {
                        ctx.lineTo(e.clientX / game.documentZoom - ui.arena.offsetLeft, e.clientY / game.documentZoom - ui.arena.offsetTop);
                     }
                     ctx.stroke();
                     if (!_status.multitarget) {
                        for (var i = 0; i < _status.lastdragchange.length; i++) {
                           ctx.moveTo(_status.mousedragging.clientX / game.documentZoom - ui.arena.offsetLeft, _status.mousedragging.clientY / game.documentZoom - ui.arena.offsetTop);
                           var exy = _status.lastdragchange[i]._lastdragchange;
                           ctx.lineTo(exy[0], exy[1]);
                           ctx.stroke();
                        }
                     }
                  }

                  while (item) {
                     if (item == _status.mousedragorigin) {
                        if (_status.mouseleft) {
                           _status.mousedragging = null;
                           _status.mousedragorigin = null;
                           _status.clicked = false;
                           if (_status.event.type == 'phase' && !_status.event.skill && ui.confirm) {
                              ui.confirm.classList.add('removing');
                           }
                           game.uncheck();
                           game.check();
                           _status.clicked = true;
                        }
                        return;
                     }
                     var itemtype = get.itemtype(item);
                     if (itemtype == 'card' || itemtype == 'button' || itemtype == 'player') {
                        _status.mouseleft = true;
                        if (ui.selected.cards.length) {
                           ui.selected.cards[0].updateTransform(true, 100);
                        }
                        var ex = e.clientX / game.documentZoom - ui.arena.offsetLeft;
                        var ey = e.clientY / game.documentZoom - ui.arena.offsetTop;
                        var exx = ex, eyy = ey;
                        if (game.chess) {
                           ex -= -ui.chessContainer.chessLeft + ui.chess.offsetLeft;
                           ey -= -ui.chessContainer.chessTop + ui.chess.offsetTop;
                        }
                        if (itemtype != 'player' || game.chess || (ex > item.offsetLeft && ex < item.offsetLeft + item.offsetWidth &&
                           ey > item.offsetTop && ey < item.offsetTop + item.offsetHeight)) {
                           var targetfixed = false;
                           if (itemtype == 'player') {
                              if (get.select(_status.event.selectTarget)[1] == -1) {
                                 targetfixed = true;
                              }
                           }
                           if (!targetfixed && item.classList.contains('selectable') && _status.dragstatuschanged != item) {
                              _status.mouseleft = true;
                              _status.dragstatuschanged = item;
                              _status.clicked = false;
                              var notbefore = itemtype == 'player' && !item.classList.contains('selected');
                              ui.click[itemtype].call(item);
                              if (item.classList.contains('selected')) {
                                 if (notbefore) {
                                    _status.lastdragchange.push(item);
                                    item._lastdragchange = [exx, eyy];
                                 }
                              }
                              else {
                                 _status.lastdragchange.remove(item);
                              }
                              _status.selectionfull = true;
                              if (_status.event.filterButton && ui.selected.buttons.length < get.select(_status.event.selectButton)[1]) {
                                 _status.selectionfull = false;
                              }
                              else if (_status.event.filterCard && ui.selected.cards.length < get.select(_status.event.selectCard)[1]) {
                                 _status.selectionfull = false;
                              }
                              else if (_status.event.filterTarget && ui.selected.targets.length < get.select(_status.event.selectTarget)[1]) {
                                 _status.selectionfull = false;
                              }
                           }
                        }
                        return;
                     }
                     item = item.parentNode;
                  }
                  if (!_status.mouseleft) {
                     _status.mouseleft = true;
                     game.check();
                     for (var i = 0; i < ui.selected.cards.length; i++) {
                        ui.selected.cards[i].updateTransform(true);
                     }
                  }
                  _status.dragstatuschanged = null;
               }
               else {
                  while (item) {
                     if (item == node && !node._mouseentercreated) {
                        ui.click.mouseentercancel();
                        var hoveration;
                        if (typeof node._hoveration == 'number') {
                           hoveration = node._hoveration;
                        }
                        else {
                           hoveration = parseInt(lib.config.hoveration);
                           if (node.classList.contains('button') ||
                              (node.parentNode && node.parentNode.parentNode) == ui.me) {
                              hoveration += 500;
                           }
                        }
                        _status._mouseentertimeout = setTimeout(function () {
                           if (_status.currentmouseenter != node || node._mouseentercreated || _status.tempunpopup ||
                              _status.mousedragging || _status.mousedown || !node.offsetWidth || !node.offsetHeight) {
                              return;
                           }
                           if (node._hoverfunc && !node._nopup) {
                              var dialog = node._hoverfunc.call(node, e);
                              if (dialog) {
                                 dialog.classList.add('popped');
                                 ui.window.appendChild(dialog);
                                 lib.placePoppedDialog(dialog, e);
                                 if (node._hoverwidth) {
                                    dialog.style.width = node._hoverwidth + 'px';
                                    dialog._hovercustomed = true;
                                 }
                                 node._mouseenterdialog = dialog;
                                 node._mouseentercreated = true;
                              }
                           }
                        }, hoveration);
                        break;
                     }
                     item = item.parentNode;
                  }
                  if (_status.draggingdialog) {
                     var ddialog = _status.draggingdialog;
                     if (ddialog._dragorigin && ddialog._dragtransform) {
                        var translate = ddialog._dragtransform.slice(0);
                        translate[0] += e.clientX / game.documentZoom - ddialog._dragorigin.clientX / game.documentZoom;
                        translate[1] += e.clientY / game.documentZoom - ddialog._dragorigin.clientY / game.documentZoom;
                        ui.click.checkdialogtranslate(translate, ddialog);
                     }
                     _status.clicked = true;
                  }
                  if (_status.draggingroundmenu) {
                     if (ui.roundmenu._dragorigin && ui.roundmenu._dragtransform) {
                        var translate = ui.roundmenu._dragtransform.slice(0);
                        translate[0] += e.clientX / game.documentZoom - ui.roundmenu._dragorigin.clientX / game.documentZoom;
                        translate[1] += e.clientY / game.documentZoom - ui.roundmenu._dragorigin.clientY / game.documentZoom;
                        ui.click.checkroundtranslate(translate);
                     }
                     _status.clicked = true;
                  }
               }
            },
            windowmousedown: function (e) {
               if (window.inSplash) return;
               if (!ui.window) return;
               if (e.button == 2) return;
               _status.mousedown = true;
               var dialogs = ui.window.querySelectorAll('#window>.dialog.popped:not(.static)');
               for (var i = 0; i < dialogs.length; i++) {
                  dialogs[i].delete();
               }
               var sourceitem = document.elementFromPoint(e.clientX, e.clientY);
               var item = sourceitem;
               while (item) {
                  var itemtype = get.itemtype(item);
                  if (itemtype == 'button') break;
                  if (itemtype == 'dialog' &&
                     !item.classList.contains('popped') &&
                     !item.classList.contains('fixed')) {
                     var ddialog = item;
                     _status.draggingdialog = ddialog;
                     ddialog._dragorigin = e;
                     if (!ddialog._dragtransform) {
                        ddialog._dragtransform = [0, 0];
                     }
                     return;
                  }
                  if (item == ui.roundmenu) {
                     _status.draggingroundmenu = true;
                     ui.roundmenu._dragorigin = e;
                     if (!ui.roundmenu._dragtransform) {
                        ui.roundmenu._dragtransform = [0, 0];
                     }
                     return;
                  }
                  item = item.parentNode;
               }

               var evt = _status.event;
               if (!lib.config.enable_drag) return;
               if (!ui.arena.classList.contains('selecting')) return;
               if (!evt.isMine()) return;

               item = sourceitem;
               while (item) {
                  var itemtype = get.itemtype(item);
                  if (itemtype == 'card' || itemtype == 'button' || itemtype == 'player') {
                     if (item.classList.contains('selectable') &&
                        !item.classList.contains('selected') &&
                        !item.classList.contains('noclick')) {
                        _status.clicked = false;
                        ui.click[itemtype].call(item);
                        if (item.classList.contains('selected')) {
                           _status.mousedragging = e;
                           _status.mousedragorigin = item;
                           _status.mouseleft = false;
                           _status.selectionfull = false;
                           _status.multitarget = false;
                           _status.lastmouseutc = get.utc();
                           ui.arena.classList.add('dragging');
                        }
                     }
                     return;
                  }
                  item = item.parentNode;
               }
            },
            cardtouchstart: function (e) {
               if (e.touches.length != 1) return;
               if (!lib.config.enable_drag) return;
               if (!this.parentNode) return;
               if (!this.parentNode.parentNode) return;
               if (this.parentNode.parentNode.parentNode != ui.me) return;
               if (this.parentNode.parentNode.classList.contains('scrollh')) return;
               if (this.classList.contains('selectable') &&
                  !this.classList.contains('selected') &&
                  !this.classList.contains('noclick')) {
                  this._waitingfordrag = {
                     clientX: e.touches[0].clientX,
                     clientY: e.touches[0].clientY
                  };
               }
            },
            cardtouchmove: function (e) {
               ui.click.longpresscancel.call(this);
               if (this._waitingfordrag) {
                  var drag = this._waitingfordrag;
                  _status.clicked = false;
                  _status.touchnocheck = true;
                  ui.click.card.call(this);
                  _status.touchnocheck = false;
                  if (this.classList.contains('selected')) {
                     _status.mousedragging = drag;
                     _status.mousedragorigin = this;
                     _status.mouseleft = false;
                     _status.selectionfull = false;
                     _status.multitarget = false;
                  }
                  delete this._waitingfordrag;
               }
            },
            windowmouseup: function (e) {
               delete _status.force;
               // if(_status.forcetouchinterval){
               //     clearInterval(_status.forcetouchinterval);
               //     delete _status.forcetouchinterval;
               // }
               if (window.inSplash) return;
               if (_status.draggingdialog) {
                  var ddialog = _status.draggingdialog;
                  var translate;
                  if (ddialog._dragorigin && ddialog._dragtransform) {
                     translate = ddialog._dragtransform;
                     translate[0] += e.clientX / game.documentZoom - ddialog._dragorigin.clientX / game.documentZoom;
                     translate[1] += e.clientY / game.documentZoom - ddialog._dragorigin.clientY / game.documentZoom;
                     ui.click.checkdialogtranslate(null, ddialog);
                     delete ddialog._dragorigin;
                  }
                  game.saveConfig('dialog_transform', translate);
                  delete _status.draggingdialog;
               }
               if (_status.draggingroundmenu) {
                  var translate;
                  if (ui.roundmenu._dragorigin && ui.roundmenu._dragtransform) {
                     var dx = e.clientX / game.documentZoom - ui.roundmenu._dragorigin.clientX / game.documentZoom;
                     var dy = e.clientY / game.documentZoom - ui.roundmenu._dragorigin.clientY / game.documentZoom;
                     if (dx * dx + dy * dy < 25) {
                        ui.click.roundmenu();
                     }
                     translate = ui.roundmenu._dragtransform;
                     translate[0] += dx;
                     translate[1] += dy;
                     ui.click.checkroundtranslate();
                     delete ui.roundmenu._dragorigin;
                  }
                  game.saveConfig('roundmenu_transform', translate);
                  delete _status.draggingroundmenu;
               }
               if (e.button == 2) {
                  if (_status.mousedragging) {
                     _status.mousedragging = null;
                     _status.mouseleft = false;
                     _status.mousedragorigin = null;
                     _status.dragstatuschanged = false;
                     game.uncheck();
                     game.check();
                     _status.noright = true;
                  }
               }
               else {
                  var tmpflag = false;
                  _status.mousedown = false;
                  for (var i = 0; i < ui.selected.cards.length; i++) {
                     ui.selected.cards[i].updateTransform(true);
                  }
                  if (_status.mousedragging && _status.mouseleft) {
                     if (game.check()) {
                        if (ui.confirm) {
                           ui.confirm.close();
                        }
                        ui.click.ok();
                     }
                     else {
                        game.uncheck();
                        game.check();
                     }
                  }
                  else if (_status.mousedragging && _status.mousedragorigin) {
                     tmpflag = _status.mousedragorigin;
                  }
                  _status.lastdragchange.length = 0;
                  _status.mousedragging = null;
                  _status.mouseleft = false;
                  _status.mousedragorigin = null;
                  _status.dragstatuschanged = false;
                  if (ui.arena) {
                     ui.canvas.width = ui.arena.offsetWidth;
                     ui.canvas.height = ui.arena.offsetHeight;
                  }
                  if (tmpflag) {
                     ui.click[get.itemtype(tmpflag)].call(tmpflag);
                     game.check();
                  }
                  // ui.updatehl();
               }
               if (ui.arena) {
                  ui.arena.classList.remove('dragging');
               }
            },
            mousemove: function () {
               if (!lib.config.hover_handcard && this.parentNode && this.parentNode.parentNode == ui.me) {
                  return;
               }
               if (!_status.currentmouseenter) {
                  _status.currentmouseenter = this;
               }
            },
            mouseenter: function () {
               if (!lib.config.hover_handcard && this.parentNode && this.parentNode.parentNode == ui.me) {
                  return;
               }
               _status.currentmouseenter = this;
            },
            mouseleave: function () {
               ui.click.mouseentercancel();
               if (_status.currentmouseenter == this) {
                  _status.currentmouseenter = null;
               }
               this._mouseentercreated = false;
            },
            mousedown: function () {
               ui.click.mouseentercancel();
               if (_status.currentmouseenter == this) {
                  _status.currentmouseenter = null;
               }
               this._mouseentercreated = true;
            },
            mouseentercancel: function () {
               if (_status._mouseentertimeout) {
                  clearTimeout(_status._mouseentertimeout);
                  delete _status._mouseentertimeout
               }
            },
            hoverplayer: function (e) {
               var node = get.nodeintro(this, true);
               if (node) node.style.zIndex = 21;
               return node;
            },
            longpressdown: function (e) {
               if (_status.longpressed) return;
               if (this._longpresstimeout) {
                  clearTimeout(this._longpresstimeout);
               }
               if (lib.config.longpress_info) {
                  this._longpresstimeout = setTimeout(ui.click.longpresscallback, 500);
               }
               this._longpressevent = e;
               if (_status.longpressing && _status.longpressing != this) {
                  ui.click.longpresscancel.call(_status.longpressing);
               }
               // if(window.ForceTouch&&!_status.forcetouchinterval&&lib.config.enable_pressure){
               //     _status.forcetouchinterval=setInterval(ui.click.forcetouch,30);
               // }
               _status.longpressing = this;
            },
            longpresscallback: function () {
               if (!_status.longpressing) return;
               var node = _status.longpressing;
               var func = node._longpresscallback;
               var e = node._longpressevent;
               if (!func || !e) return;
               clearTimeout(node._longpresstimeout);
               _status.force = true;
               delete _status.longpressing;
               delete node._longpresstimeout;
               delete node._longpressevent;
               if (_status.mousedragging && _status.mouseleft) return;
               if (!_status.longpressed) {
                  _status.longpressed = true;
                  setTimeout(function () {
                     _status.longpressed = false;
                  }, 500);
                  func.call(node, e);
                  if (lib.config.touchscreen && lib.config.enable_drag && !node._waitingfordrag) {
                     _status.mousedragging = null;
                     _status.mousedragorigin = null;
                     _status.clicked = false;
                     game.uncheck();
                     game.check();
                     _status.clicked = true;
                  }
                  delete node._waitingfordrag;
                  ui.click.touchpop();
               }
            },
            longpresscancel: function () {
               if (this._longpresstimeout) {
                  clearTimeout(this._longpresstimeout);
                  delete this._longpresstimeout;
               }
               delete this._longpressevent;
               if (_status.longpressing == this) {
                  delete _status.longpressing;
               }
            },
            window: function () {
               var clicked = _status.clicked;
               var dialogtouched = false;
               if (_status.dialogtouched) {
                  _status.dialogtouched = false;
                  dialogtouched = true;
               }
               if (_status.dragged) return;
               if (_status.touchpopping) return;
               if (_status.reloading) return;
               if (_status.clicked || _status.clicked2) {
                  _status.clicked = false;
                  _status.clicked2 = false;
               }
               else {
                  if (_status.clickingidentity) {
                     for (var i = 0; i < _status.clickingidentity[1].length; i++) {
                        _status.clickingidentity[1][i].delete();
                        _status.clickingidentity[1][i].style.transform = '';
                     }
                     delete _status.clickingidentity;
                  }
                  if (!_status.event.isMine) return;
                  if (ui.controls.length) {
                     ui.updatec();
                  }
                  if (_status.editing) {
                     if (_status.editing.innerHTML.length) {
                        _status.editing.link = _status.editing.innerHTML;
                     }
                     _status.editing.innerHTML = get.translation(_status.editing.link);
                     delete _status.editing;
                  }
                  else if (_status.choosing) {
                     if (!_status.choosing.expand) {
                        _status.choosing.parentNode.style.height = '';
                        _status.choosing.nextSibling.delete();
                        _status.choosing.previousSibling.show();
                        delete _status.choosing;
                     }
                  }
                  else if (ui.intro) {
                     ui.intro.close();
                     delete ui.intro;
                     ui.control.show();
                     game.resume2();
                  }
                  else if ((_status.event.isMine() || _status.event.forceMine) && !dialogtouched) {
                     if (_status.event.custom && _status.event.custom.replace.window) {
                        _status.event.custom.replace.window();
                     }
                     else {
                        if (_status.event.skill && _status.event.name == 'chooseToUse') {
                           ui.click.cancel();
                        }
                        else {
                           game.uncheck();
                           game.check();
                        }
                     }
                  }
                  if (!ui.shortcut.classList.contains('hidden')) {
                     ui.click.shortcut(false);
                  }
                  if (get.is.phoneLayout() && ui.menuContainer && ui.menuContainer.classList.contains('hidden')) {
                     if (ui.system2.classList.contains('shown')) {
                        _status.removinground = true;
                        setTimeout(function () {
                           _status.removinground = false;
                        }, 200);
                     }
                     ui.arena.classList.remove('phonetop');
                     ui.system1.classList.remove('shown');
                     ui.system2.classList.remove('shown');
                     // if(ui.chessinfo){
                     //     ui.chessinfo.classList.remove('zoomed');
                     // }
                  }
               }
               if (_status.tempunpop) {
                  _status.tempunpop = false;
               }
               else {
                  game.closePopped();
               }
               if (_status.event.custom && _status.event.custom.add.window) {
                  _status.event.custom.add.window(clicked);
               }
            },
            toggle: function () {
               if (_status.dragged) return;
               if (this.parentNode.classList.contains('disabled')) return;
               _status.tempunpop = true;
               if (this.link) {
                  this.link = false;
                  this.classList.remove('on');
                  if (this.additionalCommand) this.additionalCommand(false, this.parentNode);
               }
               else {
                  this.link = true;
                  this.classList.add('on');
                  if (this.additionalCommand) this.additionalCommand(true, this.parentNode);
               }
            },
            editor: function () {
               if (_status.dragged) return;
               if (_status.editing) return;
               _status.clicked = true;
               this.innerHTML = '';
               _status.editing = this;
               if (this.additionalCommand) this.additionalCommand(this);
            },
            switcher: function () {
               if (_status.dragged) return;
               if (this.parentNode.classList.contains('disabled')) return;
               if (_status.choosing) return;
               _status.clicked = true;
               _status.tempunpop = true;
               this.previousSibling.hide();
               var node = ui.create.div('.switcher', this.parentNode).animate('start');
               for (var i = 0; i < this.choice.length; i++) {
                  var choice = ui.create.div('.pointerdiv', node);
                  choice.innerHTML = get.translation(this.choice[i]);
                  choice.link = this.choice[i];
                  choice.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.choice);
               }
               // this.parentNode.style.height=(node.offsetHeight)+'px';
               _status.choosing = this;
               if (!_status.choosing.expand) {
                  _status.choosing.expand = true;
                  setTimeout(function () {
                     _status.choosing.expand = false;
                  }, 500);
               }
            },
            choice: function () {
               if (_status.dragged) return;
               if (!_status.choosing) return;
               _status.choosing.link = this.link;
               _status.choosing.innerHTML = get.translation(this.link);
               this.parentNode.parentNode.style.height = '';
               this.parentNode.delete();
               _status.choosing.previousSibling.show();
               delete _status.choosing;
               if (this.parentNode.parentNode.querySelector('.toggle').additionalCommand) {
                  this.parentNode.parentNode.querySelector('.toggle').additionalCommand(this.link, this.parentNode.parentNode);
               }
            },
            button: function () {
               if (_status.dragged) return;
               if (_status.clicked) return;
               if (_status.tempNoButton) return;
               if (_status.draggingtouchdialog) return;
               if (this.classList.contains('noclick')) return;
               if (_status.justdragged) return;
               _status.clicked = true;
               var custom = _status.event.custom;
               if (custom && custom.replace.button) {
                  custom.replace.button(this);
                  return;
               }
               if (!_status.event.isMine()) return;
               if (this.classList.contains('selectable') == false) return;
               if (this.classList.contains('selected')) {
                  ui.selected.buttons.remove(this);
                  this.classList.remove('selected');
                  if (_status.multitarget || _status.event.complexSelect) {
                     game.uncheck();
                     game.check();
                  }
               }
               else {
                  this.classList.add('selected');
                  ui.selected.buttons.add(this);
               }
               if (custom.add.button) {
                  custom.add.button();
               }
               game.check();
            },
            touchintro: function () {
               var rect = this.getBoundingClientRect();
               ui.click.touchpop();
               ui.click.intro.call(this, {
                  clientX: rect.left + 18,
                  clientY: rect.top + 12
               });
               _status.clicked = false;
            },
            /**
             * 卡牌点击事件
             * @callback
             */
            card: function () {
               delete this._waitingfordrag;
               if (_status.dragged) return;
               if (_status.clicked) return;
               if (ui.intro) return;
               _status.clicked = true;
               if (this.parentNode && (this.parentNode.classList.contains('judges') || this.parentNode.classList.contains('marks'))) {
                  var rect = this.getBoundingClientRect();
                  ui.click.touchpop();
                  ui.click.intro.call(this, {
                     clientX: rect.left + 18,
                     clientY: rect.top + 12
                  });
                  _status.clicked = false;
                  return;
               }
               var custom = _status.event.custom;
               if (custom && custom.replace.card) {
                  custom.replace.card(this);
                  return;
               }
               if (this.classList.contains('selectable') == false) return;
               if (this.classList.contains('selected')) {
                  ui.selected.cards.remove(this);
                  if (_status.multitarget || _status.event.complexSelect) {
                     game.uncheck();
                     game.check();
                  }
                  else {
                     this.classList.remove('selected');
                     this.updateTransform();
                  }
               }
               else {
                  ui.selected.cards.add(this);
                  this.classList.add('selected');
                  this.updateTransform(true);
               }
               if (game.chess && get.config('show_range') && !_status.event.skill && this.classList.contains('selected') &&
                  _status.event.isMine() && _status.event.name == 'chooseToUse') {
                  var player = _status.event.player;
                  var range = get.info(this).range;
                  if (range) {
                     if (typeof range.attack === 'number') {
                        player.createRangeShadow(Math.min(8, player.getAttackRange(true) + range.attack - 1));
                     }
                     else if (typeof range.global === 'number') {
                        player.createRangeShadow(Math.min(8, player.getGlobalFrom() + range.global));
                     }
                  }
               }
               if (custom.add.card) {
                  custom.add.card();
               }
               game.check();

               if (lib.config.popequip && get.is.phoneLayout() &&
                  arguments[0] != 'popequip' && ui.arena && ui.arena.classList.contains('selecting') &&
                  this.parentNode && this.parentNode.classList.contains('popequip')) {
                  var rect = this.getBoundingClientRect();
                  ui.click.touchpop();
                  ui.click.intro.call(this.parentNode, {
                     clientX: rect.left + 18,
                     clientY: rect.top + 12
                  });
               }
            },
            avatar: function () {
               if (!lib.config.doubleclick_intro) return;
               if (this.playerEle.isUnseen(0)) return;
               if (!lib.character[this.playerEle.name]) return;
               if (!ui.menuContainer) return;
               var avatar = this;
               var player = this.playerEle;
               if (!game.players.contains(player) && !game.dead.contains(player)) return;
               if (!this._doubleClicking) {
                  this._doubleClicking = true;
                  setTimeout(function () {
                     avatar._doubleClicking = false;
                  }, 500);
                  return;
               }
               // ui.click.skin(this,player.name);
               game.pause2();
               ui.click.charactercard(player.name, null, null, true, this);
            },
            avatar2: function () {
               if (!lib.config.doubleclick_intro) return;
               if (this.playerEle.classList.contains('unseen2')) return;
               if (!lib.character[this.playerEle.name2]) return;
               if (!ui.menuContainer) return;
               var avatar = this;
               var player = this.playerEle;
               if (!game.players.contains(player) && !game.dead.contains(player)) return;
               if (!this._doubleClicking) {
                  this._doubleClicking = true;
                  setTimeout(function () {
                     avatar._doubleClicking = false;
                  }, 500);
                  return;
               }
               // ui.click.skin(this,player.name2);
               game.pause2();
               ui.click.charactercard(player.name2, null, null, true, this);
            },
            connectroom: function (e) {
               if (_status.dragged) return;
               if (_status.clicked) return;
               if (ui.intro) return;
               if (this.roomfull) {
                  alert('房间已满');
               }
               else if (this.roomgaming && !game.onlineID) {
                  if (this.config && this.config.observe) {
                     alert('房间暂时不可旁观');
                  }
                  else {
                     alert('房间不允许旁观');
                  }
               }
               else if (!this.roomempty && this.version != lib.versionOL) {
                  if (this.version > lib.versionOL) {
                     alert('加入失败：你的游戏版本过低');
                  }
                  else {
                     alert('加入失败：房主的游戏版本过低');
                  }
               }
               else {
                  if (!_status.enteringroom) {
                     _status.enteringroom = true;
                     _status.enteringroomserver = this.serving;
                     game.send('server', 'enter', this.key, get.connectNickname(), lib.config.connect_avatar);
                  }
               }
            },
            player: function () {
               return ui.click.target.apply(this, arguments);
            },
            target: function (e) {
               if (_status.dragged) return;
               if (_status.clicked) return;
               if (ui.intro) return;
               if (this.classList.contains('connect')) {
                  if (game.online) {
                     if (game.onlinezhu) {
                        if (!this.playerid && game.connectPlayers) {
                           if (['versus', 'doudizhu', 'longlaoguan'].contains(lib.configOL.mode)) return;
                           if (lib.configOL.mode == 'identity' && lib.configOL.identity_mode == 'zhong') return;
                           if (!this.classList.contains('unselectable2') && lib.configOL.number <= 2) return;
                           this.classList.toggle('unselectable2')
                           if (this.classList.contains('unselectable2')) {
                              lib.configOL.number--;
                           }
                           else {
                              lib.configOL.number++;
                           }
                           game.send('changeNumConfig', lib.configOL.number,
                              game.connectPlayers.indexOf(this), this.classList.contains('unselectable2'));
                        }
                     }
                     return;
                  }
                  if (this.playerid) {
                     if (this.ws) {
                        if (confirm('是否踢出' + this.nickname + '？')) {
                           var id = get.id();
                           this.ws.send(function (id) {
                              if (game.ws) {
                                 game.ws.close();
                                 game.saveConfig('reconnect_info');
                                 game.saveConfig('banned_info', id);
                              }
                           }, id);
                           lib.node.banned.push(id);
                        }
                     }
                  }
                  else {
                     if (['versus', 'doudizhu', 'longlaoguan', 'single'].contains(lib.configOL.mode)) return;
                     if (lib.configOL.mode == 'identity' && (lib.configOL.identity_mode == 'zhong' || lib.configOL.identity_mode == 'purple')) return;
                     if (!this.classList.contains('unselectable2') && lib.configOL.number <= 2) return;
                     this.classList.toggle('unselectable2')
                     if (this.classList.contains('unselectable2')) {
                        lib.configOL.number--;
                     }
                     else {
                        lib.configOL.number++;
                     }
                     game.send('server', 'config', lib.configOL);
                     game.updateWaiting();
                  }
                  return;
               }
               _status.clicked = true;
               var custom = _status.event.custom;
               if (custom && custom.replace.target) {
                  custom.replace.target(this, e);
                  return;
               }
               if (this.classList.contains('selectable') == false) return;
               this.unprompt();
               if (this.classList.contains('selected')) {
                  ui.selected.targets.remove(this);
                  if (_status.multitarget || _status.event.complexSelect) {
                     game.uncheck();
                     game.check();
                  }
                  else {
                     this.classList.remove('selected');
                  }
               }
               else {
                  ui.selected.targets.add(this);
                  if (_status.event.name == 'chooseTarget' || _status.event.name == 'chooseToUse' || _status.event.name == 'chooseCardTarget') {
                     var targetprompt = null;
                     if (_status.event.targetprompt) {
                        targetprompt = _status.event.targetprompt;
                     }
                     else if (_status.event.skill && !get.info(_status.event.skill).viewAs) {
                        targetprompt = get.info(_status.event.skill).targetprompt;
                     }
                     else if (_status.event.name == 'chooseToUse') {
                        var currentcard = get.card();
                        if (currentcard) {
                           targetprompt = get.info(currentcard).targetprompt;
                        }
                     }
                     if (targetprompt) {
                        if (Array.isArray(targetprompt)) {
                           targetprompt = targetprompt[Math.min(targetprompt.length - 1, ui.selected.targets.indexOf(this))];
                        }
                        else if (typeof targetprompt == 'function') {
                           targetprompt = targetprompt(this);
                        }
                        if (targetprompt && typeof targetprompt == 'string') {
                           this.prompt(targetprompt);
                        }
                     }
                  }
                  this.classList.add('selected');
               }
               if (custom.add.target) {
                  custom.add.target();
               }
               game.check();
            },
            control2: function () {
               if (this.childNodes.length == 1 && !this._doubleclick) {
                  ui.click.control.call(this.firstChild);
               }
            },
            control: function () {
               if (_status.dragged) return;
               if (ui.control.classList.contains('hidden')) return;
               var node = this.parentNode;
               if (node) {
                  if (node._doubleclick) {
                     return;
                  }
                  else {
                     node._doubleclick = true;
                     setTimeout(function () {
                        node._doubleclick = false;
                     }, 500);
                  }
                  if (node.classList.contains('hidden')) return;
                  if (node.classList.contains('removing')) return;
                  if (node.classList.contains('disabled')) return;
               }
               if (ui.intro) {
                  ui.intro.close();
                  delete ui.intro;
               }
               _status.clicked = true;
               if (this.parentNode.custom) {
                  this.parentNode.custom(this.link, this);
                  return;
               }
               if (this.link == 'ok') {
                  ui.click.ok(this);
               }
               else if (this.link == 'cancel') {
                  ui.click.cancel(this);
               }
               else {
                  _status.event.result = {
                     buttons: ui.selected.buttons.slice(0),
                     cards: ui.selected.cards.slice(0),
                     targets: ui.selected.targets.slice(0),
                     control: this.link,
                     links: get.links(ui.selected.buttons)
                  };
                  if (this.parentNode.close != false) {
                     game.uncheck();
                     this.parentNode.close();
                  }
                  game.resume();
               }
            },
            dialogcontrol: function () {
               _status.event.result = {
                  buttons: ui.selected.buttons.slice(0),
                  cards: ui.selected.cards.slice(0),
                  targets: ui.selected.targets.slice(0),
                  control: this.link,
                  links: get.links(ui.selected.buttons)
               };
               game.resume();
            },
            skill: function (skill) {
               var info = get.info(skill);
               var Evt = _status.event;
               Evt.backup(skill);
               if (info.filterCard && info.discard != false && info.lose != false && !info.viewAs) {
                  var cards = Evt.player.getCards(Evt.position);
                  for (var i = 0; i < cards.length; i++) {
                     if (!lib.filter.cardDiscardable(cards[i], Evt.player)) {
                        cards[i].uncheck('useSkill');
                     }
                  }
               }
               if (typeof Evt.skillDialog == 'object') {
                  Evt.skillDialog.close();
               }
               if (Evt.isMine()) {
                  Evt.skillDialog = true;
               }
               game.uncheck();
               game.check();
               if (Evt.skillDialog) {
                  var str = get.translation(skill);
                  if (info.prompt) {
                     var str2;
                     if (typeof info.prompt == 'function') {
                        str2 = info.prompt(Evt);
                     }
                     else {
                        str2 = info.prompt;
                     }
                     Evt.skillDialog = ui.create.dialog(str, '<div><div style="width:100%;text-align:center">' + str2 + '</div></div>');
                     if (info.longprompt) {
                        Evt.skillDialog.forcebutton = true;
                        ui.update();
                     }
                  }
                  else if (info.promptfunc) {
                     Evt.skillDialog = ui.create.dialog(str, '<div><div style="width:100%">' + info.promptfunc(Evt, Evt.player) + '</div></div>');
                  }
                  else if (lib.dynamicTranslate[skill] || lib.translate[skill + '_info']) {
                     Evt.skillDialog = ui.create.dialog(str, '<div><div style="width:100%">' + get.skillInfoTranslation(skill, _status.event.player) + '</div></div>');
                  }
               }
            },
            /**
             * 玩家/ai确认选择的函数
             * @function
             * @param {?HTMLDivElement} node 调用确认函数的节点，如果不为null，对`node`的父节点调用`close()`函数
             */
            ok: function (node) {
               var Evt = _status.event;
               if (Evt.custom && Evt.custom.replace.confirm) {
                  Evt.custom.replace.confirm(true); return;
               }
               Evt.result = {
                  buttons: ui.selected.buttons.slice(0),//选择的按钮
                  cards: ui.selected.cards.slice(0),//选择的牌
                  targets: ui.selected.targets.slice(0),//选择的目标
                  confirm: 'ok',//确认
                  bool: true,
                  links: get.links(ui.selected.buttons)
               };
               if (node) {
                  node.parentNode.close();
               }
               if (Evt.skill) {
                  Evt.result.skill = Evt.skill;
                  if (typeof get.info(Evt.skill).viewAs == 'function') Evt.result.card = get.info(Evt.skill).viewAs(Evt.result.cards, Evt.player);
                  else Evt.result.card = get.copy(get.info(Evt.skill).viewAs);
                  if (Evt.result.cards.length == 1 && Evt.result.card) {
                     Evt.result.card.suit = get.suit(Evt.result.cards[0]);
                     Evt.result.card.number = get.number(Evt.result.cards[0]);
                  }
                  if (Evt.skillDialog && get.objtype(Evt.skillDialog) == 'div') {
                     Evt.skillDialog.close();
                  }
                  var cards = Evt.player.getCards('hej');
                  for (var i = 0; i < cards.length; i++) {
                     cards[i].recheck('useSkill');
                  }
                  Evt.restore();
               }
               else if (Evt.name == 'chooseToUse' || Evt.name == 'chooseToRespond') {
                  Evt.result.card = get.autoViewAs(Evt.result.cards[0]);
               }
               if (ui.skills) ui.skills.close();
               if (ui.skills2) ui.skills2.close();
               if (ui.skills3) ui.skills3.close();
               game.uncheck();
               if (Evt.custom.add.confirm) {
                  Evt.custom.add.confirm(true);
               }
               game.resume();
            },
            /**
             * 托管按钮点击函数
             * @function
             * @param {?HTMLDivElement} node 调用确认函数的节点，如果不为null，对`node`的父节点调用`close()`函数
             */
            cancel: function (node) {
               var Evt = _status.event;
               if (Evt.custom.replace.confirm) {
                  Evt.custom.replace.confirm(false); return;
               }
               if (Evt.skill && !Evt.norestore) {
                  if (Evt.skillDialog && get.objtype(Evt.skillDialog) == 'div') {
                     Evt.skillDialog.close();
                  }
                  if (typeof Evt.dialog == 'string' && Evt.isMine()) {
                     Evt.dialog = ui.create.dialog(Evt.dialog);
                  }
                  if (_status.event.type == 'phase' && ui.confirm) {
                     ui.confirm.classList.add('removing');
                  }
                  // ui.control.animate('nozoom',100);
                  Evt.restore();
                  var cards = Evt.player.getCards('hej');
                  for (var i = 0; i < cards.length; i++) {
                     cards[i].recheck('useSkill');
                  }
                  game.uncheck();
                  game.check();
                  return;
               }
               Evt.result = {
                  confirm: 'cancel',
                  bool: false
               };
               if (node) {
                  node.parentNode.close();
               }
               if (ui.skills) ui.skills.close();
               if (ui.skills2) ui.skills2.close();
               if (ui.skills3) ui.skills3.close();
               game.uncheck();
               if (Evt.custom.add.confirm) {
                  Evt.custom.add.confirm(true);
               }
               game.resume();
            },
            logv: function (e) {
               if (_status.currentlogv) {
                  if (_status.currentlogv == this) return;
                  if (_status.logvtimeout) {
                     clearTimeout(_status.logvtimeout);
                  }
                  _status.logvtimeout = setTimeout(() => {
                     if (!_status.currentlogv) {
                        _status.currentlogv = this;
                        ui.click.intro.call(this, e);
                     }
                  }, 200);
                  this.logvtimeout = _status.logvtimeout;
               }
               else {
                  _status.currentlogv = this;
                  ui.click.intro.call(this, e);
               }
            },
            logvleave: function () {
               if (_status.currentlogv == this) {
                  setTimeout(function () {
                     delete _status.currentlogv;
                  }, 150);
               }
               if (this.logvtimeout) {
                  clearTimeout(this.logvtimeout);
                  if (_status.logvtimeout == this.logvtimeout) {
                     delete _status.logvtimeout;
                  }
                  delete this.logvtimeout;
               }
            },
            charactercard: function (name, sourcenode, noedit, resume, avatar) {
               if (_status.dragged) return;
               if (lib.config.theme != 'simple') {
                  ui.window.classList.add('shortcutpaused');
                  ui.menuContainer.classList.add('forceopaque');
               }
               else {
                  ui.window.classList.add('systempaused');
                  ui.menuContainer.classList.add('transparent2');
               }
               if (lib.config.blur_ui) {
                  ui.arena.classList.add('blur');
                  ui.system.classList.add('blur');
                  ui.menuContainer.classList.add('blur');
               }
               var layer = ui.create.div('.popup-container');
               var clicklayer = function (e) {
                  if (_status.touchpopping) return;
                  if (_status.dragged) return;
                  ui.window.classList.remove('shortcutpaused');
                  ui.window.classList.remove('systempaused');
                  ui.menuContainer.classList.remove('forceopaque');
                  ui.menuContainer.classList.remove('transparent2');
                  ui.arena.classList.remove('blur');
                  ui.system.classList.remove('blur');
                  ui.menuContainer.classList.remove('blur');
                  this.delete();
                  e.stopPropagation();
                  if (resume) game.resume2();
                  return false;
               }
               var uiintro = ui.create.div('.menubg.charactercard', layer);
               var playerbg = ui.create.div('.menubutton.large.ava', uiintro);
               var bg = ui.create.div('.avatar', playerbg, function () {
                  if (changeskinfunc) {
                     changeskinfunc();
                  }
               }).setBackground(name, 'character');
               var changeskinfunc = null;
               var nameskin = name;
               var nameskin2 = name;
               var gzbool = false;
               if (nameskin.indexOf('gz_shibing') == 0) {
                  nameskin = nameskin.slice(3, 11);
               }
               else if (nameskin.indexOf('gz_') == 0) {
                  nameskin = nameskin.slice(3);
                  gzbool = true;
               }
               var changeskin = function () {
                  var node = ui.create.div('.changeskin', '可换肤', playerbg);
                  var avatars = ui.create.div('.avatars', playerbg);
                  changeskinfunc = function () {
                     playerbg.classList.add('scroll');
                     if (node._created) {
                        return;
                     }
                     node._created = true;
                     var createButtons = function (num) {
                        if (!num) return;
                        if (num >= 4) {
                           avatars.classList.add('scroll');
                           if (lib.config.touchscreen) {
                              lib.setScroll(avatars);
                           }
                        }
                        for (var i = 0; i <= num; i++) {
                           var button = ui.create.div(avatars, function () {
                              playerbg.classList.remove('scroll');
                              if (this._link) {
                                 lib.config.skin[nameskin] = this._link;
                                 bg.style.backgroundImage = this.style.backgroundImage;
                                 if (sourcenode) sourcenode.style.backgroundImage = this.style.backgroundImage;
                                 if (avatar) avatar.style.backgroundImage = this.style.backgroundImage;
                                 game.saveConfig('skin', lib.config.skin);
                              }
                              else {
                                 delete lib.config.skin[nameskin];
                                 if (gzbool && lib.character[nameskin2][4].contains('gzskin') && lib.config.mode_config.guozhan.guozhanSkin) {
                                    bg.setBackground(nameskin2, 'character');
                                    if (sourcenode) sourcenode.setBackground(nameskin2, 'character');
                                    if (avatar) avatar.setBackground(nameskin2, 'character');
                                 }
                                 else {
                                    bg.setBackground(nameskin, 'character');
                                    if (sourcenode) sourcenode.setBackground(nameskin, 'character');
                                    if (avatar) avatar.setBackground(nameskin, 'character');
                                 }
                                 game.saveConfig('skin', lib.config.skin);
                              }
                           });
                           button._link = i;
                           if (i) {
                              button.setBackgroundImage('image/skin/' + nameskin + '/' + i + '.jpg');
                           }
                           else {
                              if (gzbool && lib.character[nameskin2][4].contains('gzskin') && lib.config.mode_config.guozhan.guozhanSkin) button.setBackground(nameskin2, 'character', 'noskin');
                              else button.setBackground(nameskin, 'character', 'noskin');
                           }
                        }
                     };
                     var num = 1;
                     var loadImage = function () {
                        var img = new Image();
                        img.onload = function () {
                           num++;
                           loadImage();
                        }
                        img.onerror = function () {
                           num--;
                           createButtons(num);
                        }
                        img.src = lib.assetURL + 'image/skin/' + nameskin + '/' + num + '.jpg';
                     }
                     if (lib.config.change_skin) {
                        loadImage();
                     }
                     else {
                        createButtons(lib.skin[nameskin]);
                     }
                  };
               };
               if (lib.config.change_skin) {
                  var img = new Image();
                  img.onload = changeskin;
                  img.src = lib.assetURL + 'image/skin/' + nameskin + '/1.jpg';
               }
               else if (lib.config.debug && lib.skin[nameskin]) {
                  changeskin();
               }
               var ban = ui.create.div('.menubutton.large.ban.character', uiintro, '禁用', function (e) {
                  if (this.classList.contains('unselectable')) return;
                  if (typeof noedit == 'string') {
                     this.classList.toggle('active');
                     var bannedname = noedit + '_banned';
                     if (!lib.config[bannedname]) {
                        lib.config[bannedname] = [];
                     }
                     if (this.classList.contains('active')) {
                        lib.config[bannedname].add(name);
                     }
                     else {
                        lib.config[bannedname].remove(name);
                     }
                     game.saveConfig(bannedname, lib.config[bannedname]);
                     ban.updateBanned();
                  }
                  else {
                     ui.click.touchpop();
                     ui.click.intro.call(this, e);
                     _status.clicked = true;
                  }
               });
               ban.link = name;
               ban._banning = 'offline';
               ban.updateBanned = function () {
                  if (noedit === true) return;
                  if (lib.config[get.mode() + '_banned'] && lib.config[get.mode() + '_banned'].contains(name)) {
                     ban.classList.add('active');
                  }
                  else {
                     ban.classList.remove('active');
                  }
                  if (sourcenode && sourcenode.updateBanned) {
                     sourcenode.updateBanned();
                  }
               };
               ban.updateBanned();
               var fav = ui.create.div('.menubutton.large.fav', uiintro, '收藏', function () {
                  if (this.classList.contains('unselectable')) return;
                  this.classList.toggle('active');
                  if (this.classList.contains('active')) {
                     lib.config.favouriteCharacter.add(name);
                  }
                  else {
                     lib.config.favouriteCharacter.remove(name);
                  }
                  game.saveConfig('favouriteCharacter', lib.config.favouriteCharacter);
               });
               if (noedit === true) {
                  fav.classList.add('unselectable');
                  ban.classList.add('unselectable');
               }
               else if (lib.config.favouriteCharacter.contains(name)) {
                  fav.classList.add('active');
               }
               var intro = ui.create.div('.charactercontainer', uiintro);
               if (get.characterIntro(name).length) {
                  var intro0 = ui.create.div('.characterintro', get.characterIntro(name), intro);
               }
               if (get.characterTag(name).length) {
                  var intro1 = ui.create.div('.characterintro.intro1', get.characterTag(name), intro);
               }
               var intro2 = ui.create.div('.characterintro.intro2', intro);
               var list = get.character(name, 3) || [];
               var skills = ui.create.div('.characterskill', intro);
               if (lib.config.touchscreen) {
                  lib.setScroll(intro);
                  lib.setScroll(intro2);
                  lib.setScroll(skills);
               }

               if (lib.config.mousewheel) {
                  skills.onmousewheel = ui.click.mousewheel;
               }
               var clickSkill = function (e) {
                  var current = this.parentNode.querySelector('.active');
                  if (current) {
                     current.classList.remove('active');
                  }
                  this.classList.add('active');
                  intro2.innerHTML = '<span style="font-weight:bold;margin-right:5px">' + get.translation(this.link) + '</span>' + get.skillInfoTranslation(this.link);
                  var info = get.info(this.link);
                  var skill = this.link;
                  var playername = this.linkname;
                  var skillnode = this;
                  if (info.derivation) {
                     var derivation = info.derivation;
                     if (typeof derivation == 'string') {
                        derivation = [derivation];
                     }
                     for (var i = 0; i < derivation.length; i++) {
                        intro2.innerHTML += '<br><br><span style="font-weight:bold;margin-right:5px">' + get.translation(derivation[i]) + '</span>' + get.skillInfoTranslation(derivation[i]);
                     }
                  }
                  if (info.alter) {
                     intro2.innerHTML += '<br><br><div class="hrefnode skillversion"></div>';
                     var skillversionnode = intro2.querySelector('.hrefnode.skillversion');
                     if (lib.config.vintageSkills.contains(skill)) {
                        skillversionnode.innerHTML = '切换至新版';
                     }
                     else {
                        skillversionnode.innerHTML = '切换至旧版';
                     }
                     skillversionnode.listen(function () {
                        if (lib.config.vintageSkills.contains(skill)) {
                           lib.config.vintageSkills.remove(skill);
                           lib.translate[skill + '_info'] = lib.translate[skill + '_info_alter'];
                        }
                        else {
                           lib.config.vintageSkills.push(skill);
                           lib.translate[skill + '_info'] = lib.translate[skill + '_info_origin'];
                        }
                        game.saveConfig('vintageSkills', lib.config.vintageSkills);
                        clickSkill.call(skillnode, 'init');
                     });
                  }
                  if (lib.config.background_speak && e !== 'init') {
                     var audioname = this.link;
                     if (info.audioname2 && info.audioname2[playername]) {
                        audioname = info.audioname2[playername];
                        info = lib.skill[audioname];
                     }
                     var audioinfo = info.audio;
                     var getIndex = (i) => {
                        if (typeof this.audioindex != 'number') {
                           this.audioindex = i;
                        }
                        this.audioindex++;
                        if (this.audioindex > i) {
                           this.audioindex = 1;
                        }
                        return this.audioindex;
                     };
                     if (typeof audioinfo == 'string') {
                        if (audioinfo.indexOf('ext:') == 0) {
                           audioinfo = audioinfo.split(':');
                           if (audioinfo.length == 3) {
                              if (audioinfo[2] == 'true') {
                                 game.playAudio('..', 'extension', audioinfo[1], audioname);
                              }
                              else {
                                 audioinfo[2] = parseInt(audioinfo[2]);
                                 if (audioinfo[2]) {
                                    game.playAudio('..', 'extension', audioinfo[1], audioname + getIndex(audioinfo[2]));
                                 }
                              }
                           }
                           return;
                        }
                        else {
                           audioname = audioinfo;
                           if (lib.skill[audioinfo]) {
                              audioinfo = lib.skill[audioinfo].audio;
                           }
                        }
                     }
                     else if (Array.isArray(audioinfo)) {
                        audioname = audioinfo[0];
                        audioinfo = audioinfo[1];
                     }
                     if (typeof audioinfo == 'number') {
                        if (Array.isArray(info.audioname) && info.audioname.contains(playername)) audioname = audioname + '_' + playername;
                        game.playAudio('skill', audioname + getIndex(audioinfo));
                     }
                     else if (audioinfo) {
                        if (Array.isArray(info.audioname) && info.audioname.contains(playername)) audioname = audioname + '_' + playername;
                        game.playAudio('skill', audioname);
                     }
                     else if ( true && info.audio !== false) {
                        if (Array.isArray(info.audioname) && info.audioname.contains(playername)) audioname = audioname + '_' + playername;
                        game.playSkillAudio(audioname, getIndex(2));
                     }
                  }
               }
               var initskill = false;
               for (var i = 0; i < list.length; i++) {
                  if (!get.info(list[i]) || get.info(list[i]).nopop) continue;
                  if (!lib.translate[list[i]] || !lib.translate[list[i] + '_info']) continue;
                  var skilltrans = get.translation(list[i]);
                  if (skilltrans.indexOf('&nbsp;') == 0) {
                     skilltrans = skilltrans.slice(6);
                  }
                  var current = ui.create.div('.menubutton.large', skills, clickSkill, skilltrans);
                  current.link = list[i];
                  current.linkname = name;
                  if (!initskill) {
                     initskill = true;
                     clickSkill.call(current, 'init');
                  }
               }

               uiintro.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.touchpop);
               layer.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', clicklayer);
               ui.window.appendChild(layer);
            },
            /**
             * 详细信息弹窗
             * @function
             * @param {(MouseEvent|TouchEvent)} e 
             * @returns {(undefined|false|HTMLDivElement)}
             */
            intro: function (e) {
               if (_status.dragged) return;
               _status.clicked = true;
               if (this.classList.contains('player') && !this.name) {
                  return;
               }
               if (this.parentNode == ui.historybar) {
                  if (ui.historybar.style.zIndex == '22') {
                     if (_status.removePop) {
                        if (_status.removePop(this) == false) return;
                     }
                     else {
                        return;
                     }
                  }
                  ui.historybar.style.zIndex = 22;
               }
               var uiintro;
               if (this.classList.contains('card') && this.parentNode &&
                  this.parentNode.classList.contains('equips') && get.is.phoneLayout() &&
                  !get.is.mobileMe(this.parentNode.parentNode)) {
                  uiintro = get.nodeintro(this.parentNode.parentNode, false, e);
               }
               uiintro = uiintro || get.nodeintro(this, false, e);
               if (!uiintro) return;
               uiintro.classList.add('popped');
               uiintro.classList.add('static');
               ui.window.appendChild(uiintro);
               var layer = ui.create.div('.poplayer', ui.window);
               var clicklayer = function (e) {
                  if (_status.touchpopping) return;
                  delete ui.throwEmotion;
                  delete _status.removePop;
                  uiintro.delete();
                  this.remove();
                  ui.historybar.style.zIndex = '';
                  delete _status.currentlogv;
                  if (!ui.arena.classList.contains('menupaused') && !uiintro.noresume) game.resume2();
                  if (e && e.stopPropagation) e.stopPropagation();
                  if (uiintro._onclose) {
                     uiintro._onclose();
                  }
                  return false;
               }
               layer.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', clicklayer);
               if (!lib.config.touchscreen) layer.oncontextmenu = clicklayer;
               if (this.parentNode == ui.historybar && lib.config.touchscreen) {
                  var rect = this.getBoundingClientRect();
                  e = { clientX: 0, clientY: rect.top + 30 };
               }
               lib.placePoppedDialog(uiintro, e);
               if (this.parentNode == ui.historybar) {
                  if (lib.config.show_history == 'right') {
                     uiintro.style.left = (ui.historybar.offsetLeft - 230) + 'px';
                  }
                  else {
                     uiintro.style.left = (ui.historybar.offsetLeft + 60) + 'px';
                  }
               }
               uiintro.style.zIndex = 21;
               var clickintro = function () {
                  if (_status.touchpopping) return;
                  delete _status.removePop;
                  layer.remove();
                  this.delete();
                  ui.historybar.style.zIndex = '';
                  delete _status.currentlogv;
                  if (!ui.arena.classList.contains('menupaused') && !uiintro.noresume) game.resume2();
                  if (uiintro._onclose) {
                     uiintro._onclose();
                  }
               };
               var currentpop = this;
               _status.removePop = function (node) {
                  if (node == currentpop) return false;
                  layer.remove();
                  uiintro.delete();
                  delete _status.removePop;
                  return true;
               };
               if (uiintro.clickintro) {
                  uiintro.listen(function () {
                     _status.clicked = true;
                  });
                  uiintro._clickintro = clicklayer;
               }
               else if (!lib.config.touchscreen) {
                  uiintro.addEventListener('mouseleave', clickintro);
                  uiintro.addEventListener('click', clickintro);
               }
               else if (uiintro.touchclose) {
                  uiintro.listen(clickintro);
               }
               uiintro._close = clicklayer;

               game.pause2();
               return uiintro;
            },
            intro2: function () {
               if (ui.intro) {
                  ui.intro.close();
                  if (ui.intro.source == this) {
                     delete ui.intro;
                     ui.control.show();
                     game.resume2();
                     return;
                  }
               }
            },
            /**
             * 托管按钮点击函数
             * @function
             */
            auto: function () {
               if (ui.auto.classList.contains('hidden') && arguments[0] !== 'forced') return;
               if (_status.paused2) return;
               ui.click.shortcut(false);
               if (!_status.auto) {
                  _status.auto = true;
                  ui.auto.classList.add('glow');
                  ui.arena.classList.add('auto');

                  if (_status.imchoosing && _status.paused) {
                     if (ui.confirm) ui.confirm.close();
                     ui.control.hide();
                     if (_status.event.switchToAuto) {
                        _status.event.switchToAuto();
                     }
                     else {
                        if (_status.paused && _status.imchoosing) {
                           game.uncheck();
                           _status.event.redo();
                        }
                     }
                     game.resume();
                  }
                  else if (_status.event.switchToAuto) {
                     _status.event.switchToAuto();
                  }
                  if (game.online) {
                     game.send('auto');
                  }
                  else if (_status.connectMode) {
                     game.broadcastAll(function (player) {
                        player.setNickname(player.nickname + ' - 托管');
                     }, game.me);
                  }
               }
               else {
                  if (game.notMe) return;
                  ui.control.show();
                  _status.auto = false;
                  ui.auto.classList.remove('glow');
                  ui.arena.classList.remove('auto');

                  if (game.online) {
                     game.send('unauto');
                  }
                  else if (_status.connectMode) {
                     game.broadcastAll(function (player) {
                        player.setNickname(player.nickname);
                     }, game.me);
                  }
               }
            },
            /**
             * 无懈按钮点击函数
             * @function
             */
            wuxie: function () {
               if (this.classList.contains('hidden')) return;
               this.classList.toggle('glow');
               if (this.classList.contains('glow') && _status.event.type == 'wuxie' &&
                  _status.event.isMine() && ui.confirm && _status.imchoosing) {
                  ui.click.cancel(ui.confirm.lastChild);
               }
            },
            tempnowuxie: function () {
               if (this.classList.contains('hidden')) return;
               this.classList.toggle('glow');
               if (this.classList.contains('glow') && _status.event.type == 'wuxie' &&
                  _status.event.isMine() && ui.confirm && _status.imchoosing) {
                  var triggerevent = _status.event.getTrigger();
                  if (triggerevent && this._origin == triggerevent.parent.id) {
                     if (triggerevent.targets && triggerevent.num == triggerevent.targets.length - 1) {
                        this.close();
                     }
                  }
                  ui.click.cancel(ui.confirm.lastChild);
               }
            },
            pause: function () {
               if (_status.paused2 || _status.pausing || _status.nopause) return;
               if (!_status.video) {
                  if (ui.pause.classList.contains('hidden')) return;
                  if (!_status.gameStarted) return;
               }
               ui.system.hide();
               game.pause2();
               var node = ui.create.pause();
               if (!node) return;
               node.animate('start');
               ui.sidebar3.innerHTML = '';
               if (lib.config.show_discardpile) {
                  for (var i = 0; i < ui.discardPile.childNodes.length; i++) {
                     var div = ui.create.div(ui.sidebar3);
                     div.innerHTML = get.translation(ui.discardPile.childNodes[i]);
                     ui.sidebar3.insertBefore(div, ui.sidebar3.firstChild);
                  }
               }
               node.appendChild(ui.sidebar);
               node.appendChild(ui.sidebar3);
               ui.historybar.classList.add('paused');
               ui.arena.classList.add('paused');
               ui.window.classList.add('touchinfohidden');
               ui.time.hide();
               if (game.onpause) {
                  game.onpause();
               }
            },
            resume: function (e) {
               if (_status.pausing) return;
               if (_status.dragged) return;
               if (_status.clicked) return;
               this.delete();
               ui.system.show();
               ui.time.show();
               ui.historybar.classList.remove('paused');
               ui.arena.classList.remove('paused');
               ui.window.classList.remove('touchinfohidden');
               game.resume2();
               e.stopPropagation();
               if (game.onresume) {
                  game.onresume();
               }
               return false;
            },
            config: function () {
               if (!ui.click.configMenu) return;
               if (_status.paused2) _status.config2 = false;
               else _status.config2 = true;

               _status.clicked = true;
               game.pause2();
               ui.click.configMenu();
               ui.system1.classList.remove('shown');
               ui.system2.classList.remove('shown');
            },
            swap: function () {
               if (_status.dragged) return;
               if (this.classList.contains('dead')) return;
               if (_status.over) return;
               if (ui.auto) ui.auto.show();
               if (ui.wuxie) ui.wuxie.show();
               game.swapPlayer(this);
            },
            mousewheel: function (evt) {
               if (this.firstChild && this.firstChild.classList.contains('handcards') &&
                  !this.classList.contains('scrollh')) return;
               var node = this;
               var num = this._scrollnum || 6;
               var speed = this._scrollspeed || 16;
               clearInterval(node.interval);
               if (evt.detail > 0 || evt.wheelDelta < 0) {
                  node.interval = setInterval(function () {
                     if (num-- && Math.abs(node.scrollLeft + node.clientWidth - node.scrollWidth) > 0) {
                        node.scrollLeft += speed;
                     }
                     else {
                        clearInterval(node.interval);
                     }
                  }, 16);
               }
               else {
                  node.interval = setInterval(function () {
                     if (num-- && node.scrollLeft > 0) {
                        node.scrollLeft -= speed;
                     }
                     else {
                        clearInterval(node.interval);
                     }
                  }, 16);
               }
            },
            touchStart: function (e) {
               this.startX = e.touches[0].clientX / game.documentZoom;
               this.startY = e.touches[0].clientY / game.documentZoom;
               _status.dragged = false;
            },
            dialogtouchStart: function (e) {
               ui.click.touchStart.call(this, e);
               _status.dialogtouched = true;
            },
            touchScroll: function (e) {
               if (_status.mousedragging) return;
               if (_status.draggingtouchdialog) return;
               if (!_status.dragged) {
                  if (Math.abs(e.touches[0].clientX / game.documentZoom - this.startX) > 10 ||
                     Math.abs(e.touches[0].clientY / game.documentZoom - this.startY) > 10) {
                     _status.dragged = true;
                  }
               }
               if ((this == ui.handcards1Container || this == ui.handcards2Container) && !this.classList.contains('scrollh')) {
                  e.preventDefault();
               }
               else if (lib.device == 'ios' && this.scrollHeight <= this.offsetHeight + 5 && this.scrollWidth <= this.offsetWidth + 5) {
                  e.preventDefault();
               }
               else {
                  delete _status._swipeorigin;
                  e.stopPropagation();
               }
            },
            autoskill: function (bool, node) {
               var list = lib.config.autoskilllist;
               if (bool) {
                  list.remove(node.link);
               }
               else {
                  list.add(node.link);
               }
               game.saveConfig('autoskilllist', list);
            },
            skillbutton: function () {
               this.func(this.link);
            },
            autoskill2: function (e) {
               this.classList.toggle('on');
               var list = [];
               if (lib.skill[this.link].frequent) {
                  list.push(this.link);
               }
               if (lib.skill[this.link].subfrequent) {
                  for (var i = 0; i < lib.skill[this.link].subfrequent.length; i++) {
                     list.push(this.link + '_' + lib.skill[this.link].subfrequent[i]);
                  }
               }
               for (var i = 0; i < list.length; i++) {
                  if (this.classList.contains('on')) {
                     lib.config.autoskilllist.remove(list[i]);
                  }
                  else {
                     lib.config.autoskilllist.add(list[i]);
                  }
               }
               game.saveConfig('autoskilllist', lib.config.autoskilllist);
               ui.click.touchpop();
               e.stopPropagation();
            },
            hiddenskill: function (e) {
               this.classList.toggle('on');
               var hidden = lib.skill[this.link].preHidden;
               if (Array.isArray(hidden)) {
                  if (this.classList.contains('on')) {
                     _status.prehidden_skills.removeArray(hidden);
                  }
                  else {
                     _status.prehidden_skills.addArray(hidden);
                  }
               }
               if (this.classList.contains('on')) {
                  _status.prehidden_skills.remove(this.link);
               }
               else {
                  _status.prehidden_skills.add(this.link);
               }
               ui.click.touchpop();
               e.stopPropagation();
            },
            rightplayer: function (e) {
               if (this._nopup) return false;
               if (_status.clickedplayer) {
                  return false;
               }

               if (this._mouseenterdialog && this._mouseenterdialog.parentNode) {
                  this._mouseenterdialog.delete();
               }
               else {
                  ui.click.intro.call(this, e);
               }
               _status.clickedplayer = true;
               _status.clicked = false;
               ui.click.longpresscancel.call(this);
               return false;
            },
            right: function (e) {
               if (window.inSplash) return false;
               if (lib.config.touchscreen) return;
               if (_status.noright) {
                  _status.noright = false;
                  return false;
               }
               if (_status.clickedplayer) {
                  _status.clickedplayer = false;
                  return;
               }
               game.closePopped();
               switch (lib.config.right_click) {
                  case 'shortcut': ui.click.shortcut(); break;
                  case 'pause': ui.click.pause(); break;
                  case 'auto': ui.click.auto(); break;
                  case 'config': ui.click.config(); break;
               }
               e.preventDefault();
               return false;
            }
         },
         /**
          * 当前被选择的对象
          * 在游戏中非常有用的对象
          * ui.selected = {buttons: [被选择的按钮], cards: [被选择的卡牌], targets: [被选择的角色]},
          * @type {!Object}
          */
         selected: {
            buttons: [], cards: [], targets: []
         },
         /**
          * 清除残留ui
          * 例如：被使用或打出的牌，会显示并停留在画面中央，直到ui.clear将其清除
          * @function
          */
         clear: function () {
            game.addVideo('uiClear');
            var thrown = document.getElementsByClassName('thrown');
            var nodes = [];
            var i;
            for (i = 0; i < thrown.length; i++) {
               nodes.push(thrown[i]);
            }
            for (i = 0; i < nodes.length; i++) {
               if (!nodes[i].fixed) nodes[i].delete();
            }
         },
         updatec: function () {
            if (_status.noupdatec) return;
            var length = 0;
            var controls = [];
            var widths = [];
            var add = function (node, first) {
               var thiswidth = parseInt(node.style.width);
               if (thiswidth) {
                  thiswidth += 8;
                  length += thiswidth;
                  if (first) {
                     widths.unshift(thiswidth);
                  }
                  else {
                     widths.push(thiswidth);
                  }
               }
               else {
                  length += node.offsetWidth;
                  if (first) {
                     widths.unshift(node.offsetWidth);
                  }
                  else {
                     widths.push(node.offsetWidth);
                  }
               }
               if (first) {
                  controls.unshift(node);
               }
               else {
                  controls.push(node);
               }
            }
            var stayleft = null;
            for (var i = 0; i < ui.control.childNodes.length; i++) {
               if (ui.control.childNodes[i].classList.contains('removing')) continue;
               if (!stayleft && lib.config.wuxie_right && ui.control.childNodes[i].stayleft) {
                  stayleft = ui.control.childNodes[i];
               }
               else {
                  add(ui.control.childNodes[i]);
               }
            }
            if (stayleft) {
               var fullwidth = 0;
               var fullright = (game.layout == 'long' || game.layout == 'long2' || game.chess || (game.layout != 'nova' && parseInt(ui.arena.dataset.number) <= 5));
               for (var i = 0; i < widths.length; i++) {
                  fullwidth += widths[i] + 6;
                  if (get.is.phoneLayout()) fullwidth += 6;
               }
               fullwidth /= 2;
               fullwidth += stayleft.offsetWidth;
               if (get.is.phoneLayout()) {
                  fullwidth += 18;
               }
               else {
                  fullwidth += 12;
               }
               if (fullright) {
                  fullwidth += 124;
                  if ((game.layout == 'long2' || game.layout == 'nova') && ui.arena.dataset.number == '8' && get.mode() != 'boss') {
                     fullwidth += game.me.getLeft();
                  }
               }
               else {
                  fullwidth += 154;
               }
               if (game.layout != 'default' && game.layout != 'newlayout' && ui.arena.offsetWidth / 2 >= fullwidth) {
                  var current_offset = stayleft._offset;
                  if (fullright) {
                     stayleft._offset = Math.ceil(-ui.arena.offsetWidth / 2) + 135;
                     if ((game.layout == 'long2' || game.layout == 'nova') && ui.arena.dataset.number == '8' && get.mode() != 'boss') {
                        stayleft._offset += game.me.getLeft();
                     }
                  }
                  else {
                     stayleft._offset = Math.ceil(-ui.arena.offsetWidth / 2) + 165;
                  }
                  if (current_offset != stayleft._offset) {
                     stayleft.animate('controlpressdownx', 500);
                     stayleft.style.transform = 'translateX(' + stayleft._offset + 'px)';
                  }
               }
               else {
                  add(stayleft, true);
               }
            }
            if (!controls.length) return;
            var offset = -length / 2;
            var control = controls.shift();
            if (control._offset != offset) {
               control.animate('controlpressdownx', 500);
               control.style.transform = 'translateX(' + offset + 'px)';
               control._offset = offset;
            }
            while (controls.length) {
               var control = controls.shift();
               var width = widths.shift();
               offset += width + 6;
               if (get.is.phoneLayout()) {
                  offset += 6;
               }
               if (control._offset != offset) {
                  control.animate('controlpressdownx', 500);
                  control.style.transform = 'translateX(' + offset + 'px)';
                  control._offset = offset;
               }
            }
         },
         updatex: function () {
            ui.update.apply(this, arguments);
            ui.updatehl();
            for (var i = 0; i < lib.onresize.length; i++) {
               lib.onresize[i]();
            }
            var cfg = game.documentZoom / game.deviceZoom;
            ui.updated();
            game.documentZoom = cfg * game.deviceZoom;
            ui.updatez();
            delete ui._updatexr;
         },
         updatexr: function () {
            if (ui._updatexr) {
               clearTimeout(ui._updatexr);
            }
            ui._updatexr = setTimeout(ui.updatex, 500);
         },
         /**
          * 更新标记位置
          * @function
          * @param {GameCores.GameObjects.Player} player 要更新的角色
          * @param {HTMLDivElement} nodes 父节点，对其中作为标记的子节点变换位置
          * @param {?number} start 起始子节点[>=0]，从该子节点开始变换位置
          * @param {?boolean} inv 是否反向，如果为true表示反向，如果为false或未指定则默认正向；正向为X轴的正方向，如果沿Y轴位移，不做变换
          */
         updatejm: function (player, nodes, start, inv) {
            if (typeof start != 'number') {
               start = 0;
            }
            var str;
            if (get.is.mobileMe(player) || game.layout == 'default' || player.classList.contains('linked')) {
               str = 'translateX(';
               if (inv) {
                  str += '-';
               }
            }
            else {
               str = 'translateY(';
            }
            var num = 0;
            for (var i = 0; i < nodes.childElementCount; i++) {
               var node = nodes.childNodes[i];
               if (i < start) {
                  node.style.transform = '';
               }
               else if (node.classList.contains('removing')) {
                  start++;
               }
               else {
                  ui.refresh(node);
                  node.classList.remove('drawinghidden');
                  node._transform = str + ((i - start) * 28) + 'px)';
                  node.style.transform = node._transform;
               }
            }
         },
         /**
          * 更新角色标记
          * @function
          * @param {?GameCores.GameObjects.Player} player 要更新的角色，如果未指定则对全部角色更新
          */
         updatem: function (player) {
            if (player) {
               var start = 0;
               if (!player.classList.contains('linked2') || !ui.arena.classList.contains('nolink')) {
                  start = 1;
               }
               ui.updatejm(player, player.node.marks, start, get.is.mobileMe(player));
            }
            else {
               for (var i = 0; i < game.players.length; i++) {
                  ui.updatem(game.players[i]);
               }
            }
         },
         /**
          * 更新角色判定标记
          * @function
          * @param {?GameCores.GameObjects.Player} player 要更新的角色，如果未指定则对全部角色更新
          */
         updatej: function (player) {
            if (player) {
               ui.updatejm(player, player.node.judges);
            }
            else {
               for (var i = 0; i < game.players.length; i++) {
                  ui.updatej(game.players[i]);
               }
            }
         },
         updatehl: function () {
            if (!game.me) return;
            if (!ui.handcards1Container || !ui.handcards2Container) return;
            if (!ui.handcards1Container.childNodes.length) return;
            var hs1 = [], hs2 = [];
            for (var i = 0; i < ui.handcards1Container.firstChild.childElementCount; i++) {
               if (!ui.handcards1Container.firstChild.childNodes[i].classList.contains('removing')) {
                  hs1.push(ui.handcards1Container.firstChild.childNodes[i]);
               }
            }
            for (var i = 0; i < ui.handcards2Container.firstChild.childElementCount; i++) {
               if (!ui.handcards2Container.firstChild.childNodes[i].classList.contains('removing')) {
                  hs2.push(ui.handcards2Container.firstChild.childNodes[i]);
               }
            }
            var offset1, offset12 = 0;
            if (!lib.config.fold_card) {
               offset1 = 112;
               ui.handcards1Container.classList.add('scrollh');
            }
            else {
               offset1 = Math.min(112, (ui.handcards1Container.offsetWidth - 128) / (hs1.length - 1));
               if (hs1.length > 1 && offset1 < 32) {
                  offset1 = 32;
                  ui.handcards1Container.classList.add('scrollh');
               }
               else {
                  ui.handcards1Container.classList.remove('scrollh');
               }
            }
            if (offset1 < 100) {
               offset12 = 100 - offset1;
            }
            for (var i = 0; i < hs1.length; i++) {
               hs1[i].style.transform = 'translateX(' + (i * offset1) + 'px)';
               hs1[i]._transform = 'translateX(' + (i * offset1) + 'px)';
               ui.refresh(hs1[i]);
               hs1[i].classList.remove('drawinghidden');
               if (offset12 > 40) {
                  offset12 = 90 - hs1[i].node.info.offsetWidth;
                  hs1[i].node.info.querySelector('span').style.display = 'none';
                  if (hs1[i].node.name.classList.contains('long')) {
                     hs1[i].node.name.style.transform = 'translateY(16px)  scale(0.85)';
                     hs1[i].node.name.style.transformOrigin = 'top left';
                  }
                  else {
                     hs1[i].node.name.style.transform = 'translateY(16px)';
                  }
                  hs1[i].node.info.style.transform = 'translateX(-' + offset12 + 'px) translateY(-3px)';
               }
               else {
                  hs1[i].node.info.querySelector('span').style.display = '';
                  hs1[i].node.name.style.transform = '';
                  hs1[i].node.name.style.transformOrigin = '';
                  hs1[i].node.info.style.transform = 'translateX(-' + offset12 + 'px)';
               }
            }
            ui.handcards1Container.firstChild.style.width = (offset1 * (hs1.length - 1) + 118) + 'px';

            var offset2, offset22 = 0;
            if (!lib.config.fold_card) {
               offset2 = 112;
               ui.handcards2Container.classList.add('scrollh');
            }
            else {
               offset2 = Math.min(112, (ui.handcards2Container.offsetWidth - 128) / (hs2.length - 1));
               if (hs2.length > 1 && offset2 < 32) {
                  offset2 = 32;
                  ui.handcards2Container.classList.add('scrollh');
               }
               else {
                  ui.handcards2Container.classList.remove('scrollh');
               }
            }
            if (offset2 < 100) {
               offset22 = 100 - offset2;
            }
            for (var i = 0; i < hs2.length; i++) {
               hs2[i].style.transform = 'translateX(' + (i * offset2) + 'px)';
               hs2[i]._transform = 'translateX(' + (i * offset2) + 'px)';
               ui.refresh(hs2[i]);
               hs2[i].classList.remove('drawinghidden');
               if (offset22 > 40) {
                  offset22 = 90 - hs2[i].node.info.offsetWidth;
                  hs2[i].node.info.querySelector('span').style.display = 'none';
                  if (hs2[i].node.name.classList.contains('long')) {
                     hs2[i].node.name.style.transform = 'translateY(16px)  scale(0.85)';
                     hs2[i].node.name.style.transformOrigin = 'top left';
                  }
                  else {
                     hs2[i].node.name.style.transform = 'translateY(16px)';
                  }
                  hs2[i].node.info.style.transform = 'translateX(-' + offset22 + 'px) translateY(-3px)';
               }
               else {
                  hs2[i].node.info.querySelector('span').style.display = '';
                  hs2[i].node.name.style.transform = '';
                  hs2[i].node.name.style.transformOrigin = '';
                  hs2[i].node.info.style.transform = 'translateX(-' + offset22 + 'px)';
               }
            }
            ui.handcards2Container.firstChild.style.width = (offset2 * (hs2.length - 1) + 118) + 'px';
         },
         /**
          * 更新角色手牌
          * @function
          * @param {?boolean} compute 是否重新计算位置，如果为true则计算
          */
         updateh: function (compute) {
            if (!game.me) return;
            if (!ui.handcards1Container) return;
            if (lib.config.low_performance) {
               if (compute) {
                  ui.updatehl();
                  setTimeout(ui.updatehl, 1000);
               }
               return;
            }
            if (compute) {
               ui.handcards1Container._handcardsWidth = ui.handcards1Container.offsetWidth;
               ui.handcards2Container._handcardsWidth = ui.handcards2Container.offsetWidth;
            }
            ui.updatehx(game.me.node.handcards1);
            ui.updatehx(game.me.node.handcards2);
         },
         updatehx: function (node) {
            var width = node.parentNode._handcardsWidth;
            var num = node.childElementCount - node.getElementsByClassName('removing').length;
            node.classList.remove('fold0');
            node.classList.remove('fold1');
            node.classList.remove('fold2');
            node.classList.remove('fold3');
            if (num * 78 + 40 >= width) {
               // node.dataset.fold=3;
               node.classList.add('fold3');
            }
            else if (num * 93 + 25 >= width) {
               // node.dataset.fold=2;
               node.classList.add('fold2');
            }
            else if (num * 112 + 6 >= width) {
               // node.dataset.fold=1;
               node.classList.add('fold1');
            }
            else {
               // node.dataset.fold=0;
               node.classList.add('fold0');
            }
         },
         /**
          * 更新设备缩放比例
          * @function
          */
         updated: function () {
            if (document.documentElement.offsetWidth < 900 || document.documentElement.offsetHeight < 500) {
               /**
                * 设备缩放比例
                * @type {number}
                */
               game.deviceZoom = Math.min(
                  Math.round(document.documentElement.offsetWidth / 98) / 10,//?? 98?
                  Math.round(document.documentElement.offsetHeight / 50) / 10
               );
            }
            else {
               game.deviceZoom = 1;
            }
         },
         /**
          * 根据{@link game.documenZoom}调整document大小
          * @function
          */
         updatez: function () {
            var width = document.documentElement.offsetWidth;
            var height = document.documentElement.offsetHeight;
            var zoom = game.documentZoom;
            if (zoom != 1) {
               document.body.style.width = Math.round(width / zoom) + 'px';
               document.body.style.height = Math.round(height / zoom) + 'px';
               document.body.style.transform = 'scale(' + (Math.floor(zoom * 100) / 100) + ')';
            }
            else {
               document.body.style.width = width + 'px';
               document.body.style.height = height + 'px';
               document.body.style.transform = '';
            }
         },
         /**
          * 更新UI，弹窗
          * @function
          */
         update: function () {
            for (var i = 0; i < ui.updates.length; i++) {
               ui.updates[i]();
            }
            if (ui.dialog && !ui.dialog.classList.contains('noupdate')) {
               if (game.chess) {
                  if (ui.dialog.content.scrollHeight < 240 && (!ui.dialog.buttons || !ui.dialog.buttons.length) && !ui.dialog.forcebutton) {
                     ui.dialog.style.height = ui.dialog.content.offsetHeight + 'px';
                     ui.dialog.classList.add('slim');
                  }
                  else {
                     ui.dialog.style.height = '';
                     ui.dialog.classList.remove('slim');
                  }
               }
               else {
                  if ((!ui.dialog.buttons || !ui.dialog.buttons.length) && !ui.dialog.forcebutton && ui.dialog.classList.contains('fullheight') == false && get.mode() != 'stone') {
                     ui.dialog.classList.add('nobutton');
                     if (ui.dialog.content.offsetHeight < 240) {
                        if (!ui.dialog._heightset) {
                           ui.dialog._heightset = ui.dialog.style.height || true;
                        }
                        ui.dialog.style.height = ui.dialog.content.offsetHeight + 'px';
                        if (lib.config.show_log != 'off') {
                           ui.dialog.classList.add('scroll1');
                           ui.dialog.classList.add('scroll2');
                           return;
                        }
                     }
                     else {
                        if (typeof ui.dialog._heightset == 'string') {
                           ui.dialog.style.height = ui.dialog._heightset;
                        }
                        else if (ui.dialog._heightset) {
                           ui.dialog.style.height = '';
                        }
                        delete ui.dialog._heightset;
                     }
                  }
                  else {
                     if (typeof ui.dialog._heightset == 'string') {
                        ui.dialog.style.height = ui.dialog._heightset;
                     }
                     else if (ui.dialog._heightset) {
                        ui.dialog.style.height = '';
                     }
                     delete ui.dialog._heightset;
                     ui.dialog.classList.remove('nobutton');
                  }
               }
               var height1 = ui.dialog.content.offsetHeight;
               var height2 = ui.dialog.contentContainer.offsetHeight;
               if (game.chess) {
                  if (height1 < 240) {
                     ui.dialog.style.height = height1 + 'px';
                  }
               }
               else {
                  if (!ui.dialog.forcebutton && !ui.dialog._scrollset && (height1 <= 190 || (height2 >= height1 && height2 >= 210))) {
                     ui.dialog.classList.remove('scroll1');
                     ui.dialog.classList.remove('scroll2');
                  }
                  else {
                     ui.dialog.classList.add('scroll1');
                     ui.dialog.classList.add('scroll2');
                     if (game.layout != 'default' && !ui.dialog.promotionbutton) {
                        ui.dialog.style.height = Math.min(height1, ((game.layout == 'long2' || game.layout == 'nova') && ui.arena.classList.contains('choose-character')) ? 380 : 350) + 'px';
                        ui.dialog._scrollset = true;
                     }
                  }
                  if (game.layout == 'long2' || game.layout == 'nova') {
                     if (height1 + 240 >= ui.arena.offsetHeight) {
                        ui.dialog.classList.add('scroll3');
                     }
                     else {
                        ui.dialog.classList.remove('scroll3');
                     }
                  }
               }
            }
         },
         recycle: function (node, key) {
            if (!ui._recycle) ui._recycle = {};
            if (typeof node == 'string') {
               return ui._recycle[node]
            }
            ui._recycle[key] = node;
         },
      }
   }
}

/***/ }),

/***/ 6254:
/***/ ((module) => {

let { game, ui, get, ai, lib, _status } = vkCore
/**联机类game方法 */
module.exports = {
    waitForPlayer: function (func) {
        var next = game.createEvent('waitForPlayer', false);
        next.func = func;
        next.setContent('waitForPlayer');
    },
    countDown: function (time, onEnd) {
        time = parseInt(time);
        if (!time) return;
        if (time <= 0) return;
        var current = time;
        ui.timer.set(current, 1);
        _status.countDown = setInterval(function () {
            if (--current) {
                ui.timer.set(current, current / time);
            }
            else {
                ui.timer.set(0, 0);
                clearInterval(_status.countDown);
                delete _status.countDown;
                if (onEnd) onEnd();
            }
        }, 1000);
    },
    countChoose: function (clear) {
        if (_status.imchoosing) {
            return;
        }
        _status.imchoosing = true;
        if (_status.connectMode && !_status.countDown) {
            ui.timer.show();
            var num;
            //这么一大行都是为了祢衡
            if (_status.event && _status.event.name == 'chooseToUse' && _status.event.type == 'phase' &&
                _status.event.player && _status.event.player.forceCountChoose &&
                typeof _status.event.player.forceCountChoose.phaseUse == 'number') {
                num = _status.event.player.forceCountChoose.phaseUse;
            }
            else if (_status.connectMode) {
                num = lib.configOL.choose_timeout;
                if (ui.arena && ui.arena.classList.contains('choose-character') && lib.configOL.chooseCharacter_timeout) {
                    num = parseInt(num) * 5;
                }
            }
            else {
                num = get.config('choose_timeout');
            }
            game.countDown(parseInt(num), function () {
                ui.click.auto();
                ui.timer.hide();
            });
            if (!game.online && game.me) {
                if (_status.event.getParent().skillHidden) {
                    for (var i = 0; i < game.players.length; i++) {
                        game.players[i].showTimer();
                    }
                    game.me._hide_all_timer = true;
                }
                else if (!_status.event._global_waiting) {
                    game.me.showTimer();
                }
            }
        }
        else if (_status.event.player.forceCountChoose && _status.event.isMine() && !_status.countDown) {
            var info = _status.event.player.forceCountChoose;
            var num;
            if (_status.event.name == 'chooseToUse' && _status.event.type == 'phase' && typeof info.phaseUse == 'number') {
                num = info.phaseUse;
            }
            else if (typeof info[_status.event.name] == 'number') {
                num = info[_status.event.name]
            }
            else if (info.default) {
                num = info.default;
            }
            else return;
            var finish = function () {
                if (_status.event.endButton) {
                    if (_status.event.skill) {
                        ui.click.cancel();
                    }
                    ui.click.cancel();
                }
                else {
                    if (ui.confirm && ui.confirm.str) {
                        if (ui.confirm.str.indexOf('c') != -1) {
                            ui.click.cancel();
                        }
                        else if (ui.confirm.str.indexOf('o') != -1) {
                            ui.click.ok();
                        }
                    }
                    else if (['chooseControl', 'chooseBool'].contains(_status.event.name) && _status.paused) {
                        _status.event.result = 'ai';
                        game.resume();
                    }
                    else {
                        ui.click.auto('forced');
                        setTimeout(function () {
                            ui.click.auto('forced');
                        }, 200);
                    }
                }
                ui.timer.hide();
            };
            if (!num) {
                ui.timer.hide();
                game.uncheck();
                setTimeout(finish, 200);
            }
            else {
                ui.timer.show();
                game.countDown(num, finish);
            }
        }
    },
    stopCountChoose: function () {
        if (_status.countDown) {
            clearInterval(_status.countDown);
            delete _status.countDown;
            ui.timer.hide();
        }
        if (_status.connectMode && !game.online && game.me) {
            if (game.me._hide_all_timer) {
                delete game.me._hide_all_timer;
                for (var i = 0; i < game.players.length; i++) {
                    game.players[i].hideTimer();
                }
            }
            else if (!_status.event._global_waiting) {
                game.me.hideTimer();
            }
        }
    },
    connect: function (ip, callback) {
        if (game.online) return;
        var withport = false;
        var index = ip.lastIndexOf(':');
        if (index != -1) {
            index = parseFloat(ip.slice(index + 1));
            if (index && Math.floor(index) == index) {
                withport = true;
            }
        }
        if (!withport) {
            //ip=ip+':8080';
            if ('https:' != document.location.protocol)
                ip = ip + ':8080';
        }
        _status.connectCallback = callback;
        try {
            if (game.ws) {
                game.ws._nocallback = true;
                game.ws.close();
                delete game.ws;
            }
            var ishttps = 'https:' == document.location.protocol ? true : false;
            if (ishttps) {
                //alert("这是一个https请求");
                game.ws = new WebSocket('wss://' + ip + '/wss/');
            } else {
                //alert("这是一个http请求");
                game.ws = new WebSocket('ws://' + ip + '');
            }
            //game.ws=new WebSocket('ws://'+ip+'');
        }
        catch (e) {
            alert('错误：无效联机地址');
            if (callback) {
                callback(false);
            }
            return;
        }
        game.ws.onopen = lib.element.ws.onopen;
        game.ws.onmessage = lib.element.ws.onmessage;
        game.ws.onerror = lib.element.ws.onerror;
        game.ws.onclose = lib.element.ws.onclose;
        _status.ip = ip;
    },
    send: function () {
        if (game.observe && arguments[0] != 'reinited') return;
        if (game.ws) {
            var args = Array.from(arguments);
            if (typeof args[0] == 'function') {
                args.unshift('exec');
            }
            game.ws.send(JSON.stringify(get.stringifiedResult(args)));
        }
    },
    sendTo: function (id, message) {
        var ws = { wsid: id };
        for (var i in lib.element.nodews) {
            ws[i] = lib.element.nodews[i];
        }
        var client = {
            ws: ws,
            id: ws.wsid,
            closed: false
        };
        for (var i in lib.element.client) {
            client[i] = lib.element.client[i];
        }
        client.send(message);
    },
}

/***/ }),

/***/ 5909:
/***/ ((module) => {

let { game, ui, get, ai, lib, _status } = vkCore
/**检测类game方法 */
module.exports = {
    /**
     * 判定是否存在满足条件的角色
     * @param {?Function} func 用于筛选的函数
     * @returns {!boolean} 是否存在
     */
    hasPlayer: function (func) {
        for (var i = 0; i < game.players.length; i++) {
            if (game.players[i].isOut()) continue;
            if (func(game.players[i])) return true;
        }
        return false;
    },
    /**
     * 判定是否存在满足条件的角色（包括已死亡角色）
     * @param {?Function} func 用于筛选的函数
     * @returns {!boolean} 是否存在
     */
    hasPlayer2: function (func) {
        var players = game.players.slice(0).concat(game.dead);
        for (var i = 0; i < players.length; i++) {
            if (players[i].isOut()) continue;
            if (func(players[i])) return true;
        }
        return false;
    },
    /**
     * 获取满足条件的角色
     * @param {?Function} func 用于筛选的函数
     * @returns {Array<HTMLDivElement>} 由满足条件的角色组成的数组
     */
    countPlayer: function (func) {
        var num = 0;
        if (typeof func != 'function') {
            func = lib.filter.all;
        }
        for (var i = 0; i < game.players.length; i++) {
            if (game.players[i].isOut()) continue;
            var result = func(game.players[i]);
            if (typeof result == 'number') {
                num += result;
            }
            else if (result) {
                num++;
            }
        }
        return num;
    },
    /**
     * 获取满足条件的角色（包括已死亡角色）
     * @param {?Function} func 用于筛选的函数
     * @returns {Array<HTMLDivElement>} 由满足条件的角色组成的数组
     */
    countPlayer2: function (func) {
        var num = 0;
        if (typeof func != 'function') {
            func = lib.filter.all;
        }
        var players = game.players.slice(0).concat(game.dead);
        for (var i = 0; i < players.length; i++) {
            if (players[i].isOut()) continue;
            var result = func(players[i]);
            if (typeof result == 'number') {
                num += result;
            }
            else if (result) {
                num++;
            }
        }
        return num;
    },
    filterPlayer: function (func, list) {
        if (!Array.isArray(list)) {
            list = [];
        }
        if (typeof func != 'function') {
            func = lib.filter.all;
        }
        for (var i = 0; i < game.players.length; i++) {
            if (game.players[i].isOut()) continue;
            if (func(game.players[i])) {
                list.add(game.players[i]);
            }
        }
        return list;
    },
    filterPlayer2: function (func, list) {
        if (!Array.isArray(list)) {
            list = [];
        }
        if (typeof func != 'function') {
            func = lib.filter.all;
        }
        var players = game.players.slice(0).concat(game.dead);
        for (var i = 0; i < players.length; i++) {
            if (players[i].isOut()) continue;
            if (func(players[i])) {
                list.add(players[i]);
            }
        }
        return list;
    },
    findPlayer: function (func) {
        for (var i = 0; i < game.players.length; i++) {
            if (game.players[i].isOut()) continue;
            if (func(game.players[i])) {
                return game.players[i];
            }
        }
        return null;
    },
    findPlayer2: function (func) {
        var players = game.players.slice(0).concat(game.dead);
        for (var i = 0; i < players.length; i++) {
            if (players[i].isOut()) continue;
            if (func(players[i])) {
                return players[i];
            }
        }
        return null;
    },
    findCards: function (func, all) {
        var cards = [];
        for (var i in lib.card) {
            if (!lib.translate[i + '_info']) continue;
            if (lib.card[i].mode && lib.card[i].mode.contains(lib.config.mode) == false) continue;
            if (!all && !lib.inpile.contains(i)) continue;
            if (func(i, lib.card[i])) {
                cards.push(i);
            }
        }
        return cards;
    },
    /**
     * 用 countPlayer 计算场上存在的势力数
     * @returns {!number} 势力数
     */
    countGroup: function () {
        var list = lib.group.slice(0);
        return game.countPlayer(function (current) {
            if (list.contains(current.group)) {
                list.remove(current.group);
                return true;
            }
        });
    },
}

/***/ }),

/***/ 6439:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(944);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_filter__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4670);
/* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_sort__WEBPACK_IMPORTED_MODULE_1__);



/***/ }),

/***/ 944:
/***/ (() => {

{
  /**
   * 用于简单筛选的回调函数组
   * @namespace
   */
  let { game, ui, get, ai, lib, _status } = window.vkCore
  lib.filter = {
    all: function () {
      return true;
    },
    buttonIncluded: function (button) {
      return !(_status.event.excludeButton && _status.event.excludeButton.contains(button));
    },
    filterButton: function (button) {
      return true;
    },
    /**
     * 检测角色A能否使用某卡牌救治角色B
     * @function
     * @param {!GameCores.GameObjects.Card} card 检测卡牌
     * @param {!GameCores.GameObjects.Player} player 卡牌使用者(角色A)
     * @param {!GameCores.GameObjects.Player} target 卡牌目标(角色B)
     * @returns {!boolean} 如果可触发，返回true；否则返回false
     */
    cardSavable: function (card, player, target) {
      var mod2 = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
      if (mod2 != 'unchanged') return mod2;
      var mod = game.checkMod(card, player, target, 'unchanged', 'cardSavable', player);
      if (mod != 'unchanged') return mod;
      var savable = get.info(card).savable;
      if (typeof savable == 'function') savable = savable(card, player, target);
      return savable;
    },
    /**
     * 检测技能的trigger事件是否可触发
     * @function
     * @param {!GameCores.Bases.Event} event 父事件
     * @param {!GameCores.GameObjects.Player} player 触发对象(角色)
     * @param {!string} name 触发器名/触发条件，即triggername
     * @param {!string} skill 技能ID
     * @returns {!boolean} 如果可触发，返回true；否则返回false
     */
    filterTrigger: function (event, player, name, skill) {
      if (player._hookTrigger) {
        for (let i = 0; i < player._hookTrigger.length; i++) {
          let info = lib.skill[player._hookTrigger[i]].hookTrigger;
          if (info) {
            if (info.block && info.block(event, player, name, skill)) {
              return false;
            }
          }
        }
      }
      var fullskills = game.expandSkills(player.getSkills().concat(lib.skill.global));
      var info = get.info(skill);
      if ((info.noHidden || get.mode() != 'guozhan') && !fullskills.contains(skill)) {
        return false;
      }
      if (!info.trigger) return false;
      var bool = false;
      var has = function (obj) {
        if (typeof obj == 'string') return obj == name;
        else if (obj.contains(name)) return true;
        return false;
      }
      for (let i in info.trigger) {//check trigger
        if ((i == 'global' || player == event[i]) && has(info.trigger[i])) {
          bool = true; break;
        }
      }
      if (!bool) return false;
      if (info.filter && !info.filter(event, player, name)) {
        return false;
      }
      if (event._notrigger.contains(player) && !lib.skill.global.contains(skill)) {
        return false;
      }
      if (typeof info.usable == 'number' && player.hasSkill('counttrigger') &&
        player.$.counttrigger && player.$.counttrigger[skill] >= info.usable) {
        return false;
      }
      if (info.round && player.storage[skill + '_roundcount'] > 0) {
        return false;
      }
      return true;
    },
    characterDisabled: function (i, libCharacter) {
      if (!lib.character[i] || lib.character[i][4] && lib.character[i][4].contains('forbidai')) return true;
      if (lib.character[i][4] && lib.character[i][4].contains('unseen')) return true;
      if (lib.config.forbidai.contains(i)) return true;
      if (lib.characterFilter[i] && !lib.characterFilter[i](get.mode())) return true;
      if (_status.connectMode) {
        if (lib.configOL.banned.contains(i) || lib.connectBanned.contains(i)) return true;
        if (lib.configOL.protect_beginner && get.is.banForBeginner(i)) return true;
        var double_character = false;
        if (lib.configOL.mode == 'guozhan') {
          double_character = true;
        }
        else if (lib.configOL.double_character && (lib.configOL.mode == 'identity' || lib.configOL.mode == 'stone')) {
          double_character = true;
        }
        else if (lib.configOL.double_character_jiange && (lib.configOL.mode == 'versus' && _status.mode == 'jiange')) {
          double_character = true;
        }
        if (double_character && lib.config.forbiddouble.contains(i)) {
          return true;
        }
        // if(lib.configOL.ban_weak){
        //     if(lib.config.replacecharacter[i]&&libCharacter&&libCharacter[lib.config.replacecharacter[i]]) return true;
        //     if(lib.config.forbidall.contains(i)) return true;
        //     if(!double_character&&get.rank(i,true)<=2){
        //         return true;
        //     }
        // }
        // if(lib.configOL.ban_strong&&get.rank(i,true)>=8){
        //     return true;
        // }
      }
      else {
        if (lib.config.banned.contains(i)) return true;
        var double_character = false;
        if (get.mode() == 'guozhan') {
          double_character = true;
        }
        else if (get.config('double_character') && (lib.config.mode == 'identity' || lib.config.mode == 'stone')) {
          double_character = true;
        }
        else if (get.config('double_character_jiange') && (lib.config.mode == 'versus' && _status.mode == 'jiange')) {
          double_character = true;
        }
        if (double_character && lib.config.forbiddouble.contains(i)) {
          return true;
        }
        // if(get.config('ban_weak')){
        //     if(lib.config.replacecharacter[i]&&lib.character[lib.config.replacecharacter[i]]) return true;
        //     if(lib.config.forbidall.contains(i)) return true;
        //     if(!double_character&&get.rank(i,true)<=2){
        //         return true;
        //     }
        // }
        // if(get.config('ban_strong')&&get.rank(i,true)>=8){
        //     return true;
        // }
      }
    },
    characterDisabled2: function (i) {
      var info = lib.character[i];
      if (!info) return true;
      if (info[4]) {
        if (info[4].contains('boss')) return true;
        if (info[4].contains('hiddenboss')) return true;
        if (info[4].contains('minskin')) return true;
        if (info[4].contains('unseen')) return true;
        if (info[4].contains('forbidai') && (!_status.event.isMine || !_status.event.isMine())) return true;
        if (lib.characterFilter[i] && !lib.characterFilter[i](get.mode())) return true;
      }
      return false;
    },
    skillDisabled: function (skill) {
      if (!lib.translate[skill] || !lib.translate[skill + '_info']) return true;
      var info = lib.skill[skill];
      if (info && !info.unique && !info.temp && !info.sub && !info.fixed && !info.vanish) {
        return false;
      }
      return true;
    },
    cardEnabled: function (card, player, event) {
      if (player == undefined) player = _status.event.player;
      if (!player) return false;
      var mod2 = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
      if (mod2 != 'unchanged') return mod2;
      card = get.autoViewAs(card, null, player);
      if (event === 'forceEnable') {
        var mod = game.checkMod(card, player, 'unchanged', 'cardEnabled', player);
        if (mod != 'unchanged') return mod;
        return true;
      }
      else {
        var filter = get.info(card).enable;
        if (!filter) return;
        var mod = game.checkMod(card, player, 'unchanged', 'cardEnabled', player);
        if (mod != 'unchanged') return mod;
        if (typeof filter == 'boolean') return filter;
        if (typeof filter == 'function') return filter(card, player, event);
      }
    },
    cardRespondable: function (card, player, event) {
      event = event || _status.event;
      if (event.name != 'chooseToRespond') return true;
      var source = event.getParent().player;
      if (source && source != player) {
        if (source.hasSkillTag('norespond', false, [card, player, event], true)) {
          return false;
        }
      }
      if (player == undefined) player = _status.event.player;
      var mod2 = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
      if (mod2 != 'unchanged') return mod2;
      var mod = game.checkMod(card, player, 'unchanged', 'cardRespondable', player);
      if (mod != 'unchanged') return mod;
      return true;
    },
    cardUsable2: function (card, player, event) {
      card = get.autoViewAs(card, null, player);
      var info = get.info(card);
      if (info.updateUsable == 'phaseUse') {
        event = event || _status.event;
        if (player != _status.event.player) return true;
        if (event.getParent().name != 'phaseUse') return true;
        if (event.getParent().player != player) return true;
      }
      var num = info.usable;
      if (typeof num == 'function') num = num(card, player);
      num = game.checkMod(card, player, num, 'cardUsable', player);
      if (typeof num != 'number') return true;
      else return (player.countUsed(card) < num);
    },
    cardUsable: function (card, player, event) {
      card = get.autoViewAs(card, null, player);
      var info = get.info(card);
      event = event || _status.event;
      if (player != _status.event.player) return true;
      if (info.updateUsable == 'phaseUse') {
        if (event.getParent().name != 'phaseUse') return true;
        if (event.getParent().player != player) return true;
      }
      event.addCount_extra = true;
      var num = info.usable;
      if (typeof num == 'function') num = num(card, player);
      num = game.checkMod(card, player, num, 'cardUsable', player);
      if (typeof num != 'number') return true;
      if (player.countUsed(card) < num) return true;
      if (game.hasPlayer(function (current) {
        return game.checkMod(card, player, current, false, 'cardUsableTarget', player);
      })) {
        return true;
      }
      return false;
    },
    cardDiscardable: function (card, player, event) {
      event = event || _status.event;
      if (typeof event != 'string') event = event.getParent().name;
      var mod = game.checkMod(card, player, event, 'unchanged', 'cardDiscardable', player);
      if (mod != 'unchanged') return mod;
      return true;
    },
    canBeDiscarded: function (card, player, target, event) {
      event = event || _status.event;
      if (typeof event != 'string') event = event.getParent().name;
      var mod = game.checkMod(card, player, target, event, 'unchanged', 'canBeDiscarded', target);
      if (mod != 'unchanged') return mod;
      return true;
    },
    canBeGained: function (card, player, target, event) {
      event = event || _status.event;
      if (typeof event != 'string') event = event.getParent().name;
      var mod = game.checkMod(card, player, target, event, 'unchanged', 'canBeGained', target);
      if (mod != 'unchanged') return mod;
      return true;
    },
    cardAiIncluded: function (card) {
      if (_status.event.isMine()) return true;
      return (_status.event._aiexclude.contains(card) == false);
    },
    filterCard: function (card, player, event) {
      var info = get.info(card);
      //if(info.toself&&!lib.filter.targetEnabled(card,player,player)) return false;
      if (player == undefined) player = _status.event.player;
      if (!lib.filter.cardEnabled(card, player, event) || !lib.filter.cardUsable(card, player, event)) return false;
      if (info.notarget) return true;
      var range;
      var select = get.copy(info.selectTarget);
      if (select == undefined) {
        if (info.filterTarget == undefined) return true;
        range = [1, 1];
      }
      else if (typeof select == 'number') range = [select, select];
      else if (get.itemtype(select) == 'select') range = select;
      else if (typeof select == 'function') range = select(card, player);
      if (!range[1]) console.log(card, select, range)
      game.checkMod(card, player, range, 'selectTarget', player);
      if (!range || range[1] != -1) return true;
      var filterTarget = (event && event.filterTarget) ? event.filterTarget : lib.filter.filterTarget;
      return game.hasPlayer(function (current) {
        return filterTarget(card, player, current);
      });
    },
    targetEnabledx: function (card, player, target) {
      if (!card) return false;
      if (_status.event.addCount_extra && !lib.filter.cardUsable2(card, player) && !game.checkMod(card, player, target, false, 'cardUsableTarget', player)) return false;
      return lib.filter.targetEnabled.apply(this, arguments);
    },
    targetEnabled: function (card, player, target) {
      if (!card) return false;
      var info = get.info(card);
      var filter = info.filterTarget;
      var mod = game.checkMod(card, player, target, 'unchanged', 'playerEnabled', player);
      if (mod == false) return false;
      if (!info.singleCard || ui.selected.targets.length == 0) {
        var mod = game.checkMod(card, player, target, 'unchanged', 'targetEnabled', target);
        if (mod != 'unchanged') return mod;
      }
      if (typeof filter == 'boolean') return filter;
      if (typeof filter == 'function') return filter(card, player, target);
    },
    targetEnabled2: function (card, player, target) {
      if (lib.filter.targetEnabled(card, player, target)) return true;
      if (!card) return false;

      if (game.checkMod(card, player, target, 'unchanged', 'playerEnabled', player) == false) return false;
      if (game.checkMod(card, player, target, 'unchanged', 'targetEnabled', target) == false) return false;

      var filter = get.info(card).modTarget;
      if (typeof filter == 'boolean') return filter;
      if (typeof filter == 'function') return filter(card, player, target);
      return false;
    },
    targetEnabled3: function (card, player, target) {
      if (!card) return false;
      var info = get.info(card);

      if (info.filterTarget == true) return true;
      if (typeof info.filterTarget == 'function' && info.filterTarget(card, player, target)) return true;

      if (info.modTarget == true) return true;
      if (typeof info.modTarget == 'function' && info.modTarget(card, player, target)) return true;
      return false;
    },
    targetInRange: function (card, player, target) {
      var mod = game.checkMod(card, player, target, 'unchanged', 'targetInRange', player);
      var extra = 0;
      if (mod != 'unchanged') {
        if (typeof mod == 'boolean') return mod;
        if (typeof mod == 'number') extra = mod;
      }
      var info = get.info(card);
      var range = info.range;
      var outrange = info.outrange;
      if (range == undefined && outrange == undefined) return true;

      if (player.hasSkill('undist') || target.hasSkill('undist')) return false;
      for (var i in range) {
        if (i == 'attack') {
          if (player.inRange(target)) return true;
          var range2 = player.getAttackRange();
          if (range2 <= 0) return false;
          var distance = get.distance(player, target) + extra;
          if (range[i] <= distance - range2) return false;
        }
        else {
          var distance = get.distance(player, target, i) + extra;
          if (range[i] < distance) return false;
        }
      }
      for (var i in outrange) {
        if (i == 'attack') {
          var range2 = player.getAttackRange();
          if (range2 <= 0) return false;
          var distance = get.distance(player, target) + extra;
          if (outrange[i] > distance - range2 + 1) return false;
        }
        else {
          var distance = get.distance(player, target, i) + extra;
          if (outrange[i] > distance) return false;
        }
      }
      return true;
    },
    filterTarget: function (card, player, target) {
      return (lib.filter.targetEnabledx(card, player, target) &&
        lib.filter.targetInRange(card, player, target));
    },
    filterTarget2: function (card, player, target) {
      return (lib.filter.targetEnabled2(card, player, target) &&
        lib.filter.targetInRange(card, player, target));
    },
    notMe: function (card, player, target) {
      return player != target;
    },
    isMe: function (card, player, target) {
      return player == target;
    },
    attackFrom: function (card, player, target) {
      return get.distance(player, target, 'attack') <= 1;
    },
    globalFrom: function (card, player, target) {
      return get.distance(player, target) <= 1;
    },
    selectCard: function () {
      return [1, 1];
    },
    selectTarget: function () {
      var card = get.card(), player = get.player();
      if (card == undefined) return;
      var range;
      var select = get.copy(get.info(card).selectTarget);
      if (select == undefined) {
        if (get.info(card).filterTarget == undefined) return [0, 0];
        range = [1, 1];
      }
      else if (typeof select == 'number') range = [select, select];
      else if (get.itemtype(select) == 'select') range = select;
      else if (typeof select == 'function') range = select(card, player);
      game.checkMod(card, player, range, 'selectTarget', player);
      return range;
    },
    judge: function (card, player, target) {
      var judges = target.getCards('j');
      for (var i = 0; i < judges.length; i++) {
        if ((judges[i].viewAs || judges[i].name) == card.name) return false;
      }
      return true;
    },
    autoRespondSha: function () {
      return !this.player.hasSha(true);
    },
    autoRespondShan: function () {
      return !this.player.hasShan();
    },
    wuxieSwap: function (event) {
      if (event.type == 'wuxie') {
        if (ui.wuxie && ui.wuxie.classList.contains('glow')) {
          return true;
        }
        if (ui.tempnowuxie && ui.tempnowuxie.classList.contains('glow') && event.state > 0) {
          var triggerevent = event.getTrigger();
          if (triggerevent) {
            if (ui.tempnowuxie._origin == triggerevent.parent.id) {
              return true;
            }
          }
          else if (ui.tempnowuxie._origin == _status.event.id2) {
            return true;
          }
        }
        if (!_status.connectMode && lib.config.wuxie_self && event.getParent().state) {
          var tw = event.getTrigger().parent;
          if (tw.player.isUnderControl(true) && !tw.player.hasSkillTag('noautowuxie') &&
            tw.targets && tw.targets.length == 1 && !tw.noai) {
            return true;
          }
        }
      }
    }
  }
}

/***/ }),

/***/ 4670:
/***/ (() => {

{
  /**
   * 用于简单排序的回调函数组
   * @name sort
   * @namespace
   */
  let { game, ui, get, ai, lib, _status } = window.vkCore
  lib.sort = {
    /**
     * 将角色按照势力排列
     * @name sort.character
     * @function
     */
    character: function (a, b) {
      var getGroup = function (name) {
        var group = get.is.double(name, true);
        if (group) return group[0];
        return lib.character[name][1];
      },
        groupSort = function (name) {
          if (!lib.character[name]) return 50;
          var group = getGroup(name);
          if (group == 'shen') return -1;
          var list = get.groups();
          if (list.contains(group)) return list.indexOf(group);
          return 49;
        };
      var del = groupSort(a) - groupSort(b);
      if (del != 0) return del;
      var aa = a, bb = b;
      if (a.indexOf('_') != -1) {
        a = a.slice(a.indexOf('_') + 1);
      }
      if (b.indexOf('_') != -1) {
        b = b.slice(b.indexOf('_') + 1);
      }
      if (a != b) {
        return a > b ? 1 : -1;
      }
      return aa > bb ? 1 : -1;
    },
    /**
     * 将卡牌按照类型排列
     * @name sort.card
     * @function
     */
    card: function (a, b) {
      var typeSort = function (name) {
        var type = get.type(name);
        if (!type) return 10;
        if (type == 'basic') return -1;
        if (type == 'trick') return 0;
        if (type == 'delay') return 1;
        if (type == 'equip') {
          var type2 = get.subtype(name);
          if (type2 && type2.slice) return 1 + parseInt(type2.slice(5) || 7);
          return 8.5
        }
        return 9;
      }
      var del = typeSort(a) - typeSort(b);
      if (del != 0) return del;
      var aa = a, bb = b;
      if (a.indexOf('_') != -1) {
        a = a.slice(a.indexOf('_') + 1);
      }
      if (b.indexOf('_') != -1) {
        b = b.slice(b.indexOf('_') + 1);
      }
      if (a != b) {
        return a > b ? 1 : -1;
      }
      return aa > bb ? 1 : -1;
    },
    random: function () {
      return (Math.random() - 0.5);
    },
    /**
     * 将角色按照距离排列
     * @name sort.seat
     * @function
     */
    seat: function (a, b) {
      var player = lib.tempSortSeat || _status.event.player;
      var delta = get.distance(player, a, 'absolute') - get.distance(player, b, 'absolute');
      if (delta) return delta;
      delta = parseInt(a.dataset.position) - parseInt(b.dataset.position);
      if (player.side == game.me.side) return delta;
      return -delta;
    },
    position: function (a, b) {
      return parseInt(a.dataset.position) - parseInt(b.dataset.position);
    },
    priority: function (a, b) {
      var i1 = get.info(a[0]), i2 = get.info(b[0]);
      if (i1.priority == undefined) i1.priority = 0;
      if (i2.priority == undefined) i2.priority = 0;
      if (i1.priority == i2.priority) {
        if (i1.forced == undefined && i2.forced == undefined) return 0;
        if (i1.forced && i2.forced) return 0;
        if (i1.forced) return 1;
        if (i2.forced) return -1;
      }
      return i2.priority - i1.priority;
    },
    number: function (a, b) {
      return get.number(a) - get.number(b);
    },
    number2: function (a, b) {
      return get.number(b) - get.number(a);
    },
    capt: function (a, b) {
      var aa = a, bb = b;
      if (aa.indexOf('_') != -1) {
        aa = aa.slice(aa.indexOf('_') + 1);
      }
      if (bb.indexOf('_') != -1) {
        bb = bb.slice(bb.indexOf('_') + 1);
      }
      if (aa != bb) {
        return aa > bb ? 1 : -1;
      }
      return a > b ? 1 : -1;
    },
    name: function (a, b) {
      if (a > b) return 1;
      if (a < b) return -1;
      return 0;
    }
  }
}

/***/ }),

/***/ 5693:
/***/ ((module) => {

"use strict";


/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
const mask = (source, mask, output, offset, length) => {
  for (var i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
};

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
const unmask = (buffer, mask) => {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (var i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
};

module.exports = { mask, unmask };


/***/ }),

/***/ 796:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


try {
  module.exports = __webpack_require__(601)(__dirname);
} catch (e) {
  module.exports = __webpack_require__(5693);
}


/***/ }),

/***/ 1206:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4933);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3476);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".scedi{\r\n\tbackground-color: rgba(0,0,0,0.5);\r\n\twidth: 100%;\r\n\theight: 100%;\r\n\tz-index: 7;\r\n\tbackground-size: cover;\r\n}\r\n.scedi>.sce{\r\n\tleft: 0;\r\n\tbottom: 0;\r\n\twidth: 100%;\r\n\theight: 180px;\r\n\tbackground-color: rgba(0, 255, 255, 0.5);\r\n\tz-index: 1;\r\n}\r\n.scedi>.scetu{\r\n\tbackground-size: cover;\r\n}\r\n.scedi>.drive{\r\n\twidth: 100%;\r\n\theight: 100%;\r\n\tleft: 0;\r\n\tright: 0;\r\n\tz-index: 2;\r\n}\r\n.sce>.tou{\r\n\twidth: 150px;\r\n\theight: 100%;\r\n\tbackground-size: cover;\r\n}\r\n.sce>.yingyin{\r\n\topacity: .5;\r\n}\r\n.sce>.txt{\r\n\tvertical-align: top;\r\n\twidth: calc(100% - 150px);\r\n\theight: 100%;\r\n\tright: 0;\r\n\tpadding: 10px;\r\n\tbox-sizing: border-box;\r\n\tfont-size: 25px;\r\n\tcolor: #ffff00;\r\n\ttext-shadow: #000000 1px 0 0,#000000 0 1px 0,#000000 -1px 0 0,#000000 0 -1px 0;\r\n}\r\n.scedi .xsmall{\r\n\tfont-size: 15px;\r\n\tvertical-align: text-bottom;\r\n}\r\n.scedi .small{\r\n\tfont-size: 20px;\r\n\tvertical-align: text-bottom;\r\n}\r\n.scedi .large{\r\n\tfont-size: 35px;\r\n\tvertical-align: text-top;\r\n}\r\n.scedi .xlarge{\r\n\tfont-size: 45px;\r\n\tvertical-align: text-top;\r\n}\r\n.scedi .teal{\r\n\tcolor: teal;\r\n}\r\n.scedi .olive{\r\n\tcolor: olive;\r\n}\r\n.scedi .fuchsia{\r\n\tcolor: fuchsia;\r\n}\r\n.scedi .lime{\r\n\tcolor: lime;\r\n}\r\n.scedi .navy{\r\n\tcolor: navy;\r\n}\r\n.scedi .maroon{\r\n\tcolor: maroon;\r\n}\r\n.scedi .gray{\r\n\tcolor: gray;\r\n}\r\n.scedi .yellow{\r\n\tcolor: yellow;\r\n}\r\n.scedi .blue{\r\n\tcolor: blue;\r\n}\r\n.scedi .red{\r\n\tcolor: red;\r\n}\r\n.scedi .black{\r\n\tcolor: black;\r\n}\r\n.scedi .white{\r\n\tcolor: white;\r\n}\r\n.scedi .green{\r\n\tcolor: green;\r\n}\r\n.scedi .purple{\r\n\tcolor: purple;\r\n}\r\n.scedi .orange{\r\n\tcolor: orange;\r\n}\r\n.scedi .pink{\r\n\tcolor: pink;\r\n}\r\n.scedi .aqua{\r\n\tcolor: aqua;\r\n}\r\n.sce>.txt2{\r\n\twidth: calc(100% - 300px);\r\n\tright: 150px;\r\n}\r\n.sce>.galright{\r\n\twidth: 150px;\r\n\theight: 100%;\r\n\tbackground-size: cover;\r\n\tright: 0;\r\n}\r\n.galright>.name{\r\n\twidth: 25px;\r\n\tright: 0;\r\n\tfont-size: 25px;\r\n\tpadding: 10px;\r\n\ttext-shadow: #000000 1px 0 0,#000000 0 1px 0,#000000 -1px 0 0,#000000 0 -1px 0;\r\n}\r\n.tou>.name{\r\n\twidth: 0;\r\n\tfont-size: 25px;\r\n\tpadding: 10px;\r\n\ttext-shadow: #000000 1px 0 0,#000000 0 1px 0,#000000 -1px 0 0,#000000 0 -1px 0;\r\n}\r\n.scedi>.choose{\r\n\twidth: 60%;\r\n\tleft: 20%;\r\n\tbottom: 200px;\r\n\theight: 40%;\r\n\toverflow: auto;\r\n\tz-index: 3;\r\n}\r\n.choose>.sele{\r\n\tbackground-color: rgba(0, 255, 255, 0.5);\r\n\tposition: static;\r\n\tfont-size: 30px;\r\n\tmargin-bottom: 20px;\r\n\twidth: 100%;\r\n\tbox-sizing: border-box;\r\n\tdisplay: flex;\r\n\tjustify-content: center;\r\n\talign-items: center;\r\n\theight: 40px;\r\n\tborder: #000000 solid 2px;\r\n\tcolor: #ffff00;\r\n\tborder-radius: 20px;\r\n\ttext-shadow: #000000 1px 0 0,#000000 0 1px 0,#000000 -1px 0 0,#000000 0 -1px 0;\r\n}\r\n.choose>.sele:hover{\r\n\tbox-shadow:0px 0px 10px 10px #ffffff inset;\r\n}\r\n.cg{\r\n\twidth: 100%;\r\n\theight: 100%;\r\n\tbackground-color: #000000;\r\n\tz-index: 4;\r\n}\r\n", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 9315:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4933);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3476);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/*--------标签--------*/\nhtml {\n  width: 100%;\n  height: 100%;\n  font-size: 16px;\n  cursor: default;\n  overflow: hidden;\n  user-select: none;\n  -ms-user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  -webkit-font-smoothing: subpixel-antialiased;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  background-color: #3c3c3c;\n}\nbody {\n  width: 100%;\n  height: 100%;\n  padding: 0;\n  margin: 0;\n  left: 0;\n  top: 0;\n  position: absolute;\n  overflow: hidden;\n  text-rendering: optimizeLegibility;\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n  font-family: 'STHeiti', 'SimHei', 'Microsoft JhengHei', 'Microsoft YaHei', 'WenQuanYi Micro Hei', Helvetica, Arial, sans-serif;\n}\ndiv {\n  display: inline-block;\n  position: absolute;\n  transition: all 0.5s;\n}\ntable {\n  table-layout: fixed;\n}\n/*--------场景--------*/\n#window {\n  width: 100%;\n  height: 100%;\n  top: 0px;\n  left: 0;\n  transition-property: opacity;\n  overflow: hidden;\n}\n#window.connecting > *:not(#system) {\n  opacity: 0.5;\n}\n#window.server > div:not(.serverinfo) {\n  display: none !important;\n}\n#window.server > .serverinfo {\n  width: 400px;\n  height: 200px;\n  font-family: 'xinwei';\n  text-align: center;\n  left: calc(50% - 200px);\n  top: calc(50% - 100px);\n}\n#window.server > .serverinfo > div {\n  position: relative;\n  display: block;\n  font-size: 20px;\n  margin-top: 10px;\n}\n#window.server > .serverinfo > div > div {\n  position: relative;\n  display: inline-block;\n}\n#window.server > .serverinfo > div > div:last-child {\n  width: 60px;\n  text-align: left;\n  white-space: nowrap;\n}\n#window.server > .serverinfo > div > .menubutton.large:last-child {\n  width: auto;\n  margin-top: 30px;\n  cursor: pointer;\n}\n#window.server > .serverinfo > div:first-child {\n  font-size: 40px;\n}\n.connectlayer > div {\n  display: table-cell;\n  vertical-align: middle;\n  font-size: 60px;\n  color: white;\n  text-shadow: black 0 0 2px;\n  position: relative;\n  font-family: 'xinwei';\n  transition: all 0.5s;\n}\n.connectlayer.fullsize {\n  display: table;\n  text-align: center;\n  z-index: 100;\n}\n.statusbar #window {\n  top: 24px;\n  height: calc(100% - 24px);\n}\n.statusbar #statusbg {\n  display: block;\n}\n#statusbg {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 24px;\n  background: rgba(0, 0, 0, 0.4);\n  display: none;\n}\n#window > .tutorial_tap {\n  width: 30px;\n  height: 30px;\n  border-radius: 100%;\n  background: rgba(255, 255, 255, 0.5);\n  box-shadow: rgba(255, 255, 255, 0.5) 0 0 5px;\n  left: calc(50% - 15px);\n  top: calc(50% - 15px);\n  position: absolute;\n  transition: all 1s;\n}\n#window.testing > *:not(.pausedbg) {\n  display: none !important;\n}\n#window.modepaused > div:not(.modenopause):not(#arena):not(.popped) {\n  opacity: 0.3;\n}\n#window.modepaused > #arena > #roundmenu {\n  opacity: 0.3;\n}\n#window.shortcutpaused > .modeshortcutpause {\n  opacity: 0.3 !important;\n}\n#window.shortcutpaused > div:not(.background):not(#shortcut):not(#system):not(#arena):not(.hidden):not(.removing):not(.dialog):not(.centermenu):not(.popup-container):not(.forceopaque) {\n  opacity: 0.3 !important;\n}\n#window.shortcutpaused > #arena > div:not(#timer):not(.removing):not(.hidden):not(#autonode) {\n  opacity: 0.3 !important;\n}\n#window.shortcutpaused > #system {\n  z-index: 31;\n}\n#window.shortcutpaused.modepaused > .modenopause.popup-container:not(.filter-character) {\n  opacity: 0.3;\n}\n#window.systempaused > #system {\n  opacity: 0.3 !important;\n}\n#window.noclick_important * {\n  pointer-events: none !important;\n}\n#window.noclick_important .noclick_click_important div {\n  pointer-events: auto !important;\n}\n#window.blur_ui #arena.paused,\n#window.blur_ui #arena.menupaused,\n#window.blur_ui #historybar.paused,\n#window.blur_ui #historybar.menupaused,\n#window.blur_ui #arena.unfocus,\n#window.blur_ui #arena.right {\n  filter: blur(3px);\n  -webkit-filter: blur(3px);\n}\n#window.blur_ui #arena.menupaused,\n#window.blur_ui #historybar.menupaused {\n  opacity: 0.6;\n}\n#window.blur_ui #arena.thrownhighlight > .card.thrown:not(.thrownhighlight) {\n  filter: blur(2px);\n  -webkit-filter: blur(2px);\n}\n#window.blur_ui.shortcutpaused > #arena,\n#window.blur_ui.shortcutpaused > #historybar {\n  filter: blur(3px);\n  -webkit-filter: blur(3px);\n}\n#time {\n  width: 100%;\n  padding: 0;\n  margin: 0;\n  position: absolute;\n  left: 0;\n  top: 11px;\n  text-align: center;\n  pointer-events: none;\n  display: block;\n  font-family: 'xinwei';\n}\n#time > div {\n  margin: 0;\n  padding: 0;\n  display: inline-block;\n  margin-left: 6px;\n  margin-right: 6px;\n  position: relative;\n}\n#shortcut {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  left: 0;\n  top: 0;\n  z-index: 10;\n  /*background-color: rgba(0, 0, 0, 0.6);*/\n}\n#shortcut > div {\n  width: 80px;\n  height: 80px;\n  padding: 10px;\n  margin: 0;\n  overflow: hidden;\n  line-height: 80px;\n  font-size: 50px;\n  white-space: nowrap;\n  text-align: center;\n  letter-spacing: -6px;\n  -webkit-transform: scale(1.3);\n          transform: scale(1.3);\n}\n#shortcut > div:not(.menubutton) {\n  width: 100%;\n  height: 80px;\n  margin: 0;\n  padding: 0;\n  left: 0;\n  top: 0;\n}\n#shortcut > div > span {\n  width: 200px;\n  left: -63px;\n  position: relative;\n  display: inline-block;\n}\n#shortcut > div[data-position=\"1\"] {\n  left: calc(50% - 50px);\n  top: calc(50% - 190px);\n}\n#shortcut > div[data-position=\"2\"] {\n  left: calc(50% + 100px);\n  top: calc(50% - 40px);\n}\n#shortcut > div[data-position=\"3\"] {\n  left: calc(50% - 50px);\n  top: calc(50% + 110px);\n}\n#shortcut > div[data-position=\"4\"] {\n  left: calc(50% - 200px);\n  top: calc(50% - 40px);\n}\n#shortcut > div[data-position=\"5\"] {\n  left: calc(50% - 50px);\n  top: calc(50% - 50px);\n}\n#shortcut > .favmodelist:not(.menubutton) {\n  width: 130px;\n  height: 300px;\n  top: calc(50% - 150px);\n  left: calc(50% - 430px);\n  overflow: visible;\n}\n#shortcut > .favmodelist > .menubutton.large {\n  display: block;\n  position: absolute;\n  left: 0;\n  letter-spacing: 0;\n}\n#shortcut > .favmodelist > [data-type=\"even\"] {\n  top: calc(50% - 45px);\n}\n#shortcut > .favmodelist > [data-type=\"odd\"] {\n  top: calc(50% - 20px);\n}\n#shortcut > .favmodelist > [data-position=\"0\"] {\n  transition-duration: 0.5s;\n}\n#shortcut > .favmodelist > [data-position=\"1\"] {\n  transition-duration: 0.6s;\n  -webkit-transform: translateY(50px);\n          transform: translateY(50px);\n}\n#shortcut > .favmodelist > [data-position=\"2\"] {\n  transition-duration: 0.4s;\n  -webkit-transform: translateY(-50px);\n          transform: translateY(-50px);\n}\n#shortcut > .favmodelist > [data-position=\"3\"] {\n  transition-duration: 0.7s;\n  -webkit-transform: translateY(100px);\n          transform: translateY(100px);\n}\n#shortcut > .favmodelist > [data-position=\"4\"] {\n  transition-duration: 0.3s;\n  -webkit-transform: translateY(-100px);\n          transform: translateY(-100px);\n}\n#shortcut > .favmodelist > [data-position=\"5\"] {\n  transition-duration: 0.8s;\n  -webkit-transform: translateY(150px);\n          transform: translateY(150px);\n}\n#shortcut.hidden {\n  pointer-events: none;\n  transition: opacity 0.3s;\n}\n#shortcut.hidden > div[data-position=\"1\"] {\n  -webkit-transform: scale(1) translateY(150px);\n          transform: scale(1) translateY(150px);\n}\n#shortcut.hidden > div[data-position=\"2\"] {\n  -webkit-transform: scale(1) translateX(-150px);\n          transform: scale(1) translateX(-150px);\n}\n#shortcut.hidden > div[data-position=\"3\"] {\n  -webkit-transform: scale(1) translateY(-150px);\n          transform: scale(1) translateY(-150px);\n}\n#shortcut.hidden > div[data-position=\"4\"] {\n  -webkit-transform: scale(1) translateX(150px);\n          transform: scale(1) translateX(150px);\n}\n#shortcut.hidden > .favmodelist > [data-position=\"0\"] {\n  -webkit-transform: translateX(-140px);\n          transform: translateX(-140px);\n}\n#shortcut.hidden > .favmodelist > [data-position=\"1\"] {\n  -webkit-transform: translateY(50px) translateX(-150px);\n          transform: translateY(50px) translateX(-150px);\n}\n#shortcut.hidden > .favmodelist > [data-position=\"2\"] {\n  -webkit-transform: translateY(-50px) translateX(-130px);\n          transform: translateY(-50px) translateX(-130px);\n}\n#shortcut.hidden > .favmodelist > [data-position=\"3\"] {\n  -webkit-transform: translateY(100px) translateX(-160px);\n          transform: translateY(100px) translateX(-160px);\n}\n#shortcut.hidden > .favmodelist > [data-position=\"4\"] {\n  -webkit-transform: translateY(-100px) translateX(-120px);\n          transform: translateY(-100px) translateX(-120px);\n}\n#shortcut.hidden > .favmodelist > [data-position=\"5\"] {\n  -webkit-transform: translateY(150px) translateX(-170px);\n          transform: translateY(150px) translateX(-170px);\n}\n#splash {\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n  position: absolute;\n  text-align: center;\n  overflow: visible;\n  transition: all 0.3s;\n  overflow-x: scroll;\n  white-space: nowrap;\n}\n#splash:not(.touch) > div:hover:not(.clicked) {\n  -webkit-transform: translateY(-20px);\n          transform: translateY(-20px);\n}\n#splash > div {\n  width: 110px;\n  height: 300px;\n  top: calc(50% - 150px);\n  margin-left: 10px;\n  margin-right: 10px;\n  position: relative;\n  transition: all 0.8s;\n}\n#splash > div:first-child {\n  margin-left: 20px;\n}\n#splash > div:last-child {\n  margin-right: 20px;\n}\n#splash > div > .splashtext {\n  font-family: 'Tiejili', 'huangcao', 'xinwei';\n  font-size: 50px;\n  position: absolute;\n  right: 7px;\n  bottom: 7px;\n  z-index: 1;\n}\n#splash > div > .avatar {\n  width: 86px;\n  height: calc(100% - 14px);\n  left: 7px;\n  top: 7px;\n  background-size: cover;\n}\n#splash > div.clicked {\n  -webkit-transform: translateY(-20px) scale(1.5);\n          transform: translateY(-20px) scale(1.5);\n  transition: all 0.3s;\n  opacity: 0;\n}\n#splash > div.hidden {\n  -webkit-transform: translateY(-300px) scale(0.5);\n          transform: translateY(-300px) scale(0.5);\n}\n#splash.slim > div .splashtext {\n  -webkit-filter: drop-shadow(3px 3px 2px #454579);\n          filter: drop-shadow(3px 3px 2px #454579);\n  right: 5px;\n  bottom: 5px;\n}\n#splash.slim > div .avatar {\n  width: calc(100% - 10px);\n  height: calc(100% - 10px);\n  left: 5px;\n  top: 5px;\n}\n#splash.removing {\n  pointer-events: none;\n}\n#splash[data-radius_size='reduce'] > div > div,\n#splash[data-radius_size='reduce'] > div {\n  border-radius: 4px;\n}\n#splash[data-radius_size='off'] > div > div,\n#splash[data-radius_size='off'] > div {\n  border-radius: 0px;\n}\n#splash[data-radius_size='increase'] > div > div,\n#splash[data-radius_size='increase'] > div {\n  border-radius: 12px;\n}\n#arenalog {\n  width: calc(50% - 210px);\n  height: calc(100% - 370px);\n  left: calc(50% + 60px);\n  top: 200px;\n  overflow: hidden;\n}\n#arenalog:not(.oldlayout) > #arenalog[data-position=\"center\"] {\n  left: calc(25% + 105px);\n}\n#arenalog:not(.oldlayout) #arena:not(.oldlayout) > #arenalog[data-position=\"left\"] {\n  left: 150px;\n}\n#arenalog > div {\n  position: relative;\n  display: block;\n  width: calc(100% - 20px);\n  left: 20px;\n  line-height: 18px;\n}\n#arenalog.withdialog {\n  opacity: 0.5;\n}\n#arena.oldlayout #arenalog {\n  top: 160px;\n  width: calc(50% - 300px);\n  height: calc(100% - 325px);\n}\n#arena.oldlayout #arenalog[data-position=\"center\"] {\n  left: calc(25% + 150px);\n}\n#arena.oldlayout #arenalog[data-position=\"left\"] {\n  left: 240px;\n}\n#arena {\n  width: 94%;\n  height: 90%;\n  top: calc(5% + 10px);\n  left: 3%;\n  transition-property: opacity;\n}\n#arena > canvas {\n  z-index: 10;\n  pointer-events: none;\n  position: absolute;\n}\n#arena #me > div > div > .card {\n  position: absolute;\n  left: 8px;\n}\n#arena.playerhidden > .player,\n#arena.playerhidden > #mebg,\n#arena.markhidden > .player > .marks {\n  visibility: hidden;\n  opacity: 0;\n}\n#arena.hide_name .player > .name:not(.name_seat),\n#arena.hide_name .player > .name2,\n#arena.hide_name > .dialog .button.character > .name {\n  display: none !important;\n}\n#arena.chess > #arenalog {\n  display: none !important;\n}\n#arena.observe .handcards > .card > div {\n  opacity: 0 !important;\n}\n#arena.right:not(.noleft) {\n  left: 240px;\n  opacity: 0.6;\n}\n#arena.left:not(.noleft) {\n  left: calc(10% - 240px);\n  opacity: 0.6;\n}\n#arena.top {\n  top: -100%;\n}\n#arena.paused2 {\n  opacity: 0.1 !important;\n}\n#arena.only_dialog > div:not(.dialog):not(#control) {\n  opacity: 0 !important;\n  pointer-events: none !important;\n}\n#arena.playerfocus > div:not(#timer):not(.playerfocus):not(#chess-container):not(.removing):not(#autonode),\n#arena.playerfocus #chess > div:not(.playerfocus):not(.removing) {\n  opacity: 0.3 !important;\n}\n#window.leftbar #arena:not(.chess) {\n  left: calc(3% + 50px);\n  width: calc(94% - 50px);\n}\n#window.rightbar #arena:not(.chess) {\n  width: calc(94% - 50px);\n}\n#arena.paused,\n#arena.unfocus,\n#historybar.paused {\n  opacity: 0.3 !important;\n}\n#arena > .poplayer,\n#window > .poplayer {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  left: 0;\n  top: 0;\n  z-index: 20;\n}\n#historybar {\n  left: 1.5%;\n  width: 50px;\n  height: calc(90% - 20px);\n  top: calc(5% + 25px);\n  border-radius: 4px;\n  visibility: hidden;\n  opacity: 0;\n  overflow: hidden;\n  z-index: 2;\n  transition-property: opacity, visibility;\n}\n#historybar > div {\n  width: 42px;\n  height: 42px;\n  margin: 0;\n  padding: 4px;\n  display: block;\n  position: absolute;\n}\n#historybar > div > .card {\n  -webkit-transform: scale(0.403846);\n          transform: scale(0.403846);\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n  margin: 0;\n  left: 4px;\n  top: 4px;\n  position: absolute;\n}\n#historybar > div > .avatar {\n  padding: 0;\n  margin: 0;\n  position: absolute;\n  left: 4px;\n  top: 4px;\n  width: 42px;\n  height: 42px;\n  border-radius: 3.230768px;\n}\n#historybar > div > .avatar > div {\n  position: absolute;\n  margin: 0;\n  padding: 0;\n  left: 0;\n  bottom: 2px;\n  height: auto;\n  font-family: 'xinwei';\n  font-size: 18px;\n  text-align: center;\n  width: 100%;\n}\n#historybar > div > .avatar > .avatarbg {\n  bottom: 0;\n  height: 100%;\n  background-size: cover;\n}\n#historybar > div > .avatar2 {\n  width: 20px;\n  height: 20px;\n  left: 28px;\n  top: 28px;\n  border-radius: 100%;\n  font-family: 'xinwei';\n  font-size: 20px;\n  line-height: 20px;\n  z-index: 1;\n}\n#historybar > div > .avatar2.avatar3 {\n  left: 12px;\n  top: 31px;\n  -webkit-transform: scale(0.7);\n          transform: scale(0.7);\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n}\n#historybar.hidden {\n  pointer-events: none;\n}\n#window.rightbar #historybar {\n  left: calc(98.5% - 50px);\n  opacity: 1;\n  visibility: visible;\n}\n#window.rightbar2:not(.leftbar) #historybar {\n  left: calc(98.5% - 50px);\n}\n#window.leftbar #historyba {\n  opacity: 1;\n  visibility: visible;\n}\n#window:not(.low_performance) #arena #arenalog > div {\n  animation: game_start 0.5s;\n  -webkit-animation: game_start 0.5s;\n}\n#splash.low_performance div {\n  transition: all 0.5s;\n}\n#splash.low_performance div.hidden {\n  -webkit-transform: scale(0.8);\n          transform: scale(0.8);\n}\n#window.low_performance #arena .player .equips,\n#window.low_performance #arena .player .name {\n  transition: all 0s;\n}\n#window.low_performance .menu.main > .menu-content > div > .right.pane > div:not(.expanded) > .config.auto-hide,\n#window.low_performance .menu.main > .menu-content > div > .right.pane > div > .config.hidden {\n  display: none;\n  transition-property: -webkit-transform;\n  transition-property: transform;\n  transition-property: transform, -webkit-transform;\n}\n/*--------角色--------*/\n.player:not(.treasure).playerfocus {\n  -webkit-transform: scale(1.1);\n          transform: scale(1.1);\n}\n.player.linked:not(.treasure).playerfocus {\n  -webkit-transform: scale(1.1) rotate(-90deg);\n          transform: scale(1.1) rotate(-90deg);\n}\n.player.connect > div:not(.displayer):not(.name):not(.nameol):not(.hp):not(.room):not(.gaming):not(.identity) {\n  display: none !important;\n}\n.player.connect > .gaming {\n  left: 16px;\n  top: auto;\n  bottom: 16px;\n  font-family: 'xinwei';\n}\n.player.connect[data-cursor_style=\"forbidden\"] {\n  opacity: 0.5;\n}\n.player {\n  z-index: 2;\n  width: 240px;\n  height: 120px;\n}\n.player .playerjiu {\n  animation: game_start 0.5s;\n  -webkit-animation: game_start 0.5s;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n  z-index: 4;\n  pointer-events: none;\n  background: rgba(255, 0, 0, 0.3);\n}\n.player > .displayer > .avatar > .action {\n  margin: 5px;\n  font-family: 'xinwei';\n  font-size: 20px;\n  letter-spacing: -2px;\n  right: 5px;\n  text-align: right;\n}\n.player > .displayer > .avatar > .action:not(.freecolor) {\n  text-shadow: black 0 0 1px, #0a9b43 0 0 5px, #0a9b43 0 0 10px;\n}\n.player > .displayer > .avatar.hidden {\n  pointer-events: none !important;\n}\n.player > .displayer > .avatar.disabled {\n  filter: grayscale(1);\n  -webkit-filter: grayscale(1);\n  opacity: 0.8;\n}\n.player > .displayer > .avatar2.hidden {\n  pointer-events: none !important;\n}\n.player > .displayer > .avatar2.disabled {\n  filter: grayscale(1);\n  -webkit-filter: grayscale(1);\n  opacity: 0.8;\n}\n.player:not(.current_action) .avatar > .action {\n  opacity: 0;\n}\n.player > div {\n  z-index: 2;\n}\n.player > .nameol {\n  left: 0;\n  top: 13px;\n  width: 100%;\n  font-size: 12px;\n  text-align: center;\n  white-space: nowrap;\n  /*opacity: 0;*/\n}\n.player:hover > .nameol {\n  opacity: 1;\n}\n.player > .name {\n  left: 16px;\n  top: 24px;\n  font-size: 20px;\n  font-family: 'xinwei';\n}\n.player > .name.name2 {\n  left: 81px;\n}\n.player > .intro {\n  top: 87px;\n  left: 18px;\n}\n.player > .turned {\n  font-family: 'xinwei';\n  width: 100%;\n  height: 100%;\n  line-height: 50px;\n  left: 0;\n  margin: 0;\n  padding: 0;\n  text-align: center;\n  font-size: 50px;\n  opacity: 0;\n  pointer-events: none;\n  background: black;\n  top: 0;\n  border-radius: 8px;\n  color: rgba(255, 255, 255, 0.8);\n  text-shadow: none;\n}\n.player > .turned > div {\n  top: calc(50% - 50px);\n  width: 100%;\n  left: 0;\n}\n.player > .chain {\n  top: calc(50% - 10px);\n  left: 0;\n  height: 20px;\n  width: 100%;\n  overflow-x: hidden;\n  overflow-y: visible;\n  white-space: nowrap;\n  padding: 0;\n  margin: 0;\n  z-index: 3;\n  pointer-events: none;\n}\n.player > .chain > div {\n  overflow: visible;\n  left: 0;\n  top: 0;\n  margin: 0;\n  padding: 0;\n}\n.player > .chain > div > div {\n  position: absolute;\n  margin: 0;\n  padding: 0;\n  left: 0;\n  box-shadow: rgba(0, 0, 0, 0.4) 0 0 0 1px, rgba(0, 0, 0, 0.4) 0 0 2px;\n}\n.player > .chain > div > div:nth-child(odd) {\n  height: 8px;\n  width: 10px;\n  border-radius: 2px;\n  top: 6px;\n}\n.player > .chain > div > div:nth-child(even) {\n  width: 10px;\n  height: 2px;\n  top: 9px;\n  z-index: 1;\n  border-radius: 2px;\n}\n.player:not(.linked2) > .chain > div {\n  opacity: 0;\n  -webkit-transform: translateX(-40px);\n          transform: translateX(-40px);\n}\n.player.playerbright {\n  filter: brightness(1.2);\n  -webkit-filter: brightness(1.2);\n}\n.player.playerflip {\n  animation: playerflip 0.3s ease-out;\n  -webkit-animation: playerflip 0.3s ease-out;\n}\n.player.controlfakeme {\n  width: 100px;\n  height: 120px;\n  top: calc(100% - 140px);\n}\n.player.controlfakeme .avatar {\n  width: 100%;\n  height: 100%;\n  box-shadow: none;\n  left: 0;\n  top: 0;\n}\n.player.minskin {\n  width: 120px;\n}\n#arena.chess:not(.selecting) .player.current_action .avatar > .action {\n  opacity: 0;\n}\n.player.replaceme {\n  animation: replaceme 0.5s;\n  -webkit-animation: replaceme 0.5s;\n}\n.player.replaceenemy {\n  animation: replaceenemy 0.5s;\n  -webkit-animation: replaceenemy 0.5s;\n}\n.player.dead,\n.player.likedead,\n.grayscale1 {\n  z-index: 1;\n  filter: grayscale(1);\n  -webkit-filter: grayscale(1);\n}\n.grayscale {\n  filter: grayscale(1);\n  -webkit-filter: grayscale(1);\n}\n#arena.slim_player .player > .name {\n  left: 13px;\n  top: 21px;\n}\n#arena.slim_player .player > .name.name2 {\n  left: 78px;\n}\n#arena.slim_player .player.minskin > .name {\n  font-size: 18px;\n  line-height: 120%;\n  top: 15px;\n}\n#arena.slim_player .player.minskin > .name.long {\n  -webkit-transform: scale(0.9);\n          transform: scale(0.9);\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n  top: 13px;\n}\n#arena.slim_player .player.minskin.linked > .name {\n  -webkit-transform: rotate(90deg) translate(81px, -66px);\n          transform: rotate(90deg) translate(81px, -66px);\n}\n#arena .player.minskin > .name {\n  font-size: 18px;\n  line-height: 120%;\n  top: 15px;\n}\n#arena .player.minskin > .name.long {\n  -webkit-transform: scale(0.9);\n          transform: scale(0.9);\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n  top: 13px;\n}\n#arena .player.linked.minskin > .name {\n  -webkit-transform: rotate(90deg) translate(81px, -66px);\n          transform: rotate(90deg) translate(81px, -66px);\n}\n#arena:not(.hide_turned):not(.oldlayout) .player.turnedover > .turned {\n  opacity: 0.2;\n}\n#arena.nolink .player > .chain {\n  display: none;\n}\n.unseen .avatar,\n.unseen > .name:not(.name2) {\n  opacity: 0 !important;\n}\n.unseen2 .avatar2,\n.unseen2 > .name2 {\n  opacity: 0 !important;\n}\n#arena:not(.observe) .unseen_v .avatar,\n#arena:not(.observe) .player[data-position='0'].unseen .avatar,\n#arena:not(.observe) .unseen_v > .name:not(.name2):not(.name_seat),\n#arena:not(.observe) .player[data-position='0'].unseen > .name:not(.name2):not(.name_seat) {\n  opacity: 0.2 !important;\n}\n#arena:not(.observe) .unseen2_v .avatar2,\n#arena:not(.observe) .player[data-position='0'].unseen2 .avatar2,\n#arena:not(.observe) .unseen2_v > .name2,\n#arena:not(.observe) .player[data-position='0'].unseen2 > .name2 {\n  opacity: 0.2 !important;\n}\n.player > .name_seat {\n  opacity: 0;\n}\n.player:not([data-position='0']) .unseen.unseen2 > .name_seat,\n.player:not([data-position='0']):not(.fullskin2).unseen > .name_seat {\n  opacity: 1 !important;\n}\n.linked > .displayer > .avatar,\n.linked > .displayer > .avatar2 {\n  -webkit-transform: rotate(-90deg);\n          transform: rotate(-90deg);\n}\n.linked > .displayer > .avatar2 {\n  top: 5px;\n}\n.linked > .identity {\n  top: 88px;\n}\n.linked > .count {\n  right: 154px;\n}\n.hp {\n  left: 18px;\n  top: 14px;\n  width: 72px;\n  line-height: 14px;\n  text-align: left;\n}\n.hp.text {\n  top: 18px;\n}\n.hp.textstyle {\n  font-family: 'xinwei';\n}\n.hp > div {\n  width: 8px;\n  height: 8px;\n  margin-left: 3px;\n  border-radius: 100%;\n  box-shadow: rgba(0, 0, 0, 0.2) 1px -1px 2px inset, rgba(255, 255, 255, 0.15) -1px 1px 5px inset;\n  position: relative;\n  filter: brightness(1.5);\n  -webkit-filter: brightness(1.5);\n  transition: all 0.5s;\n  background-repeat: no-repeat;\n}\n.hp[data-condition=\"high\"] > div:not(.lost) {\n  background: #397b04;\n  border: 1px solid #274f07;\n}\n.hp[data-condition=\"mid\"] > div:not(.lost) {\n  background: #a68c06;\n  border: 1px solid #4f4007;\n}\n.hp[data-condition=\"low\"] > div:not(.lost) {\n  background: #941b1b;\n  border: 1px solid #4f0707;\n}\n.hp.actcount > div:not(.lost) {\n  background: #3f77ad;\n  border: 1px solid #1f5283;\n}\n.button .hp > div {\n  width: 6px;\n  height: 6px;\n  background: white;\n  box-shadow: 0px 1px 1px rgba(0, 0, 0, 0.5);\n  border: 1px solid #fff;\n}\n.treasure > .hp > div:not(.lost) {\n  background: #3f77ad !important;\n  border: 1px solid #1f5283 !important;\n}\n.hp.actcount > div.overflow:not(.lost) {\n  background: #9a9a9a;\n  border: 1px solid #6d6d6d;\n}\n.hp.actcount.overflow2 > div.overflow:not(.lost) {\n  background: #ad813f;\n  border: 1px solid #836d1f;\n}\n.hp.actcount > .lost {\n  background: #3f77ad;\n  border: 1px solid #1f5283;\n  filter: grayscale(1);\n  -webkit-filter: grayscale(1);\n}\n.hp > .lost {\n  background: #397b04;\n  border: 1px solid #274f07;\n  filter: grayscale(1);\n  -webkit-filter: grayscale(1);\n}\n.hp.text[data-condition=\"low\"],\n.hp.textstyle[data-condition=\"low\"] {\n  text-shadow: black 0 0 1px, #e83535 0 0 2px, #e83535 0 0 5px, #e83535 0 0 10px;\n}\n.hp.text[data-condition=\"mid\"],\n.hp.textstyle[data-condition=\"mid\"] {\n  text-shadow: black 0 0 1px, #ffcb00 0 0 2px, #ffcb00 0 0 5px, #ffcb00 0 0 10px;\n}\n.hp.text[data-condition=\"high\"],\n.hp.textstyle[data-condition=\"high\"] {\n  text-shadow: #397b04 0 0 2px, #397b04 0 0 5px, #397b04 0 0 10px;\n}\n.touchinfo {\n  padding: 6px;\n  position: absolute;\n  color: white;\n  text-shadow: black 0 0 2px;\n  top: 0;\n  margin: 0;\n  font-family: 'xinwei';\n}\n.touchinfo.left {\n  left: 0;\n}\n.touchinfo.right {\n  left: auto;\n  right: 0;\n  text-align: right;\n}\n#window.touchinfohidden > .touchinfo {\n  opacity: 0;\n}\n.button.replaceButton,\n.button.replaceButton.text {\n  left: 2px;\n  top: auto;\n  text-align: center;\n  width: 42px;\n  right: auto;\n  bottom: 3px;\n  background-image: linear-gradient(rgba(150, 47, 47, 0.8), rgba(132, 43, 43, 0.2));\n  border-radius: 3px;\n  font-family: 'LuoLiTi2', Helvetica, sans-serif;\n}\n.button.replaceButton > div {\n  width: 10px;\n  height: 10px;\n}\n#me .card.selected::after {\n  box-shadow: rgba(0, 0, 0, 0.2) 0 0 0 1px, #ff0000 0 0 5px, #ff0000 0 0 10px;\n}\n#me .card.glow::before {\n  box-shadow: rgba(0, 0, 0, 0.2) 0 0 0 1px, #0085ff 0 0 5px, #0085ff 0 0 10px;\n}\n#me .card.glows {\n  opacity: 1;\n  box-shadow: rgba(0, 0, 0, 0.2) 0 0 0 1px, #ff9933 0 0 5px, #ff9933 0 0 10px;\n}\n.glow:not(.button):not(.card) {\n  box-shadow: rgba(0, 0, 0, 0.2) 0 0 0 1px, rgba(0, 133, 255, 0.4) 0 0 5px, rgba(0, 133, 255, 0.5) 0 0 12px, rgba(0, 133, 255, 0.8) 0 0 15px !important;\n}\n.glow2:not(.player.glow_phase) > .displayer > .avatar {\n  /*-webkit-animation:control_glow 4s infinite;*/\n  box-shadow: rgba(0, 0, 0, 0.3) 0 0 0 1px, #0a9b43 0 0 15px, #0a9b43 0 0 15px !important;\n}\n.glow3 {\n  box-shadow: rgba(0, 0, 0, 0.4) 0 0 0 1px, rgba(0, 133, 255, 0.8) 0 0 10px, rgba(0, 133, 255, 0) 0 0 40px, rgba(0, 133, 255, 0.8) 0 0 60px !important;\n}\n.selectedx3 {\n  box-shadow: rgba(0, 0, 0, 0.4) 0 0 0 1px, rgba(255, 0, 0, 0.8) 0 0 10px, rgba(255, 0, 0, 0) 0 0 40px, rgba(255, 0, 0, 0.8) 0 0 60px !important;\n}\n.glow4 {\n  box-shadow: rgba(0, 0, 0, 0.4) 0 0 0 1px, rgba(0, 133, 255, 0.8) 0 0 10px, rgba(0, 133, 255, 0) 0 0 40px, rgba(0, 133, 255, 0.8) 0 0 40px !important;\n}\n.selectedx4 {\n  box-shadow: rgba(0, 0, 0, 0.4) 0 0 0 1px, rgba(255, 0, 0, 0.6) 0 0 10px, rgba(255, 0, 0, 0) 0 0 40px, rgba(255, 0, 0, 0.8) 0 0 40px !important;\n}\n.player:not(.glow_phase) .avatar.glow2,\n.button.glow2:not(.selected) {\n  box-shadow: rgba(0, 0, 0, 0.3) 0 0 0 1px, #0a9b43 0 0 5px, #0a9b43 0 0 5px, #0a9b43 0 0 10px, #0a9b43 0 0 10px !important;\n}\n.button.character > .identity {\n  top: -6px;\n  left: 72px;\n}\n.button.character.character.newstyle > .identity {\n  /*display: none;*/\n  border: none;\n  background: none !important;\n  /*box-shadow: none;*/\n  left: auto;\n  right: 3px;\n  top: 3px;\n  /*font-size: 20px;*/\n}\n.button.character > .name {\n  left: 5px;\n  top: 22px;\n  max-height: 68px;\n  overflow: hidden;\n}\n.button.character > .hp {\n  left: 5px;\n  top: 3px;\n}\n.button.character > .hp.text {\n  top: 8px;\n  left: 6px;\n  font-family: 'huangcao', 'xinwei';\n  font-size: 20px;\n  letter-spacing: 3px;\n}\n.button.character > .intro {\n  top: 71px;\n  left: 0;\n}\n.button.character > .identity {\n  top: -6px;\n  left: 72px;\n}\n.button.character.newstyle > .identity {\n  /*display: none;*/\n  border: none;\n  background: none !important;\n  /*box-shadow: none;*/\n  left: auto;\n  right: 3px;\n  top: 3px;\n  /*font-size: 20px;*/\n}\n.button.newstyle > .name {\n  top: 8px;\n  max-height: 84px;\n}\n.button.newstyle > .name.long {\n  top: 6px;\n  -webkit-transform: scale(0.93);\n          transform: scale(0.93);\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n}\n.button.newstyle > .hp,\n.button.newstyle > .hp.text {\n  left: auto;\n  top: auto;\n  text-align: right;\n  right: 6px;\n  bottom: 5px;\n}\n.button.newstyle > .hp > div {\n  width: 10px;\n  height: 10px;\n  background: #397b04;\n  border: 1px solid #274f07;\n  box-shadow: rgba(0, 0, 0, 0.2) 1px -1px 2px inset, rgba(255, 255, 255, 0.15) -1px 1px 5px inset;\n}\n.button.newstyle > .hp > div.text {\n  background: none !important;\n  box-shadow: none !important;\n  border: none !important;\n  font-family: 'Tiejili';\n  text-align: right;\n  width: auto;\n  height: auto;\n  -webkit-transform: none !important;\n          transform: none !important;\n  text-shadow: black 0 0 2px, black 0 0 3px;\n}\n.menu-container {\n  z-index: 8;\n}\n.menu-container div {\n  position: relative;\n}\n.menu-container.hidden {\n  pointer-events: none;\n}\n#menu-button {\n  z-index: 6;\n}\n.themebutton > div {\n  width: 50px;\n  height: 76px;\n  top: 7px;\n  right: 7px;\n  border-radius: 4px;\n}\n.themebutton > div:first-child {\n  z-index: 2;\n}\n.themebutton > div > div {\n  width: calc(100% - 10px);\n  height: 12px;\n  display: block;\n  margin-left: 5px;\n  margin-top: 6px;\n  position: relative;\n  border-radius: 2px;\n  box-shadow: rgba(0, 0, 0, 0.3) 0 0 0 1px, rgba(0, 0, 0, 0.3) 0 0 5px;\n  transition: all 0s;\n}\n.themebutton > div > div:first-child {\n  margin-top: 5px;\n}\n.themebutton > div > div > div {\n  width: 200%;\n  height: 200%;\n  left: 0;\n  top: 0;\n  -webkit-transform: scale(0.5);\n          transform: scale(0.5);\n  color: white;\n  box-shadow: black 0 0 2px;\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n  line-height: 24px;\n  text-align: center;\n  box-shadow: none !important;\n}\n.themebutton > .fakeplayer > .avatar {\n  width: calc(100% - 2px);\n  height: calc(100% - 2px);\n  left: 1px;\n  top: 1px;\n  border-radius: 2px;\n  position: absolute;\n  margin: 0 !important;\n  padding: 0;\n  box-shadow: rgba(0, 0, 0, 0.2) 0 0 0 1px inset;\n}\n.themebutton > .fakeplayer.me {\n  clip-path: polygon(-10px 0, 32px 0, 32px 32px, -10px 32px);\n  -webkit-clip-path: polygon(-10px 0, 32px 0, 32px 32px, -10px 32px);\n}\n.themebutton > .fakeplayer.me > .avatar {\n  width: 22px;\n  height: 22px;\n  left: 3px;\n  top: 0;\n  box-shadow: none;\n  border-radius: 0px;\n}\n.themebutton > .fakeplayer.oldlayout > .avatar {\n  width: calc(50% - 2px);\n}\n.popup-container {\n  z-index: 10;\n}\n.popup-container.filter-character {\n  text-align: center;\n  overflow: scroll;\n  opacity: 0;\n  transition: all 0.3s;\n}\n.popup-container.filter-character > div {\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: auto;\n  margin: 0;\n  padding: 0;\n  transition: all 0s;\n  position: relative;\n}\n.popup-container.filter-character > div > div {\n  position: relative;\n  margin: 10px;\n}\n.popup-container.filter-character > div > .capt {\n  width: 80px;\n  height: 80px;\n  padding: 0;\n  font-size: 60px;\n  line-height: 90px;\n}\n.popup-container.filter-character.shown {\n  opacity: 1;\n}\n.popup-container.filter-character.removing > div {\n  pointer-events: none;\n}\n.menu-container,\n.popup-container {\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n  position: absolute;\n}\n.roundarenabutton {\n  /*width: 50px;\n\theight: 50px;*/\n  left: 180px;\n  top: 210px;\n  position: absolute;\n  /*background: rgba(0,0,0,0.2);\n\tbox-shadow: rgba(0, 0, 0, 0.3) 0 0 0 1px;\n\tborder-radius:100%;*/\n  z-index: 7;\n  transition-property: opacity;\n  overflow: hidden;\n}\n#arena:not(.phone) #roundmenu {\n  display: none !important;\n}\n#roundmenu > div {\n  width: 26px;\n  height: 4px;\n  background: white;\n  position: absolute;\n  left: 12px;\n  border-radius: 2px;\n  box-shadow: black 0 0 2px;\n}\n#roundmenu:not(.clock) > div:nth-of-type(even) {\n  width: 20px;\n  left: 18px;\n}\n#roundmenu:not(.clock) > div:nth-of-type(odd) {\n  width: 4px;\n}\n#roundmenu:not(.clock) > div:nth-of-type(1),\n#roundmenu:not(.clock) > div:nth-of-type(2) {\n  top: 14px;\n}\n#roundmenu:not(.clock) > div:nth-of-type(3),\n#roundmenu:not(.clock) > div:nth-of-type(4) {\n  top: 23px;\n}\n#roundmenu:not(.clock) > div:nth-of-type(5),\n#roundmenu:not(.clock) > div:nth-of-type(6) {\n  top: 32px;\n  -webkit-transform: none !important;\n          transform: none !important;\n}\n#roundmenu:not(.clock) > div:nth-of-type(7),\n#roundmenu:not(.clock) > div:nth-of-type(8),\n#roundmenu:not(.clock) > div:nth-of-type(9),\n#roundmenu:not(.clock) > div:nth-of-type(10),\n#roundmenu:not(.clock) > div:nth-of-type(11),\n#roundmenu:not(.clock) > div:nth-of-type(12),\n#roundmenu:not(.clock) > div:nth-of-type(13),\n#roundmenu:not(.clock) > div:nth-of-type(14),\n#roundmenu:not(.clock) > div:nth-of-type(15) {\n  opacity: 0;\n}\n#roundmenu.clock > div {\n  width: 2px;\n  height: 2px;\n}\n#roundmenu.clock > div:nth-of-type(1) {\n  left: 24px;\n  top: 2px;\n  opacity: 1;\n}\n#roundmenu.clock > div:nth-of-type(2) {\n  left: 24px;\n  top: 46px;\n  opacity: 1;\n}\n#roundmenu.clock > div:nth-of-type(3) {\n  top: 24px;\n  left: 2px;\n  opacity: 1;\n}\n#roundmenu.clock > div:nth-of-type(4) {\n  top: 24px;\n  left: 46px;\n  opacity: 1;\n}\n#roundmenu.clock > div:nth-of-type(5) {\n  left: 24px;\n  top: 2px;\n  opacity: 0.4;\n  -webkit-transform: rotate(30deg);\n          transform: rotate(30deg);\n  -webkit-transform-origin: 1px 23px;\n          transform-origin: 1px 23px;\n}\n#roundmenu.clock > div:nth-of-type(6) {\n  left: 24px;\n  top: 46px;\n  opacity: 0.4;\n  -webkit-transform: rotate(30deg);\n          transform: rotate(30deg);\n  -webkit-transform-origin: 1px -23px;\n          transform-origin: 1px -23px;\n}\n#roundmenu.clock > div:nth-of-type(7) {\n  top: 24px;\n  left: 2px;\n  opacity: 0.4;\n  -webkit-transform: rotate(30deg);\n          transform: rotate(30deg);\n  -webkit-transform-origin: 23px 1px;\n          transform-origin: 23px 1px;\n}\n#roundmenu.clock > div:nth-of-type(8) {\n  top: 24px;\n  left: 46px;\n  opacity: 0.4;\n  -webkit-transform: rotate(30deg);\n          transform: rotate(30deg);\n  -webkit-transform-origin: -23px 1px;\n          transform-origin: -23px 1px;\n}\n#roundmenu.clock > div:nth-of-type(9) {\n  left: 24px;\n  top: 2px;\n  opacity: 0.4;\n  -webkit-transform: rotate(60deg);\n          transform: rotate(60deg);\n  -webkit-transform-origin: 1px 23px;\n          transform-origin: 1px 23px;\n}\n#roundmenu.clock > div:nth-of-type(10) {\n  left: 24px;\n  top: 46px;\n  opacity: 0.4;\n  -webkit-transform: rotate(60deg);\n          transform: rotate(60deg);\n  -webkit-transform-origin: 1px -23px;\n          transform-origin: 1px -23px;\n}\n#roundmenu.clock > div:nth-of-type(11) {\n  top: 24px;\n  left: 2px;\n  opacity: 0.4;\n  -webkit-transform: rotate(60deg);\n          transform: rotate(60deg);\n  -webkit-transform-origin: 23px 1px;\n          transform-origin: 23px 1px;\n}\n#roundmenu.clock > div:nth-of-type(12) {\n  top: 24px;\n  left: 46px;\n  opacity: 0.4;\n  -webkit-transform: rotate(60deg);\n          transform: rotate(60deg);\n  -webkit-transform-origin: -23px 1px;\n          transform-origin: -23px 1px;\n}\n#roundmenu.clock > div:nth-of-type(13) {\n  width: 22px;\n  height: 2px;\n  top: 24px;\n  left: 24px;\n  -webkit-transform-origin: 1px 1px;\n          transform-origin: 1px 1px;\n  border-radius: 4px 40px 40px 4px/4px 4px 4px 4px;\n}\n#roundmenu.clock > div:nth-of-type(14) {\n  width: 16px;\n  height: 4px;\n  top: 23px;\n  left: 23px;\n  -webkit-transform-origin: 2px 2px;\n          transform-origin: 2px 2px;\n  border-radius: 4px 23px 23px 4px/4px 4px 4px 4px;\n}\n#roundmenu.clock > div:nth-of-type(15) {\n  width: 80%;\n  height: 80%;\n  left: 10%;\n  top: 10%;\n  border-radius: 100%;\n  margin: 0;\n  padding: 0;\n  z-index: -1;\n  opacity: 0;\n}\n#roundmenu.clock[data-watchface=\"simple\"] > div:nth-of-type(1),\n#roundmenu.clock[data-watchface=\"simple\"] > div:nth-of-type(2),\n#roundmenu.clock[data-watchface=\"simple\"] > div:nth-of-type(3),\n#roundmenu.clock[data-watchface=\"simple\"] > div:nth-of-type(4),\n#roundmenu.clock[data-watchface=\"simple\"] > div:nth-of-type(5),\n#roundmenu.clock[data-watchface=\"simple\"] > div:nth-of-type(6),\n#roundmenu.clock[data-watchface=\"simple\"] > div:nth-of-type(7),\n#roundmenu.clock[data-watchface=\"simple\"] > div:nth-of-type(8),\n#roundmenu.clock[data-watchface=\"simple\"] > div:nth-of-type(9),\n#roundmenu.clock[data-watchface=\"simple\"] > div:nth-of-type(10),\n#roundmenu.clock[data-watchface=\"simple\"] > div:nth-of-type(11),\n#roundmenu.clock[data-watchface=\"simple\"] > div:nth-of-type(12) {\n  opacity: 0;\n}\n#roundmenu.clock[data-watchface=\"simple\"] > div:nth-of-type(15) {\n  opacity: 1;\n}\n.skilltext {\n  text-indent: 32px;\n}\n/** 已修改 */\n.skill {\n  left: 0 !important;\n  width: 72px !important;\n  white-space: nowrap;\n  font-family: 'LuoLiTi2', Helvetica, sans-serif;\n}\n.skill::before {\n  content: '『';\n}\n.skill::after {\n  content: '』';\n}\n.skilln {\n  left: 0 !important;\n  width: 70px !important;\n}\n.skill > .card {\n  -webkit-transform: scale(0.56);\n          transform: scale(0.56);\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n  margin-left: 2px;\n  margin-top: 6px;\n  margin-bottom: -52px;\n}\n.player .identity[data-color=\"zhu\"],\n.player .identity[data-color=\"truezhu\"],\n.player .identity[data-color=\"enemy\"] {\n  text-shadow: black 0 0 1px, #e83535 0 0 2px, #e83535 0 0 5px, #e83535 0 0 10px, #e83535 0 0 10px, #e83535 0 0 20px, #e83535 0 0 20px;\n}\ndiv[data-nature='fire'],\nspan[data-nature='fire'] {\n  text-shadow: black 0 0 1px, #e83535 0 0 2px, #e83535 0 0 5px, #e83535 0 0 10px, #e83535 0 0 10px, #e83535 0 0 20px, #e83535 0 0 20px;\n}\ndiv[data-nature='firem'],\nspan[data-nature='firem'] {\n  text-shadow: black 0 0 1px, #e83535 0 0 2px, #e83535 0 0 5px, #e83535 0 0 5px, #e83535 0 0 5px, black 0 0 1px;\n}\ndiv[data-nature='firemm'],\nspan[data-nature='firemm'] {\n  text-shadow: black 0 0 1px, #e83535 0 0 2px, #e83535 0 0 2px, #e83535 0 0 2px, #e83535 0 0 2px, black 0 0 1px;\n}\ndiv[data-nature='firemx'],\nspan[data-nature='firemx'] {\n  text-shadow: black 0 0 1px, rgba(232, 53, 53, 0.001) 0 0 2px, #e83535 0 0 2px, #e83535 0 0 5px, #e83535 0 0 5px, black 0 0 1px;\n}\n.player .identity[data-color=\"mingzhong\"],\n.player .identity[data-color=\"rZhu\"],\n.player .identity[data-color=\"rZhong\"],\n.player .identity[data-color=\"rNei\"],\n.player .identity[data-color=\"cai2\"] {\n  text-shadow: black 0 0 1px, #ff7800 0 0 2px, #ff7800 0 0 5px, #ff7800 0 0 10px, #ff7800 0 0 10px, #ff7800 0 0 20px, #ff7800 0 0 20px;\n}\ndiv[data-nature='orange'],\nspan[data-nature='orange'] {\n  text-shadow: black 0 0 1px, #ff7800 0 0 2px, #ff7800 0 0 5px, #ff7800 0 0 10px, #ff7800 0 0 10px, #ff7800 0 0 20px, #ff7800 0 0 20px;\n}\ndiv[data-nature='orangem'],\nspan[data-nature='orangem'] {\n  text-shadow: black 0 0 1px, #ff7800 0 0 2px, #ff7800 0 0 5px, #ff7800 0 0 5px, #ff7800 0 0 5px, black 0 0 1px;\n}\ndiv[data-nature='orangemm'],\nspan[data-nature='orangemm'] {\n  text-shadow: black 0 0 1px, #ff7800 0 0 2px, #ff7800 0 0 2px, #ff7800 0 0 2px, #ff7800 0 0 2px, black 0 0 1px;\n}\ndiv[data-nature='orangemx'],\nspan[data-nature='orangemx'] {\n  text-shadow: black 0 0 1px, rgba(255, 120, 0, 0.001) 0 0 2px, #ff7800 0 0 2px, #ff7800 0 0 5px, #ff7800 0 0 5px, black 0 0 1px;\n}\n.player .identity[data-color=\"zhong\"],\n.player .identity[data-color=\"qun\"],\n.player .identity[data-color=\"neutral\"],\n.player .identity[data-color=\"friend2\"],\ndiv[data-nature='metal'],\nspan[data-nature='metal'] {\n  text-shadow: black 0 0 1px, #ffcb00 0 0 2px, #ffcb00 0 0 5px, #ffcb00 0 0 10px, #ffcb00 0 0 10px, #ffcb00 0 0 20px, #ffcb00 0 0 20px;\n}\ndiv[data-nature='metalm'],\nspan[data-nature='metalm'] {\n  text-shadow: black 0 0 1px, #ffcb00 0 0 2px, #ffcb00 0 0 5px, #ffcb00 0 0 5px, #ffcb00 0 0 5px, black 0 0 1px;\n}\ndiv[data-nature='metalmm'],\nspan[data-nature='metalmm'] {\n  text-shadow: black 0 0 1px, #ffcb00 0 0 2px, #ffcb00 0 0 2px, #ffcb00 0 0 2px, #ffcb00 0 0 2px, black 0 0 1px;\n}\ndiv[data-nature='metalmx'],\nspan[data-nature='metalmx'] {\n  text-shadow: black 0 0 1px, rgba(255, 203, 0, 0.001) 0 0 2px, #ffcb00 0 0 2px, #ffcb00 0 0 5px, #ffcb00 0 0 5px, black 0 0 1px;\n}\n.player .identity[data-color=\"key\"] {\n  text-shadow: black 0 0 1px, #cbb1ff 0 0 2px, #cbb1ff 0 0 5px, #cbb1ff 0 0 10px, #cbb1ff 0 0 10px, #cbb1ff 0 0 20px, #cbb1ff 0 0 20px;\n}\ndiv[data-nature='key'],\nspan[data-nature='key'] {\n  text-shadow: black 0 0 1px, #cbb1ff 0 0 2px, #cbb1ff 0 0 5px, #cbb1ff 0 0 10px, #cbb1ff 0 0 10px, #cbb1ff 0 0 20px, #cbb1ff 0 0 20px;\n}\ndiv[data-nature='keym'],\nspan[data-nature='keym'] {\n  text-shadow: black 0 0 1px, #cbb1ff 0 0 2px, #cbb1ff 0 0 5px, #cbb1ff 0 0 5px, #cbb1ff 0 0 5px, black 0 0 1px;\n}\ndiv[data-nature='keymm'],\nspan[data-nature='keymm'] {\n  text-shadow: black 0 0 1px, #cbb1ff 0 0 2px, #cbb1ff 0 0 2px, #cbb1ff 0 0 2px, #cbb1ff 0 0 2px, black 0 0 1px;\n}\ndiv[data-nature='keymx'],\nspan[data-nature='keymx'] {\n  text-shadow: black 0 0 1px, rgba(203, 177, 255, 0.001) 0 0 2px, #cbb1ff 0 0 2px, #cbb1ff 0 0 5px, #cbb1ff 0 0 5px, black 0 0 1px;\n}\n.player .identity[data-color=\"nei\"],\n.player .identity[data-color=\"ye\"],\n.player .identity[data-color=\"rYe\"],\n.player .identity[data-color=\"bYe\"],\n.player .identity[data-color=\"jin\"] {\n  text-shadow: black 0 0 1px, #644a8b 0 0 2px, #644a8b 0 0 5px, #644a8b 0 0 10px, #644a8b 0 0 10px, #644a8b 0 0 20px, #644a8b 0 0 20px;\n}\ndiv[data-nature='thunder'],\nspan[data-nature='thunder'] {\n  text-shadow: black 0 0 1px, #644a8b 0 0 2px, #644a8b 0 0 5px, #644a8b 0 0 10px, #644a8b 0 0 10px, #644a8b 0 0 20px, #644a8b 0 0 20px;\n}\ndiv[data-nature='thunderm'],\nspan[data-nature='thunderm'] {\n  text-shadow: black 0 0 1px, #644a8b 0 0 2px, #644a8b 0 0 5px, #644a8b 0 0 5px, #644a8b 0 0 5px, black 0 0 1px;\n}\ndiv[data-nature='thundermm'],\nspan[data-nature='thundermm'] {\n  text-shadow: black 0 0 1px, #644a8b 0 0 2px, #644a8b 0 0 2px, #644a8b 0 0 2px, #644a8b 0 0 2px, black 0 0 1px;\n}\ndiv[data-nature='thundermx'],\nspan[data-nature='thundermx'] {\n  text-shadow: black 0 0 1px, rgba(100, 74, 139, 0.001) 0 0 2px, #644a8b 0 0 2px, #644a8b 0 0 5px, #644a8b 0 0 5px, black 0 0 1px;\n}\n.player .identity[data-color=\"kami\"] {\n  text-shadow: black 0 0 1px, #5a7663 0 0 2px, #5a7663 0 0 5px, #5a7663 0 0 10px, #5a7663 0 0 10px, #5a7663 0 0 20px, #5a7663 0 0 20px;\n}\ndiv[data-nature='kami'],\nspan[data-nature='kami'] {\n  text-shadow: black 0 0 1px, #5a7663 0 0 2px, #5a7663 0 0 5px, #5a7663 0 0 10px, #5a7663 0 0 10px, #5a7663 0 0 20px, #5a7663 0 0 20px;\n}\ndiv[data-nature='kamim'],\nspan[data-nature='kamim'] {\n  text-shadow: black 0 0 1px, #5a7663 0 0 2px, #5a7663 0 0 5px, #5a7663 0 0 5px, #5a7663 0 0 5px, black 0 0 1px;\n}\ndiv[data-nature='kamimm'],\nspan[data-nature='kamimm'] {\n  text-shadow: black 0 0 1px, #5a7663 0 0 2px, #5a7663 0 0 2px, #5a7663 0 0 2px, #5a7663 0 0 2px, black 0 0 1px;\n}\ndiv[data-nature='kamimx'],\nspan[data-nature='kamimx'] {\n  text-shadow: black 0 0 1px, rgba(90, 118, 99, 0.001) 0 0 2px, #5a7663 0 0 2px, #5a7663 0 0 5px, #5a7663 0 0 5px, black 0 0 1px;\n}\n.player .identity[data-color=\"fan\"],\n.player .identity[data-color=\"wu\"] {\n  text-shadow: black 0 0 1px, #397b04 0 0 2px, #397b04 0 0 5px, #397b04 0 0 10px, #397b04 0 0 10px, #397b04 0 0 20px, #397b04 0 0 20px;\n}\ndiv[data-nature='wood'],\nspan[data-nature='wood'] {\n  text-shadow: black 0 0 1px, #397b04 0 0 2px, #397b04 0 0 5px, #397b04 0 0 10px, #397b04 0 0 10px, #397b04 0 0 20px, #397b04 0 0 20px;\n}\ndiv[data-nature='woodm'],\nspan[data-nature='woodm'] {\n  text-shadow: black 0 0 1px, #397b04 0 0 2px, #397b04 0 0 5px, #397b04 0 0 5px, #397b04 0 0 5px, black 0 0 1px;\n}\ndiv[data-nature='woodmm'],\nspan[data-nature='woodmm'] {\n  text-shadow: black 0 0 1px, #397b04 0 0 2px, #397b04 0 0 2px, #397b04 0 0 2px, #397b04 0 0 2px, black 0 0 1px;\n}\ndiv[data-nature='woodmx'],\nspan[data-nature='woodmx'] {\n  text-shadow: black 0 0 1px, rgba(57, 123, 4, 0.001) 0 0 2px, #397b04 0 0 2px, #397b04 0 0 5px, #397b04 0 0 5px, black 0 0 1px;\n}\n.player .identity[data-color=\"cai\"],\n.player .identity[data-color=\"bZhu\"],\n.player .identity[data-color=\"bZhong\"],\n.player .identity[data-color=\"bNei\"],\n.player .identity[data-color=\"wei\"],\n.player .identity[data-color=\"falsezhu\"],\n.player .identity[data-color=\"friend\"],\n.water {\n  text-shadow: black 0 0 1px, #4e758c 0 0 2px, #4e758c 0 0 5px, #4e758c 0 0 10px, #4e758c 0 0 10px, #4e758c 0 0 20px, #4e758c 0 0 20px;\n}\ndiv[data-nature='water'],\nspan[data-nature='water'] {\n  text-shadow: black 0 0 1px, #4e758c 0 0 2px, #4e758c 0 0 5px, #4e758c 0 0 10px, #4e758c 0 0 10px, #4e758c 0 0 20px, #4e758c 0 0 20px;\n}\ndiv[data-nature='waterm'],\nspan[data-nature='waterm'] {\n  text-shadow: black 0 0 1px, #4e758c 0 0 2px, #4e758c 0 0 5px, #4e758c 0 0 5px, #4e758c 0 0 5px, black 0 0 1px;\n}\ndiv[data-nature='watermm'],\nspan[data-nature='watermm'] {\n  text-shadow: black 0 0 1px, #4e758c 0 0 2px, #4e758c 0 0 2px, #4e758c 0 0 2px, #4e758c 0 0 2px, black 0 0 1px;\n}\ndiv[data-nature='watermx'],\nspan[data-nature='watermx'] {\n  text-shadow: black 0 0 1px, rgba(78, 117, 140, 0.001) 0 0 2px, #4e758c 0 0 2px, #4e758c 0 0 5px, #4e758c 0 0 5px, black 0 0 1px;\n}\n.player .identity[data-color=\"shu\"] {\n  text-shadow: black 0 0 1px, #4e758c 0 0 2px, #4e758c 0 0 5px, #4e758c 0 0 10px, #4e758c 0 0 10px, #4e758c 0 0 20px, #4e758c 0 0 20px;\n}\ndiv[data-nature='soil'],\nspan[data-nature='soil'] {\n  text-shadow: black 0 0 1px, #4e758c 0 0 2px, #4e758c 0 0 5px, #4e758c 0 0 10px, #4e758c 0 0 10px, #4e758c 0 0 20px, #4e758c 0 0 20px;\n}\ndiv[data-nature='soilm'],\nspan[data-nature='soilm'] {\n  text-shadow: black 0 0 1px, #4e758c 0 0 2px, #4e758c 0 0 5px, #4e758c 0 0 5px, #4e758c 0 0 5px, black 0 0 1px;\n}\ndiv[data-nature='soilmm'],\nspan[data-nature='soilmm'] {\n  text-shadow: black 0 0 1px, #4e758c 0 0 2px, #4e758c 0 0 2px, #4e758c 0 0 2px, #4e758c 0 0 2px, black 0 0 1px;\n}\ndiv[data-nature='soilmx'],\nspan[data-nature='soilmx'] {\n  text-shadow: black 0 0 1px, rgba(78, 117, 140, 0.001) 0 0 2px, #4e758c 0 0 2px, #4e758c 0 0 5px, #4e758c 0 0 5px, black 0 0 1px;\n}\ndiv[data-nature='gray'],\nspan[data-nature='gray'] {\n  text-shadow: black 0 0 1px, #d5c2b3 0 0 2px, #d5c2b3 0 0 5px, #d5c2b3 0 0 10px, #d5c2b3 0 0 10px, #d5c2b3 0 0 20px, #d5c2b3 0 0 20px;\n}\ndiv[data-nature='graym'],\nspan[data-nature='graym'] {\n  text-shadow: black 0 0 1px, #d5c2b3 0 0 2px, #d5c2b3 0 0 5px, #d5c2b3 0 0 5px, #d5c2b3 0 0 5px, black 0 0 1px;\n}\ndiv[data-nature='graymm'],\nspan[data-nature='graymm'] {\n  text-shadow: black 0 0 1px, #d5c2b3 0 0 2px, #d5c2b3 0 0 2px, #d5c2b3 0 0 2px, #d5c2b3 0 0 2px, black 0 0 1px;\n}\ndiv[data-nature='graymx'],\nspan[data-nature='graymx'] {\n  text-shadow: black 0 0 1px, rgba(213, 194, 179, 0.001) 0 0 2px, #d5c2b3 0 0 2px, #d5c2b3 0 0 5px, #d5c2b3 0 0 5px, black 0 0 1px;\n}\ndiv[data-nature='ice'],\nspan[data-nature='ice'] {\n  text-shadow: black 0 0 1px, #748884 0 0 2px, #748884 0 0 5px, #748884 0 0 10px, #748884 0 0 10px, #748884 0 0 20px, #748884 0 0 20px;\n}\ndiv[data-nature='icem'],\nspan[data-nature='icem'] {\n  text-shadow: black 0 0 1px, #748884 0 0 2px, #748884 0 0 5px, #748884 0 0 5px, #748884 0 0 5px, black 0 0 1px;\n}\ndiv[data-nature='icemm'],\nspan[data-nature='icemm'] {\n  text-shadow: black 0 0 1px, #748884 0 0 2px, #748884 0 0 2px, #748884 0 0 2px, #748884 0 0 2px, black 0 0 1px;\n}\ndiv[data-nature='icemx'],\nspan[data-nature='icemx'] {\n  text-shadow: black 0 0 1px, rgba(116, 136, 132, 0.001) 0 0 2px, #748884 0 0 2px, #748884 0 0 5px, #748884 0 0 5px, black 0 0 1px;\n}\ndiv[data-nature='ocean'],\nspan[data-nature='ocean'] {\n  text-shadow: black 0 0 1px, #452f97 0 0 2px, #452f97 0 0 5px, #452f97 0 0 10px, #452f97 0 0 10px, #452f97 0 0 20px, #452f97 0 0 20px;\n}\ndiv[data-nature='oceanm'],\nspan[data-nature='oceanm'] {\n  text-shadow: black 0 0 1px, #452f97 0 0 2px, #452f97 0 0 5px, #452f97 0 0 5px, #452f97 0 0 5px, black 0 0 1px;\n}\ndiv[data-nature='oceanmm'],\nspan[data-nature='oceanmm'] {\n  text-shadow: black 0 0 1px, #452f97 0 0 2px, #452f97 0 0 2px, #452f97 0 0 2px, #452f97 0 0 2px, black 0 0 1px;\n}\ndiv[data-nature='oceanmx'],\nspan[data-nature='oceanmx'] {\n  text-shadow: black 0 0 1px, rgba(69, 47, 151, 0.001) 0 0 2px, #452f97 0 0 2px, #452f97 0 0 5px, #452f97 0 0 5px, black 0 0 1px;\n}\ndiv[data-nature='yami'],\nspan[data-nature='yami'] {\n  text-shadow: black 0 0 1px, #6f5979 0 0 2px, #6f5979 0 0 5px, #6f5979 0 0 10px, #6f5979 0 0 10px, #6f5979 0 0 20px, #6f5979 0 0 20px;\n}\ndiv[data-nature='yamim'],\nspan[data-nature='yamim'] {\n  text-shadow: black 0 0 1px, #6f5979 0 0 2px, #6f5979 0 0 5px, #6f5979 0 0 5px, #6f5979 0 0 5px, black 0 0 1px;\n}\ndiv[data-nature='yamimm'],\nspan[data-nature='yamimm'] {\n  text-shadow: black 0 0 1px, #6f5979 0 0 2px, #6f5979 0 0 2px, #6f5979 0 0 2px, #6f5979 0 0 2px, black 0 0 1px;\n}\ndiv[data-nature='yamimx'],\nspan[data-nature='yamimx'] {\n  text-shadow: black 0 0 1px, rgba(111, 89, 121, 0.001) 0 0 2px, #6f5979 0 0 2px, #6f5979 0 0 5px, #6f5979 0 0 5px, black 0 0 1px;\n}\ndiv[data-nature='black'],\nspan[data-nature='black'] {\n  text-shadow: black 0 0 1px, rgba(0, 0, 0, 0.5) 0 0 2px, rgba(0, 0, 0, 0.5) 0 0 5px, rgba(0, 0, 0, 0.5) 0 0 10px, rgba(0, 0, 0, 0.5) 0 0 10px, rgba(0, 0, 0, 0.5) 0 0 20px, rgba(0, 0, 0, 0.5) 0 0 20px;\n}\ndiv[data-nature='unknownm'],\nspan[data-nature='unknownm'] {\n  text-shadow: black 0 0 1px, rgba(0, 0, 0, 0.5) 0 0 2px, rgba(0, 0, 0, 0.5) 0 0 5px, rgba(0, 0, 0, 0.5) 0 0 5px, rgba(0, 0, 0, 0.5) 0 0 5px, black 0 0 1px;\n}\ndiv[data-nature='unknown'],\nspan[data-nature='unknown'] {\n  text-shadow: black 0 0 1px, #6f5979 0 0 2px, #6f5979 0 0 2px, #6f5979 0 0 2px, #6f5979 0 0 2px, black 0 0 1px;\n}\n.player .identity[data-color=\"unknownx\"] {\n  text-shadow: black 0 0 1px, rgba(0, 0, 0, 0.5) 0 0 2px, rgba(0, 0, 0, 0.5) 0 0 5px, rgba(0, 0, 0, 0.5) 0 0 10px, rgba(0, 0, 0, 0.5) 0 0 10px, rgba(0, 0, 0, 0.5) 0 0 20px, rgba(0, 0, 0, 0.5) 0 0 20px;\n}\ndiv[data-nature=\"unknown\"] {\n  text-shadow: rgba(0, 0, 0, 0.2) 0 0 2px, rgba(0, 0, 0, 0.2) 0 0 5px, rgba(0, 0, 0, 0.2) 0 0 10px, rgba(0, 0, 0, 0.2) 0 0 10px, rgba(0, 0, 0, 0.2) 0 0 20px, rgba(0, 0, 0, 0.2) 0 0 20px, rgba(0, 0, 0, 0.6) 0 0 1px;\n}\n#window:not(.nopointer) #control {\n  cursor: pointer;\n}\n#window:not(.nopointer) #system > div > div:not(.hidden),\n#window:not(.nopointer) .choosedouble.character,\n#window:not(.nopointer) .config.more,\n#window:not(.nopointer) .dashboard,\n#window:not(.nopointer) .textlink,\n#window:not(.nopointer) .hrefnode,\n#window:not(.nopointer) #historybar > div > div,\n#window:not(.nopointer) .closenode,\n#window:not(.nopointer) .pointerdiv,\n#window:not(.nopointer) .pointernode div,\n#window:not(.nopointer) .pointerspan span,\n#window:not(.nopointer) .pointertable td > span,\n#window:not(.nopointer) .config > .toggle.onoff,\n#window:not(.nopointer) .pointerdialog .button:not(.unselectable),\n#window:not(.nopointer) .dialog.fullheight .buttons .button:not(.selectedx):not(.glow):not(.glows):not(.forbidden),\n#window:not(.nopointer) #arena.selecting:not(.video) .player .equips > .card.selectable,\n#window:not(.nopointer) #arena.selecting #me .card.selectable,\n#window:not(.nopointer) #arena.selecting .button.selectable,\n#window:not(.nopointer) #arena.selecting .player.selectable,\n#window:not(.nopointer) .menubutton.round,\n#window:not(.nopointer) *[data-cursor_style=\"pointer\"] {\n  cursor: pointer;\n}\n#window:not(.nopointer) .player .judges > .card,\n#window:not(.nopointer) .player .marks > .card {\n  cursor: context-menu;\n}\n#window:not(.nopointer) .player .identity.guessing {\n  cursor: help;\n}\n#window:not(.nopointer) > .choosedouble.character.moved:not(.selecting) {\n  cursor: default;\n}\n#window:not(.nopointer) .cardpiledelete {\n  cursor: pointer;\n}\n#window:not(.nopointer) .menubg.charactercard .menubutton:not(.ava):not(.intro):not(.unselectable),\n#window:not(.nopointer) .menubg.charactercard > .ava > .avatars > div {\n  cursor: pointer;\n}\n#window:not(.nopointer) .popup-container > .menu > div {\n  cursor: pointer;\n}\n#window:not(.nopointer) .popup-container > .menu.visual.withbar > div:last-child > div {\n  cursor: pointer;\n}\n#window:not(.nopointer) input.fileinput {\n  cursor: pointer;\n}\n#window:not(.nopointer) .config.switcher > div,\n#window:not(.nopointer) .config.toggle > div {\n  cursor: pointer;\n}\n#window:not(.nopointer) .videonode.menubutton.extension > .caption > .menubutton:not(.transparent2):not(.nopointer) {\n  cursor: pointer;\n}\n#window:not(.nopointer) .popup-container > .prompt-container > div > div > div > .menubutton {\n  cursor: pointer;\n}\n", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 3855:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4933);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3476);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* *{\n    cursor: url('./cursor/aero_arrow_glow.cur'),auto;\n} */\n.card_hightlight {\n  -webkit-animation: pulse 5s infinite;\n          animation: pulse 5s infinite;\n}\n.player_buff {\n  animation: game_start 0.2s;\n  -webkit-animation: game_start 0.2s;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n  z-index: 3;\n  pointer-events: none;\n  background: rgba(255, 150, 0, 0.45);\n}\n.player_nerf {\n  animation: game_start 0.2s;\n  -webkit-animation: game_start 0.2s;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n  z-index: 3;\n  pointer-events: none;\n  background: rgba(10, 155, 70, 0.5);\n}\n@-webkit-keyframes pulse {\n  0% {\n    box-shadow: 0 0 8px 6px #fff;\n  }\n  50% {\n    box-shadow: 0 0 8px 6px #faf607;\n  }\n  100% {\n    box-shadow: 0 0 8px 6px #fff;\n  }\n}\n@keyframes pulse {\n  0% {\n    box-shadow: 0 0 8px 6px #fff;\n  }\n  50% {\n    box-shadow: 0 0 8px 6px #faf607;\n  }\n  100% {\n    box-shadow: 0 0 8px 6px #fff;\n  }\n}\n.displayer {\n  left: 0;\n  top: 0;\n  width: 100% !important;\n  height: 100% !important;\n}\n#window:not(.low_performance) .player.fullskin.glow_phase .displayer::before {\n  content: '';\n  position: absolute;\n  pointer-events: none;\n  z-index: 3;\n  width: 100%;\n  height: 100%;\n  background: linear-gradient(#1a98ca, #1a98ca), linear-gradient(90deg, rgba(255,255,255,0.2) 1px, transparent 0, transparent 19px), linear-gradient(rgba(255,255,255,0.2) 1px, transparent 0, transparent 19px), linear-gradient(transparent, #1a98ca);\n  background-size: 100% 1.5%, 10% 100%, 100% 8%, 100% 100%;\n  background-repeat: no-repeat, repeat, repeat, no-repeat;\n  background-position: 0% 0%, 0 0, 0 0, 0 0;\n  /* 初始位置 */\n  -webkit-clip-path: polygon(0% 0%, 100% 0%, 100% 1.5%, 0% 1.5%);\n          clip-path: polygon(0% 0%, 100% 0%, 100% 1.5%, 0% 1.5%);\n  /* 添加动画效果 */\n  -webkit-animation: move-wrapper 3s infinite linear;\n          animation: move-wrapper 3s infinite linear;\n}\n#window:not(.low_performance) .player .displayer::after,\n#window:not(.low_performance) .card .displayer::after {\n  content: '已选择';\n  position: absolute;\n  pointer-events: none;\n  z-index: 4;\n  width: 100%;\n  height: 100%;\n  top: calc(50% - 1em);\n  left: calc(45% - 1.5em);\n  font-size: larger;\n  font-family: 'Tiejili', 'LuoLiTi2', sans-serif;\n  color: white;\n  opacity: 0;\n  transition: all 1s;\n}\n#window:not(.low_performance) .player.selected .displayer::after,\n#window:not(.low_performance) .card.selected .displayer::after {\n  text-shadow: 0 0 2px #F00, 0px 0px 4px #a54d2a;\n  opacity: 1;\n}\n@-webkit-keyframes move-wrapper {\n  from {\n    opacity: 0.2;\n  }\n  85% {\n    opacity: 0.9;\n    background-position: 0 100%, 0 0, 0 0, 0 0;\n    /* 终止位置 */\n    -webkit-clip-path: polygon(0% 0%, 100% 0%, 100% 95%, 0% 95%);\n            clip-path: polygon(0% 0%, 100% 0%, 100% 95%, 0% 95%);\n  }\n  to {\n    opacity: 0.1;\n    background-position: 0 100%, 0 0, 0 0, 0 0;\n    /* 终止位置 */\n    -webkit-clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);\n            clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);\n  }\n}\n@keyframes move-wrapper {\n  from {\n    opacity: 0.2;\n  }\n  85% {\n    opacity: 0.9;\n    background-position: 0 100%, 0 0, 0 0, 0 0;\n    /* 终止位置 */\n    -webkit-clip-path: polygon(0% 0%, 100% 0%, 100% 95%, 0% 95%);\n            clip-path: polygon(0% 0%, 100% 0%, 100% 95%, 0% 95%);\n  }\n  to {\n    opacity: 0.1;\n    background-position: 0 100%, 0 0, 0 0, 0 0;\n    /* 终止位置 */\n    -webkit-clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);\n            clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);\n  }\n}\ntd.warnning_flash {\n  text-shadow: 0 0 2px #F00, 0px 0px 4px #a54d2a;\n  -webkit-animation: nofade_flash 2s infinite;\n          animation: nofade_flash 2s infinite;\n}\n.slow_flash {\n  animation: nofade_flash 5s infinite;\n  -webkit-animation: nofade_flash 5s infinite;\n}\n@-webkit-keyframes nofade_flash {\n  0% {\n    opacity: 1;\n  }\n  50% {\n    opacity: 0.4;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n@keyframes nofade_flash {\n  0% {\n    opacity: 1;\n  }\n  50% {\n    opacity: 0.4;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 3476:
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ 4933:
/***/ ((module) => {

"use strict";


module.exports = function (i) {
  return i[1];
};

/***/ }),

/***/ 6459:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);

const pathFile = path.join(__dirname, 'path.txt');

function getElectronPath () {
  let executablePath;
  if (fs.existsSync(pathFile)) {
    executablePath = fs.readFileSync(pathFile, 'utf-8');
  }
  if (process.env.ELECTRON_OVERRIDE_DIST_PATH) {
    return path.join(process.env.ELECTRON_OVERRIDE_DIST_PATH, executablePath || 'electron');
  }
  if (executablePath) {
    return path.join(__dirname, 'dist', executablePath);
  } else {
    throw new Error('Electron failed to install correctly, please delete node_modules/electron and try installing again');
  }
}

module.exports = getElectronPath();


/***/ }),

/***/ 2858:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!

JSZip v3.7.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/

!function(t){if(true)module.exports=t();else {}}(function(){return function s(a,o,h){function u(r,t){if(!o[r]){if(!a[r]){var e=undefined;if(!t&&__webpack_require__(3441))return require(r,!0);if(l)return l(r,!0);var i=new Error("Cannot find module '"+r+"'");throw i.code="MODULE_NOT_FOUND",i}var n=o[r]={exports:{}};a[r][0].call(n.exports,function(t){var e=a[r][1][t];return u(e||t)},n,n.exports,s,a,o,h)}return o[r].exports}for(var l=undefined,t=0;t<h.length;t++)u(h[t]);return u}({1:[function(t,e,r){"use strict";var c=t("./utils"),d=t("./support"),p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";r.encode=function(t){for(var e,r,i,n,s,a,o,h=[],u=0,l=t.length,f=l,d="string"!==c.getTypeOf(t);u<t.length;)f=l-u,i=d?(e=t[u++],r=u<l?t[u++]:0,u<l?t[u++]:0):(e=t.charCodeAt(u++),r=u<l?t.charCodeAt(u++):0,u<l?t.charCodeAt(u++):0),n=e>>2,s=(3&e)<<4|r>>4,a=1<f?(15&r)<<2|i>>6:64,o=2<f?63&i:64,h.push(p.charAt(n)+p.charAt(s)+p.charAt(a)+p.charAt(o));return h.join("")},r.decode=function(t){var e,r,i,n,s,a,o=0,h=0,u="data:";if(t.substr(0,u.length)===u)throw new Error("Invalid base64 input, it looks like a data url.");var l,f=3*(t=t.replace(/[^A-Za-z0-9\+\/\=]/g,"")).length/4;if(t.charAt(t.length-1)===p.charAt(64)&&f--,t.charAt(t.length-2)===p.charAt(64)&&f--,f%1!=0)throw new Error("Invalid base64 input, bad content length.");for(l=d.uint8array?new Uint8Array(0|f):new Array(0|f);o<t.length;)e=p.indexOf(t.charAt(o++))<<2|(n=p.indexOf(t.charAt(o++)))>>4,r=(15&n)<<4|(s=p.indexOf(t.charAt(o++)))>>2,i=(3&s)<<6|(a=p.indexOf(t.charAt(o++))),l[h++]=e,64!==s&&(l[h++]=r),64!==a&&(l[h++]=i);return l}},{"./support":30,"./utils":32}],2:[function(t,e,r){"use strict";var i=t("./external"),n=t("./stream/DataWorker"),s=t("./stream/Crc32Probe"),a=t("./stream/DataLengthProbe");function o(t,e,r,i,n){this.compressedSize=t,this.uncompressedSize=e,this.crc32=r,this.compression=i,this.compressedContent=n}o.prototype={getContentWorker:function(){var t=new n(i.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")),e=this;return t.on("end",function(){if(this.streamInfo.data_length!==e.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),t},getCompressedWorker:function(){return new n(i.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},o.createWorkerFrom=function(t,e,r){return t.pipe(new s).pipe(new a("uncompressedSize")).pipe(e.compressWorker(r)).pipe(new a("compressedSize")).withStreamInfo("compression",e)},e.exports=o},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(t,e,r){"use strict";var i=t("./stream/GenericWorker");r.STORE={magic:"\0\0",compressWorker:function(t){return new i("STORE compression")},uncompressWorker:function(){return new i("STORE decompression")}},r.DEFLATE=t("./flate")},{"./flate":7,"./stream/GenericWorker":28}],4:[function(t,e,r){"use strict";var i=t("./utils");var o=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();e.exports=function(t,e){return void 0!==t&&t.length?"string"!==i.getTypeOf(t)?function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t}(0|e,t,t.length,0):function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e.charCodeAt(a))];return-1^t}(0|e,t,t.length,0):0}},{"./utils":32}],5:[function(t,e,r){"use strict";r.base64=!1,r.binary=!1,r.dir=!1,r.createFolders=!0,r.date=null,r.compression=null,r.compressionOptions=null,r.comment=null,r.unixPermissions=null,r.dosPermissions=null},{}],6:[function(t,e,r){"use strict";var i=null;i="undefined"!=typeof Promise?Promise:t("lie"),e.exports={Promise:i}},{lie:37}],7:[function(t,e,r){"use strict";var i="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,n=t("pako"),s=t("./utils"),a=t("./stream/GenericWorker"),o=i?"uint8array":"array";function h(t,e){a.call(this,"FlateWorker/"+t),this._pako=null,this._pakoAction=t,this._pakoOptions=e,this.meta={}}r.magic="\b\0",s.inherits(h,a),h.prototype.processChunk=function(t){this.meta=t.meta,null===this._pako&&this._createPako(),this._pako.push(s.transformTo(o,t.data),!1)},h.prototype.flush=function(){a.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},h.prototype.cleanUp=function(){a.prototype.cleanUp.call(this),this._pako=null},h.prototype._createPako=function(){this._pako=new n[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var e=this;this._pako.onData=function(t){e.push({data:t,meta:e.meta})}},r.compressWorker=function(t){return new h("Deflate",t)},r.uncompressWorker=function(){return new h("Inflate",{})}},{"./stream/GenericWorker":28,"./utils":32,pako:38}],8:[function(t,e,r){"use strict";function A(t,e){var r,i="";for(r=0;r<e;r++)i+=String.fromCharCode(255&t),t>>>=8;return i}function i(t,e,r,i,n,s){var a,o,h=t.file,u=t.compression,l=s!==O.utf8encode,f=I.transformTo("string",s(h.name)),d=I.transformTo("string",O.utf8encode(h.name)),c=h.comment,p=I.transformTo("string",s(c)),m=I.transformTo("string",O.utf8encode(c)),_=d.length!==h.name.length,g=m.length!==c.length,b="",v="",y="",w=h.dir,k=h.date,x={crc32:0,compressedSize:0,uncompressedSize:0};e&&!r||(x.crc32=t.crc32,x.compressedSize=t.compressedSize,x.uncompressedSize=t.uncompressedSize);var S=0;e&&(S|=8),l||!_&&!g||(S|=2048);var z=0,C=0;w&&(z|=16),"UNIX"===n?(C=798,z|=function(t,e){var r=t;return t||(r=e?16893:33204),(65535&r)<<16}(h.unixPermissions,w)):(C=20,z|=function(t){return 63&(t||0)}(h.dosPermissions)),a=k.getUTCHours(),a<<=6,a|=k.getUTCMinutes(),a<<=5,a|=k.getUTCSeconds()/2,o=k.getUTCFullYear()-1980,o<<=4,o|=k.getUTCMonth()+1,o<<=5,o|=k.getUTCDate(),_&&(v=A(1,1)+A(B(f),4)+d,b+="up"+A(v.length,2)+v),g&&(y=A(1,1)+A(B(p),4)+m,b+="uc"+A(y.length,2)+y);var E="";return E+="\n\0",E+=A(S,2),E+=u.magic,E+=A(a,2),E+=A(o,2),E+=A(x.crc32,4),E+=A(x.compressedSize,4),E+=A(x.uncompressedSize,4),E+=A(f.length,2),E+=A(b.length,2),{fileRecord:R.LOCAL_FILE_HEADER+E+f+b,dirRecord:R.CENTRAL_FILE_HEADER+A(C,2)+E+A(p.length,2)+"\0\0\0\0"+A(z,4)+A(i,4)+f+b+p}}var I=t("../utils"),n=t("../stream/GenericWorker"),O=t("../utf8"),B=t("../crc32"),R=t("../signature");function s(t,e,r,i){n.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=e,this.zipPlatform=r,this.encodeFileName=i,this.streamFiles=t,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}I.inherits(s,n),s.prototype.push=function(t){var e=t.meta.percent||0,r=this.entriesCount,i=this._sources.length;this.accumulate?this.contentBuffer.push(t):(this.bytesWritten+=t.data.length,n.prototype.push.call(this,{data:t.data,meta:{currentFile:this.currentFile,percent:r?(e+100*(r-i-1))/r:100}}))},s.prototype.openedSource=function(t){this.currentSourceOffset=this.bytesWritten,this.currentFile=t.file.name;var e=this.streamFiles&&!t.file.dir;if(e){var r=i(t,e,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:r.fileRecord,meta:{percent:0}})}else this.accumulate=!0},s.prototype.closedSource=function(t){this.accumulate=!1;var e=this.streamFiles&&!t.file.dir,r=i(t,e,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(r.dirRecord),e)this.push({data:function(t){return R.DATA_DESCRIPTOR+A(t.crc32,4)+A(t.compressedSize,4)+A(t.uncompressedSize,4)}(t),meta:{percent:100}});else for(this.push({data:r.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},s.prototype.flush=function(){for(var t=this.bytesWritten,e=0;e<this.dirRecords.length;e++)this.push({data:this.dirRecords[e],meta:{percent:100}});var r=this.bytesWritten-t,i=function(t,e,r,i,n){var s=I.transformTo("string",n(i));return R.CENTRAL_DIRECTORY_END+"\0\0\0\0"+A(t,2)+A(t,2)+A(e,4)+A(r,4)+A(s.length,2)+s}(this.dirRecords.length,r,t,this.zipComment,this.encodeFileName);this.push({data:i,meta:{percent:100}})},s.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},s.prototype.registerPrevious=function(t){this._sources.push(t);var e=this;return t.on("data",function(t){e.processChunk(t)}),t.on("end",function(){e.closedSource(e.previous.streamInfo),e._sources.length?e.prepareNextSource():e.end()}),t.on("error",function(t){e.error(t)}),this},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},s.prototype.error=function(t){var e=this._sources;if(!n.prototype.error.call(this,t))return!1;for(var r=0;r<e.length;r++)try{e[r].error(t)}catch(t){}return!0},s.prototype.lock=function(){n.prototype.lock.call(this);for(var t=this._sources,e=0;e<t.length;e++)t[e].lock()},e.exports=s},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(t,e,r){"use strict";var u=t("../compressions"),i=t("./ZipFileWorker");r.generateWorker=function(t,a,e){var o=new i(a.streamFiles,e,a.platform,a.encodeFileName),h=0;try{t.forEach(function(t,e){h++;var r=function(t,e){var r=t||e,i=u[r];if(!i)throw new Error(r+" is not a valid compression method !");return i}(e.options.compression,a.compression),i=e.options.compressionOptions||a.compressionOptions||{},n=e.dir,s=e.date;e._compressWorker(r,i).withStreamInfo("file",{name:t,dir:n,date:s,comment:e.comment||"",unixPermissions:e.unixPermissions,dosPermissions:e.dosPermissions}).pipe(o)}),o.entriesCount=h}catch(t){o.error(t)}return o}},{"../compressions":3,"./ZipFileWorker":8}],10:[function(t,e,r){"use strict";function i(){if(!(this instanceof i))return new i;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files=Object.create(null),this.comment=null,this.root="",this.clone=function(){var t=new i;for(var e in this)"function"!=typeof this[e]&&(t[e]=this[e]);return t}}(i.prototype=t("./object")).loadAsync=t("./load"),i.support=t("./support"),i.defaults=t("./defaults"),i.version="3.7.1",i.loadAsync=function(t,e){return(new i).loadAsync(t,e)},i.external=t("./external"),e.exports=i},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(t,e,r){"use strict";var i=t("./utils"),n=t("./external"),o=t("./utf8"),h=t("./zipEntries"),s=t("./stream/Crc32Probe"),u=t("./nodejsUtils");function l(i){return new n.Promise(function(t,e){var r=i.decompressed.getContentWorker().pipe(new s);r.on("error",function(t){e(t)}).on("end",function(){r.streamInfo.crc32!==i.decompressed.crc32?e(new Error("Corrupted zip : CRC32 mismatch")):t()}).resume()})}e.exports=function(t,s){var a=this;return s=i.extend(s||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:o.utf8decode}),u.isNode&&u.isStream(t)?n.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):i.prepareContent("the loaded zip file",t,!0,s.optimizedBinaryString,s.base64).then(function(t){var e=new h(s);return e.load(t),e}).then(function(t){var e=[n.Promise.resolve(t)],r=t.files;if(s.checkCRC32)for(var i=0;i<r.length;i++)e.push(l(r[i]));return n.Promise.all(e)}).then(function(t){for(var e=t.shift(),r=e.files,i=0;i<r.length;i++){var n=r[i];a.file(n.fileNameStr,n.decompressed,{binary:!0,optimizedBinaryString:!0,date:n.date,dir:n.dir,comment:n.fileCommentStr.length?n.fileCommentStr:null,unixPermissions:n.unixPermissions,dosPermissions:n.dosPermissions,createFolders:s.createFolders})}return e.zipComment.length&&(a.comment=e.zipComment),a})}},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(t,e,r){"use strict";var i=t("../utils"),n=t("../stream/GenericWorker");function s(t,e){n.call(this,"Nodejs stream input adapter for "+t),this._upstreamEnded=!1,this._bindStream(e)}i.inherits(s,n),s.prototype._bindStream=function(t){var e=this;(this._stream=t).pause(),t.on("data",function(t){e.push({data:t,meta:{percent:0}})}).on("error",function(t){e.isPaused?this.generatedError=t:e.error(t)}).on("end",function(){e.isPaused?e._upstreamEnded=!0:e.end()})},s.prototype.pause=function(){return!!n.prototype.pause.call(this)&&(this._stream.pause(),!0)},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},e.exports=s},{"../stream/GenericWorker":28,"../utils":32}],13:[function(t,e,r){"use strict";var n=t("readable-stream").Readable;function i(t,e,r){n.call(this,e),this._helper=t;var i=this;t.on("data",function(t,e){i.push(t)||i._helper.pause(),r&&r(e)}).on("error",function(t){i.emit("error",t)}).on("end",function(){i.push(null)})}t("../utils").inherits(i,n),i.prototype._read=function(){this._helper.resume()},e.exports=i},{"../utils":32,"readable-stream":16}],14:[function(t,e,r){"use strict";e.exports={isNode:"undefined"!=typeof Buffer,newBufferFrom:function(t,e){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(t,e);if("number"==typeof t)throw new Error('The "data" argument must not be a number');return new Buffer(t,e)},allocBuffer:function(t){if(Buffer.alloc)return Buffer.alloc(t);var e=new Buffer(t);return e.fill(0),e},isBuffer:function(t){return Buffer.isBuffer(t)},isStream:function(t){return t&&"function"==typeof t.on&&"function"==typeof t.pause&&"function"==typeof t.resume}}},{}],15:[function(t,e,r){"use strict";function s(t,e,r){var i,n=u.getTypeOf(e),s=u.extend(r||{},f);s.date=s.date||new Date,null!==s.compression&&(s.compression=s.compression.toUpperCase()),"string"==typeof s.unixPermissions&&(s.unixPermissions=parseInt(s.unixPermissions,8)),s.unixPermissions&&16384&s.unixPermissions&&(s.dir=!0),s.dosPermissions&&16&s.dosPermissions&&(s.dir=!0),s.dir&&(t=g(t)),s.createFolders&&(i=_(t))&&b.call(this,i,!0);var a="string"===n&&!1===s.binary&&!1===s.base64;r&&void 0!==r.binary||(s.binary=!a),(e instanceof d&&0===e.uncompressedSize||s.dir||!e||0===e.length)&&(s.base64=!1,s.binary=!0,e="",s.compression="STORE",n="string");var o=null;o=e instanceof d||e instanceof l?e:p.isNode&&p.isStream(e)?new m(t,e):u.prepareContent(t,e,s.binary,s.optimizedBinaryString,s.base64);var h=new c(t,o,s);this.files[t]=h}var n=t("./utf8"),u=t("./utils"),l=t("./stream/GenericWorker"),a=t("./stream/StreamHelper"),f=t("./defaults"),d=t("./compressedObject"),c=t("./zipObject"),o=t("./generate"),p=t("./nodejsUtils"),m=t("./nodejs/NodejsStreamInputAdapter"),_=function(t){"/"===t.slice(-1)&&(t=t.substring(0,t.length-1));var e=t.lastIndexOf("/");return 0<e?t.substring(0,e):""},g=function(t){return"/"!==t.slice(-1)&&(t+="/"),t},b=function(t,e){return e=void 0!==e?e:f.createFolders,t=g(t),this.files[t]||s.call(this,t,null,{dir:!0,createFolders:e}),this.files[t]};function h(t){return"[object RegExp]"===Object.prototype.toString.call(t)}var i={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(t){var e,r,i;for(e in this.files)i=this.files[e],(r=e.slice(this.root.length,e.length))&&e.slice(0,this.root.length)===this.root&&t(r,i)},filter:function(r){var i=[];return this.forEach(function(t,e){r(t,e)&&i.push(e)}),i},file:function(t,e,r){if(1!==arguments.length)return t=this.root+t,s.call(this,t,e,r),this;if(h(t)){var i=t;return this.filter(function(t,e){return!e.dir&&i.test(t)})}var n=this.files[this.root+t];return n&&!n.dir?n:null},folder:function(r){if(!r)return this;if(h(r))return this.filter(function(t,e){return e.dir&&r.test(t)});var t=this.root+r,e=b.call(this,t),i=this.clone();return i.root=e.name,i},remove:function(r){r=this.root+r;var t=this.files[r];if(t||("/"!==r.slice(-1)&&(r+="/"),t=this.files[r]),t&&!t.dir)delete this.files[r];else for(var e=this.filter(function(t,e){return e.name.slice(0,r.length)===r}),i=0;i<e.length;i++)delete this.files[e[i].name];return this},generate:function(t){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(t){var e,r={};try{if((r=u.extend(t||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:n.utf8encode})).type=r.type.toLowerCase(),r.compression=r.compression.toUpperCase(),"binarystring"===r.type&&(r.type="string"),!r.type)throw new Error("No output type specified.");u.checkSupport(r.type),"darwin"!==r.platform&&"freebsd"!==r.platform&&"linux"!==r.platform&&"sunos"!==r.platform||(r.platform="UNIX"),"win32"===r.platform&&(r.platform="DOS");var i=r.comment||this.comment||"";e=o.generateWorker(this,r,i)}catch(t){(e=new l("error")).error(t)}return new a(e,r.type||"string",r.mimeType)},generateAsync:function(t,e){return this.generateInternalStream(t).accumulate(e)},generateNodeStream:function(t,e){return(t=t||{}).type||(t.type="nodebuffer"),this.generateInternalStream(t).toNodejsStream(e)}};e.exports=i},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(t,e,r){e.exports=t("stream")},{stream:void 0}],17:[function(t,e,r){"use strict";var i=t("./DataReader");function n(t){i.call(this,t);for(var e=0;e<this.data.length;e++)t[e]=255&t[e]}t("../utils").inherits(n,i),n.prototype.byteAt=function(t){return this.data[this.zero+t]},n.prototype.lastIndexOfSignature=function(t){for(var e=t.charCodeAt(0),r=t.charCodeAt(1),i=t.charCodeAt(2),n=t.charCodeAt(3),s=this.length-4;0<=s;--s)if(this.data[s]===e&&this.data[s+1]===r&&this.data[s+2]===i&&this.data[s+3]===n)return s-this.zero;return-1},n.prototype.readAndCheckSignature=function(t){var e=t.charCodeAt(0),r=t.charCodeAt(1),i=t.charCodeAt(2),n=t.charCodeAt(3),s=this.readData(4);return e===s[0]&&r===s[1]&&i===s[2]&&n===s[3]},n.prototype.readData=function(t){if(this.checkOffset(t),0===t)return[];var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./DataReader":18}],18:[function(t,e,r){"use strict";var i=t("../utils");function n(t){this.data=t,this.length=t.length,this.index=0,this.zero=0}n.prototype={checkOffset:function(t){this.checkIndex(this.index+t)},checkIndex:function(t){if(this.length<this.zero+t||t<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+t+"). Corrupted zip ?")},setIndex:function(t){this.checkIndex(t),this.index=t},skip:function(t){this.setIndex(this.index+t)},byteAt:function(t){},readInt:function(t){var e,r=0;for(this.checkOffset(t),e=this.index+t-1;e>=this.index;e--)r=(r<<8)+this.byteAt(e);return this.index+=t,r},readString:function(t){return i.transformTo("string",this.readData(t))},readData:function(t){},lastIndexOfSignature:function(t){},readAndCheckSignature:function(t){},readDate:function(){var t=this.readInt(4);return new Date(Date.UTC(1980+(t>>25&127),(t>>21&15)-1,t>>16&31,t>>11&31,t>>5&63,(31&t)<<1))}},e.exports=n},{"../utils":32}],19:[function(t,e,r){"use strict";var i=t("./Uint8ArrayReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.readData=function(t){this.checkOffset(t);var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(t,e,r){"use strict";var i=t("./DataReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.byteAt=function(t){return this.data.charCodeAt(this.zero+t)},n.prototype.lastIndexOfSignature=function(t){return this.data.lastIndexOf(t)-this.zero},n.prototype.readAndCheckSignature=function(t){return t===this.readData(4)},n.prototype.readData=function(t){this.checkOffset(t);var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./DataReader":18}],21:[function(t,e,r){"use strict";var i=t("./ArrayReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.readData=function(t){if(this.checkOffset(t),0===t)return new Uint8Array(0);var e=this.data.subarray(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./ArrayReader":17}],22:[function(t,e,r){"use strict";var i=t("../utils"),n=t("../support"),s=t("./ArrayReader"),a=t("./StringReader"),o=t("./NodeBufferReader"),h=t("./Uint8ArrayReader");e.exports=function(t){var e=i.getTypeOf(t);return i.checkSupport(e),"string"!==e||n.uint8array?"nodebuffer"===e?new o(t):n.uint8array?new h(i.transformTo("uint8array",t)):new s(i.transformTo("array",t)):new a(t)}},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(t,e,r){"use strict";r.LOCAL_FILE_HEADER="PK",r.CENTRAL_FILE_HEADER="PK",r.CENTRAL_DIRECTORY_END="PK",r.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",r.ZIP64_CENTRAL_DIRECTORY_END="PK",r.DATA_DESCRIPTOR="PK\b"},{}],24:[function(t,e,r){"use strict";var i=t("./GenericWorker"),n=t("../utils");function s(t){i.call(this,"ConvertWorker to "+t),this.destType=t}n.inherits(s,i),s.prototype.processChunk=function(t){this.push({data:n.transformTo(this.destType,t.data),meta:t.meta})},e.exports=s},{"../utils":32,"./GenericWorker":28}],25:[function(t,e,r){"use strict";var i=t("./GenericWorker"),n=t("../crc32");function s(){i.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}t("../utils").inherits(s,i),s.prototype.processChunk=function(t){this.streamInfo.crc32=n(t.data,this.streamInfo.crc32||0),this.push(t)},e.exports=s},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(t,e,r){"use strict";var i=t("../utils"),n=t("./GenericWorker");function s(t){n.call(this,"DataLengthProbe for "+t),this.propName=t,this.withStreamInfo(t,0)}i.inherits(s,n),s.prototype.processChunk=function(t){if(t){var e=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=e+t.data.length}n.prototype.processChunk.call(this,t)},e.exports=s},{"../utils":32,"./GenericWorker":28}],27:[function(t,e,r){"use strict";var i=t("../utils"),n=t("./GenericWorker");function s(t){n.call(this,"DataWorker");var e=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,t.then(function(t){e.dataIsReady=!0,e.data=t,e.max=t&&t.length||0,e.type=i.getTypeOf(t),e.isPaused||e._tickAndRepeat()},function(t){e.error(t)})}i.inherits(s,n),s.prototype.cleanUp=function(){n.prototype.cleanUp.call(this),this.data=null},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,i.delay(this._tickAndRepeat,[],this)),!0)},s.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(i.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},s.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var t=null,e=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":t=this.data.substring(this.index,e);break;case"uint8array":t=this.data.subarray(this.index,e);break;case"array":case"nodebuffer":t=this.data.slice(this.index,e)}return this.index=e,this.push({data:t,meta:{percent:this.max?this.index/this.max*100:0}})},e.exports=s},{"../utils":32,"./GenericWorker":28}],28:[function(t,e,r){"use strict";function i(t){this.name=t||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}i.prototype={push:function(t){this.emit("data",t)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(t){this.emit("error",t)}return!0},error:function(t){return!this.isFinished&&(this.isPaused?this.generatedError=t:(this.isFinished=!0,this.emit("error",t),this.previous&&this.previous.error(t),this.cleanUp()),!0)},on:function(t,e){return this._listeners[t].push(e),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(t,e){if(this._listeners[t])for(var r=0;r<this._listeners[t].length;r++)this._listeners[t][r].call(this,e)},pipe:function(t){return t.registerPrevious(this)},registerPrevious:function(t){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=t.streamInfo,this.mergeStreamInfo(),this.previous=t;var e=this;return t.on("data",function(t){e.processChunk(t)}),t.on("end",function(){e.end()}),t.on("error",function(t){e.error(t)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;var t=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),t=!0),this.previous&&this.previous.resume(),!t},flush:function(){},processChunk:function(t){this.push(t)},withStreamInfo:function(t,e){return this.extraStreamInfo[t]=e,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var t in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(t)&&(this.streamInfo[t]=this.extraStreamInfo[t])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var t="Worker "+this.name;return this.previous?this.previous+" -> "+t:t}},e.exports=i},{}],29:[function(t,e,r){"use strict";var h=t("../utils"),n=t("./ConvertWorker"),s=t("./GenericWorker"),u=t("../base64"),i=t("../support"),a=t("../external"),o=null;if(i.nodestream)try{o=t("../nodejs/NodejsStreamOutputAdapter")}catch(t){}function l(t,o){return new a.Promise(function(e,r){var i=[],n=t._internalType,s=t._outputType,a=t._mimeType;t.on("data",function(t,e){i.push(t),o&&o(e)}).on("error",function(t){i=[],r(t)}).on("end",function(){try{var t=function(t,e,r){switch(t){case"blob":return h.newBlob(h.transformTo("arraybuffer",e),r);case"base64":return u.encode(e);default:return h.transformTo(t,e)}}(s,function(t,e){var r,i=0,n=null,s=0;for(r=0;r<e.length;r++)s+=e[r].length;switch(t){case"string":return e.join("");case"array":return Array.prototype.concat.apply([],e);case"uint8array":for(n=new Uint8Array(s),r=0;r<e.length;r++)n.set(e[r],i),i+=e[r].length;return n;case"nodebuffer":return Buffer.concat(e);default:throw new Error("concat : unsupported type '"+t+"'")}}(n,i),a);e(t)}catch(t){r(t)}i=[]}).resume()})}function f(t,e,r){var i=e;switch(e){case"blob":case"arraybuffer":i="uint8array";break;case"base64":i="string"}try{this._internalType=i,this._outputType=e,this._mimeType=r,h.checkSupport(i),this._worker=t.pipe(new n(i)),t.lock()}catch(t){this._worker=new s("error"),this._worker.error(t)}}f.prototype={accumulate:function(t){return l(this,t)},on:function(t,e){var r=this;return"data"===t?this._worker.on(t,function(t){e.call(r,t.data,t.meta)}):this._worker.on(t,function(){h.delay(e,arguments,r)}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(t){if(h.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new o(this,{objectMode:"nodebuffer"!==this._outputType},t)}},e.exports=f},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(t,e,r){"use strict";if(r.base64=!0,r.array=!0,r.string=!0,r.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,r.nodebuffer="undefined"!=typeof Buffer,r.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)r.blob=!1;else{var i=new ArrayBuffer(0);try{r.blob=0===new Blob([i],{type:"application/zip"}).size}catch(t){try{var n=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);n.append(i),r.blob=0===n.getBlob("application/zip").size}catch(t){r.blob=!1}}}try{r.nodestream=!!t("readable-stream").Readable}catch(t){r.nodestream=!1}},{"readable-stream":16}],31:[function(t,e,s){"use strict";for(var o=t("./utils"),h=t("./support"),r=t("./nodejsUtils"),i=t("./stream/GenericWorker"),u=new Array(256),n=0;n<256;n++)u[n]=252<=n?6:248<=n?5:240<=n?4:224<=n?3:192<=n?2:1;u[254]=u[254]=1;function a(){i.call(this,"utf-8 decode"),this.leftOver=null}function l(){i.call(this,"utf-8 encode")}s.utf8encode=function(t){return h.nodebuffer?r.newBufferFrom(t,"utf-8"):function(t){var e,r,i,n,s,a=t.length,o=0;for(n=0;n<a;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),o+=r<128?1:r<2048?2:r<65536?3:4;for(e=h.uint8array?new Uint8Array(o):new Array(o),n=s=0;s<o;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),r<128?e[s++]=r:(r<2048?e[s++]=192|r>>>6:(r<65536?e[s++]=224|r>>>12:(e[s++]=240|r>>>18,e[s++]=128|r>>>12&63),e[s++]=128|r>>>6&63),e[s++]=128|63&r);return e}(t)},s.utf8decode=function(t){return h.nodebuffer?o.transformTo("nodebuffer",t).toString("utf-8"):function(t){var e,r,i,n,s=t.length,a=new Array(2*s);for(e=r=0;e<s;)if((i=t[e++])<128)a[r++]=i;else if(4<(n=u[i]))a[r++]=65533,e+=n-1;else{for(i&=2===n?31:3===n?15:7;1<n&&e<s;)i=i<<6|63&t[e++],n--;1<n?a[r++]=65533:i<65536?a[r++]=i:(i-=65536,a[r++]=55296|i>>10&1023,a[r++]=56320|1023&i)}return a.length!==r&&(a.subarray?a=a.subarray(0,r):a.length=r),o.applyFromCharCode(a)}(t=o.transformTo(h.uint8array?"uint8array":"array",t))},o.inherits(a,i),a.prototype.processChunk=function(t){var e=o.transformTo(h.uint8array?"uint8array":"array",t.data);if(this.leftOver&&this.leftOver.length){if(h.uint8array){var r=e;(e=new Uint8Array(r.length+this.leftOver.length)).set(this.leftOver,0),e.set(r,this.leftOver.length)}else e=this.leftOver.concat(e);this.leftOver=null}var i=function(t,e){var r;for((e=e||t.length)>t.length&&(e=t.length),r=e-1;0<=r&&128==(192&t[r]);)r--;return r<0?e:0===r?e:r+u[t[r]]>e?r:e}(e),n=e;i!==e.length&&(h.uint8array?(n=e.subarray(0,i),this.leftOver=e.subarray(i,e.length)):(n=e.slice(0,i),this.leftOver=e.slice(i,e.length))),this.push({data:s.utf8decode(n),meta:t.meta})},a.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:s.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},s.Utf8DecodeWorker=a,o.inherits(l,i),l.prototype.processChunk=function(t){this.push({data:s.utf8encode(t.data),meta:t.meta})},s.Utf8EncodeWorker=l},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(t,e,a){"use strict";var o=t("./support"),h=t("./base64"),r=t("./nodejsUtils"),i=t("set-immediate-shim"),u=t("./external");function n(t){return t}function l(t,e){for(var r=0;r<t.length;++r)e[r]=255&t.charCodeAt(r);return e}a.newBlob=function(e,r){a.checkSupport("blob");try{return new Blob([e],{type:r})}catch(t){try{var i=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return i.append(e),i.getBlob(r)}catch(t){throw new Error("Bug : can't construct the Blob.")}}};var s={stringifyByChunk:function(t,e,r){var i=[],n=0,s=t.length;if(s<=r)return String.fromCharCode.apply(null,t);for(;n<s;)"array"===e||"nodebuffer"===e?i.push(String.fromCharCode.apply(null,t.slice(n,Math.min(n+r,s)))):i.push(String.fromCharCode.apply(null,t.subarray(n,Math.min(n+r,s)))),n+=r;return i.join("")},stringifyByChar:function(t){for(var e="",r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e},applyCanBeUsed:{uint8array:function(){try{return o.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(t){return!1}}(),nodebuffer:function(){try{return o.nodebuffer&&1===String.fromCharCode.apply(null,r.allocBuffer(1)).length}catch(t){return!1}}()}};function f(t){var e=65536,r=a.getTypeOf(t),i=!0;if("uint8array"===r?i=s.applyCanBeUsed.uint8array:"nodebuffer"===r&&(i=s.applyCanBeUsed.nodebuffer),i)for(;1<e;)try{return s.stringifyByChunk(t,r,e)}catch(t){e=Math.floor(e/2)}return s.stringifyByChar(t)}function d(t,e){for(var r=0;r<t.length;r++)e[r]=t[r];return e}a.applyFromCharCode=f;var c={};c.string={string:n,array:function(t){return l(t,new Array(t.length))},arraybuffer:function(t){return c.string.uint8array(t).buffer},uint8array:function(t){return l(t,new Uint8Array(t.length))},nodebuffer:function(t){return l(t,r.allocBuffer(t.length))}},c.array={string:f,array:n,arraybuffer:function(t){return new Uint8Array(t).buffer},uint8array:function(t){return new Uint8Array(t)},nodebuffer:function(t){return r.newBufferFrom(t)}},c.arraybuffer={string:function(t){return f(new Uint8Array(t))},array:function(t){return d(new Uint8Array(t),new Array(t.byteLength))},arraybuffer:n,uint8array:function(t){return new Uint8Array(t)},nodebuffer:function(t){return r.newBufferFrom(new Uint8Array(t))}},c.uint8array={string:f,array:function(t){return d(t,new Array(t.length))},arraybuffer:function(t){return t.buffer},uint8array:n,nodebuffer:function(t){return r.newBufferFrom(t)}},c.nodebuffer={string:f,array:function(t){return d(t,new Array(t.length))},arraybuffer:function(t){return c.nodebuffer.uint8array(t).buffer},uint8array:function(t){return d(t,new Uint8Array(t.length))},nodebuffer:n},a.transformTo=function(t,e){if(e=e||"",!t)return e;a.checkSupport(t);var r=a.getTypeOf(e);return c[r][t](e)},a.getTypeOf=function(t){return"string"==typeof t?"string":"[object Array]"===Object.prototype.toString.call(t)?"array":o.nodebuffer&&r.isBuffer(t)?"nodebuffer":o.uint8array&&t instanceof Uint8Array?"uint8array":o.arraybuffer&&t instanceof ArrayBuffer?"arraybuffer":void 0},a.checkSupport=function(t){if(!o[t.toLowerCase()])throw new Error(t+" is not supported by this platform")},a.MAX_VALUE_16BITS=65535,a.MAX_VALUE_32BITS=-1,a.pretty=function(t){var e,r,i="";for(r=0;r<(t||"").length;r++)i+="\\x"+((e=t.charCodeAt(r))<16?"0":"")+e.toString(16).toUpperCase();return i},a.delay=function(t,e,r){i(function(){t.apply(r||null,e||[])})},a.inherits=function(t,e){function r(){}r.prototype=e.prototype,t.prototype=new r},a.extend=function(){var t,e,r={};for(t=0;t<arguments.length;t++)for(e in arguments[t])arguments[t].hasOwnProperty(e)&&void 0===r[e]&&(r[e]=arguments[t][e]);return r},a.prepareContent=function(r,t,i,n,s){return u.Promise.resolve(t).then(function(i){return o.blob&&(i instanceof Blob||-1!==["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(i)))&&"undefined"!=typeof FileReader?new u.Promise(function(e,r){var t=new FileReader;t.onload=function(t){e(t.target.result)},t.onerror=function(t){r(t.target.error)},t.readAsArrayBuffer(i)}):i}).then(function(t){var e=a.getTypeOf(t);return e?("arraybuffer"===e?t=a.transformTo("uint8array",t):"string"===e&&(s?t=h.decode(t):i&&!0!==n&&(t=function(t){return l(t,o.uint8array?new Uint8Array(t.length):new Array(t.length))}(t))),t):u.Promise.reject(new Error("Can't read the data of '"+r+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})}},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,"set-immediate-shim":54}],33:[function(t,e,r){"use strict";var i=t("./reader/readerFor"),n=t("./utils"),s=t("./signature"),a=t("./zipEntry"),o=(t("./utf8"),t("./support"));function h(t){this.files=[],this.loadOptions=t}h.prototype={checkSignature:function(t){if(!this.reader.readAndCheckSignature(t)){this.reader.index-=4;var e=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+n.pretty(e)+", expected "+n.pretty(t)+")")}},isSignature:function(t,e){var r=this.reader.index;this.reader.setIndex(t);var i=this.reader.readString(4)===e;return this.reader.setIndex(r),i},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var t=this.reader.readData(this.zipCommentLength),e=o.uint8array?"uint8array":"array",r=n.transformTo(e,t);this.zipComment=this.loadOptions.decodeFileName(r)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var t,e,r,i=this.zip64EndOfCentralSize-44;0<i;)t=this.reader.readInt(2),e=this.reader.readInt(4),r=this.reader.readData(e),this.zip64ExtensibleData[t]={id:t,length:e,value:r}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var t,e;for(t=0;t<this.files.length;t++)e=this.files[t],this.reader.setIndex(e.localHeaderOffset),this.checkSignature(s.LOCAL_FILE_HEADER),e.readLocalPart(this.reader),e.handleUTF8(),e.processAttributes()},readCentralDir:function(){var t;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(t=new a({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(t);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var t=this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);if(t<0)throw!this.isSignature(0,s.LOCAL_FILE_HEADER)?new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip: can't find end of central directory");this.reader.setIndex(t);var e=t;if(this.checkSignature(s.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===n.MAX_VALUE_16BITS||this.diskWithCentralDirStart===n.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===n.MAX_VALUE_16BITS||this.centralDirRecords===n.MAX_VALUE_16BITS||this.centralDirSize===n.MAX_VALUE_32BITS||this.centralDirOffset===n.MAX_VALUE_32BITS){if(this.zip64=!0,(t=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(t),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,s.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var r=this.centralDirOffset+this.centralDirSize;this.zip64&&(r+=20,r+=12+this.zip64EndOfCentralSize);var i=e-r;if(0<i)this.isSignature(e,s.CENTRAL_FILE_HEADER)||(this.reader.zero=i);else if(i<0)throw new Error("Corrupted zip: missing "+Math.abs(i)+" bytes.")},prepareReader:function(t){this.reader=i(t)},load:function(t){this.prepareReader(t),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},e.exports=h},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utf8":31,"./utils":32,"./zipEntry":34}],34:[function(t,e,r){"use strict";var i=t("./reader/readerFor"),s=t("./utils"),n=t("./compressedObject"),a=t("./crc32"),o=t("./utf8"),h=t("./compressions"),u=t("./support");function l(t,e){this.options=t,this.loadOptions=e}l.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(t){var e,r;if(t.skip(22),this.fileNameLength=t.readInt(2),r=t.readInt(2),this.fileName=t.readData(this.fileNameLength),t.skip(r),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(null===(e=function(t){for(var e in h)if(h.hasOwnProperty(e)&&h[e].magic===t)return h[e];return null}(this.compressionMethod)))throw new Error("Corrupted zip : compression "+s.pretty(this.compressionMethod)+" unknown (inner file : "+s.transformTo("string",this.fileName)+")");this.decompressed=new n(this.compressedSize,this.uncompressedSize,this.crc32,e,t.readData(this.compressedSize))},readCentralPart:function(t){this.versionMadeBy=t.readInt(2),t.skip(2),this.bitFlag=t.readInt(2),this.compressionMethod=t.readString(2),this.date=t.readDate(),this.crc32=t.readInt(4),this.compressedSize=t.readInt(4),this.uncompressedSize=t.readInt(4);var e=t.readInt(2);if(this.extraFieldsLength=t.readInt(2),this.fileCommentLength=t.readInt(2),this.diskNumberStart=t.readInt(2),this.internalFileAttributes=t.readInt(2),this.externalFileAttributes=t.readInt(4),this.localHeaderOffset=t.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");t.skip(e),this.readExtraFields(t),this.parseZIP64ExtraField(t),this.fileComment=t.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var t=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0==t&&(this.dosPermissions=63&this.externalFileAttributes),3==t&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(t){if(this.extraFields[1]){var e=i(this.extraFields[1].value);this.uncompressedSize===s.MAX_VALUE_32BITS&&(this.uncompressedSize=e.readInt(8)),this.compressedSize===s.MAX_VALUE_32BITS&&(this.compressedSize=e.readInt(8)),this.localHeaderOffset===s.MAX_VALUE_32BITS&&(this.localHeaderOffset=e.readInt(8)),this.diskNumberStart===s.MAX_VALUE_32BITS&&(this.diskNumberStart=e.readInt(4))}},readExtraFields:function(t){var e,r,i,n=t.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});t.index+4<n;)e=t.readInt(2),r=t.readInt(2),i=t.readData(r),this.extraFields[e]={id:e,length:r,value:i};t.setIndex(n)},handleUTF8:function(){var t=u.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=o.utf8decode(this.fileName),this.fileCommentStr=o.utf8decode(this.fileComment);else{var e=this.findExtraFieldUnicodePath();if(null!==e)this.fileNameStr=e;else{var r=s.transformTo(t,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(r)}var i=this.findExtraFieldUnicodeComment();if(null!==i)this.fileCommentStr=i;else{var n=s.transformTo(t,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(n)}}},findExtraFieldUnicodePath:function(){var t=this.extraFields[28789];if(t){var e=i(t.value);return 1!==e.readInt(1)?null:a(this.fileName)!==e.readInt(4)?null:o.utf8decode(e.readData(t.length-5))}return null},findExtraFieldUnicodeComment:function(){var t=this.extraFields[25461];if(t){var e=i(t.value);return 1!==e.readInt(1)?null:a(this.fileComment)!==e.readInt(4)?null:o.utf8decode(e.readData(t.length-5))}return null}},e.exports=l},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(t,e,r){"use strict";function i(t,e,r){this.name=t,this.dir=r.dir,this.date=r.date,this.comment=r.comment,this.unixPermissions=r.unixPermissions,this.dosPermissions=r.dosPermissions,this._data=e,this._dataBinary=r.binary,this.options={compression:r.compression,compressionOptions:r.compressionOptions}}var s=t("./stream/StreamHelper"),n=t("./stream/DataWorker"),a=t("./utf8"),o=t("./compressedObject"),h=t("./stream/GenericWorker");i.prototype={internalStream:function(t){var e=null,r="string";try{if(!t)throw new Error("No output type specified.");var i="string"===(r=t.toLowerCase())||"text"===r;"binarystring"!==r&&"text"!==r||(r="string"),e=this._decompressWorker();var n=!this._dataBinary;n&&!i&&(e=e.pipe(new a.Utf8EncodeWorker)),!n&&i&&(e=e.pipe(new a.Utf8DecodeWorker))}catch(t){(e=new h("error")).error(t)}return new s(e,r,"")},async:function(t,e){return this.internalStream(t).accumulate(e)},nodeStream:function(t,e){return this.internalStream(t||"nodebuffer").toNodejsStream(e)},_compressWorker:function(t,e){if(this._data instanceof o&&this._data.compression.magic===t.magic)return this._data.getCompressedWorker();var r=this._decompressWorker();return this._dataBinary||(r=r.pipe(new a.Utf8EncodeWorker)),o.createWorkerFrom(r,t,e)},_decompressWorker:function(){return this._data instanceof o?this._data.getContentWorker():this._data instanceof h?this._data:new n(this._data)}};for(var u=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],l=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},f=0;f<u.length;f++)i.prototype[u[f]]=l;e.exports=i},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(t,l,e){(function(e){"use strict";var r,i,t=e.MutationObserver||e.WebKitMutationObserver;if(t){var n=0,s=new t(u),a=e.document.createTextNode("");s.observe(a,{characterData:!0}),r=function(){a.data=n=++n%2}}else if(e.setImmediate||void 0===e.MessageChannel)r="document"in e&&"onreadystatechange"in e.document.createElement("script")?function(){var t=e.document.createElement("script");t.onreadystatechange=function(){u(),t.onreadystatechange=null,t.parentNode.removeChild(t),t=null},e.document.documentElement.appendChild(t)}:function(){setTimeout(u,0)};else{var o=new e.MessageChannel;o.port1.onmessage=u,r=function(){o.port2.postMessage(0)}}var h=[];function u(){var t,e;i=!0;for(var r=h.length;r;){for(e=h,h=[],t=-1;++t<r;)e[t]();r=h.length}i=!1}l.exports=function(t){1!==h.push(t)||i||r()}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],37:[function(t,e,r){"use strict";var n=t("immediate");function u(){}var l={},s=["REJECTED"],a=["FULFILLED"],i=["PENDING"];function o(t){if("function"!=typeof t)throw new TypeError("resolver must be a function");this.state=i,this.queue=[],this.outcome=void 0,t!==u&&c(this,t)}function h(t,e,r){this.promise=t,"function"==typeof e&&(this.onFulfilled=e,this.callFulfilled=this.otherCallFulfilled),"function"==typeof r&&(this.onRejected=r,this.callRejected=this.otherCallRejected)}function f(e,r,i){n(function(){var t;try{t=r(i)}catch(t){return l.reject(e,t)}t===e?l.reject(e,new TypeError("Cannot resolve promise with itself")):l.resolve(e,t)})}function d(t){var e=t&&t.then;if(t&&("object"==typeof t||"function"==typeof t)&&"function"==typeof e)return function(){e.apply(t,arguments)}}function c(e,t){var r=!1;function i(t){r||(r=!0,l.reject(e,t))}function n(t){r||(r=!0,l.resolve(e,t))}var s=p(function(){t(n,i)});"error"===s.status&&i(s.value)}function p(t,e){var r={};try{r.value=t(e),r.status="success"}catch(t){r.status="error",r.value=t}return r}(e.exports=o).prototype.finally=function(e){if("function"!=typeof e)return this;var r=this.constructor;return this.then(function(t){return r.resolve(e()).then(function(){return t})},function(t){return r.resolve(e()).then(function(){throw t})})},o.prototype.catch=function(t){return this.then(null,t)},o.prototype.then=function(t,e){if("function"!=typeof t&&this.state===a||"function"!=typeof e&&this.state===s)return this;var r=new this.constructor(u);this.state!==i?f(r,this.state===a?t:e,this.outcome):this.queue.push(new h(r,t,e));return r},h.prototype.callFulfilled=function(t){l.resolve(this.promise,t)},h.prototype.otherCallFulfilled=function(t){f(this.promise,this.onFulfilled,t)},h.prototype.callRejected=function(t){l.reject(this.promise,t)},h.prototype.otherCallRejected=function(t){f(this.promise,this.onRejected,t)},l.resolve=function(t,e){var r=p(d,e);if("error"===r.status)return l.reject(t,r.value);var i=r.value;if(i)c(t,i);else{t.state=a,t.outcome=e;for(var n=-1,s=t.queue.length;++n<s;)t.queue[n].callFulfilled(e)}return t},l.reject=function(t,e){t.state=s,t.outcome=e;for(var r=-1,i=t.queue.length;++r<i;)t.queue[r].callRejected(e);return t},o.resolve=function(t){if(t instanceof this)return t;return l.resolve(new this(u),t)},o.reject=function(t){var e=new this(u);return l.reject(e,t)},o.all=function(t){var r=this;if("[object Array]"!==Object.prototype.toString.call(t))return this.reject(new TypeError("must be an array"));var i=t.length,n=!1;if(!i)return this.resolve([]);var s=new Array(i),a=0,e=-1,o=new this(u);for(;++e<i;)h(t[e],e);return o;function h(t,e){r.resolve(t).then(function(t){s[e]=t,++a!==i||n||(n=!0,l.resolve(o,s))},function(t){n||(n=!0,l.reject(o,t))})}},o.race=function(t){var e=this;if("[object Array]"!==Object.prototype.toString.call(t))return this.reject(new TypeError("must be an array"));var r=t.length,i=!1;if(!r)return this.resolve([]);var n=-1,s=new this(u);for(;++n<r;)a=t[n],e.resolve(a).then(function(t){i||(i=!0,l.resolve(s,t))},function(t){i||(i=!0,l.reject(s,t))});var a;return s}},{immediate:36}],38:[function(t,e,r){"use strict";var i={};(0,t("./lib/utils/common").assign)(i,t("./lib/deflate"),t("./lib/inflate"),t("./lib/zlib/constants")),e.exports=i},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(t,e,r){"use strict";var a=t("./zlib/deflate"),o=t("./utils/common"),h=t("./utils/strings"),n=t("./zlib/messages"),s=t("./zlib/zstream"),u=Object.prototype.toString,l=0,f=-1,d=0,c=8;function p(t){if(!(this instanceof p))return new p(t);this.options=o.assign({level:f,method:c,chunkSize:16384,windowBits:15,memLevel:8,strategy:d,to:""},t||{});var e=this.options;e.raw&&0<e.windowBits?e.windowBits=-e.windowBits:e.gzip&&0<e.windowBits&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new s,this.strm.avail_out=0;var r=a.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(r!==l)throw new Error(n[r]);if(e.header&&a.deflateSetHeader(this.strm,e.header),e.dictionary){var i;if(i="string"==typeof e.dictionary?h.string2buf(e.dictionary):"[object ArrayBuffer]"===u.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,(r=a.deflateSetDictionary(this.strm,i))!==l)throw new Error(n[r]);this._dict_set=!0}}function i(t,e){var r=new p(e);if(r.push(t,!0),r.err)throw r.msg||n[r.err];return r.result}p.prototype.push=function(t,e){var r,i,n=this.strm,s=this.options.chunkSize;if(this.ended)return!1;i=e===~~e?e:!0===e?4:0,"string"==typeof t?n.input=h.string2buf(t):"[object ArrayBuffer]"===u.call(t)?n.input=new Uint8Array(t):n.input=t,n.next_in=0,n.avail_in=n.input.length;do{if(0===n.avail_out&&(n.output=new o.Buf8(s),n.next_out=0,n.avail_out=s),1!==(r=a.deflate(n,i))&&r!==l)return this.onEnd(r),!(this.ended=!0);0!==n.avail_out&&(0!==n.avail_in||4!==i&&2!==i)||("string"===this.options.to?this.onData(h.buf2binstring(o.shrinkBuf(n.output,n.next_out))):this.onData(o.shrinkBuf(n.output,n.next_out)))}while((0<n.avail_in||0===n.avail_out)&&1!==r);return 4===i?(r=a.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===l):2!==i||(this.onEnd(l),!(n.avail_out=0))},p.prototype.onData=function(t){this.chunks.push(t)},p.prototype.onEnd=function(t){t===l&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},r.Deflate=p,r.deflate=i,r.deflateRaw=function(t,e){return(e=e||{}).raw=!0,i(t,e)},r.gzip=function(t,e){return(e=e||{}).gzip=!0,i(t,e)}},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(t,e,r){"use strict";var d=t("./zlib/inflate"),c=t("./utils/common"),p=t("./utils/strings"),m=t("./zlib/constants"),i=t("./zlib/messages"),n=t("./zlib/zstream"),s=t("./zlib/gzheader"),_=Object.prototype.toString;function a(t){if(!(this instanceof a))return new a(t);this.options=c.assign({chunkSize:16384,windowBits:0,to:""},t||{});var e=this.options;e.raw&&0<=e.windowBits&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(0<=e.windowBits&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),15<e.windowBits&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new n,this.strm.avail_out=0;var r=d.inflateInit2(this.strm,e.windowBits);if(r!==m.Z_OK)throw new Error(i[r]);this.header=new s,d.inflateGetHeader(this.strm,this.header)}function o(t,e){var r=new a(e);if(r.push(t,!0),r.err)throw r.msg||i[r.err];return r.result}a.prototype.push=function(t,e){var r,i,n,s,a,o,h=this.strm,u=this.options.chunkSize,l=this.options.dictionary,f=!1;if(this.ended)return!1;i=e===~~e?e:!0===e?m.Z_FINISH:m.Z_NO_FLUSH,"string"==typeof t?h.input=p.binstring2buf(t):"[object ArrayBuffer]"===_.call(t)?h.input=new Uint8Array(t):h.input=t,h.next_in=0,h.avail_in=h.input.length;do{if(0===h.avail_out&&(h.output=new c.Buf8(u),h.next_out=0,h.avail_out=u),(r=d.inflate(h,m.Z_NO_FLUSH))===m.Z_NEED_DICT&&l&&(o="string"==typeof l?p.string2buf(l):"[object ArrayBuffer]"===_.call(l)?new Uint8Array(l):l,r=d.inflateSetDictionary(this.strm,o)),r===m.Z_BUF_ERROR&&!0===f&&(r=m.Z_OK,f=!1),r!==m.Z_STREAM_END&&r!==m.Z_OK)return this.onEnd(r),!(this.ended=!0);h.next_out&&(0!==h.avail_out&&r!==m.Z_STREAM_END&&(0!==h.avail_in||i!==m.Z_FINISH&&i!==m.Z_SYNC_FLUSH)||("string"===this.options.to?(n=p.utf8border(h.output,h.next_out),s=h.next_out-n,a=p.buf2string(h.output,n),h.next_out=s,h.avail_out=u-s,s&&c.arraySet(h.output,h.output,n,s,0),this.onData(a)):this.onData(c.shrinkBuf(h.output,h.next_out)))),0===h.avail_in&&0===h.avail_out&&(f=!0)}while((0<h.avail_in||0===h.avail_out)&&r!==m.Z_STREAM_END);return r===m.Z_STREAM_END&&(i=m.Z_FINISH),i===m.Z_FINISH?(r=d.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===m.Z_OK):i!==m.Z_SYNC_FLUSH||(this.onEnd(m.Z_OK),!(h.avail_out=0))},a.prototype.onData=function(t){this.chunks.push(t)},a.prototype.onEnd=function(t){t===m.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=c.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},r.Inflate=a,r.inflate=o,r.inflateRaw=function(t,e){return(e=e||{}).raw=!0,o(t,e)},r.ungzip=o},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(t,e,r){"use strict";var i="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;r.assign=function(t){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var r=e.shift();if(r){if("object"!=typeof r)throw new TypeError(r+"must be non-object");for(var i in r)r.hasOwnProperty(i)&&(t[i]=r[i])}}return t},r.shrinkBuf=function(t,e){return t.length===e?t:t.subarray?t.subarray(0,e):(t.length=e,t)};var n={arraySet:function(t,e,r,i,n){if(e.subarray&&t.subarray)t.set(e.subarray(r,r+i),n);else for(var s=0;s<i;s++)t[n+s]=e[r+s]},flattenChunks:function(t){var e,r,i,n,s,a;for(e=i=0,r=t.length;e<r;e++)i+=t[e].length;for(a=new Uint8Array(i),e=n=0,r=t.length;e<r;e++)s=t[e],a.set(s,n),n+=s.length;return a}},s={arraySet:function(t,e,r,i,n){for(var s=0;s<i;s++)t[n+s]=e[r+s]},flattenChunks:function(t){return[].concat.apply([],t)}};r.setTyped=function(t){t?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,n)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,s))},r.setTyped(i)},{}],42:[function(t,e,r){"use strict";var h=t("./common"),n=!0,s=!0;try{String.fromCharCode.apply(null,[0])}catch(t){n=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(t){s=!1}for(var u=new h.Buf8(256),i=0;i<256;i++)u[i]=252<=i?6:248<=i?5:240<=i?4:224<=i?3:192<=i?2:1;function l(t,e){if(e<65537&&(t.subarray&&s||!t.subarray&&n))return String.fromCharCode.apply(null,h.shrinkBuf(t,e));for(var r="",i=0;i<e;i++)r+=String.fromCharCode(t[i]);return r}u[254]=u[254]=1,r.string2buf=function(t){var e,r,i,n,s,a=t.length,o=0;for(n=0;n<a;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),o+=r<128?1:r<2048?2:r<65536?3:4;for(e=new h.Buf8(o),n=s=0;s<o;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),r<128?e[s++]=r:(r<2048?e[s++]=192|r>>>6:(r<65536?e[s++]=224|r>>>12:(e[s++]=240|r>>>18,e[s++]=128|r>>>12&63),e[s++]=128|r>>>6&63),e[s++]=128|63&r);return e},r.buf2binstring=function(t){return l(t,t.length)},r.binstring2buf=function(t){for(var e=new h.Buf8(t.length),r=0,i=e.length;r<i;r++)e[r]=t.charCodeAt(r);return e},r.buf2string=function(t,e){var r,i,n,s,a=e||t.length,o=new Array(2*a);for(r=i=0;r<a;)if((n=t[r++])<128)o[i++]=n;else if(4<(s=u[n]))o[i++]=65533,r+=s-1;else{for(n&=2===s?31:3===s?15:7;1<s&&r<a;)n=n<<6|63&t[r++],s--;1<s?o[i++]=65533:n<65536?o[i++]=n:(n-=65536,o[i++]=55296|n>>10&1023,o[i++]=56320|1023&n)}return l(o,i)},r.utf8border=function(t,e){var r;for((e=e||t.length)>t.length&&(e=t.length),r=e-1;0<=r&&128==(192&t[r]);)r--;return r<0?e:0===r?e:r+u[t[r]]>e?r:e}},{"./common":41}],43:[function(t,e,r){"use strict";e.exports=function(t,e,r,i){for(var n=65535&t|0,s=t>>>16&65535|0,a=0;0!==r;){for(r-=a=2e3<r?2e3:r;s=s+(n=n+e[i++]|0)|0,--a;);n%=65521,s%=65521}return n|s<<16|0}},{}],44:[function(t,e,r){"use strict";e.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(t,e,r){"use strict";var o=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();e.exports=function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t}},{}],46:[function(t,e,r){"use strict";var h,d=t("../utils/common"),u=t("./trees"),c=t("./adler32"),p=t("./crc32"),i=t("./messages"),l=0,f=4,m=0,_=-2,g=-1,b=4,n=2,v=8,y=9,s=286,a=30,o=19,w=2*s+1,k=15,x=3,S=258,z=S+x+1,C=42,E=113,A=1,I=2,O=3,B=4;function R(t,e){return t.msg=i[e],e}function T(t){return(t<<1)-(4<t?9:0)}function D(t){for(var e=t.length;0<=--e;)t[e]=0}function F(t){var e=t.state,r=e.pending;r>t.avail_out&&(r=t.avail_out),0!==r&&(d.arraySet(t.output,e.pending_buf,e.pending_out,r,t.next_out),t.next_out+=r,e.pending_out+=r,t.total_out+=r,t.avail_out-=r,e.pending-=r,0===e.pending&&(e.pending_out=0))}function N(t,e){u._tr_flush_block(t,0<=t.block_start?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,F(t.strm)}function U(t,e){t.pending_buf[t.pending++]=e}function P(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e}function L(t,e){var r,i,n=t.max_chain_length,s=t.strstart,a=t.prev_length,o=t.nice_match,h=t.strstart>t.w_size-z?t.strstart-(t.w_size-z):0,u=t.window,l=t.w_mask,f=t.prev,d=t.strstart+S,c=u[s+a-1],p=u[s+a];t.prev_length>=t.good_match&&(n>>=2),o>t.lookahead&&(o=t.lookahead);do{if(u[(r=e)+a]===p&&u[r+a-1]===c&&u[r]===u[s]&&u[++r]===u[s+1]){s+=2,r++;do{}while(u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&s<d);if(i=S-(d-s),s=d-S,a<i){if(t.match_start=e,o<=(a=i))break;c=u[s+a-1],p=u[s+a]}}}while((e=f[e&l])>h&&0!=--n);return a<=t.lookahead?a:t.lookahead}function j(t){var e,r,i,n,s,a,o,h,u,l,f=t.w_size;do{if(n=t.window_size-t.lookahead-t.strstart,t.strstart>=f+(f-z)){for(d.arraySet(t.window,t.window,f,f,0),t.match_start-=f,t.strstart-=f,t.block_start-=f,e=r=t.hash_size;i=t.head[--e],t.head[e]=f<=i?i-f:0,--r;);for(e=r=f;i=t.prev[--e],t.prev[e]=f<=i?i-f:0,--r;);n+=f}if(0===t.strm.avail_in)break;if(a=t.strm,o=t.window,h=t.strstart+t.lookahead,u=n,l=void 0,l=a.avail_in,u<l&&(l=u),r=0===l?0:(a.avail_in-=l,d.arraySet(o,a.input,a.next_in,l,h),1===a.state.wrap?a.adler=c(a.adler,o,l,h):2===a.state.wrap&&(a.adler=p(a.adler,o,l,h)),a.next_in+=l,a.total_in+=l,l),t.lookahead+=r,t.lookahead+t.insert>=x)for(s=t.strstart-t.insert,t.ins_h=t.window[s],t.ins_h=(t.ins_h<<t.hash_shift^t.window[s+1])&t.hash_mask;t.insert&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[s+x-1])&t.hash_mask,t.prev[s&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=s,s++,t.insert--,!(t.lookahead+t.insert<x)););}while(t.lookahead<z&&0!==t.strm.avail_in)}function Z(t,e){for(var r,i;;){if(t.lookahead<z){if(j(t),t.lookahead<z&&e===l)return A;if(0===t.lookahead)break}if(r=0,t.lookahead>=x&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==r&&t.strstart-r<=t.w_size-z&&(t.match_length=L(t,r)),t.match_length>=x)if(i=u._tr_tally(t,t.strstart-t.match_start,t.match_length-x),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=x){for(t.match_length--;t.strstart++,t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart,0!=--t.match_length;);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+1])&t.hash_mask;else i=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=t.strstart<x-1?t.strstart:x-1,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}function W(t,e){for(var r,i,n;;){if(t.lookahead<z){if(j(t),t.lookahead<z&&e===l)return A;if(0===t.lookahead)break}if(r=0,t.lookahead>=x&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=x-1,0!==r&&t.prev_length<t.max_lazy_match&&t.strstart-r<=t.w_size-z&&(t.match_length=L(t,r),t.match_length<=5&&(1===t.strategy||t.match_length===x&&4096<t.strstart-t.match_start)&&(t.match_length=x-1)),t.prev_length>=x&&t.match_length<=t.prev_length){for(n=t.strstart+t.lookahead-x,i=u._tr_tally(t,t.strstart-1-t.prev_match,t.prev_length-x),t.lookahead-=t.prev_length-1,t.prev_length-=2;++t.strstart<=n&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!=--t.prev_length;);if(t.match_available=0,t.match_length=x-1,t.strstart++,i&&(N(t,!1),0===t.strm.avail_out))return A}else if(t.match_available){if((i=u._tr_tally(t,0,t.window[t.strstart-1]))&&N(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return A}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=u._tr_tally(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<x-1?t.strstart:x-1,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}function M(t,e,r,i,n){this.good_length=t,this.max_lazy=e,this.nice_length=r,this.max_chain=i,this.func=n}function H(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=v,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new d.Buf16(2*w),this.dyn_dtree=new d.Buf16(2*(2*a+1)),this.bl_tree=new d.Buf16(2*(2*o+1)),D(this.dyn_ltree),D(this.dyn_dtree),D(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new d.Buf16(k+1),this.heap=new d.Buf16(2*s+1),D(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new d.Buf16(2*s+1),D(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function G(t){var e;return t&&t.state?(t.total_in=t.total_out=0,t.data_type=n,(e=t.state).pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?C:E,t.adler=2===e.wrap?0:1,e.last_flush=l,u._tr_init(e),m):R(t,_)}function K(t){var e=G(t);return e===m&&function(t){t.window_size=2*t.w_size,D(t.head),t.max_lazy_match=h[t.level].max_lazy,t.good_match=h[t.level].good_length,t.nice_match=h[t.level].nice_length,t.max_chain_length=h[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=x-1,t.match_available=0,t.ins_h=0}(t.state),e}function Y(t,e,r,i,n,s){if(!t)return _;var a=1;if(e===g&&(e=6),i<0?(a=0,i=-i):15<i&&(a=2,i-=16),n<1||y<n||r!==v||i<8||15<i||e<0||9<e||s<0||b<s)return R(t,_);8===i&&(i=9);var o=new H;return(t.state=o).strm=t,o.wrap=a,o.gzhead=null,o.w_bits=i,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=n+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+x-1)/x),o.window=new d.Buf8(2*o.w_size),o.head=new d.Buf16(o.hash_size),o.prev=new d.Buf16(o.w_size),o.lit_bufsize=1<<n+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new d.Buf8(o.pending_buf_size),o.d_buf=1*o.lit_bufsize,o.l_buf=3*o.lit_bufsize,o.level=e,o.strategy=s,o.method=r,K(t)}h=[new M(0,0,0,0,function(t,e){var r=65535;for(r>t.pending_buf_size-5&&(r=t.pending_buf_size-5);;){if(t.lookahead<=1){if(j(t),0===t.lookahead&&e===l)return A;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var i=t.block_start+r;if((0===t.strstart||t.strstart>=i)&&(t.lookahead=t.strstart-i,t.strstart=i,N(t,!1),0===t.strm.avail_out))return A;if(t.strstart-t.block_start>=t.w_size-z&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):(t.strstart>t.block_start&&(N(t,!1),t.strm.avail_out),A)}),new M(4,4,8,4,Z),new M(4,5,16,8,Z),new M(4,6,32,32,Z),new M(4,4,16,16,W),new M(8,16,32,32,W),new M(8,16,128,128,W),new M(8,32,128,256,W),new M(32,128,258,1024,W),new M(32,258,258,4096,W)],r.deflateInit=function(t,e){return Y(t,e,v,15,8,0)},r.deflateInit2=Y,r.deflateReset=K,r.deflateResetKeep=G,r.deflateSetHeader=function(t,e){return t&&t.state?2!==t.state.wrap?_:(t.state.gzhead=e,m):_},r.deflate=function(t,e){var r,i,n,s;if(!t||!t.state||5<e||e<0)return t?R(t,_):_;if(i=t.state,!t.output||!t.input&&0!==t.avail_in||666===i.status&&e!==f)return R(t,0===t.avail_out?-5:_);if(i.strm=t,r=i.last_flush,i.last_flush=e,i.status===C)if(2===i.wrap)t.adler=0,U(i,31),U(i,139),U(i,8),i.gzhead?(U(i,(i.gzhead.text?1:0)+(i.gzhead.hcrc?2:0)+(i.gzhead.extra?4:0)+(i.gzhead.name?8:0)+(i.gzhead.comment?16:0)),U(i,255&i.gzhead.time),U(i,i.gzhead.time>>8&255),U(i,i.gzhead.time>>16&255),U(i,i.gzhead.time>>24&255),U(i,9===i.level?2:2<=i.strategy||i.level<2?4:0),U(i,255&i.gzhead.os),i.gzhead.extra&&i.gzhead.extra.length&&(U(i,255&i.gzhead.extra.length),U(i,i.gzhead.extra.length>>8&255)),i.gzhead.hcrc&&(t.adler=p(t.adler,i.pending_buf,i.pending,0)),i.gzindex=0,i.status=69):(U(i,0),U(i,0),U(i,0),U(i,0),U(i,0),U(i,9===i.level?2:2<=i.strategy||i.level<2?4:0),U(i,3),i.status=E);else{var a=v+(i.w_bits-8<<4)<<8;a|=(2<=i.strategy||i.level<2?0:i.level<6?1:6===i.level?2:3)<<6,0!==i.strstart&&(a|=32),a+=31-a%31,i.status=E,P(i,a),0!==i.strstart&&(P(i,t.adler>>>16),P(i,65535&t.adler)),t.adler=1}if(69===i.status)if(i.gzhead.extra){for(n=i.pending;i.gzindex<(65535&i.gzhead.extra.length)&&(i.pending!==i.pending_buf_size||(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending!==i.pending_buf_size));)U(i,255&i.gzhead.extra[i.gzindex]),i.gzindex++;i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),i.gzindex===i.gzhead.extra.length&&(i.gzindex=0,i.status=73)}else i.status=73;if(73===i.status)if(i.gzhead.name){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending===i.pending_buf_size)){s=1;break}s=i.gzindex<i.gzhead.name.length?255&i.gzhead.name.charCodeAt(i.gzindex++):0,U(i,s)}while(0!==s);i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),0===s&&(i.gzindex=0,i.status=91)}else i.status=91;if(91===i.status)if(i.gzhead.comment){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending===i.pending_buf_size)){s=1;break}s=i.gzindex<i.gzhead.comment.length?255&i.gzhead.comment.charCodeAt(i.gzindex++):0,U(i,s)}while(0!==s);i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),0===s&&(i.status=103)}else i.status=103;if(103===i.status&&(i.gzhead.hcrc?(i.pending+2>i.pending_buf_size&&F(t),i.pending+2<=i.pending_buf_size&&(U(i,255&t.adler),U(i,t.adler>>8&255),t.adler=0,i.status=E)):i.status=E),0!==i.pending){if(F(t),0===t.avail_out)return i.last_flush=-1,m}else if(0===t.avail_in&&T(e)<=T(r)&&e!==f)return R(t,-5);if(666===i.status&&0!==t.avail_in)return R(t,-5);if(0!==t.avail_in||0!==i.lookahead||e!==l&&666!==i.status){var o=2===i.strategy?function(t,e){for(var r;;){if(0===t.lookahead&&(j(t),0===t.lookahead)){if(e===l)return A;break}if(t.match_length=0,r=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,r&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}(i,e):3===i.strategy?function(t,e){for(var r,i,n,s,a=t.window;;){if(t.lookahead<=S){if(j(t),t.lookahead<=S&&e===l)return A;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=x&&0<t.strstart&&(i=a[n=t.strstart-1])===a[++n]&&i===a[++n]&&i===a[++n]){s=t.strstart+S;do{}while(i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&n<s);t.match_length=S-(s-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=x?(r=u._tr_tally(t,1,t.match_length-x),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(r=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),r&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}(i,e):h[i.level].func(i,e);if(o!==O&&o!==B||(i.status=666),o===A||o===O)return 0===t.avail_out&&(i.last_flush=-1),m;if(o===I&&(1===e?u._tr_align(i):5!==e&&(u._tr_stored_block(i,0,0,!1),3===e&&(D(i.head),0===i.lookahead&&(i.strstart=0,i.block_start=0,i.insert=0))),F(t),0===t.avail_out))return i.last_flush=-1,m}return e!==f?m:i.wrap<=0?1:(2===i.wrap?(U(i,255&t.adler),U(i,t.adler>>8&255),U(i,t.adler>>16&255),U(i,t.adler>>24&255),U(i,255&t.total_in),U(i,t.total_in>>8&255),U(i,t.total_in>>16&255),U(i,t.total_in>>24&255)):(P(i,t.adler>>>16),P(i,65535&t.adler)),F(t),0<i.wrap&&(i.wrap=-i.wrap),0!==i.pending?m:1)},r.deflateEnd=function(t){var e;return t&&t.state?(e=t.state.status)!==C&&69!==e&&73!==e&&91!==e&&103!==e&&e!==E&&666!==e?R(t,_):(t.state=null,e===E?R(t,-3):m):_},r.deflateSetDictionary=function(t,e){var r,i,n,s,a,o,h,u,l=e.length;if(!t||!t.state)return _;if(2===(s=(r=t.state).wrap)||1===s&&r.status!==C||r.lookahead)return _;for(1===s&&(t.adler=c(t.adler,e,l,0)),r.wrap=0,l>=r.w_size&&(0===s&&(D(r.head),r.strstart=0,r.block_start=0,r.insert=0),u=new d.Buf8(r.w_size),d.arraySet(u,e,l-r.w_size,r.w_size,0),e=u,l=r.w_size),a=t.avail_in,o=t.next_in,h=t.input,t.avail_in=l,t.next_in=0,t.input=e,j(r);r.lookahead>=x;){for(i=r.strstart,n=r.lookahead-(x-1);r.ins_h=(r.ins_h<<r.hash_shift^r.window[i+x-1])&r.hash_mask,r.prev[i&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=i,i++,--n;);r.strstart=i,r.lookahead=x-1,j(r)}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=x-1,r.match_available=0,t.next_in=o,t.input=h,t.avail_in=a,r.wrap=s,m},r.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(t,e,r){"use strict";e.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}},{}],48:[function(t,e,r){"use strict";e.exports=function(t,e){var r,i,n,s,a,o,h,u,l,f,d,c,p,m,_,g,b,v,y,w,k,x,S,z,C;r=t.state,i=t.next_in,z=t.input,n=i+(t.avail_in-5),s=t.next_out,C=t.output,a=s-(e-t.avail_out),o=s+(t.avail_out-257),h=r.dmax,u=r.wsize,l=r.whave,f=r.wnext,d=r.window,c=r.hold,p=r.bits,m=r.lencode,_=r.distcode,g=(1<<r.lenbits)-1,b=(1<<r.distbits)-1;t:do{p<15&&(c+=z[i++]<<p,p+=8,c+=z[i++]<<p,p+=8),v=m[c&g];e:for(;;){if(c>>>=y=v>>>24,p-=y,0===(y=v>>>16&255))C[s++]=65535&v;else{if(!(16&y)){if(0==(64&y)){v=m[(65535&v)+(c&(1<<y)-1)];continue e}if(32&y){r.mode=12;break t}t.msg="invalid literal/length code",r.mode=30;break t}w=65535&v,(y&=15)&&(p<y&&(c+=z[i++]<<p,p+=8),w+=c&(1<<y)-1,c>>>=y,p-=y),p<15&&(c+=z[i++]<<p,p+=8,c+=z[i++]<<p,p+=8),v=_[c&b];r:for(;;){if(c>>>=y=v>>>24,p-=y,!(16&(y=v>>>16&255))){if(0==(64&y)){v=_[(65535&v)+(c&(1<<y)-1)];continue r}t.msg="invalid distance code",r.mode=30;break t}if(k=65535&v,p<(y&=15)&&(c+=z[i++]<<p,(p+=8)<y&&(c+=z[i++]<<p,p+=8)),h<(k+=c&(1<<y)-1)){t.msg="invalid distance too far back",r.mode=30;break t}if(c>>>=y,p-=y,(y=s-a)<k){if(l<(y=k-y)&&r.sane){t.msg="invalid distance too far back",r.mode=30;break t}if(S=d,(x=0)===f){if(x+=u-y,y<w){for(w-=y;C[s++]=d[x++],--y;);x=s-k,S=C}}else if(f<y){if(x+=u+f-y,(y-=f)<w){for(w-=y;C[s++]=d[x++],--y;);if(x=0,f<w){for(w-=y=f;C[s++]=d[x++],--y;);x=s-k,S=C}}}else if(x+=f-y,y<w){for(w-=y;C[s++]=d[x++],--y;);x=s-k,S=C}for(;2<w;)C[s++]=S[x++],C[s++]=S[x++],C[s++]=S[x++],w-=3;w&&(C[s++]=S[x++],1<w&&(C[s++]=S[x++]))}else{for(x=s-k;C[s++]=C[x++],C[s++]=C[x++],C[s++]=C[x++],2<(w-=3););w&&(C[s++]=C[x++],1<w&&(C[s++]=C[x++]))}break}}break}}while(i<n&&s<o);i-=w=p>>3,c&=(1<<(p-=w<<3))-1,t.next_in=i,t.next_out=s,t.avail_in=i<n?n-i+5:5-(i-n),t.avail_out=s<o?o-s+257:257-(s-o),r.hold=c,r.bits=p}},{}],49:[function(t,e,r){"use strict";var I=t("../utils/common"),O=t("./adler32"),B=t("./crc32"),R=t("./inffast"),T=t("./inftrees"),D=1,F=2,N=0,U=-2,P=1,i=852,n=592;function L(t){return(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24)}function s(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new I.Buf16(320),this.work=new I.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function a(t){var e;return t&&t.state?(e=t.state,t.total_in=t.total_out=e.total=0,t.msg="",e.wrap&&(t.adler=1&e.wrap),e.mode=P,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new I.Buf32(i),e.distcode=e.distdyn=new I.Buf32(n),e.sane=1,e.back=-1,N):U}function o(t){var e;return t&&t.state?((e=t.state).wsize=0,e.whave=0,e.wnext=0,a(t)):U}function h(t,e){var r,i;return t&&t.state?(i=t.state,e<0?(r=0,e=-e):(r=1+(e>>4),e<48&&(e&=15)),e&&(e<8||15<e)?U:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=r,i.wbits=e,o(t))):U}function u(t,e){var r,i;return t?(i=new s,(t.state=i).window=null,(r=h(t,e))!==N&&(t.state=null),r):U}var l,f,d=!0;function j(t){if(d){var e;for(l=new I.Buf32(512),f=new I.Buf32(32),e=0;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(T(D,t.lens,0,288,l,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;T(F,t.lens,0,32,f,0,t.work,{bits:5}),d=!1}t.lencode=l,t.lenbits=9,t.distcode=f,t.distbits=5}function Z(t,e,r,i){var n,s=t.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new I.Buf8(s.wsize)),i>=s.wsize?(I.arraySet(s.window,e,r-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):(i<(n=s.wsize-s.wnext)&&(n=i),I.arraySet(s.window,e,r-i,n,s.wnext),(i-=n)?(I.arraySet(s.window,e,r-i,i,0),s.wnext=i,s.whave=s.wsize):(s.wnext+=n,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=n))),0}r.inflateReset=o,r.inflateReset2=h,r.inflateResetKeep=a,r.inflateInit=function(t){return u(t,15)},r.inflateInit2=u,r.inflate=function(t,e){var r,i,n,s,a,o,h,u,l,f,d,c,p,m,_,g,b,v,y,w,k,x,S,z,C=0,E=new I.Buf8(4),A=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!t||!t.state||!t.output||!t.input&&0!==t.avail_in)return U;12===(r=t.state).mode&&(r.mode=13),a=t.next_out,n=t.output,h=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,u=r.hold,l=r.bits,f=o,d=h,x=N;t:for(;;)switch(r.mode){case P:if(0===r.wrap){r.mode=13;break}for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(2&r.wrap&&35615===u){E[r.check=0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0),l=u=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&u)<<8)+(u>>8))%31){t.msg="incorrect header check",r.mode=30;break}if(8!=(15&u)){t.msg="unknown compression method",r.mode=30;break}if(l-=4,k=8+(15&(u>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){t.msg="invalid window size",r.mode=30;break}r.dmax=1<<k,t.adler=r.check=1,r.mode=512&u?10:12,l=u=0;break;case 2:for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(r.flags=u,8!=(255&r.flags)){t.msg="unknown compression method",r.mode=30;break}if(57344&r.flags){t.msg="unknown header flags set",r.mode=30;break}r.head&&(r.head.text=u>>8&1),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=3;case 3:for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.head&&(r.head.time=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,E[2]=u>>>16&255,E[3]=u>>>24&255,r.check=B(r.check,E,4,0)),l=u=0,r.mode=4;case 4:for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.head&&(r.head.xflags=255&u,r.head.os=u>>8),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=5;case 5:if(1024&r.flags){for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.length=u,r.head&&(r.head.extra_len=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&(o<(c=r.length)&&(c=o),c&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),I.arraySet(r.head.extra,i,s,c,k)),512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,r.length-=c),r.length))break t;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===o)break t;for(c=0;k=i[s+c++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,k)break t}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===o)break t;for(c=0;k=i[s+c++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,k)break t}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u!==(65535&r.check)){t.msg="header crc mismatch",r.mode=30;break}l=u=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),t.adler=r.check=0,r.mode=12;break;case 10:for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}t.adler=r.check=L(u),l=u=0,r.mode=11;case 11:if(0===r.havedict)return t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,2;t.adler=r.check=1,r.mode=12;case 12:if(5===e||6===e)break t;case 13:if(r.last){u>>>=7&l,l-=7&l,r.mode=27;break}for(;l<3;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}switch(r.last=1&u,l-=1,3&(u>>>=1)){case 0:r.mode=14;break;case 1:if(j(r),r.mode=20,6!==e)break;u>>>=2,l-=2;break t;case 2:r.mode=17;break;case 3:t.msg="invalid block type",r.mode=30}u>>>=2,l-=2;break;case 14:for(u>>>=7&l,l-=7&l;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if((65535&u)!=(u>>>16^65535)){t.msg="invalid stored block lengths",r.mode=30;break}if(r.length=65535&u,l=u=0,r.mode=15,6===e)break t;case 15:r.mode=16;case 16:if(c=r.length){if(o<c&&(c=o),h<c&&(c=h),0===c)break t;I.arraySet(n,i,s,c,a),o-=c,s+=c,h-=c,a+=c,r.length-=c;break}r.mode=12;break;case 17:for(;l<14;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(r.nlen=257+(31&u),u>>>=5,l-=5,r.ndist=1+(31&u),u>>>=5,l-=5,r.ncode=4+(15&u),u>>>=4,l-=4,286<r.nlen||30<r.ndist){t.msg="too many length or distance symbols",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;l<3;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.lens[A[r.have++]]=7&u,u>>>=3,l-=3}for(;r.have<19;)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},x=T(0,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,x){t.msg="invalid code lengths set",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(b<16)u>>>=_,l-=_,r.lens[r.have++]=b;else{if(16===b){for(z=_+2;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u>>>=_,l-=_,0===r.have){t.msg="invalid bit length repeat",r.mode=30;break}k=r.lens[r.have-1],c=3+(3&u),u>>>=2,l-=2}else if(17===b){for(z=_+3;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}l-=_,k=0,c=3+(7&(u>>>=_)),u>>>=3,l-=3}else{for(z=_+7;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}l-=_,k=0,c=11+(127&(u>>>=_)),u>>>=7,l-=7}if(r.have+c>r.nlen+r.ndist){t.msg="invalid bit length repeat",r.mode=30;break}for(;c--;)r.lens[r.have++]=k}}if(30===r.mode)break;if(0===r.lens[256]){t.msg="invalid code -- missing end-of-block",r.mode=30;break}if(r.lenbits=9,S={bits:r.lenbits},x=T(D,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,x){t.msg="invalid literal/lengths set",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},x=T(F,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,x){t.msg="invalid distances set",r.mode=30;break}if(r.mode=20,6===e)break t;case 20:r.mode=21;case 21:if(6<=o&&258<=h){t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,R(t,d),a=t.next_out,n=t.output,h=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,u=r.hold,l=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(g&&0==(240&g)){for(v=_,y=g,w=b;g=(C=r.lencode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,r.length=b,0===g){r.mode=26;break}if(32&g){r.back=-1,r.mode=12;break}if(64&g){t.msg="invalid literal/length code",r.mode=30;break}r.extra=15&g,r.mode=22;case 22:if(r.extra){for(z=r.extra;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.length+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=23;case 23:for(;g=(C=r.distcode[u&(1<<r.distbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(0==(240&g)){for(v=_,y=g,w=b;g=(C=r.distcode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,64&g){t.msg="invalid distance code",r.mode=30;break}r.offset=b,r.extra=15&g,r.mode=24;case 24:if(r.extra){for(z=r.extra;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.offset+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){t.msg="invalid distance too far back",r.mode=30;break}r.mode=25;case 25:if(0===h)break t;if(c=d-h,r.offset>c){if((c=r.offset-c)>r.whave&&r.sane){t.msg="invalid distance too far back",r.mode=30;break}p=c>r.wnext?(c-=r.wnext,r.wsize-c):r.wnext-c,c>r.length&&(c=r.length),m=r.window}else m=n,p=a-r.offset,c=r.length;for(h<c&&(c=h),h-=c,r.length-=c;n[a++]=m[p++],--c;);0===r.length&&(r.mode=21);break;case 26:if(0===h)break t;n[a++]=r.length,h--,r.mode=21;break;case 27:if(r.wrap){for(;l<32;){if(0===o)break t;o--,u|=i[s++]<<l,l+=8}if(d-=h,t.total_out+=d,r.total+=d,d&&(t.adler=r.check=r.flags?B(r.check,n,d,a-d):O(r.check,n,d,a-d)),d=h,(r.flags?u:L(u))!==r.check){t.msg="incorrect data check",r.mode=30;break}l=u=0}r.mode=28;case 28:if(r.wrap&&r.flags){for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u!==(4294967295&r.total)){t.msg="incorrect length check",r.mode=30;break}l=u=0}r.mode=29;case 29:x=1;break t;case 30:x=-3;break t;case 31:return-4;case 32:default:return U}return t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,(r.wsize||d!==t.avail_out&&r.mode<30&&(r.mode<27||4!==e))&&Z(t,t.output,t.next_out,d-t.avail_out)?(r.mode=31,-4):(f-=t.avail_in,d-=t.avail_out,t.total_in+=f,t.total_out+=d,r.total+=d,r.wrap&&d&&(t.adler=r.check=r.flags?B(r.check,n,d,t.next_out-d):O(r.check,n,d,t.next_out-d)),t.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0==f&&0===d||4===e)&&x===N&&(x=-5),x)},r.inflateEnd=function(t){if(!t||!t.state)return U;var e=t.state;return e.window&&(e.window=null),t.state=null,N},r.inflateGetHeader=function(t,e){var r;return t&&t.state?0==(2&(r=t.state).wrap)?U:((r.head=e).done=!1,N):U},r.inflateSetDictionary=function(t,e){var r,i=e.length;return t&&t.state?0!==(r=t.state).wrap&&11!==r.mode?U:11===r.mode&&O(1,e,i,0)!==r.check?-3:Z(t,e,i,i)?(r.mode=31,-4):(r.havedict=1,N):U},r.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(t,e,r){"use strict";var D=t("../utils/common"),F=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],N=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],U=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],P=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];e.exports=function(t,e,r,i,n,s,a,o){var h,u,l,f,d,c,p,m,_,g=o.bits,b=0,v=0,y=0,w=0,k=0,x=0,S=0,z=0,C=0,E=0,A=null,I=0,O=new D.Buf16(16),B=new D.Buf16(16),R=null,T=0;for(b=0;b<=15;b++)O[b]=0;for(v=0;v<i;v++)O[e[r+v]]++;for(k=g,w=15;1<=w&&0===O[w];w--);if(w<k&&(k=w),0===w)return n[s++]=20971520,n[s++]=20971520,o.bits=1,0;for(y=1;y<w&&0===O[y];y++);for(k<y&&(k=y),b=z=1;b<=15;b++)if(z<<=1,(z-=O[b])<0)return-1;if(0<z&&(0===t||1!==w))return-1;for(B[1]=0,b=1;b<15;b++)B[b+1]=B[b]+O[b];for(v=0;v<i;v++)0!==e[r+v]&&(a[B[e[r+v]]++]=v);if(c=0===t?(A=R=a,19):1===t?(A=F,I-=257,R=N,T-=257,256):(A=U,R=P,-1),b=y,d=s,S=v=E=0,l=-1,f=(C=1<<(x=k))-1,1===t&&852<C||2===t&&592<C)return 1;for(;;){for(p=b-S,_=a[v]<c?(m=0,a[v]):a[v]>c?(m=R[T+a[v]],A[I+a[v]]):(m=96,0),h=1<<b-S,y=u=1<<x;n[d+(E>>S)+(u-=h)]=p<<24|m<<16|_|0,0!==u;);for(h=1<<b-1;E&h;)h>>=1;if(0!==h?(E&=h-1,E+=h):E=0,v++,0==--O[b]){if(b===w)break;b=e[r+a[v]]}if(k<b&&(E&f)!==l){for(0===S&&(S=k),d+=y,z=1<<(x=b-S);x+S<w&&!((z-=O[x+S])<=0);)x++,z<<=1;if(C+=1<<x,1===t&&852<C||2===t&&592<C)return 1;n[l=E&f]=k<<24|x<<16|d-s|0}}return 0!==E&&(n[d+E]=b-S<<24|64<<16|0),o.bits=k,0}},{"../utils/common":41}],51:[function(t,e,r){"use strict";e.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],52:[function(t,e,r){"use strict";var n=t("../utils/common"),o=0,h=1;function i(t){for(var e=t.length;0<=--e;)t[e]=0}var s=0,a=29,u=256,l=u+1+a,f=30,d=19,_=2*l+1,g=15,c=16,p=7,m=256,b=16,v=17,y=18,w=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],k=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],x=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],S=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],z=new Array(2*(l+2));i(z);var C=new Array(2*f);i(C);var E=new Array(512);i(E);var A=new Array(256);i(A);var I=new Array(a);i(I);var O,B,R,T=new Array(f);function D(t,e,r,i,n){this.static_tree=t,this.extra_bits=e,this.extra_base=r,this.elems=i,this.max_length=n,this.has_stree=t&&t.length}function F(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}function N(t){return t<256?E[t]:E[256+(t>>>7)]}function U(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255}function P(t,e,r){t.bi_valid>c-r?(t.bi_buf|=e<<t.bi_valid&65535,U(t,t.bi_buf),t.bi_buf=e>>c-t.bi_valid,t.bi_valid+=r-c):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=r)}function L(t,e,r){P(t,r[2*e],r[2*e+1])}function j(t,e){for(var r=0;r|=1&t,t>>>=1,r<<=1,0<--e;);return r>>>1}function Z(t,e,r){var i,n,s=new Array(g+1),a=0;for(i=1;i<=g;i++)s[i]=a=a+r[i-1]<<1;for(n=0;n<=e;n++){var o=t[2*n+1];0!==o&&(t[2*n]=j(s[o]++,o))}}function W(t){var e;for(e=0;e<l;e++)t.dyn_ltree[2*e]=0;for(e=0;e<f;e++)t.dyn_dtree[2*e]=0;for(e=0;e<d;e++)t.bl_tree[2*e]=0;t.dyn_ltree[2*m]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0}function M(t){8<t.bi_valid?U(t,t.bi_buf):0<t.bi_valid&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0}function H(t,e,r,i){var n=2*e,s=2*r;return t[n]<t[s]||t[n]===t[s]&&i[e]<=i[r]}function G(t,e,r){for(var i=t.heap[r],n=r<<1;n<=t.heap_len&&(n<t.heap_len&&H(e,t.heap[n+1],t.heap[n],t.depth)&&n++,!H(e,i,t.heap[n],t.depth));)t.heap[r]=t.heap[n],r=n,n<<=1;t.heap[r]=i}function K(t,e,r){var i,n,s,a,o=0;if(0!==t.last_lit)for(;i=t.pending_buf[t.d_buf+2*o]<<8|t.pending_buf[t.d_buf+2*o+1],n=t.pending_buf[t.l_buf+o],o++,0===i?L(t,n,e):(L(t,(s=A[n])+u+1,e),0!==(a=w[s])&&P(t,n-=I[s],a),L(t,s=N(--i),r),0!==(a=k[s])&&P(t,i-=T[s],a)),o<t.last_lit;);L(t,m,e)}function Y(t,e){var r,i,n,s=e.dyn_tree,a=e.stat_desc.static_tree,o=e.stat_desc.has_stree,h=e.stat_desc.elems,u=-1;for(t.heap_len=0,t.heap_max=_,r=0;r<h;r++)0!==s[2*r]?(t.heap[++t.heap_len]=u=r,t.depth[r]=0):s[2*r+1]=0;for(;t.heap_len<2;)s[2*(n=t.heap[++t.heap_len]=u<2?++u:0)]=1,t.depth[n]=0,t.opt_len--,o&&(t.static_len-=a[2*n+1]);for(e.max_code=u,r=t.heap_len>>1;1<=r;r--)G(t,s,r);for(n=h;r=t.heap[1],t.heap[1]=t.heap[t.heap_len--],G(t,s,1),i=t.heap[1],t.heap[--t.heap_max]=r,t.heap[--t.heap_max]=i,s[2*n]=s[2*r]+s[2*i],t.depth[n]=(t.depth[r]>=t.depth[i]?t.depth[r]:t.depth[i])+1,s[2*r+1]=s[2*i+1]=n,t.heap[1]=n++,G(t,s,1),2<=t.heap_len;);t.heap[--t.heap_max]=t.heap[1],function(t,e){var r,i,n,s,a,o,h=e.dyn_tree,u=e.max_code,l=e.stat_desc.static_tree,f=e.stat_desc.has_stree,d=e.stat_desc.extra_bits,c=e.stat_desc.extra_base,p=e.stat_desc.max_length,m=0;for(s=0;s<=g;s++)t.bl_count[s]=0;for(h[2*t.heap[t.heap_max]+1]=0,r=t.heap_max+1;r<_;r++)p<(s=h[2*h[2*(i=t.heap[r])+1]+1]+1)&&(s=p,m++),h[2*i+1]=s,u<i||(t.bl_count[s]++,a=0,c<=i&&(a=d[i-c]),o=h[2*i],t.opt_len+=o*(s+a),f&&(t.static_len+=o*(l[2*i+1]+a)));if(0!==m){do{for(s=p-1;0===t.bl_count[s];)s--;t.bl_count[s]--,t.bl_count[s+1]+=2,t.bl_count[p]--,m-=2}while(0<m);for(s=p;0!==s;s--)for(i=t.bl_count[s];0!==i;)u<(n=t.heap[--r])||(h[2*n+1]!==s&&(t.opt_len+=(s-h[2*n+1])*h[2*n],h[2*n+1]=s),i--)}}(t,e),Z(s,u,t.bl_count)}function X(t,e,r){var i,n,s=-1,a=e[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),e[2*(r+1)+1]=65535,i=0;i<=r;i++)n=a,a=e[2*(i+1)+1],++o<h&&n===a||(o<u?t.bl_tree[2*n]+=o:0!==n?(n!==s&&t.bl_tree[2*n]++,t.bl_tree[2*b]++):o<=10?t.bl_tree[2*v]++:t.bl_tree[2*y]++,s=n,u=(o=0)===a?(h=138,3):n===a?(h=6,3):(h=7,4))}function V(t,e,r){var i,n,s=-1,a=e[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),i=0;i<=r;i++)if(n=a,a=e[2*(i+1)+1],!(++o<h&&n===a)){if(o<u)for(;L(t,n,t.bl_tree),0!=--o;);else 0!==n?(n!==s&&(L(t,n,t.bl_tree),o--),L(t,b,t.bl_tree),P(t,o-3,2)):o<=10?(L(t,v,t.bl_tree),P(t,o-3,3)):(L(t,y,t.bl_tree),P(t,o-11,7));s=n,u=(o=0)===a?(h=138,3):n===a?(h=6,3):(h=7,4)}}i(T);var q=!1;function J(t,e,r,i){P(t,(s<<1)+(i?1:0),3),function(t,e,r,i){M(t),i&&(U(t,r),U(t,~r)),n.arraySet(t.pending_buf,t.window,e,r,t.pending),t.pending+=r}(t,e,r,!0)}r._tr_init=function(t){q||(function(){var t,e,r,i,n,s=new Array(g+1);for(i=r=0;i<a-1;i++)for(I[i]=r,t=0;t<1<<w[i];t++)A[r++]=i;for(A[r-1]=i,i=n=0;i<16;i++)for(T[i]=n,t=0;t<1<<k[i];t++)E[n++]=i;for(n>>=7;i<f;i++)for(T[i]=n<<7,t=0;t<1<<k[i]-7;t++)E[256+n++]=i;for(e=0;e<=g;e++)s[e]=0;for(t=0;t<=143;)z[2*t+1]=8,t++,s[8]++;for(;t<=255;)z[2*t+1]=9,t++,s[9]++;for(;t<=279;)z[2*t+1]=7,t++,s[7]++;for(;t<=287;)z[2*t+1]=8,t++,s[8]++;for(Z(z,l+1,s),t=0;t<f;t++)C[2*t+1]=5,C[2*t]=j(t,5);O=new D(z,w,u+1,l,g),B=new D(C,k,0,f,g),R=new D(new Array(0),x,0,d,p)}(),q=!0),t.l_desc=new F(t.dyn_ltree,O),t.d_desc=new F(t.dyn_dtree,B),t.bl_desc=new F(t.bl_tree,R),t.bi_buf=0,t.bi_valid=0,W(t)},r._tr_stored_block=J,r._tr_flush_block=function(t,e,r,i){var n,s,a=0;0<t.level?(2===t.strm.data_type&&(t.strm.data_type=function(t){var e,r=4093624447;for(e=0;e<=31;e++,r>>>=1)if(1&r&&0!==t.dyn_ltree[2*e])return o;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return h;for(e=32;e<u;e++)if(0!==t.dyn_ltree[2*e])return h;return o}(t)),Y(t,t.l_desc),Y(t,t.d_desc),a=function(t){var e;for(X(t,t.dyn_ltree,t.l_desc.max_code),X(t,t.dyn_dtree,t.d_desc.max_code),Y(t,t.bl_desc),e=d-1;3<=e&&0===t.bl_tree[2*S[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(t),n=t.opt_len+3+7>>>3,(s=t.static_len+3+7>>>3)<=n&&(n=s)):n=s=r+5,r+4<=n&&-1!==e?J(t,e,r,i):4===t.strategy||s===n?(P(t,2+(i?1:0),3),K(t,z,C)):(P(t,4+(i?1:0),3),function(t,e,r,i){var n;for(P(t,e-257,5),P(t,r-1,5),P(t,i-4,4),n=0;n<i;n++)P(t,t.bl_tree[2*S[n]+1],3);V(t,t.dyn_ltree,e-1),V(t,t.dyn_dtree,r-1)}(t,t.l_desc.max_code+1,t.d_desc.max_code+1,a+1),K(t,t.dyn_ltree,t.dyn_dtree)),W(t),i&&M(t)},r._tr_tally=function(t,e,r){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&r,t.last_lit++,0===e?t.dyn_ltree[2*r]++:(t.matches++,e--,t.dyn_ltree[2*(A[r]+u+1)]++,t.dyn_dtree[2*N(e)]++),t.last_lit===t.lit_bufsize-1},r._tr_align=function(t){P(t,2,3),L(t,m,z),function(t){16===t.bi_valid?(U(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):8<=t.bi_valid&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}(t)}},{"../utils/common":41}],53:[function(t,e,r){"use strict";e.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},{}],54:[function(t,e,r){"use strict";e.exports="function"==typeof setImmediate?setImmediate:function(){var t=[].slice.apply(arguments);t.splice(1,0,0),setTimeout.apply(null,t)}},{}]},{},[10])(10)});

/***/ }),

/***/ 3441:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 3441;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 601:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(7147)
var path = __webpack_require__(1017)
var os = __webpack_require__(2037)

// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'
var runtimeRequire =  true ? require : 0 // eslint-disable-line

var vars = (process.config && process.config.variables) || {}
var prebuildsOnly = !!process.env.PREBUILDS_ONLY
var abi = process.versions.modules // TODO: support old node where this is undef
var runtime = isElectron() ? 'electron' : 'node'
var arch = os.arch()
var platform = os.platform()
var libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc')
var armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || ''
var uv = (process.versions.uv || '').split('.')[0]

module.exports = load

function load (dir) {
  return runtimeRequire(load.path(dir))
}

load.path = function (dir) {
  dir = path.resolve(dir || '.')

  try {
    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_')
    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD']
  } catch (err) {}

  if (!prebuildsOnly) {
    var release = getFirst(path.join(dir, 'build/Release'), matchBuild)
    if (release) return release

    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)
    if (debug) return debug
  }

  var prebuild = resolve(dir)
  if (prebuild) return prebuild

  var nearby = resolve(path.dirname(process.execPath))
  if (nearby) return nearby

  var target = [
    'platform=' + platform,
    'arch=' + arch,
    'runtime=' + runtime,
    'abi=' + abi,
    'uv=' + uv,
    armv ? 'armv=' + armv : '',
    'libc=' + libc,
    'node=' + process.versions.node,
    process.versions.electron ? 'electron=' + process.versions.electron : '',
     true ? 'webpack=true' : 0 // eslint-disable-line
  ].filter(Boolean).join(' ')

  throw new Error('No native build was found for ' + target + '\n    loaded from: ' + dir + '\n')

  function resolve (dir) {
    // Find matching "prebuilds/<platform>-<arch>" directory
    var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple)
    var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0]
    if (!tuple) return

    // Find most specific flavor first
    var prebuilds = path.join(dir, 'prebuilds', tuple.name)
    var parsed = readdirSync(prebuilds).map(parseTags)
    var candidates = parsed.filter(matchTags(runtime, abi))
    var winner = candidates.sort(compareTags(runtime))[0]
    if (winner) return path.join(prebuilds, winner.file)
  }
}

function readdirSync (dir) {
  try {
    return fs.readdirSync(dir)
  } catch (err) {
    return []
  }
}

function getFirst (dir, filter) {
  var files = readdirSync(dir).filter(filter)
  return files[0] && path.join(dir, files[0])
}

function matchBuild (name) {
  return /\.node$/.test(name)
}

function parseTuple (name) {
  // Example: darwin-x64+arm64
  var arr = name.split('-')
  if (arr.length !== 2) return

  var platform = arr[0]
  var architectures = arr[1].split('+')

  if (!platform) return
  if (!architectures.length) return
  if (!architectures.every(Boolean)) return

  return { name, platform, architectures }
}

function matchTuple (platform, arch) {
  return function (tuple) {
    if (tuple == null) return false
    if (tuple.platform !== platform) return false
    return tuple.architectures.includes(arch)
  }
}

function compareTuples (a, b) {
  // Prefer single-arch prebuilds over multi-arch
  return a.architectures.length - b.architectures.length
}

function parseTags (file) {
  var arr = file.split('.')
  var extension = arr.pop()
  var tags = { file: file, specificity: 0 }

  if (extension !== 'node') return

  for (var i = 0; i < arr.length; i++) {
    var tag = arr[i]

    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {
      tags.runtime = tag
    } else if (tag === 'napi') {
      tags.napi = true
    } else if (tag.slice(0, 3) === 'abi') {
      tags.abi = tag.slice(3)
    } else if (tag.slice(0, 2) === 'uv') {
      tags.uv = tag.slice(2)
    } else if (tag.slice(0, 4) === 'armv') {
      tags.armv = tag.slice(4)
    } else if (tag === 'glibc' || tag === 'musl') {
      tags.libc = tag
    } else {
      continue
    }

    tags.specificity++
  }

  return tags
}

function matchTags (runtime, abi) {
  return function (tags) {
    if (tags == null) return false
    if (tags.runtime !== runtime && !runtimeAgnostic(tags)) return false
    if (tags.abi !== abi && !tags.napi) return false
    if (tags.uv && tags.uv !== uv) return false
    if (tags.armv && tags.armv !== armv) return false
    if (tags.libc && tags.libc !== libc) return false

    return true
  }
}

function runtimeAgnostic (tags) {
  return tags.runtime === 'node' && tags.napi
}

function compareTags (runtime) {
  // Precedence: non-agnostic runtime, abi over napi, then by specificity.
  return function (a, b) {
    if (a.runtime !== b.runtime) {
      return a.runtime === runtime ? -1 : 1
    } else if (a.abi !== b.abi) {
      return a.abi ? -1 : 1
    } else if (a.specificity !== b.specificity) {
      return a.specificity > b.specificity ? -1 : 1
    } else {
      return 0
    }
  }
}

function isElectron () {
  if (process.versions && process.versions.electron) return true
  if (process.env.ELECTRON_RUN_AS_NODE) return true
  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'
}

function isAlpine (platform) {
  return platform === 'linux' && fs.existsSync('/etc/alpine-release')
}

// Exposed for unit tests
// TODO: move to lib
load.parseTags = parseTags
load.matchTags = matchTags
load.compareTags = compareTags
load.parseTuple = parseTuple
load.matchTuple = matchTuple
load.compareTuples = compareTuples


/***/ }),

/***/ 4978:
/***/ (function(module) {

/*! NoSleep.min.js v0.12.0 - git.io/vfn01 - Rich Tibbett - MIT license */
!function(A,e){ true?module.exports=e():0}(this,(function(){return function(A){var e={};function B(g){if(e[g])return e[g].exports;var o=e[g]={i:g,l:!1,exports:{}};return A[g].call(o.exports,o,o.exports,B),o.l=!0,o.exports}return B.m=A,B.c=e,B.d=function(A,e,g){B.o(A,e)||Object.defineProperty(A,e,{enumerable:!0,get:g})},B.r=function(A){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(A,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(A,"__esModule",{value:!0})},B.t=function(A,e){if(1&e&&(A=B(A)),8&e)return A;if(4&e&&"object"==typeof A&&A&&A.__esModule)return A;var g=Object.create(null);if(B.r(g),Object.defineProperty(g,"default",{enumerable:!0,value:A}),2&e&&"string"!=typeof A)for(var o in A)B.d(g,o,function(e){return A[e]}.bind(null,o));return g},B.n=function(A){var e=A&&A.__esModule?function(){return A.default}:function(){return A};return B.d(e,"a",e),e},B.o=function(A,e){return Object.prototype.hasOwnProperty.call(A,e)},B.p="",B(B.s=0)}([function(A,e,B){"use strict";var g=function(){function A(A,e){for(var B=0;B<e.length;B++){var g=e[B];g.enumerable=g.enumerable||!1,g.configurable=!0,"value"in g&&(g.writable=!0),Object.defineProperty(A,g.key,g)}}return function(e,B,g){return B&&A(e.prototype,B),g&&A(e,g),e}}();var o=B(1),E=o.webm,n=o.mp4,C=function(){return"undefined"!=typeof navigator&&parseFloat((""+(/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent)||[0,""])[1]).replace("undefined","3_2").replace("_",".").replace("_",""))<10&&!window.MSStream},Q=function(){return"wakeLock"in navigator},i=function(){function A(){var e=this;if(function(A,e){if(!(A instanceof e))throw new TypeError("Cannot call a class as a function")}(this,A),this.enabled=!1,Q()){this._wakeLock=null;var B=function(){null!==e._wakeLock&&"visible"===document.visibilityState&&e.enable()};document.addEventListener("visibilitychange",B),document.addEventListener("fullscreenchange",B)}else C()?this.noSleepTimer=null:(this.noSleepVideo=document.createElement("video"),this.noSleepVideo.setAttribute("title","No Sleep"),this.noSleepVideo.setAttribute("playsinline",""),this._addSourceToVideo(this.noSleepVideo,"webm",E),this._addSourceToVideo(this.noSleepVideo,"mp4",n),this.noSleepVideo.addEventListener("loadedmetadata",(function(){e.noSleepVideo.duration<=1?e.noSleepVideo.setAttribute("loop",""):e.noSleepVideo.addEventListener("timeupdate",(function(){e.noSleepVideo.currentTime>.5&&(e.noSleepVideo.currentTime=Math.random())}))})))}return g(A,[{key:"_addSourceToVideo",value:function(A,e,B){var g=document.createElement("source");g.src=B,g.type="video/"+e,A.appendChild(g)}},{key:"enable",value:function(){var A=this;return Q()?navigator.wakeLock.request("screen").then((function(e){A._wakeLock=e,A.enabled=!0,console.log("Wake Lock active."),A._wakeLock.addEventListener("release",(function(){console.log("Wake Lock released.")}))})).catch((function(e){throw A.enabled=!1,console.error(e.name+", "+e.message),e})):C()?(this.disable(),console.warn("\n        NoSleep enabled for older iOS devices. This can interrupt\n        active or long-running network requests from completing successfully.\n        See https://github.com/richtr/NoSleep.js/issues/15 for more details.\n      "),this.noSleepTimer=window.setInterval((function(){document.hidden||(window.location.href=window.location.href.split("#")[0],window.setTimeout(window.stop,0))}),15e3),this.enabled=!0,Promise.resolve()):this.noSleepVideo.play().then((function(e){return A.enabled=!0,e})).catch((function(e){throw A.enabled=!1,e}))}},{key:"disable",value:function(){Q()?(this._wakeLock&&this._wakeLock.release(),this._wakeLock=null):C()?this.noSleepTimer&&(console.warn("\n          NoSleep now disabled for older iOS devices.\n        "),window.clearInterval(this.noSleepTimer),this.noSleepTimer=null):this.noSleepVideo.pause(),this.enabled=!1}},{key:"isEnabled",get:function(){return this.enabled}}]),A}();A.exports=i},function(A,e,B){"use strict";A.exports={webm:"data:video/webm;base64,GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4EEQoWBAhhTgGcBAAAAAAAVkhFNm3RALE27i1OrhBVJqWZTrIHfTbuMU6uEFlSua1OsggEwTbuMU6uEHFO7a1OsghV17AEAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAAEUq17GDD0JATYCNTGF2ZjU1LjMzLjEwMFdBjUxhdmY1NS4zMy4xMDBzpJBlrrXf3DCDVB8KcgbMpcr+RImIQJBgAAAAAAAWVK5rAQAAAAAAD++uAQAAAAAAADLXgQFzxYEBnIEAIrWcg3VuZIaFVl9WUDiDgQEj44OEAmJaAOABAAAAAAAABrCBsLqBkK4BAAAAAAAPq9eBAnPFgQKcgQAitZyDdW5khohBX1ZPUkJJU4OBAuEBAAAAAAAAEZ+BArWIQOdwAAAAAABiZIEgY6JPbwIeVgF2b3JiaXMAAAAAAoC7AAAAAAAAgLUBAAAAAAC4AQN2b3JiaXMtAAAAWGlwaC5PcmcgbGliVm9yYmlzIEkgMjAxMDExMDEgKFNjaGF1ZmVudWdnZXQpAQAAABUAAABlbmNvZGVyPUxhdmM1NS41Mi4xMDIBBXZvcmJpcyVCQ1YBAEAAACRzGCpGpXMWhBAaQlAZ4xxCzmvsGUJMEYIcMkxbyyVzkCGkoEKIWyiB0JBVAABAAACHQXgUhIpBCCGEJT1YkoMnPQghhIg5eBSEaUEIIYQQQgghhBBCCCGERTlokoMnQQgdhOMwOAyD5Tj4HIRFOVgQgydB6CCED0K4moOsOQghhCQ1SFCDBjnoHITCLCiKgsQwuBaEBDUojILkMMjUgwtCiJqDSTX4GoRnQXgWhGlBCCGEJEFIkIMGQcgYhEZBWJKDBjm4FITLQagahCo5CB+EIDRkFQCQAACgoiiKoigKEBqyCgDIAAAQQFEUx3EcyZEcybEcCwgNWQUAAAEACAAAoEiKpEiO5EiSJFmSJVmSJVmS5omqLMuyLMuyLMsyEBqyCgBIAABQUQxFcRQHCA1ZBQBkAAAIoDiKpViKpWiK54iOCISGrAIAgAAABAAAEDRDUzxHlETPVFXXtm3btm3btm3btm3btm1blmUZCA1ZBQBAAAAQ0mlmqQaIMAMZBkJDVgEACAAAgBGKMMSA0JBVAABAAACAGEoOogmtOd+c46BZDppKsTkdnEi1eZKbirk555xzzsnmnDHOOeecopxZDJoJrTnnnMSgWQqaCa0555wnsXnQmiqtOeeccc7pYJwRxjnnnCateZCajbU555wFrWmOmkuxOeecSLl5UptLtTnnnHPOOeecc84555zqxekcnBPOOeecqL25lpvQxTnnnE/G6d6cEM4555xzzjnnnHPOOeecIDRkFQAABABAEIaNYdwpCNLnaCBGEWIaMulB9+gwCRqDnELq0ehopJQ6CCWVcVJKJwgNWQUAAAIAQAghhRRSSCGFFFJIIYUUYoghhhhyyimnoIJKKqmooowyyyyzzDLLLLPMOuyssw47DDHEEEMrrcRSU2011lhr7jnnmoO0VlprrbVSSimllFIKQkNWAQAgAAAEQgYZZJBRSCGFFGKIKaeccgoqqIDQkFUAACAAgAAAAABP8hzRER3RER3RER3RER3R8RzPESVREiVREi3TMjXTU0VVdWXXlnVZt31b2IVd933d933d+HVhWJZlWZZlWZZlWZZlWZZlWZYgNGQVAAACAAAghBBCSCGFFFJIKcYYc8w56CSUEAgNWQUAAAIACAAAAHAUR3EcyZEcSbIkS9IkzdIsT/M0TxM9URRF0zRV0RVdUTdtUTZl0zVdUzZdVVZtV5ZtW7Z125dl2/d93/d93/d93/d93/d9XQdCQ1YBABIAADqSIymSIimS4ziOJElAaMgqAEAGAEAAAIriKI7jOJIkSZIlaZJneZaomZrpmZ4qqkBoyCoAABAAQAAAAAAAAIqmeIqpeIqoeI7oiJJomZaoqZoryqbsuq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq4LhIasAgAkAAB0JEdyJEdSJEVSJEdygNCQVQCADACAAAAcwzEkRXIsy9I0T/M0TxM90RM901NFV3SB0JBVAAAgAIAAAAAAAAAMybAUy9EcTRIl1VItVVMt1VJF1VNVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVN0zRNEwgNWQkAkAEAkBBTLS3GmgmLJGLSaqugYwxS7KWxSCpntbfKMYUYtV4ah5RREHupJGOKQcwtpNApJq3WVEKFFKSYYyoVUg5SIDRkhQAQmgHgcBxAsixAsiwAAAAAAAAAkDQN0DwPsDQPAAAAAAAAACRNAyxPAzTPAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA0jRA8zxA8zwAAAAAAAAA0DwP8DwR8EQRAAAAAAAAACzPAzTRAzxRBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA0jRA8zxA8zwAAAAAAAAAsDwP8EQR0DwRAAAAAAAAACzPAzxRBDzRAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEOAAABBgIRQasiIAiBMAcEgSJAmSBM0DSJYFTYOmwTQBkmVB06BpME0AAAAAAAAAAAAAJE2DpkHTIIoASdOgadA0iCIAAAAAAAAAAAAAkqZB06BpEEWApGnQNGgaRBEAAAAAAAAAAAAAzzQhihBFmCbAM02IIkQRpgkAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAGHAAAAgwoQwUGrIiAIgTAHA4imUBAIDjOJYFAACO41gWAABYliWKAABgWZooAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAYcAAACDChDBQashIAiAIAcCiKZQHHsSzgOJYFJMmyAJYF0DyApgFEEQAIAAAocAAACLBBU2JxgEJDVgIAUQAABsWxLE0TRZKkaZoniiRJ0zxPFGma53meacLzPM80IYqiaJoQRVE0TZimaaoqME1VFQAAUOAAABBgg6bE4gCFhqwEAEICAByKYlma5nmeJ4qmqZokSdM8TxRF0TRNU1VJkqZ5niiKommapqqyLE3zPFEURdNUVVWFpnmeKIqiaaqq6sLzPE8URdE0VdV14XmeJ4qiaJqq6roQRVE0TdNUTVV1XSCKpmmaqqqqrgtETxRNU1Vd13WB54miaaqqq7ouEE3TVFVVdV1ZBpimaaqq68oyQFVV1XVdV5YBqqqqruu6sgxQVdd1XVmWZQCu67qyLMsCAAAOHAAAAoygk4wqi7DRhAsPQKEhKwKAKAAAwBimFFPKMCYhpBAaxiSEFEImJaXSUqogpFJSKRWEVEoqJaOUUmopVRBSKamUCkIqJZVSAADYgQMA2IGFUGjISgAgDwCAMEYpxhhzTiKkFGPOOScRUoox55yTSjHmnHPOSSkZc8w556SUzjnnnHNSSuacc845KaVzzjnnnJRSSuecc05KKSWEzkEnpZTSOeecEwAAVOAAABBgo8jmBCNBhYasBABSAQAMjmNZmuZ5omialiRpmud5niiapiZJmuZ5nieKqsnzPE8URdE0VZXneZ4oiqJpqirXFUXTNE1VVV2yLIqmaZqq6rowTdNUVdd1XZimaaqq67oubFtVVdV1ZRm2raqq6rqyDFzXdWXZloEsu67s2rIAAPAEBwCgAhtWRzgpGgssNGQlAJABAEAYg5BCCCFlEEIKIYSUUggJAAAYcAAACDChDBQashIASAUAAIyx1lprrbXWQGettdZaa62AzFprrbXWWmuttdZaa6211lJrrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmstpZRSSimllFJKKaWUUkoppZRSSgUA+lU4APg/2LA6wknRWGChISsBgHAAAMAYpRhzDEIppVQIMeacdFRai7FCiDHnJKTUWmzFc85BKCGV1mIsnnMOQikpxVZjUSmEUlJKLbZYi0qho5JSSq3VWIwxqaTWWoutxmKMSSm01FqLMRYjbE2ptdhqq7EYY2sqLbQYY4zFCF9kbC2m2moNxggjWywt1VprMMYY3VuLpbaaizE++NpSLDHWXAAAd4MDAESCjTOsJJ0VjgYXGrISAAgJACAQUooxxhhzzjnnpFKMOeaccw5CCKFUijHGnHMOQgghlIwx5pxzEEIIIYRSSsaccxBCCCGEkFLqnHMQQgghhBBKKZ1zDkIIIYQQQimlgxBCCCGEEEoopaQUQgghhBBCCKmklEIIIYRSQighlZRSCCGEEEIpJaSUUgohhFJCCKGElFJKKYUQQgillJJSSimlEkoJJYQSUikppRRKCCGUUkpKKaVUSgmhhBJKKSWllFJKIYQQSikFAAAcOAAABBhBJxlVFmGjCRcegEJDVgIAZAAAkKKUUiktRYIipRikGEtGFXNQWoqocgxSzalSziDmJJaIMYSUk1Qy5hRCDELqHHVMKQYtlRhCxhik2HJLoXMOAAAAQQCAgJAAAAMEBTMAwOAA4XMQdAIERxsAgCBEZohEw0JweFAJEBFTAUBigkIuAFRYXKRdXECXAS7o4q4DIQQhCEEsDqCABByccMMTb3jCDU7QKSp1IAAAAAAADADwAACQXAAREdHMYWRobHB0eHyAhIiMkAgAAAAAABcAfAAAJCVAREQ0cxgZGhscHR4fICEiIyQBAIAAAgAAAAAggAAEBAQAAAAAAAIAAAAEBB9DtnUBAAAAAAAEPueBAKOFggAAgACjzoEAA4BwBwCdASqwAJAAAEcIhYWIhYSIAgIABhwJ7kPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99YAD+/6tQgKOFggADgAqjhYIAD4AOo4WCACSADqOZgQArADECAAEQEAAYABhYL/QACIBDmAYAAKOFggA6gA6jhYIAT4AOo5mBAFMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAGSADqOFggB6gA6jmYEAewAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIAj4AOo5mBAKMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAKSADqOFggC6gA6jmYEAywAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIAz4AOo4WCAOSADqOZgQDzADECAAEQEAAYABhYL/QACIBDmAYAAKOFggD6gA6jhYIBD4AOo5iBARsAEQIAARAQFGAAYWC/0AAiAQ5gGACjhYIBJIAOo4WCATqADqOZgQFDADECAAEQEAAYABhYL/QACIBDmAYAAKOFggFPgA6jhYIBZIAOo5mBAWsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAXqADqOFggGPgA6jmYEBkwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIBpIAOo4WCAbqADqOZgQG7ADECAAEQEAAYABhYL/QACIBDmAYAAKOFggHPgA6jmYEB4wAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIB5IAOo4WCAfqADqOZgQILADECAAEQEAAYABhYL/QACIBDmAYAAKOFggIPgA6jhYICJIAOo5mBAjMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAjqADqOFggJPgA6jmYECWwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYICZIAOo4WCAnqADqOZgQKDADECAAEQEAAYABhYL/QACIBDmAYAAKOFggKPgA6jhYICpIAOo5mBAqsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCArqADqOFggLPgA6jmIEC0wARAgABEBAUYABhYL/QACIBDmAYAKOFggLkgA6jhYIC+oAOo5mBAvsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAw+ADqOZgQMjADECAAEQEAAYABhYL/QACIBDmAYAAKOFggMkgA6jhYIDOoAOo5mBA0sAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCA0+ADqOFggNkgA6jmYEDcwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIDeoAOo4WCA4+ADqOZgQObADECAAEQEAAYABhYL/QACIBDmAYAAKOFggOkgA6jhYIDuoAOo5mBA8MAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCA8+ADqOFggPkgA6jhYID+oAOo4WCBA+ADhxTu2sBAAAAAAAAEbuPs4EDt4r3gQHxghEr8IEK",mp4:"data:video/mp4;base64,AAAAHGZ0eXBNNFYgAAACAGlzb21pc28yYXZjMQAAAAhmcmVlAAAGF21kYXTeBAAAbGliZmFhYyAxLjI4AABCAJMgBDIARwAAArEGBf//rdxF6b3m2Ui3lizYINkj7u94MjY0IC0gY29yZSAxNDIgcjIgOTU2YzhkOCAtIEguMjY0L01QRUctNCBBVkMgY29kZWMgLSBDb3B5bGVmdCAyMDAzLTIwMTQgLSBodHRwOi8vd3d3LnZpZGVvbGFuLm9yZy94MjY0Lmh0bWwgLSBvcHRpb25zOiBjYWJhYz0wIHJlZj0zIGRlYmxvY2s9MTowOjAgYW5hbHlzZT0weDE6MHgxMTEgbWU9aGV4IHN1Ym1lPTcgcHN5PTEgcHN5X3JkPTEuMDA6MC4wMCBtaXhlZF9yZWY9MSBtZV9yYW5nZT0xNiBjaHJvbWFfbWU9MSB0cmVsbGlzPTEgOHg4ZGN0PTAgY3FtPTAgZGVhZHpvbmU9MjEsMTEgZmFzdF9wc2tpcD0xIGNocm9tYV9xcF9vZmZzZXQ9LTIgdGhyZWFkcz02IGxvb2thaGVhZF90aHJlYWRzPTEgc2xpY2VkX3RocmVhZHM9MCBucj0wIGRlY2ltYXRlPTEgaW50ZXJsYWNlZD0wIGJsdXJheV9jb21wYXQ9MCBjb25zdHJhaW5lZF9pbnRyYT0wIGJmcmFtZXM9MCB3ZWlnaHRwPTAga2V5aW50PTI1MCBrZXlpbnRfbWluPTI1IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMy4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCB2YnZfbWF4cmF0ZT03NjggdmJ2X2J1ZnNpemU9MzAwMCBjcmZfbWF4PTAuMCBuYWxfaHJkPW5vbmUgZmlsbGVyPTAgaXBfcmF0aW89MS40MCBhcT0xOjEuMDAAgAAAAFZliIQL8mKAAKvMnJycnJycnJycnXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXiEASZACGQAjgCEASZACGQAjgAAAAAdBmjgX4GSAIQBJkAIZACOAAAAAB0GaVAX4GSAhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGagC/AySEASZACGQAjgAAAAAZBmqAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZrAL8DJIQBJkAIZACOAAAAABkGa4C/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmwAvwMkhAEmQAhkAI4AAAAAGQZsgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGbQC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm2AvwMkhAEmQAhkAI4AAAAAGQZuAL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGboC/AySEASZACGQAjgAAAAAZBm8AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZvgL8DJIQBJkAIZACOAAAAABkGaAC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmiAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpAL8DJIQBJkAIZACOAAAAABkGaYC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmoAvwMkhAEmQAhkAI4AAAAAGQZqgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGawC/AySEASZACGQAjgAAAAAZBmuAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZsAL8DJIQBJkAIZACOAAAAABkGbIC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm0AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZtgL8DJIQBJkAIZACOAAAAABkGbgCvAySEASZACGQAjgCEASZACGQAjgAAAAAZBm6AnwMkhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AAAAhubW9vdgAAAGxtdmhkAAAAAAAAAAAAAAAAAAAD6AAABDcAAQAAAQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAzB0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAABAAAAAAAAA+kAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAALAAAACQAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAPpAAAAAAABAAAAAAKobWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAB1MAAAdU5VxAAAAAAALWhkbHIAAAAAAAAAAHZpZGUAAAAAAAAAAAAAAABWaWRlb0hhbmRsZXIAAAACU21pbmYAAAAUdm1oZAAAAAEAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAhNzdGJsAAAAr3N0c2QAAAAAAAAAAQAAAJ9hdmMxAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAALAAkABIAAAASAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGP//AAAALWF2Y0MBQsAN/+EAFWdCwA3ZAsTsBEAAAPpAADqYA8UKkgEABWjLg8sgAAAAHHV1aWRraEDyXyRPxbo5pRvPAyPzAAAAAAAAABhzdHRzAAAAAAAAAAEAAAAeAAAD6QAAABRzdHNzAAAAAAAAAAEAAAABAAAAHHN0c2MAAAAAAAAAAQAAAAEAAAABAAAAAQAAAIxzdHN6AAAAAAAAAAAAAAAeAAADDwAAAAsAAAALAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAAiHN0Y28AAAAAAAAAHgAAAEYAAANnAAADewAAA5gAAAO0AAADxwAAA+MAAAP2AAAEEgAABCUAAARBAAAEXQAABHAAAASMAAAEnwAABLsAAATOAAAE6gAABQYAAAUZAAAFNQAABUgAAAVkAAAFdwAABZMAAAWmAAAFwgAABd4AAAXxAAAGDQAABGh0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAACAAAAAAAABDcAAAAAAAAAAAAAAAEBAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAQkAAADcAABAAAAAAPgbWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAC7gAAAykBVxAAAAAAALWhkbHIAAAAAAAAAAHNvdW4AAAAAAAAAAAAAAABTb3VuZEhhbmRsZXIAAAADi21pbmYAAAAQc21oZAAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAADT3N0YmwAAABnc3RzZAAAAAAAAAABAAAAV21wNGEAAAAAAAAAAQAAAAAAAAAAAAIAEAAAAAC7gAAAAAAAM2VzZHMAAAAAA4CAgCIAAgAEgICAFEAVBbjYAAu4AAAADcoFgICAAhGQBoCAgAECAAAAIHN0dHMAAAAAAAAAAgAAADIAAAQAAAAAAQAAAkAAAAFUc3RzYwAAAAAAAAAbAAAAAQAAAAEAAAABAAAAAgAAAAIAAAABAAAAAwAAAAEAAAABAAAABAAAAAIAAAABAAAABgAAAAEAAAABAAAABwAAAAIAAAABAAAACAAAAAEAAAABAAAACQAAAAIAAAABAAAACgAAAAEAAAABAAAACwAAAAIAAAABAAAADQAAAAEAAAABAAAADgAAAAIAAAABAAAADwAAAAEAAAABAAAAEAAAAAIAAAABAAAAEQAAAAEAAAABAAAAEgAAAAIAAAABAAAAFAAAAAEAAAABAAAAFQAAAAIAAAABAAAAFgAAAAEAAAABAAAAFwAAAAIAAAABAAAAGAAAAAEAAAABAAAAGQAAAAIAAAABAAAAGgAAAAEAAAABAAAAGwAAAAIAAAABAAAAHQAAAAEAAAABAAAAHgAAAAIAAAABAAAAHwAAAAQAAAABAAAA4HN0c3oAAAAAAAAAAAAAADMAAAAaAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAACMc3RjbwAAAAAAAAAfAAAALAAAA1UAAANyAAADhgAAA6IAAAO+AAAD0QAAA+0AAAQAAAAEHAAABC8AAARLAAAEZwAABHoAAASWAAAEqQAABMUAAATYAAAE9AAABRAAAAUjAAAFPwAABVIAAAVuAAAFgQAABZ0AAAWwAAAFzAAABegAAAX7AAAGFwAAAGJ1ZHRhAAAAWm1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAALWlsc3QAAAAlqXRvbwAAAB1kYXRhAAAAAQAAAABMYXZmNTUuMzMuMTAw"}}])}));

/***/ }),

/***/ 9723:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1892);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5760);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8311);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8192);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8060);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4865);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_0_oneOf_0_use_2_galgame_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1206);

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_0_oneOf_0_use_2_galgame_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z, options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_0_oneOf_0_use_2_galgame_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_0_oneOf_0_use_2_galgame_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"].locals */ .Z.locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_0_oneOf_0_use_2_galgame_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"].locals */ .Z.locals : undefined);


/***/ }),

/***/ 2568:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1892);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5760);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8311);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8192);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8060);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4865);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_0_oneOf_1_use_2_node_modules_less_loader_dist_cjs_js_basis_less__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9315);

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_0_oneOf_1_use_2_node_modules_less_loader_dist_cjs_js_basis_less__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z, options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_0_oneOf_1_use_2_node_modules_less_loader_dist_cjs_js_basis_less__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_0_oneOf_1_use_2_node_modules_less_loader_dist_cjs_js_basis_less__WEBPACK_IMPORTED_MODULE_6__/* ["default"].locals */ .Z.locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_0_oneOf_1_use_2_node_modules_less_loader_dist_cjs_js_basis_less__WEBPACK_IMPORTED_MODULE_6__/* ["default"].locals */ .Z.locals : undefined);


/***/ }),

/***/ 9735:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1892);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5760);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8311);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8192);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8060);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4865);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_0_oneOf_1_use_2_node_modules_less_loader_dist_cjs_js_custom_less__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3855);

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_0_oneOf_1_use_2_node_modules_less_loader_dist_cjs_js_custom_less__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z, options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_0_oneOf_1_use_2_node_modules_less_loader_dist_cjs_js_custom_less__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_0_oneOf_1_use_2_node_modules_less_loader_dist_cjs_js_custom_less__WEBPACK_IMPORTED_MODULE_6__/* ["default"].locals */ .Z.locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_0_oneOf_1_use_2_node_modules_less_loader_dist_cjs_js_custom_less__WEBPACK_IMPORTED_MODULE_6__/* ["default"].locals */ .Z.locals : undefined);


/***/ }),

/***/ 1892:
/***/ ((module) => {

"use strict";


var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ 8311:
/***/ ((module) => {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ 8060:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ 8192:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ 5760:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ 4865:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ 3991:
/***/ ((module) => {

"use strict";


/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0x00) {  // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {  // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0  // overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {  // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||  // overlong
        buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0  // surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {  // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||  // overlong
        buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4  // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

module.exports = isValidUTF8;


/***/ }),

/***/ 9167:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


try {
  module.exports = __webpack_require__(601)(__dirname);
} catch (e) {
  module.exports = __webpack_require__(3991);
}


/***/ }),

/***/ 9398:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const WebSocket = __webpack_require__(7787);

WebSocket.createWebSocketStream = __webpack_require__(942);
WebSocket.Server = __webpack_require__(1528);
WebSocket.Receiver = __webpack_require__(9519);
WebSocket.Sender = __webpack_require__(3120);

WebSocket.WebSocket = WebSocket;
WebSocket.WebSocketServer = WebSocket.Server;

module.exports = WebSocket;


/***/ }),

/***/ 5551:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { EMPTY_BUFFER } = __webpack_require__(9834);

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) return target.slice(0, offset);

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = Buffer.from(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

try {
  const bufferUtil = __webpack_require__(796);

  module.exports = {
    concat,
    mask(source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bufferUtil.mask(source, mask, output, offset, length);
    },
    toArrayBuffer,
    toBuffer,
    unmask(buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bufferUtil.unmask(buffer, mask);
    }
  };
} catch (e) /* istanbul ignore next */ {
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
}


/***/ }),

/***/ 9834:
/***/ ((module) => {

"use strict";


module.exports = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
  kListener: Symbol('kListener'),
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  NOOP: () => {}
};


/***/ }),

/***/ 8289:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { kForOnEventAttribute, kListener } = __webpack_require__(9834);

const kCode = Symbol('kCode');
const kData = Symbol('kData');
const kError = Symbol('kError');
const kMessage = Symbol('kMessage');
const kReason = Symbol('kReason');
const kTarget = Symbol('kTarget');
const kType = Symbol('kType');
const kWasClean = Symbol('kWasClean');

/**
 * Class representing an event.
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(type) {
    this[kTarget] = null;
    this[kType] = type;
  }

  /**
   * @type {*}
   */
  get target() {
    return this[kTarget];
  }

  /**
   * @type {String}
   */
  get type() {
    return this[kType];
  }
}

Object.defineProperty(Event.prototype, 'target', { enumerable: true });
Object.defineProperty(Event.prototype, 'type', { enumerable: true });

/**
 * Class representing a close event.
 *
 * @extends Event
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(type, options = {}) {
    super(type);

    this[kCode] = options.code === undefined ? 0 : options.code;
    this[kReason] = options.reason === undefined ? '' : options.reason;
    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
  }

  /**
   * @type {Number}
   */
  get code() {
    return this[kCode];
  }

  /**
   * @type {String}
   */
  get reason() {
    return this[kReason];
  }

  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[kWasClean];
  }
}

Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

/**
 * Class representing an error event.
 *
 * @extends Event
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(type, options = {}) {
    super(type);

    this[kError] = options.error === undefined ? null : options.error;
    this[kMessage] = options.message === undefined ? '' : options.message;
  }

  /**
   * @type {*}
   */
  get error() {
    return this[kError];
  }

  /**
   * @type {String}
   */
  get message() {
    return this[kMessage];
  }
}

Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

/**
 * Class representing a message event.
 *
 * @extends Event
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(type, options = {}) {
    super(type);

    this[kData] = options.data === undefined ? null : options.data;
  }

  /**
   * @type {*}
   */
  get data() {
    return this[kData];
  }
}

Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {Function} listener The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, listener, options = {}) {
    let wrapper;

    if (type === 'message') {
      wrapper = function onMessage(data, isBinary) {
        const event = new MessageEvent('message', {
          data: isBinary ? data : data.toString()
        });

        event[kTarget] = this;
        listener.call(this, event);
      };
    } else if (type === 'close') {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent('close', {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });

        event[kTarget] = this;
        listener.call(this, event);
      };
    } else if (type === 'error') {
      wrapper = function onError(error) {
        const event = new ErrorEvent('error', {
          error,
          message: error.message
        });

        event[kTarget] = this;
        listener.call(this, event);
      };
    } else if (type === 'open') {
      wrapper = function onOpen() {
        const event = new Event('open');

        event[kTarget] = this;
        listener.call(this, event);
      };
    } else {
      return;
    }

    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
    wrapper[kListener] = listener;

    if (options.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {Function} handler The listener to remove
   * @public
   */
  removeEventListener(type, handler) {
    for (const listener of this.listeners(type)) {
      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
        this.removeListener(type, listener);
        break;
      }
    }
  }
};

module.exports = {
  CloseEvent,
  ErrorEvent,
  Event,
  EventTarget,
  MessageEvent
};


/***/ }),

/***/ 1015:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(8422);

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);
  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (
        i !== 0 &&
        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
      ) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ 1697:
/***/ ((module) => {

"use strict";


const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
}

module.exports = Limiter;


/***/ }),

/***/ 8074:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const zlib = __webpack_require__(9796);

const bufferUtil = __webpack_require__(5551);
const Limiter = __webpack_require__(1697);
const { kStatusCode } = __webpack_require__(9834);

const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) data = data.slice(0, data.length - 4);

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ 9519:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Writable } = __webpack_require__(2781);

const PerMessageDeflate = __webpack_require__(8074);
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __webpack_require__(9834);
const { concat, toArrayBuffer, unmask } = __webpack_require__(5551);
const { isValidStatusCode, isValidUTF8 } = __webpack_require__(8422);

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;

/**
 * HyBi Receiver implementation.
 *
 * @extends Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(options = {}) {
    super();

    this._binaryType = options.binaryType || BINARY_TYPES[0];
    this._extensions = options.extensions || {};
    this._isServer = !!options.isServer;
    this._maxPayload = options.maxPayload | 0;
    this._skipUTF8Validation = !!options.skipUTF8Validation;
    this[kWebSocket] = undefined;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._state = GET_INFO;
    this._loop = false;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = buf.slice(n);
      return buf.slice(0, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = buf.slice(n);
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    let err;
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          err = this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          err = this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          err = this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          err = this.getData(cb);
          break;
        default:
          // `INFLATING`
          this._loop = false;
          return;
      }
    } while (this._loop);

    cb(err);
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getInfo() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      this._loop = false;
      return error(
        RangeError,
        'RSV2 and RSV3 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_2_3'
      );
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      this._loop = false;
      return error(
        RangeError,
        'RSV1 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_1'
      );
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        this._loop = false;
        return error(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );
      }

      if (!this._fragmented) {
        this._loop = false;
        return error(
          RangeError,
          'invalid opcode 0',
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        this._loop = false;
        return error(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        this._loop = false;
        return error(
          RangeError,
          'FIN must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_FIN'
        );
      }

      if (compressed) {
        this._loop = false;
        return error(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );
      }

      if (this._payloadLength > 0x7d) {
        this._loop = false;
        return error(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002,
          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
        );
      }
    } else {
      this._loop = false;
      return error(
        RangeError,
        `invalid opcode ${this._opcode}`,
        true,
        1002,
        'WS_ERR_INVALID_OPCODE'
      );
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        this._loop = false;
        return error(
          RangeError,
          'MASK must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_MASK'
        );
      }
    } else if (this._masked) {
      this._loop = false;
      return error(
        RangeError,
        'MASK must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_MASK'
      );
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else return this.haveLength();
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength16() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    return this.haveLength();
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength64() {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      this._loop = false;
      return error(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009,
        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
      );
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    return this.haveLength();
  }

  /**
   * Payload length has been read.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  haveLength() {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        this._loop = false;
        return error(
          RangeError,
          'Max payload size exceeded',
          false,
          1009,
          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
        );
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);

      if (
        this._masked &&
        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
      ) {
        unmask(data, this._mask);
      }
    }

    if (this._opcode > 0x07) return this.controlMessage(data);

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its length is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    return this.dataMessage();
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          return cb(
            error(
              RangeError,
              'Max payload size exceeded',
              false,
              1009,
              'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
            )
          );
        }

        this._fragments.push(buf);
      }

      const er = this.dataMessage();
      if (er) return cb(er);

      this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @return {(Error|undefined)} A possible error
   * @private
   */
  dataMessage() {
    if (this._fin) {
      const messageLength = this._messageLength;
      const fragments = this._fragments;

      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];

      if (this._opcode === 2) {
        let data;

        if (this._binaryType === 'nodebuffer') {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === 'arraybuffer') {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else {
          data = fragments;
        }

        this.emit('message', data, true);
      } else {
        const buf = concat(fragments, messageLength);

        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          this._loop = false;
          return error(
            Error,
            'invalid UTF-8 sequence',
            true,
            1007,
            'WS_ERR_INVALID_UTF8'
          );
        }

        this.emit('message', buf, false);
      }
    }

    this._state = GET_INFO;
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data) {
    if (this._opcode === 0x08) {
      this._loop = false;

      if (data.length === 0) {
        this.emit('conclude', 1005, EMPTY_BUFFER);
        this.end();
      } else if (data.length === 1) {
        return error(
          RangeError,
          'invalid payload length 1',
          true,
          1002,
          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
        );
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          return error(
            RangeError,
            `invalid status code ${code}`,
            true,
            1002,
            'WS_ERR_INVALID_CLOSE_CODE'
          );
        }

        const buf = data.slice(2);

        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          return error(
            Error,
            'invalid UTF-8 sequence',
            true,
            1007,
            'WS_ERR_INVALID_UTF8'
          );
        }

        this.emit('conclude', code, buf);
        this.end();
      }
    } else if (this._opcode === 0x09) {
      this.emit('ping', data);
    } else {
      this.emit('pong', data);
    }

    this._state = GET_INFO;
  }
}

module.exports = Receiver;

/**
 * Builds an error object.
 *
 * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
 * @param {String} message The error message
 * @param {Boolean} prefix Specifies whether or not to add a default prefix to
 *     `message`
 * @param {Number} statusCode The status code
 * @param {String} errorCode The exposed error code
 * @return {(Error|RangeError)} The error
 * @private
 */
function error(ErrorCtor, message, prefix, statusCode, errorCode) {
  const err = new ErrorCtor(
    prefix ? `Invalid WebSocket frame: ${message}` : message
  );

  Error.captureStackTrace(err, error);
  err.code = errorCode;
  err[kStatusCode] = statusCode;
  return err;
}


/***/ }),

/***/ 3120:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^net|tls$" }] */



const net = __webpack_require__(1808);
const tls = __webpack_require__(4404);
const { randomFillSync } = __webpack_require__(6113);

const PerMessageDeflate = __webpack_require__(8074);
const { EMPTY_BUFFER } = __webpack_require__(9834);
const { isValidStatusCode } = __webpack_require__(8422);
const { mask: applyMask, toBuffer } = __webpack_require__(5551);

const maskBuffer = Buffer.alloc(4);

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {(net.Socket|tls.Socket)} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(socket, extensions, generateMask) {
    this._extensions = extensions || {};

    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }

    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {Buffer} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {Buffer[]} The framed data as a list of `Buffer` instances
   * @public
   */
  static frame(data, options) {
    let mask;
    let merge = false;
    let offset = 2;
    let skipMasking = false;

    if (options.mask) {
      mask = options.maskBuffer || maskBuffer;

      if (options.generateMask) {
        options.generateMask(mask);
      } else {
        randomFillSync(mask, 0, 4);
      }

      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
      if (options.readOnly && !skipMasking) merge = true;

      offset = 6;
    }

    let payloadLength = data.length;

    if (data.length >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (data.length > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(data.length, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(data.length, 4, 6);
    }

    if (!options.mask) return [target, data];

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (skipMasking) return [target, data];

    if (merge) {
      applyMask(data, mask, target, offset, data.length);
      return [target];
    }

    applyMask(data, mask, data, 0, data.length);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || !data.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);

      if (typeof data === 'string') {
        buf.write(data, 2);
      } else {
        buf.set(data, 2);
      }
    }

    if (this._deflating) {
      this.enqueue([this.doClose, buf, mask, cb]);
    } else {
      this.doClose(buf, mask, cb);
    }
  }

  /**
   * Frames and sends a close message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @private
   */
  doClose(data, mask, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x08,
        mask,
        maskBuffer: this._maskBuffer,
        generateMask: this._generateMask,
        readOnly: false
      }),
      cb
    );
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    const buf = toBuffer(data);

    if (buf.length > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    if (this._deflating) {
      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);
    } else {
      this.doPing(buf, mask, toBuffer.readOnly, cb);
    }
  }

  /**
   * Frames and sends a ping message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
   * @param {Function} [cb] Callback
   * @private
   */
  doPing(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x09,
        mask,
        maskBuffer: this._maskBuffer,
        generateMask: this._generateMask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    const buf = toBuffer(data);

    if (buf.length > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    if (this._deflating) {
      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);
    } else {
      this.doPong(buf, mask, toBuffer.readOnly, cb);
    }
  }

  /**
   * Frames and sends a pong message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
   * @param {Function} [cb] Callback
   * @private
   */
  doPong(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x0a,
        mask,
        maskBuffer: this._maskBuffer,
        generateMask: this._generateMask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options, cb) {
    const buf = toBuffer(data);
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    if (this._firstFragment) {
      this._firstFragment = false;
      if (
        rsv1 &&
        perMessageDeflate &&
        perMessageDeflate.params[
          perMessageDeflate._isServer
            ? 'server_no_context_takeover'
            : 'client_no_context_takeover'
        ]
      ) {
        rsv1 = buf.length >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    if (perMessageDeflate) {
      const opts = {
        fin: options.fin,
        rsv1,
        opcode,
        mask: options.mask,
        maskBuffer: this._maskBuffer,
        generateMask: this._generateMask,
        readOnly: toBuffer.readOnly
      };

      if (this._deflating) {
        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
      } else {
        this.dispatch(buf, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender.frame(buf, {
          fin: options.fin,
          rsv1: false,
          opcode,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          generateMask: this._generateMask,
          readOnly: toBuffer.readOnly
        }),
        cb
      );
    }
  }

  /**
   * Dispatches a data message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._bufferedBytes += data.length;
    this._deflating = true;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        if (typeof cb === 'function') cb(err);

        for (let i = 0; i < this._queue.length; i++) {
          const callback = this._queue[i][4];

          if (typeof callback === 'function') callback(err);
        }

        return;
      }

      this._bufferedBytes -= data.length;
      this._deflating = false;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[1].length;
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[1].length;
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;


/***/ }),

/***/ 942:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Duplex } = __webpack_require__(2781);

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {Duplex} stream The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let terminateOnDestroy = true;

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg, isBinary) {
    const data =
      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

    if (!duplex.push(data)) ws.pause();
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
    //
    // - If the `'error'` event is emitted before the `'open'` event, then
    //   `ws.terminate()` is a noop as no socket is assigned.
    // - Otherwise, the error is re-emitted by the listener of the `'error'`
    //   event of the `Receiver` object. The listener already closes the
    //   connection by calling `ws.close()`. This allows a close frame to be
    //   sent to the other peer. If `ws.terminate()` is called right after this,
    //   then the close frame might not be sent.
    terminateOnDestroy = false;
    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });

    if (terminateOnDestroy) ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.isPaused) ws.resume();
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ 5728:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(8422);

/**
 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
 *
 * @param {String} header The field value of the header
 * @return {Set} The subprotocol names
 * @public
 */
function parse(header) {
  const protocols = new Set();
  let start = -1;
  let end = -1;
  let i = 0;

  for (i; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1) start = i;
    } else if (
      i !== 0 &&
      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
    ) {
      if (end === -1 && start !== -1) end = i;
    } else if (code === 0x2c /* ',' */) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }

      if (end === -1) end = i;

      const protocol = header.slice(start, end);

      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }

      protocols.add(protocol);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i}`);
    }
  }

  if (start === -1 || end !== -1) {
    throw new SyntaxError('Unexpected end of input');
  }

  const protocol = header.slice(start, i);

  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }

  protocols.add(protocol);
  return protocols;
}

module.exports = { parse };


/***/ }),

/***/ 8422:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
function isValidStatusCode(code) {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
}

/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0 // Overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
        buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

try {
  const isValidUTF8 = __webpack_require__(9167);

  module.exports = {
    isValidStatusCode,
    isValidUTF8(buf) {
      return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
    },
    tokenChars
  };
} catch (e) /* istanbul ignore next */ {
  module.exports = {
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
  };
}


/***/ }),

/***/ 1528:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^net|tls|https$" }] */



const EventEmitter = __webpack_require__(2361);
const http = __webpack_require__(3685);
const https = __webpack_require__(5687);
const net = __webpack_require__(1808);
const tls = __webpack_require__(4404);
const { createHash } = __webpack_require__(6113);

const extension = __webpack_require__(1015);
const PerMessageDeflate = __webpack_require__(8074);
const subprotocol = __webpack_require__(5728);
const WebSocket = __webpack_require__(7787);
const { GUID, kWebSocket } = __webpack_require__(9834);

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

const RUNNING = 0;
const CLOSING = 1;
const CLOSED = 2;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      ...options
    };

    if (
      (options.port == null && !options.server && !options.noServer) ||
      (options.port != null && (options.server || options.noServer)) ||
      (options.server && options.noServer)
    ) {
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options ' +
          'must be specified'
      );
    }

    if (options.port != null) {
      this._server = http.createServer((req, res) => {
        const body = http.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) {
      this.clients = new Set();
      this._shouldEmitClose = false;
    }

    this.options = options;
    this._state = RUNNING;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(cb) {
    if (this._state === CLOSED) {
      if (cb) {
        this.once('close', () => {
          cb(new Error('The server is not running'));
        });
      }

      process.nextTick(emitClose, this);
      return;
    }

    if (cb) this.once('close', cb);

    if (this._state === CLOSING) return;
    this._state = CLOSING;

    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }

      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose, this);
      }
    } else {
      const server = this._server;

      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // The HTTP/S server was created internally. Close it, and rely on its
      // `'close'` event.
      //
      server.close(() => {
        emitClose(this);
      });
    }
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key =
      req.headers['sec-websocket-key'] !== undefined
        ? req.headers['sec-websocket-key']
        : false;
    const version = +req.headers['sec-websocket-version'];

    if (
      req.method !== 'GET' ||
      req.headers.upgrade.toLowerCase() !== 'websocket' ||
      !key ||
      !keyRegex.test(key) ||
      (version !== 8 && version !== 13) ||
      !this.shouldHandle(req)
    ) {
      return abortHandshake(socket, 400);
    }

    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
    let protocols = new Set();

    if (secWebSocketProtocol !== undefined) {
      try {
        protocols = subprotocol.parse(secWebSocketProtocol);
      } catch (err) {
        return abortHandshake(socket, 400);
      }
    }

    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
    const extensions = {};

    if (
      this.options.perMessageDeflate &&
      secWebSocketExtensions !== undefined
    ) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = extension.parse(secWebSocketExtensions);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        return abortHandshake(socket, 400);
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(
            extensions,
            key,
            protocols,
            req,
            socket,
            head,
            cb
          );
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    if (this._state > RUNNING) return abortHandshake(socket, 503);

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new WebSocket(null);

    if (protocols.size) {
      //
      // Optionally call external protocol selection handler.
      //
      const protocol = this.options.handleProtocols
        ? this.options.handleProtocols(protocols, req)
        : protocols.values().next().value;

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = extension.format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, {
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => {
        this.clients.delete(ws);

        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose, this);
        }
      });
    }

    cb(ws, req);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server._state = CLOSED;
  server.emit('close');
}

/**
 * Handle premature socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  if (socket.writable) {
    message = message || http.STATUS_CODES[code];
    headers = {
      Connection: 'close',
      'Content-Type': 'text/html',
      'Content-Length': Buffer.byteLength(message),
      ...headers
    };

    socket.write(
      `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
        Object.keys(headers)
          .map((h) => `${h}: ${headers[h]}`)
          .join('\r\n') +
        '\r\n\r\n' +
        message
    );
  }

  socket.removeListener('error', socketOnError);
  socket.destroy();
}


/***/ }),

/***/ 7787:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Readable$" }] */



const EventEmitter = __webpack_require__(2361);
const https = __webpack_require__(5687);
const http = __webpack_require__(3685);
const net = __webpack_require__(1808);
const tls = __webpack_require__(4404);
const { randomBytes, createHash } = __webpack_require__(6113);
const { Readable } = __webpack_require__(2781);
const { URL } = __webpack_require__(7310);

const PerMessageDeflate = __webpack_require__(8074);
const Receiver = __webpack_require__(9519);
const Sender = __webpack_require__(3120);
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket,
  NOOP
} = __webpack_require__(9834);
const {
  EventTarget: { addEventListener, removeEventListener }
} = __webpack_require__(8289);
const { format, parse } = __webpack_require__(1015);
const { toBuffer } = __webpack_require__(5551);

const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
const protocolVersions = [8, 13];
const closeTimeout = 30 * 1000;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._extensions = {};
    this._paused = false;
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (protocols === undefined) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === 'object' && protocols !== null) {
          options = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._isServer = true;
    }
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(socket, head, options) {
    const receiver = new Receiver({
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options.maxPayload,
      skipUTF8Validation: options.skipUTF8Validation
    });

    this._sender = new Sender(socket, this._extensions, options.generateMask);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    socket.setTimeout(0);
    socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (
        this._closeFrameSent &&
        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
      ) {
        this._socket.end();
      }

      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;

      if (
        this._closeFrameReceived ||
        this._receiver._writableState.errorEmitted
      ) {
        this._socket.end();
      }
    });

    //
    // Specify a timeout for the closing handshake to complete.
    //
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout
    );
  }

  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = true;
    this._socket.pause();
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = false;
    if (!this._receiver._writableState.needDrain) this._socket.resume();
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'isPaused',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) return listener[kListener];
      }

      return null;
    },
    set(handler) {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) {
          this.removeListener(method, listener);
          break;
        }
      }

      if (typeof handler !== 'function') return;

      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|URL)} address The URL to which to connect
 * @param {Array} protocols The subprotocols
 * @param {Object} [options] Connection options
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Function} [options.generateMask] The function used to generate the
 *     masking key
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
 *     not to skip UTF-8 validation for text and close messages
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    createConnection: undefined,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: undefined,
    host: undefined,
    path: undefined,
    port: undefined
  };

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
    websocket._url = address.href;
  } else {
    try {
      parsedUrl = new URL(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }

    websocket._url = address;
  }

  const isSecure = parsedUrl.protocol === 'wss:';
  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';
  let invalidURLMessage;

  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isUnixSocket) {
    invalidURLMessage =
      'The URL\'s protocol must be one of "ws:", "wss:", or "ws+unix:"';
  } else if (isUnixSocket && !parsedUrl.pathname) {
    invalidURLMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidURLMessage = 'The URL contains a fragment identifier';
  }

  if (invalidURLMessage) {
    const err = new SyntaxError(invalidURLMessage);

    if (websocket._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket, err);
      return;
    }
  }

  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const get = isSecure ? https.get : http.get;
  const protocolSet = new Set();
  let perMessageDeflate;

  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket',
    ...opts.headers
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (
        typeof protocol !== 'string' ||
        !subprotocolRegex.test(protocol) ||
        protocolSet.has(protocol)
      ) {
        throw new SyntaxError(
          'An invalid or duplicated subprotocol was specified'
        );
      }

      protocolSet.add(protocol);
    }

    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isUnixSocket) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req = (websocket._req = get(opts));

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (req === null || req.aborted) return;

    req = websocket._req = null;
    emitErrorAndClose(websocket, err);
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      let addr;

      try {
        addr = new URL(location, address);
      } catch (e) {
        const err = new SyntaxError(`Invalid URL: ${location}`);
        emitErrorAndClose(websocket, err);
        return;
      }

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the `upgrade`
    // event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    let protError;

    if (serverProt !== undefined) {
      if (!protocolSet.size) {
        protError = 'Server sent a subprotocol but none was requested';
      } else if (!protocolSet.has(serverProt)) {
        protError = 'Server sent an invalid subprotocol';
      }
    } else if (protocolSet.size) {
      protError = 'Server sent no subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;

    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

    if (secWebSocketExtensions !== undefined) {
      if (!perMessageDeflate) {
        const message =
          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
          'was requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      let extensions;

      try {
        extensions = parse(secWebSocketExtensions);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      const extensionNames = Object.keys(extensions);

      if (
        extensionNames.length !== 1 ||
        extensionNames[0] !== PerMessageDeflate.extensionName
      ) {
        const message = 'Server indicated an extension that was not requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      try {
        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      websocket._extensions[PerMessageDeflate.extensionName] =
        perMessageDeflate;
    }

    websocket.setSocket(socket, head, {
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });
}

/**
 * Emit the `'error'` and `'close'` event.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {Error} The error to emit
 * @private
 */
function emitErrorAndClose(websocket, err) {
  websocket._readyState = WebSocket.CLOSING;
  websocket.emit('error', err);
  websocket.emitClose();
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
 *     abort or the socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket._readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream.abort();

    if (stream.socket && !stream.socket.destroyed) {
      //
      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
      // called after the request completed. See
      // https://github.com/websockets/ws/issues/1869.
      //
      stream.socket.destroy();
    }

    stream.once('abort', websocket.emitClose.bind(websocket));
    websocket.emit('error', err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    cb(err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {Buffer} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (websocket._socket[kWebSocket] === undefined) return;

  websocket._socket.removeListener('data', socketOnData);
  process.nextTick(resume, websocket._socket);

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  const websocket = this[kWebSocket];

  if (!websocket.isPaused) websocket._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  if (websocket._socket[kWebSocket] !== undefined) {
    websocket._socket.removeListener('data', socketOnData);

    //
    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
    // https://github.com/websockets/ws/issues/1940.
    //
    process.nextTick(resume, websocket._socket);

    websocket.close(err[kStatusCode]);
  }

  websocket.emit('error', err);
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
 * @param {Boolean} isBinary Specifies whether the message is binary or not
 * @private
 */
function receiverOnMessage(data, isBinary) {
  this[kWebSocket].emit('message', data, isBinary);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  websocket.pong(data, !websocket._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * Resume a readable stream
 *
 * @param {Readable} stream The readable stream
 * @private
 */
function resume(stream) {
  stream.resume();
}

/**
 * The listener of the `net.Socket` `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('data', socketOnData);
  this.removeListener('end', socketOnEnd);

  websocket._readyState = WebSocket.CLOSING;

  let chunk;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk.
  //
  if (
    !this._readableState.endEmitted &&
    !websocket._closeFrameReceived &&
    !websocket._receiver._writableState.errorEmitted &&
    (chunk = websocket._socket.read()) !== null
  ) {
    websocket._receiver.write(chunk);
  }

  websocket._receiver.end();

  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the `net.Socket` `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the `net.Socket` `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket._readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the `net.Socket` `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ 6113:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 2361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 7147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 3685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 5687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 1808:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 2037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 1017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 2781:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 4404:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 7310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 9796:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ 8478:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"audio":["shanbao:audio标签就是语音标签，它和music标签类似都能够播放一段音频","shanbao:但是audio标签并不会顶替掉，原本属于无名杀的背景音乐，而且audio标签所播放的音频只会持续到下一个对话标签结束为止(包括sp特殊对话标签)","shanbao:和其他的标签一样，让我们先来感受一下他的效果吧！","audio:使用教程/audio.mp3","shanbao:这……王司徒的声音还真是魔性又洗脑啊……","shanbao:这就是播放了“使用教程”扩展的，“audio.mp3”这一段语音","shanbao:编写格式和music差不多，“audio：使用教程/audio.mp3”"],"background":["shanbao:background是背景标签，可以更换当前对话的背景，以background进行声明","shanbao:background更换的背景会持续到下一个background标签或者整个对话事件结束为止","shanbao:比起一直嘴上说，还是先让你看看实际效果吧！","background:使用教程/beijin.jpg","shanbao:这就是设置当前扩展“使用教程”下面的图片“beijin.jpg”作为当前这段对话的背景，很神奇对吧？","shanbao:编写格式也是很简单的，“background：使用教程/beijin.jpg”，如果需要关闭背景的话，那可以用“background：none”"],"biaoqian":["shanbao:标签就是在一段文本中最前面的那个单词，不同的标签所产生的效果也不一样","shanbao:一般来说，一段文本是由一个打头的标签部分和一个(或多个)内容部分组成的，每个部分之间往往采用英文符号“：”来分隔"],"booth":["shanbao:学习了这么久，你也累了吧？","booth:使用教程/booth.jpg:200:200:20:20","shanbao:给！是草莓冰淇淋哦！还是在我们第一次相遇时去的那家店买的哦！","booth:none","choose:第一次？我们不是第一次见面嘛？:请你赶快说明booth标签吧！"],"booth2":["shanbao:booth标签就是展示框标签，它会在屏幕上你所指定的位置生成一个你指定大小的展示台，以booth进行声明","shanbao:内容部分需要分别输入，图片地址，展示框宽度，展示框高度，展示框的X轴位置，展示框的Y轴位置，还有一个选填的内容通道。","shanbao:图片地址直接从扩展目录写起，其余的内容均为纯数字，通道这个部分很特别，它可以填任意单词，然后他会根据你所填写的单词搜索对应的booth通道，如果没有找到的话它就会以此为依据新建一个booth通道","shanbao:例子的话，比如我要让“使用教程”扩展下的“booth.jpg”展示在右上角大概20%左右的位置展示，宽度约为200px，高度约为200px，编写代码就是“booth：使用教程/booth.jpg：200：200：20：20”","shanbao:如果需要关闭展示框的话，就只需要“booth：none”就可以了"],"cg":["shanbao:cg标签就是过场动画标签，他能够播放一段过场动画，在过场播放的播放期间，也一样会暂停原本无名杀的背景音乐，直到过场动画播放结束为止，它以cg进行声明","shanbao:难得讲解到这里了，就和我一起来欣赏一下洛小姐和乐正小姐的精彩表演吧！","cg:使用教程/cg.mp4","shanbao:洛小姐和乐正小姐表演的真是太棒啦！","shanbao:这就是播放“使用教程”扩展下的“cg.mp4”这一段过场动画","shanbao:编写方法你应该也猜到了，没错！就是“cg：使用教程/cg.mp4”"],"choose":["shanbao:choose标签就是选项标签，这个标签会在屏幕上出现多个选项每个选项之间需要用“：”进行分割","shanbao:理论上来说选项是没有数量上限的，在对选项进行选择之后，会在下一个“step”返回选择的结果，选择结果使用“result.bool”在进行记录","shanbao:让我想想怎么举例好呢……对了！比如说我在“step 0”设置了两个选项，第一项是“你好”，第二项是“再见”，假如我选择了“你好”，那么在“step 1”我们就可以获取到一个result.bool==“你好”","shanbao:需要特别注意的事，choose标签一但被执行他就会立即终止当前的对话事件，也就是说choose标签只能写到一个对话事件的最末尾处","shanbao:编写格式你应该知道的吧？“choose：选项1：选项2”，虽然多少个选项都可以，但是一定要记得每个选项之间得用“：”分割才行哦！"],"color":["shanbao:color标签就是文字框颜色标签，以color进行声明","shanbao:它能够改变文字框的颜色，内容部分分别填写要改变颜色的文字框和rbga色彩代码，目前可以改变的文字框只有choose和text两个部分","shanbao:例如，“color：text：rgba(0,0,0,0.5)”，就是把对话框的颜色变成黑色。","shanbao:<span class=\'black xsmall\'>字体的详细问题你使用软件打开本教程下的json文件看一下就能明白了</span>","shanbao:<span class=\'green\'>太小声了没听清？</span>那我就再说一边好了。","shanbao:<span class=\'red xlarge\'>字体的详细问题你使用软件打开本教程下的json文件看一下就能明白了</span>"],"daoru":["shanbao:首先我们需要将插件压缩包解压出来","shanbao:然后将解压出来的galgame.js文件、galgame.css文件与galgame.json文件复制到需要导入的扩展包内","shanbao:随后打开“导入代码.txt”文件，把里面的代码全部复制，接着把复制好的代码粘贴进需要导入的扩展包的主代码内","shanbao:最后保存并重启扩展，整个导入工作就完成了！是不是很简单呢？"],"duihua":["shanbao:一般对话标签，是最基本的标签之一","shanbao:这个标签不用特别声明，一般的编写格式是直接以需要进行这段对话的武将的ID打头，内容部分直接写需要显示的对话就行了","shanbao:比如，“guojia：你好这是一个一般对话标签”，这就是让郭奉孝先生说出“你好这是一个一般对话标签”这段话"],"end":["shanbao:那可真是太好了！","shanbao:那万由里就在这里祝愿你能用这个插件写出有意思的新扩展来分享给大家吧！","shanbao:如果之后有些标签的用法和格式忘记了也可以回万由里这里来复习一下的哦"],"jiaochen1":["shanbao:你好呀，我叫<span class=\\"purple\\">扇宝</span>，是主神大人派来指导你使用插件的","shanbao:对于galgame插件有什么不明白的的地方就请来询问我吧！"],"jiaochen2":["shanbao:请问你想了解些什么呢？","choose:如何导入Galgame插件:什么是标签？:请你介绍下一般对话标签:请你介绍下特殊对话标签:请你介绍下right标签:请你介绍下color标签及字体:请你介绍下background标签:请你介绍下music标签:请你介绍下audio标签:请你介绍下cg标签:请你介绍下none标签:请你介绍下choose标签:请你介绍下booth标签:该怎么编写属于我的剧本？:什么是事件？:我都明白了，谢谢"],"jvben":["shanbao:看来我们就快要说再见了啊……","shanbao:还记得我们一开始放进扩展的galgame.json文件吗？","shanbao:安装并使用跟着压缩包的那个APP","shanbao:点击左上角，选中打开JSON文件","shanbao:找到并选择你的galgame.json文件","shanbao:随后点击右下角的＋选择数组来新建一个事件，记得给事件取一个好听的名字哦！","shanbao:进入我们新建好的事件，再次点击右下角的＋，这次我们选择“数值”，接着选中“文字”，按照我们之前学习的各种标签的编写方法来写就可以啦","shanbao:如果还不是很明白的话，你也可以使用那个APP打开这个扩展下面的galgame.json来观看一下写法"],"music":["shanbao:music标签是背景音乐也就是BGM标签，以music进行声明","shanbao:music标签播放的音乐会一直持续到整个对话事件结束或者出现下一个music为止，即使music播放完了对话事件还没有结束，music也会从头开始循环播放","shanbao:值得一提的是，music标签的音乐播放过程中，无名杀原本的背景音乐会被暂停播放直到对话事件结束为止","shanbao:那我们来看看实际效果吧！","music:使用教程/BGM.mp3","shanbao:怎么样？洛小姐的歌声很好听吧？","shanbao:这就是把当前扩展“使用教程”的“BGM.mp3”这一段音频当做背景音乐播放","shanbao:编写方法也并不复杂，“music：使用教程/BGM.mp3”"],"none":["shanbao:none标签就是旁白标签，这个标签所进行的对话是没有人物在旁边显示的，以none进行声明","shanbao:具体效果看一眼就应该能明白了","none:万由里向你投来期待的目光，似乎是希望你已经明白了none的用法","shanbao:编写方法就是，“none：对话内容”"],"one":["shanbao:啊……对不起！没什么请你不必在意！(果然已经忘了吗……这……这也是没有办法的啊……)","none:万由里表情变得有些奇怪，眼中还隐约有泪水翻涌","shanbao:呜……(不行……明明都和@约定好了的……我……)","none:万由里突然转身，背朝着你","shanbao:啜泣……啜泣……对……对不起……好像……眼睛里进沙子……我马上……马上就能处理好的……","none:过了许久……","shanbao:对不起……让你久等了……还是让我们继续介绍booth标签吧……"],"right":["shanbao:right标签是……","right:使用教程/icey.jpg:艾希:left","shanbao:警告！警告！警告！检测到异常单位！立即清除！立即清除！立即清除！","right:使用教程/icey.jpg:艾希:right","shanbao:艾希小姐等等！他是主神大人请来的贵宾啊！况且他哪里异常了？！","right:使用教程/icey.jpg:艾希:left","shanbao:原来是主神的客人，对不起！刚刚检测到你废物度高的异常，所以以为是外敌入侵了呢！","right:使用教程/icey.jpg:艾希:right","shanbao:好了，好了，艾希小姐你就先回去吧！我还有工作没完成呢！","right:使用教程/icey.jpg:艾希:left","shanbao:工作？","right:使用教程/icey.jpg:艾希:right","shanbao:就是介绍galgame插件的使用方法！刚刚才说到……说到……啊对了！刚刚说到right标签了！","right:使用教程/icey.jpg:艾希:left","shanbao:哦！right标签刚刚好是我负责研发的呢！那作为刚刚的道歉，可以让我来说明right标签嘛？","right:使用教程/icey.jpg:艾希:right","shanbao:这样也好，那就拜托艾希小姐你说明一下right标签了！","right:none","sp:right标签是右侧图片标签！它能会占用掉对话区域一定的位置，在最右侧额外放置一个区域用于图片展示！使用right进行声明！:艾希:使用教程/icey.jpg","sp:right标签有三项属性分别是，图片地址，名称和暗淡部分！:艾希:使用教程/icey.jpg","sp:图片地址从扩展目录开始写起，比如当前扩展目录“使用教程”下的“icey.jpg”，那么直接写“使用教程/icey.jpg”就可以了！:艾希:使用教程/icey.jpg","sp:名称直接直接填写文字就可以了，不过如果你不想显示名称的话，那你可以在名称部分填写none，这样就不会显示名称了:艾希:使用教程/icey.jpg","sp:第三个内容是选填的，如果不填写那么两边都会是高光，如果填写left那么左侧部分就会变得暗淡，填写right右侧部分就会变得暗淡:艾希:使用教程/icey.jpg","sp:嗯？需要例子？看来你的智商也需要加把劲才行啊！“right：使用教程/icey.jpg：艾希(填none则不显示)”:艾希:使用教程/icey.jpg","sp:好了，我也得赶紧把食材带回去了，不然天依姐姐得把罗真姐姐的后院给啃干净了……:艾希:使用教程/icey.jpg","shanbao:啊？！那你赶紧回去啊！死神大人后院种的可都是赤色四叶草，乱吃会出大事的！","none:艾希匆匆离开","shanbao:对不起啊，让你见笑了！让我们继续吧！"],"shijian":["shanbao:事件内包含了很多对话和标签，这些对话和标签构成了一个事件的内容","shanbao:每个事件都得有一个名字，这很重要！","shanbao:我们的事件编辑好了以后，就可以使用galgame.sce()函数来调取他的内容","shanbao:比如说我编写了一个名字叫做“对话”的事件，那么我需要观看这个事件的时候，只需要使用galgame.sce(\\"对话\\")这一行代码，插件就会帮助你自动处理所有内容了！很方便对吧？"],"sp":["shanbao:特殊对话一般用于，游戏内没有对应的武将，但是你需要让某个图片作为角色说出一段话的时候使用，标签以sp进行声明","shanbao:内容部分，按顺序分别输入，对话内容，进行这段对话的人的名字，以及这个人的图片所在的地址(图片地址直接从扩展名开始)","shanbao:比如说，我要让“无名扩展”里面的图片“caocong.jpg”以名字为“曹冲”进行一段对话，那么编写方法就是“sp：我和郭嘉并称宇宙兄弟：曹冲：无名扩展/caocong.jpg”","shanbao:这样曹冲小弟弟就会说出“我和郭嘉并称宇宙兄弟”这段话了"],"xiaojvchang":["shanbao:死神大人，我回来了。","sp:呜呜呜，我好难受(๑ó﹏ò๑)阿绫……:洛天依:使用教程/洛天依.jpg","shanbao:洛小姐这是……","sp:嘁，最后还是没赶上！看来是之前动力装置受损还没完全修复好！:艾希:使用教程/icey.jpg","shanbao:什么？！那意思洛小姐还是……","none:万由里急忙向后院走去","sp:万由里！别着急！:乐正绫:使用教程/乐正绫.jpg","none:乐正绫拉住万由里","sp:只是我刚刚一走神没看住天依，她就吃了一朵下去。:乐正绫:使用教程/乐正绫.jpg","sp:只是少了一朵，罗真姐姐应该不会发现的！就算发现了应该也不会生气吧？:艾希:使用教程/icey.jpg","sp:发现什么？:罗真:使用教程/罗真.jpg","right:使用教程/icey.jpg:艾希","sp:呜！！！:洛天依:使用教程/洛天依.jpg","right:使用教程/乐正绫.jpg:乐正绫","shanbao:呀！！！","right:none","sp:你们一个个怎么了？和见鬼了似的……咦？小包子这是怎么了？:罗真:使用教程/罗真.jpg","sp:啊……！天依她吃多了！肚子疼！对吧，万由里！:乐正绫:使用教程/乐正绫.jpg","right:使用教程/shanbao.jpg:万由里:left","sp:啊？哦！对……对呀！:乐正绫:使用教程/乐正绫.jpg","right:使用教程/shanbao.jpg:万由里:right","sp:小包子吃东西吃多了？那可真是少见……之前我就和你们说了，平时就注意下小包子的饮食……:罗真:使用教程/罗真.jpg","right:使用教程/icey.jpg:艾希:left","sp:那还不是因为，之前天依姐姐一个人引爆了半个神界的力量和犹大同归于尽，最后却毫发无伤嘛！:罗真:使用教程/罗真.jpg","right:使用教程/icey.jpg:艾希:right","sp:……说的倒也是，小包子的体质万古不灭、滴血重生……能让她肚子疼恐怕不是单纯的吃多了那么简单，她对我和小儡有恩，还是我来替她来检查一下吧……:罗真:使用教程/罗真.jpg","right:none","sp:呜呜呜！！！:洛天依:使用教程/洛天依.jpg","none:洛天依整个立马往后缩了缩","right:使用教程/icey.jpg:艾希","sp:不用麻烦了！天依她真的就是吃多了！她平时有时候也这样！休息一下就好了！对吧，天依？:乐正绫:使用教程/乐正绫.jpg","right:none","sp:你们今天可真奇怪啊……平时来我这可不是这样的……对吧，万由里？:罗真:使用教程/罗真.jpg","shanbao:啊？对……对吧？","sp:……:罗真:使用教程/罗真.jpg","none:罗真嘴角扬起一抹不易察觉微笑","sp:那我给你们讲讲我这的这些东西的吧，这样小包子应该就不会那么难受了。:罗真:使用教程/罗真.jpg","sp:好呀！好呀！(可算蒙混过去了！):乐正绫:使用教程/乐正绫.jpg","none:罗真向着后院挥挥手，一朵血红色的四叶草便从后院飞到了罗真的手中","sp:这是我平时精心照料的四叶草，其实它本是在冥界开放的彼岸花，有着让死者复生的力量……:罗真:使用教程/罗真.jpg","sp:那……那可真是厉害啊！对了它能让死者复生，那活着的人呢？:艾希:使用教程/icey.jpg","sp:……生者……消亡……:罗真:使用教程/罗真.jpg","none:罗真话音刚落，在她手中的四叶草便化为灰烬四散。躲在墙角的洛天依身体颤抖的更加厉害了。","sp:！！！那……那对天依这种身体应该没事吧……？:乐正绫:使用教程/乐正绫.jpg","sp:的确……赤红的力量不足以伤害小包子这种集整个神界之力都无法完全杀死的存在……:罗真:使用教程/罗真.jpg","none:乐正绫隐隐舒了口气","sp:但是……赤红依旧会源源不断的吸走小包子的生命……她会一直痛苦不堪直至精神崩溃……:罗真:使用教程/罗真.jpg","sp:呜呜呜 (๑ó﹏ò๑)，罗真姐姐对不起！天依刚刚偷吃了你种的四叶草，现在天依肚子好疼，罗真姐姐快救救我(╥﹏╥):洛天依:使用教程/洛天依.jpg","sp:不不不，都怪我没看好天依！罗真姐你要怪就怪我吧，但是一定要救救天依啊！:乐正绫:使用教程/乐正绫.jpg","sp:呜……！这……这也算我的错！都是我在路上耽搁了！要怪就怪我才对！:艾希:使用教程/icey.jpg","shanbao:死神大人……艾希是因为我才耽误的，所以……","sp:哈哈哈……好了！好了！我根本没想怪你们，只是想看看你们什么时候坦白而已，我之前就说了小包子对我和小儡有恩，就算她把我满院的赤红毁了我也不会怪她的！:罗真:使用教程/罗真.jpg","none:罗真手往洛天依肚子一指","sp:小包子张开嘴！:罗真:使用教程/罗真.jpg","none:红光一闪，一朵无比鲜艳的四叶草便飞到了罗真手中","sp:呜呜呜，吓死天依了(๑ó﹏ò๑)，下次再也不敢碰罗真姐这里的东西了……:洛天依:使用教程/洛天依.jpg"],"xiaojvchang2":["sp:绫姐、天依姐你们为什么把这个机会让给万由里小姐呢？你们难道不想再见见@吗？:艾希:使用教程/icey.jpg","sp:才不是呢！天依做梦都想再见一次@哥哥，但是……:洛天依:使用教程/洛天依.jpg","sp:唉……其实不止我们，还有初音前辈、杨越大哥、罗真姐大家都有很多话想跟@说呢……:乐正绫:使用教程/乐正绫.jpg","sp:那为什么绿毛龟说要找个人去给@送东西，你们都不作声啊？:艾希:使用教程/icey.jpg","sp:我们和@相处的时光已经很长了……虽然还有些许遗憾，但是也已经慢慢释怀了……可是万由里她……:乐正绫:使用教程/乐正绫.jpg","sp:万由里姐姐，她因@哥哥而生又因@哥哥而逝，自始自终都守望着哥哥，却始终不能和哥哥接触……比起我们的遗憾，她的心中的悲伤多太多了……:洛天依:使用教程/洛天依.jpg","sp:只希望这次和@见面以后，她能发自内心的笑出来，而不是强颜欢笑了吧……:乐正绫:使用教程/乐正绫.jpg"],"yindaoA0":["shanbao:你好呀，这里是<span class=\\"pink\\">扇宝</span>，欢迎来到V杀（VtuberKill）的世界！","shanbao:对于V杀有什么不懂的的地方就请来询问我吧！<br>（按住Ctrl键可以加速对话哦）","shanbao:请问您之前接触过类似于V杀（diy三国杀）的游戏嘛？","choose:纯路人，什么是三国杀？:听说过，也玩过类似的桌游:只接触过原版的三国杀:游戏规则我都懂，教我怎么进行游戏配置吧:进阶教程什么的有在做嘛？:跳过引导"],"yindaoA1":["shanbao:请问您之前接触过类似于V杀（diy三国杀）的游戏嘛？","choose:纯路人，什么是三国杀？:听说过，也玩过类似的桌游:只接触过原版的三国杀:游戏规则我都懂，教教我怎么进行游戏配置吧:进阶教程什么的有在做嘛？"],"yindaoB":["shanbao:咳咳~ <打开搜索引擎>","none:“《三国杀》是中国传媒大学动画学院04级游戏专业学生黄恺（Kayak）设计，由游卡桌游出版发行的一款热门桌面游戏。”","none:“该游戏结合中国三国时期历史文化背景，以身份、势力或阵营等为线索，以卡牌为形式，玩家通过合纵连横，经过一轮一轮的谋略和动作获得最终的胜利。”","shanbao:大概就是这样子啦~ 扇宝我也是在直播中才上手三国杀的（迫真）"],"yindaoC":["booth:yindao/Kaf.jpg:160:300:15:20","shanbao:咱们这游戏是V杀，也就是将原版三国杀从古代背景跳跃到虚拟世界~","booth:yindao/LizeHelesta.jpg:160:300:30:20","shanbao:许多经典角色都会出现在游戏中哦~ ","booth:yindao/ShirakamiHaruka.jpg:160:300:45:20","shanbao:若是恰好没有实装到您推的V，您也可以为自己的推设计一套技能投稿到制作组哟~ ","booth:yindao/MiraiAkari.jpg:160:300:60:20","shanbao:此外V杀在原版三国杀的基础上又拓展了一些玩法  如果想了解的话之后我会解释 ","booth:yindao/Bella.jpg:160:300:75:20","shanbao:大概就是这样子啦~","booth:none","shanbao: "],"yindaoCard1":["booth:yindao/path2.png:100:250:8:42","right:yindao/shanbao.jpg:扇宝:left","none:这个游戏是依靠卡牌的驱动的，刚才加入你的“手牌区”的是一张【杀】 ","none:每张卡牌都有自己的效果，我们可以使用“手牌区”的一张牌来激活其效果——而【杀】的效果是对其他角色造成一点伤害 ","right:none","booth:none","shanbao: ","shanbao:那么，向我使用【杀】吧！<br>（右键点击卡牌即可查看卡牌的详细信息） ","choose:我知道了:跳过这个部分"],"yindaoCard2":["shanbao:和其他游戏一样，一名角色受到伤害之后体力就会减少，体力减少到“0”后就会“死亡”。所以一般而言我们要避免受到伤害 （当然，只是一般而言）","booth:yindao/path2.png:100:250:8:42","right:yindao/shanbao.jpg:扇宝:left","none:刚才加入你的“手牌区”的是一张【闪】，在你被杀的时候，可以使用这张牌来“抵消”这张【杀】，也就是其他游戏里常说的“闪避”啦 ","none:接下来杜松子会向你使用【杀】，作好准备吧，少年！ ","right:yindao/dusongziGin.jpg:杜松子:left","none:…… ","right:none","shanbao: "],"yindaoCard3":["shanbao:卡牌也是分种类的哦，比如我们刚才使用的【杀】和【闪】，就是“基本牌”这一类型","shanbao:除基本牌外，游戏里还有“锦囊牌”和“装备牌”两大类牌","shanbao:接下来就让我们了解这些牌吧~"],"yindaoCard33":["shanbao:游戏的过程中，每个玩家是分别进行自己的回合的（按座次，逆时针依次进行）","shanbao:每名角色在摸牌阶段摸两张牌，在出牌阶段可以使用牌，在弃牌阶段弃置超出上限的牌（一般而言，一名角色的手牌上限等于其当前的体力值）","shanbao:一般的，每名角色在一个出牌阶段内只能使用一张【杀】，而对于其他大部分牌的使用则没有限制"],"yindaoCard34":["shanbao:延时锦囊牌是一种特殊的锦囊牌，我们在之前的教程用到的锦囊【无中生有】和【过河拆桥】都是即时产生效果的 “通常锦囊” ，而延时锦囊是在目标的下个判定阶段（摸牌之前）才可能生效哦~ ","shanbao:一般的延时锦囊会在生效前进行 “判定” 来决定最终的效果（不能摸牌，不能出牌，或者受到伤害），所以把一般的延时锦囊牌理解成debuff（负面状态）也是没有问题的 ","shanbao:而 “判定” ，就是亮出牌堆顶的一张牌，将这张牌的花色、点数甚至牌名作为后续效果执行的依据。 ","shanbao:比如你手上这张【乐不思蜀】，就是让目标进行判定，如果判定出来的牌不是 红桃♥ ，就会使目标跳过下个出牌阶段（一回合不能出牌） ","shanbao:不过实际对局里延时锦囊牌的情况会很复杂，比如之前提到的【过河拆桥】，就可以拆判定区的牌，可以向队友使用解除她头顶【乐不思蜀】，这里就不演示啦~ "],"yindaoCard42":["right:yindao/dusongziGin.jpg:杜松子:left","shanbao:为什么被拆的是我呀？","right:yindao/dusongziGin.jpg:杜松子:right","shanbao:因为【过河拆桥】只能对区域内有牌的角色使用啊","right:yindao/dusongziGin.jpg:杜松子:left","shanbao:哦，扇宝你也没牌呀，那好吧","right:yindao/dusongziGin.jpg:杜松子:right","shanbao:那可不（偷偷摸一张【闪】）","right:none","shanbao: "],"yindaoCardIndex":["shanbao:想要了解些什么呢？<br>（顺便一提，选择框是可以滚动/划动的）","choose:装备牌的分类与使用:通常锦囊牌的使用:回合与阶段:判定与延时锦囊牌的使用:卡牌的「使用」与「打出」:无懈可击！:跳过这个部分"],"yindaoWuxie":["shanbao:【无懈可击】的效果是“抵消一张锦囊牌”，比如现在，你的这张决斗就被抵消了","shanbao:但是不用担心，【无懈可击】本身也是可以无懈掉的"],"yindaoD":["shanbao:理解理解，毕竟三国杀曾经也是风靡各地的游戏呢~","shanbao:那么就把关于卡牌的基础部分跳过了哦~"],"yindaoE0":["shanbao:如果你在使用手机，可能会觉得按钮有点小，将布局改成移动可以使按钮变大 ","shanbao:你可以在[选项]-[外观]-[布局]中更改此设置~ "],"yindaoE1":["shanbao:触屏模式中，下划可以显示菜单，上划可以切换托管，双指单击可以暂停 ","shanbao:你可以在[选项]-[通用]-中更改手势设置~ "],"yindaoE20":["shanbao:在菜单中，可以进行各项设置 "],"yindaoE21":["shanbao:同样是在[选项]中，如果觉得背景太花，[选项]-[外观]中可以更换背景或改为模糊状态 "],"yindaoE22":["shanbao:这里是调整武将包的地方，三国杀新手推荐只开初心包~ "],"yindaoE23":["shanbao:这里是调整卡牌包的地方，其中化鲸篇是V杀原创拓展，包含海洋系的V圈卡牌 "],"yindaoE24":["shanbao:这里是调整游戏模式的地方，切换到联机就可以与好友联机了~ ","shanbao:联机时记得在[开始]-[联机]中设置头像和昵称方便辨认 "],"yindaoE25":["shanbao:在[其他]中，可以检查更新和下载素材 ","shanbao:如果是客户端的话，记得下载完素材以获得最佳游戏体验哦~ ","shanbao:如果还有其它问题，欢迎来到V杀联机群（623566610）进行交流"],"yindaoE3":["shanbao:游戏中也有不同的布局可以设置，让我们尝试一下吧 ","choose:默认（初始样式）:旧版:宽屏:手杀:新版:结束调试"],"yindaoF0":["shanbao:V杀相较与原版的三国杀，也有许多独创的机制和玩法","shanbao:包括近些年本家新增的机制，在游戏里也有同步更新的<br>（这一点当然得归功于无名杀的更新者啦~）"],"yindaoFIndex":["shanbao:想要了解些什么呢？","choose:三国杀机制：转换技:无名杀机制：护甲:V杀新增机制：海洋与暗影:讲讲V杀游戏配置吧:跳过这个部分"],"yindaoNewSkill0":["shanbao:<看百科>“转化技是一种替换技能的机制，当你在正常状况下，此技能会作为其他技能生效，但是触发一定的条件后，它能够改变原来的效果状态，并可以在一定的条件下转化为正常状态。也可以理解为状态可逆的‘觉醒技’。” ","shanbao:<忍不住吐槽>这百科写的是啥啊？“状态可逆的‘觉醒技’”是什么奇怪的解释呀 ","shanbao:那这样吧，让一名会转换技的V带你去了解吧，可以嘛？","choose:OKK~（跟随<span class=\\"aqua\\">樋口枫</span>学习转换技）:好的哦~（跟随<span class=\\"orange\\">乃琳</span>学习转换技）:可是转换技我本来就懂啊（“阿瞒……”）"],"yindaoNewSkill1":["shanbao:欸，那好吧~ "],"yindaoHujia0":["shanbao:<li>护甲：和体力类似，每点护甲可抵挡一点伤害，但不影响手牌上限。","shanbao:其实也就类似于炉石里的护甲吧 ","shanbao:就比如~现在我叠一层护甲，你杀过来试试？"],"yindaoMaking":["duoduopoi:前面的区域，以后再来探索吧~","shanbao:欸欸欸，我们好像遇到施工地段了 ","shanbao:嘛嘛，如果有不懂的事，问问V杀群里的群友就好了嘛（匆忙离开） "],"over":["shanbao:那扇宝我就在这里祝愿新人能快速上手吧！","shanbao:如果之后有些游戏操作和规则忘记了也可以回扇宝这里来复习一下的哦","choose:再引导一次:进入身份模式:进入国战模式"]}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";

// EXTERNAL MODULE: ../node_modules/jszip/dist/jszip.min.js
var jszip_min = __webpack_require__(2858);
var jszip_min_default = /*#__PURE__*/__webpack_require__.n(jszip_min);
;// CONCATENATED MODULE: ./game/Game.js
/* harmony default export */ const Game = ({
  vkFun: function () {
    /**
     * 其中的变量是游戏中的全局变量，因为是在IIFE中声明而不是实际上的全局范围，从而对外部实现了隐藏
     * @namespace
     * @global
     */
    const _status = __webpack_require__(4491);
    /**
     * 包(游戏牌, 武将牌, 拓展)管理相关
     * 游戏入口{@link lib.init.init}
     * @namespace
     * @global
     */
    const lib = {
      configprefix: 'vtuberkill_1.9_',
      versionOL: 27,
      updateURLS: {
        coding: 'https://v8gamemaker.coding.net/p/vtuberkill/d/vtuberkill_github/git/raw/',
        github: 'https://v8gamemaker.coding.net/p/vtuberkill/d/vtuberkill_github/git/raw/',
      },
      updateURL: 'https://v8gamemaker.coding.net/p/vtuberkill/d/vtuberkill_github/git/raw/',
      mirrorURL: 'https://v8gamemaker.coding.net/p/vtuberkill/d/vtuberkill_github/git/raw/',
      hallURL: 'www.vtuberkill.com',
      assetURL: '',
    };
    /**
     * 游戏内核
     * 游戏循环{@link game.loop}
     * @namespace
     * @global
     */
    const game = {};
    /**
     * 游戏UI库
     * @namespace
     * @global
     */
    const ui = {};
    /**
     * 游戏工具函数库，对游戏中一些常用操作(查询，选择，转换，判断等)进行了封装
     * @namespace
     * @global
     */
    const get = {};
    /**
     * 游戏AI模块
     * @namespace
     * @global
     */
    const ai = {};
    const vkCore = window.vkCore = { game, ui, get, ai, lib, _status }
    function vkExtends(target, source) {
      for (let k in source) {
        if (source.hasOwnProperty(k) === true) {
          target[k] = source[k];
        }
      }
    }
    vkExtends(lib, (__webpack_require__(5248).libFun)(vkCore))
    vkExtends(game, (__webpack_require__(3207).gameFun)(vkCore))
    vkExtends(ui, (__webpack_require__(717).uiFun)(vkCore))
    vkExtends(get, (__webpack_require__(7806).getFun)(vkCore))
    vkExtends(ai, (__webpack_require__(2860).aiFun)(vkCore))
    //导入资源
    __webpack_require__(5062)
    __webpack_require__(6439)
    //galgame相关功能
    __webpack_require__(6798)()
    //点击特效功能
    game.clickCanvas = __webpack_require__(8274)
    //引入自定义样式
    __webpack_require__(9735)
    if (typeof global === 'undefined' || !__dirname.length) {
      lib.init.sheet(`*{
        cursor: url('./layout/cursor/aero_arrow_glow.cur'),auto;
      }`)
    }
    lib.init_pack = (pack) => {
      if (game.getFileList instanceof Function) {
        pack.play['特效测试'] = '特效测试'
      }
    }
    lib.init_extra = () => {
      if (game.getFileList instanceof Function) {
        lib.extensionMenu['extension_特效测试'] = {
          enable: {
            name: '开启',
            init: false,
            restart: true,
            onclick: function (bool) {
              if (bool) {
                lib.config.plays.add('特效测试');
              }
              else {
                lib.config.plays.remove('特效测试');
              }
              game.saveConfig('plays', lib.config.plays);
            }
          },
        }
      }
    }
    game.putBuff = (player, skill, buff) => {
      game.broadcastAll(function (player, skill, buff) {
        if (!player.node[skill + '_buff']) {
          player.node[skill + '_buff'] = [ui.create.div(buff, player.node.avatar), ui.create.div(buff, player.node.avatar2)];
        }
      }, player, skill, buff);
    }
    game.clearBuff = (player, skill) => {
      game.broadcastAll(function (player, skill) {
        if (player.node[skill + '_buff']) {
          if (player.node[skill + '_buff'][0].delete) {
            player.node[skill + '_buff'][0].delete();
            player.node[skill + '_buff'][1].delete();
          }
          delete player.node[skill + '_buff']
        }
      }, player, skill);
    }
    ui.putImgDialog = (str) => {
      if (str && !ui[`imgDialog_${str}`]) {
        let dialog = ui.create.dialog('hidden');
        dialog.classList.add('static');
        ui.window.appendChild(dialog);
        dialog.style.left = 'calc(50% - 270px)';
        dialog.style.top = 'calc(50% - 160px)';
        dialog.style.height = '55%';
        dialog.style.width = '60%';
        dialog.style.zIndex = 2;
        dialog.style.backgroundRepeat = 'no-repeat';
        dialog.setBackgroundImage(`layout/uiImg/${str}.png`)
        ui[`imgDialog_${str}`] = dialog

        game.broadcastAll(function (str) {
          ui.putImgDialog(str);
        }, str);
      }
    },
      ui.clearImgDialog = (str) => {
        if (ui[`imgDialog_${str}`]) {
          let dialog = ui[`imgDialog_${str}`]
          delete ui[`imgDialog_${str}`];
          setTimeout(() => {
            dialog.style.opacity = 0.05;
            setTimeout(() => {
              dialog.delete();
            }, 500);
          }, 1000);
          game.broadcastAll(function (str) {
            ui.clearImgDialog(str);
          }, str);
        }
      }
    lib.skill._pindiankuang = {
      trigger: {
        player: "chooseToCompareBefore",
      },
      forced: true,
      popup: false,
      content: function () {
        let str = 'pindian'
        ui.putImgDialog(str);
      }
    }
    lib.skill._pindiankuangAfter = {
      trigger: {
        player: "chooseToCompareAfter"
      },
      forced: true,
      popup: false,
      content: function () {
        let str = 'pindian'
        ui.clearImgDialog(str);
      }
    }
    lib.init.init();
  }
});

;// CONCATENATED MODULE: ./main.js


window.JSZip = (jszip_min_default())
Game.vkFun()
})();

/******/ })()
;