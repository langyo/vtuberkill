var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/// <reference path = "../built-in.d.ts" />
globalThis.moduleManager.define(['core/core', 'view/PlayerModel'], function (_a, PlayerModel) {
    var _status = _a._status, lib = _a.lib, game = _a.game, ui = _a.ui, get = _a.get, ai = _a.ai;
    /**
     * 包(游戏牌, 武将牌, 拓展)管理相关
     * 游戏入口{@link lib.init.init}
     * @namespace lib
     * @memberof module:core
     */
    globalThis.mixin(lib, /**@lends module:core.lib */ {
        discoloration1: "<samp id='渐变'><font face='yuanli'><style>#渐变{animation:change 0.8s linear 0s infinite;}@keyframes change{0% {color:#FF0000;}20%{color:#F0A00F;}50% {color:#F000FF;}80%{color: #F0A00F;}100%{color:#FF0000;}}</style>",
        configprefix: 'vtuberkill_1.9_',
        versionOL: 27,
        updateURLS: {
            coding: 'https://v8gamemaker.coding.net/p/vtuberkill/d/vtuberkill_github/git/raw/',
            github: 'https://v8gamemaker.coding.net/p/vtuberkill/d/vtuberkill_github/git/raw/'
        },
        updateURL: 'https://v8gamemaker.coding.net/p/vtuberkill/d/vtuberkill_github/git/raw/',
        mirrorURL: 'https://v8gamemaker.coding.net/p/vtuberkill/d/vtuberkill_github/git/raw/',
        hallURL: 'www.vtuberkill.com',
        assetURL: '',
        changeLog: [],
        updates: [],
        canvasUpdates: [],
        video: [],
        skilllist: [],
        connectBanned: [],
        characterIntro: {},
        characterTitle: {},
        characterPack: {},
        characterFilter: {},
        characterSort: {},
        characterReplace: {},
        dynamicTranslate: {},
        cardPack: {},
        onresize: [],
        onphase: [],
        onwash: [],
        onover: [],
        ondb: [],
        ondb2: [],
        chatHistory: [],
        emotionList: {
            xiaowu_emotion: 14,
            shibing_emotion: 15,
            guojia_emotion: 20,
            zhenji_emotion: 20,
            xiaosha_emotion: 20,
            xiaotao_emotion: 20,
            xiaojiu_emotion: 20,
            Diana_emotion: 6
        },
        animate: {
            skill: {},
            card: {}
        },
        arenaReady: [],
        onfree: [],
        inpile: [],
        extensions: [],
        extensionPack: {},
        cardType: {},
        hook: { globaltrigger: {}, globalskill: {} },
        hookmap: {},
        imported: {},
        layoutfixed: ['chess', 'tafang', 'stone'],
        /**
         * 角色选择弹窗中的特殊选项
         * ['收藏', '最近']
         * @name lib.characterDialogGroup
         * @see {@link ui.create.characterDialog}
         */
        characterDialogGroup: {
            '收藏': function (name, capt) {
                return lib.config.favouriteCharacter.contains(name) ? capt : null;
            },
            '最近': function (name, capt) {
                var list = get.config('recentCharacter') || [];
                return list.contains(name) ? capt : null;
            }
        },
        /**
         * 监听节点动画结束
         * @param {HTMLDivELement} node 节点
         */
        listenEnd: function (node) {
            if (!node._listeningEnd) {
                node._listeningEnd = true;
                node.listenTransition(function () {
                    delete node._listeningEnd;
                    if (node._onEndMoveDelete) {
                        node.moveDelete(node._onEndMoveDelete);
                    }
                    else if (node._onEndDelete) {
                        node["delete"]();
                    }
                    node._transitionEnded = true;
                });
            }
        },
        /**
         * 游戏菜单
         * @name configMenu
         * @namespace
         * @type {!Object}
         */
        configMenu: {
            /**
             * 通用设置
             * @name configMenu.general
             * @type {!Object}
             */
            general: {
                name: '通用',
                config: {
                    low_performance: {
                        name: '流畅模式',
                        init: false,
                        intro: '减少部分游戏特效，提高游戏速度',
                        onclick: function (bool) {
                            game.saveConfig('low_performance', bool);
                            if (bool) {
                                ui.window.classList.add('low_performance');
                            }
                            else {
                                ui.window.classList.remove('low_performance');
                            }
                        }
                    },
                    compatiblemode: {
                        name: '兼容模式',
                        init: false,
                        intro: '开启兼容模式可防止扩展使游戏卡死并提高对旧扩展的兼容性，但对游戏速度有一定影响，若无不稳定或不兼容的扩展建议关闭',
                        onclick: function (bool) {
                            game.saveConfig('compatiblemode', bool);
                            if (bool) {
                                ui.window.classList.add('compatiblemode');
                            }
                            else {
                                ui.window.classList.remove('compatiblemode');
                            }
                        }
                    },
                    confirm_exit: {
                        name: '确认退出',
                        init: false,
                        unfrequent: true,
                        intro: '离开游戏前弹出确认对话框'
                    },
                    keep_awake: {
                        name: '屏幕常亮',
                        init: false,
                        unfrequent: true,
                        intro: '防止屏幕自动关闭<br>注：旧版本通过NoSleep.js实现的屏幕常亮可能会影响外置音频的音量',
                        onclick: function (bool) {
                            game.saveConfig('keep_awake', bool);
                            if (bool) {
                                if (window.plugins && window.plugins.insomnia)
                                    window.plugins.insomnia.keepAwake();
                                else if (window.noSleep) {
                                    document.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', function enableNoSleepX() {
                                        document.removeEventListener(lib.config.touchscreen ? 'touchend' : 'click', enableNoSleepX, false);
                                        window.noSleep.enable();
                                    }, false);
                                }
                            }
                            else {
                                if (window.plugins && window.plugins.insomnia)
                                    window.plugins.insomnia.allowSleepAgain();
                                else if (window.noSleep)
                                    window.noSleep.disable();
                            }
                        }
                    },
                    auto_confirm: {
                        name: '自动确认',
                        init: true,
                        unfrequent: true,
                        intro: '当候选目标只有1个时，点击目标后无需再点击确认'
                    },
                    skip_shan: {
                        name: '无闪自动取消',
                        init: false,
                        unfrequent: true,
                        intro: '当自己需要使用或打出【闪】时，若自己没有【闪】，则跳过该步骤'
                    },
                    unauto_choose: {
                        name: '拆顺手牌选择',
                        init: false,
                        unfrequent: true,
                        intro: '拆牌或者顺牌时，就算只能选择对方的手牌依然手动选择'
                    },
                    wuxie_self: {
                        name: '不无懈自己',
                        init: true,
                        unfrequent: true,
                        intro: '自己使用的单目标普通锦囊即将生效时，不询问无懈'
                    },
                    tao_enemy: {
                        name: '不对敌方出桃',
                        init: false,
                        intro: '双方阵营明确的模式中（如对决），敌方角色濒死时不询问出桃',
                        unfrequent: true
                    },
                    enable_drag: {
                        name: '启用拖拽',
                        init: true,
                        intro: '按住卡牌后可将卡牌拖至目标',
                        unfrequent: true
                    },
                    enable_dragline: {
                        name: '拖拽指示线',
                        init: true,
                        unfrequent: true,
                        intro: '拖拽时显示虚线，可能降低游戏速度'
                    },
                    enable_touchdragline: {
                        name: '拖拽指示线',
                        init: false,
                        unfrequent: true,
                        intro: '拖拽时显示虚线，可能降低游戏速度'
                    },
                    // enable_pressure:{
                    //     name:'启用压感',
                    //     init:false,
                    //     intro:'开启后可通过按压执行操作',
                    //     unfrequent:true,
                    // },
                    // pressure_taptic:{
                    //     name:'触觉反馈',
                    //     init:false,
                    //     intro:'开启后按压操作执行时将产生震动',
                    //     unfrequent:true,
                    // },
                    // pressure_click:{
                    //     name:'按压操作',
                    //     init:'pause',
                    //     intro:'在空白区域按压时的操作',
                    //     unfrequent:true,
                    //     item:{
                    //         pause:'暂停',
                    //         config:'选项',
                    //         auto:'托管',
                    //     }
                    // },
                    touchscreen: {
                        name: '触屏模式',
                        init: false,
                        restart: true,
                        unfrequent: true,
                        intro: '开启后可使触屏设备反应更快，但无法使用鼠标操作',
                        onclick: function (bool) {
                            if (get.is.nomenu('touchscreen', bool))
                                return false;
                            game.saveConfig('touchscreen', bool);
                        }
                    },
                    swipe: {
                        name: '滑动手势',
                        init: true,
                        unfrequent: true,
                        intro: '在非滚动区域向四个方向滑动可执行对应操作'
                    },
                    swipe_down: {
                        name: '下划操作',
                        init: 'menu',
                        unfrequent: true,
                        intro: '向下滑动时执行的操作',
                        item: {
                            system: '显示按钮',
                            menu: '打开菜单',
                            pause: '切换暂停',
                            auto: '切换托管',
                            chat: '显示聊天',
                            off: '关闭'
                        },
                        onclick: function (item) {
                            if (get.is.nomenu('swipe_down', item))
                                return false;
                            game.saveConfig('swipe_down', item);
                        }
                    },
                    swipe_up: {
                        name: '上划操作',
                        intro: '向上滑动时执行的操作',
                        init: 'auto',
                        unfrequent: true,
                        item: {
                            system: '显示按钮',
                            menu: '打开菜单',
                            pause: '切换暂停',
                            auto: '切换托管',
                            chat: '显示聊天',
                            off: '关闭'
                        },
                        onclick: function (item) {
                            if (get.is.nomenu('swipe_up', item))
                                return false;
                            game.saveConfig('swipe_up', item);
                        }
                    },
                    swipe_left: {
                        name: '左划操作',
                        intro: '向左滑动时执行的操作',
                        init: 'system',
                        unfrequent: true,
                        item: {
                            system: '显示按钮',
                            menu: '打开菜单',
                            pause: '切换暂停',
                            auto: '切换托管',
                            chat: '显示聊天',
                            off: '关闭'
                        },
                        onclick: function (item) {
                            if (get.is.nomenu('swipe_left', item))
                                return false;
                            game.saveConfig('swipe_left', item);
                        }
                    },
                    swipe_right: {
                        name: '右划操作',
                        intro: '向右滑动时执行的操作',
                        init: 'system',
                        unfrequent: true,
                        item: {
                            system: '显示按钮',
                            menu: '打开菜单',
                            pause: '切换暂停',
                            auto: '切换托管',
                            chat: '显示聊天',
                            off: '关闭'
                        },
                        onclick: function (item) {
                            if (get.is.nomenu('swipe_right', item))
                                return false;
                            game.saveConfig('swipe_right', item);
                        }
                    },
                    round_menu_func: {
                        name: '触屏按钮操作',
                        intro: '点击屏幕中圆形按钮时执行的操作',
                        init: 'system',
                        unfrequent: true,
                        item: {
                            system: '显示按钮',
                            menu: '打开菜单',
                            pause: '切换暂停',
                            auto: '切换托管'
                        },
                        onclick: function (item) {
                            if (get.is.nomenu('round_menu_func', item))
                                return false;
                            game.saveConfig('round_menu_func', item);
                        }
                    },
                    show_splash: {
                        name: '显示开始界面',
                        intro: '游戏开始前进入模式选择画面',
                        init: 'init',
                        item: {
                            off: '关闭',
                            init: '首次启动',
                            always: '保持开启'
                        }
                    },
                    game_speed: {
                        name: '游戏速度',
                        init: 'mid',
                        item: {
                            vslow: '慢',
                            slow: '较慢',
                            mid: '中',
                            fast: '较快',
                            vfast: '快',
                            vvfast: '很快'
                        },
                        intro: '设置不同游戏操作间的时间间隔'
                    },
                    sync_speed: {
                        name: '限制结算速度',
                        intro: '在动画结算完成前不执行下一步操作，开启后游戏操作的间隔更长但画面更浏畅，在游戏较卡时建议开启',
                        init: true
                    },
                    enable_vibrate: {
                        name: '开启震动',
                        intro: '回合开始时使手机震动',
                        init: false
                    },
                    right_click: {
                        name: '右键操作',
                        init: 'pause',
                        intro: '在空白区域点击右键时的操作',
                        unfrequent: true,
                        item: {
                            pause: '暂停',
                            shortcut: '工具',
                            config: '选项',
                            auto: '托管'
                        },
                        onclick: function (item) {
                            if (get.is.nomenu('right_click', item))
                                return false;
                            game.saveConfig('right_click', item);
                        }
                    },
                    longpress_info: {
                        name: '长按显示信息',
                        init: true,
                        unfrequent: true,
                        restart: true,
                        intro: '长按后弹出菜单'
                    },
                    right_info: {
                        name: '右键显示信息',
                        init: true,
                        unfrequent: true,
                        restart: true,
                        intro: '右键点击后弹出菜单'
                    },
                    hover_all: {
                        name: '悬停显示信息',
                        init: true,
                        unfrequent: true,
                        restart: true,
                        intro: '悬停后弹出菜单'
                    },
                    hover_handcard: {
                        name: '悬停手牌显示信息',
                        init: true,
                        unfrequent: true,
                        intro: '悬停手牌后弹出菜单'
                    },
                    hoveration: {
                        name: '悬停菜单弹出时间',
                        unfrequent: true,
                        intro: '鼠标移至目标到弹出菜单的时间间隔',
                        init: '1000',
                        item: {
                            '500': '0.5秒',
                            '700': '0.7秒',
                            '1000': '1秒',
                            '1500': '1.5秒',
                            '2500': '2.5秒'
                        }
                    },
                    doubleclick_intro: {
                        name: '双击显示武将资料',
                        init: true,
                        unfrequent: true,
                        intro: '双击武将头像后显示其资料卡'
                    },
                    video: {
                        name: '保存录像',
                        init: '20',
                        intro: '游戏结束后保存录像在最大条数，超过后将从最早的录像开始删除（已收藏的录像不计入条数）',
                        item: {
                            '0': '关闭',
                            '5': '五局',
                            '10': '十局',
                            '20': '二十局',
                            '50': '五十局',
                            '10000': '无限'
                        },
                        unfrequent: true
                    },
                    max_loadtime: {
                        name: '最长载入时间',
                        intro: '设置游戏从启动到完成载入所需的最长时间，超过此时间未完成载入会报错，若设备较慢或安装了较多扩展可适当延长此时间',
                        init: '10000',
                        unfrequent: true,
                        item: {
                            5000: '5秒',
                            10000: '10秒',
                            20000: '20秒',
                            60000: '60秒'
                        },
                        onclick: function (item) {
                            game.saveConfig('max_loadtime', item);
                            if (item == '5000') {
                                localStorage.removeItem(lib.configprefix + 'loadtime');
                            }
                            else {
                                localStorage.setItem(lib.configprefix + 'loadtime', item);
                            }
                        }
                    },
                    mousewheel: {
                        name: '滚轮控制手牌',
                        init: true,
                        unfrequent: true,
                        intro: '开启后滚轮可使手牌横向滚动，在mac等可横向滚动的设备上建议关闭',
                        onclick: function (bool) {
                            game.saveConfig('mousewheel', bool);
                            if (lib.config.touchscreen)
                                return;
                            if (lib.config.mousewheel) {
                                ui.handcards1Container.onmousewheel = ui.click.mousewheel;
                                ui.handcards2Container.onmousewheel = ui.click.mousewheel;
                            }
                            else {
                                ui.handcards1Container.onmousewheel = null;
                                ui.handcards2Container.onmousewheel = null;
                            }
                        }
                    },
                    auto_check_update: {
                        name: '自动检查游戏更新',
                        intro: '进入游戏时检查更新',
                        init: true,
                        unfrequent: true
                    },
                    lucky_star: {
                        name: '幸运星模式',
                        intro: '在涉及随机数等的技能中，必定得到效果最好的结果。（联机模式无效）',
                        init: false,
                        unfrequent: true
                    },
                    dev: {
                        name: '开发者模式',
                        intro: '开启后可使用浏览器控制台控制游戏，同时可更新到开发版',
                        init: false,
                        onclick: function (bool) {
                            game.saveConfig('dev', bool);
                            if (_status.connectMode)
                                return;
                            if (bool) {
                                lib.cheat.i();
                            }
                            else {
                                delete window.cheat;
                                // delete window.game;//[todo delete]
                                delete window.ui;
                                delete window.get;
                                delete window.ai;
                                delete window.lib;
                                delete window._status;
                            }
                        },
                        unfrequent: true
                    },
                    errstop: {
                        name: '出错时停止游戏',
                        init: false,
                        unfrequent: true
                    },
                    update_link: {
                        name: '更新地址',
                        init: 'coding',
                        unfrequent: true,
                        item: {
                            coding: 'Coding',
                            github: 'GitHub'
                        },
                        onclick: function (item) {
                            game.saveConfig('update_link', item);
                            lib.updateURL = lib.updateURLS[item] || lib.updateURLS.coding;
                        }
                    },
                    //https://raw.githubusercontent.com/libccy/noname-extension/master/
                    extension_source: {
                        name: '获取扩展地址',
                        init: 'Coding',
                        unfrequent: true,
                        item: {},
                        intro: function () {
                            return '获取在线扩展时的地址。当前地址：<br>' + lib.config.extension_sources[lib.config.extension_source];
                        },
                        onclick: function (item) {
                            game.saveConfig('extension_source', item);
                        }
                    },
                    extension_create: {
                        name: '添加获取扩展地址',
                        clear: true,
                        unfrequent: true,
                        onclick: function () {
                            game.prompt('请输入地址名称', function (str) {
                                if (str) {
                                    var map = lib.config.extension_sources;
                                    game.prompt('请输入' + str + '的地址', function (str2) {
                                        if (str2) {
                                            delete map[str];
                                            map[str] = str2;
                                            game.saveConfig('extension_sources', map);
                                            game.saveConfig('extension_source', str);
                                            var nodexx = ui.extension_source;
                                            nodexx.updateInner();
                                            var nodeyy = nodexx._link.menu;
                                            var nodezz = nodexx._link.config;
                                            for (var i = 0; i < nodeyy.childElementCount; i++) {
                                                if (nodeyy.childNodes[i]._link == str) {
                                                    nodeyy.childNodes[i].remove();
                                                    break;
                                                }
                                            }
                                            var textMenu = ui.create.div('', str, nodeyy, function () {
                                                var node = this.parentNode._link;
                                                var config = node._link.config;
                                                node._link.current = this.link;
                                                var tmpName = node.lastChild.innerHTML;
                                                node.lastChild.innerHTML = config.item[this._link];
                                                if (config.onclick) {
                                                    if (config.onclick.call(node, this._link, this) === false) {
                                                        node.lastChild.innerHTML = tmpName;
                                                    }
                                                }
                                                if (config.update) {
                                                    config.update();
                                                }
                                            });
                                            textMenu._link = str;
                                            nodezz.item[name] = str;
                                            alert('已添加扩展地址：' + str);
                                        }
                                    });
                                }
                            });
                        }
                    },
                    extension_delete: {
                        name: '删除当前扩展地址',
                        clear: true,
                        unfrequent: true,
                        onclick: function () {
                            var bool = false, map = lib.config.extension_sources;
                            for (var i in map) {
                                if (i != lib.config.extension_source) {
                                    bool = true;
                                    break;
                                }
                            }
                            if (!bool) {
                                alert('不能删除最后一个扩展地址！');
                                return;
                            }
                            var name = lib.config.extension_source;
                            game.saveConfig('extension_source', i);
                            delete map[name];
                            game.saveConfig('extension_sources', map);
                            var nodexx = ui.extension_source;
                            nodexx.updateInner();
                            var nodeyy = nodexx._link.menu;
                            var nodezz = nodexx._link.config;
                            for (var i = 0; i < nodeyy.childElementCount; i++) {
                                if (nodeyy.childNodes[i]._link == name) {
                                    nodeyy.childNodes[i].remove();
                                    break;
                                }
                            }
                            delete nodezz.item[name];
                            alert('已删除扩展地址：' + name);
                        }
                    },
                    update: function (config, map) {
                        if ('ontouchstart' in document) {
                            map.touchscreen.show();
                        }
                        else {
                            map.touchscreen.hide();
                        }
                        if (lib.device || lib.node) {
                            map.auto_check_update.show();
                        }
                        else {
                            map.auto_check_update.hide();
                        }
                        if (lib.device) {
                            map.enable_vibrate.show();
                            map.keep_awake.show();
                        }
                        else {
                            map.enable_vibrate.hide();
                            map.keep_awake.hide();
                        }
                        // if(config.enable_pressure){
                        //     map.pressure_click.show();
                        //     if(lib.device){
                        //         map.pressure_taptic.show();
                        //     }
                        //     else{
                        //         map.pressure_taptic.hide();
                        //     }
                        // }
                        // else{
                        //     map.pressure_click.hide();
                        //     map.pressure_taptic.hide();
                        // }
                        if (lib.config.touchscreen) {
                            map.mousewheel.hide();
                            map.hover_all.hide();
                            map.hover_handcard.hide();
                            map.hoveration.hide();
                            map.right_info.hide();
                            map.right_click.hide();
                            map.longpress_info.show();
                            map.swipe.show();
                            if (lib.config.swipe) {
                                map.swipe_up.show();
                                map.swipe_down.show();
                                map.swipe_left.show();
                                map.swipe_right.show();
                            }
                            else {
                                map.swipe_up.hide();
                                map.swipe_down.hide();
                                map.swipe_left.hide();
                                map.swipe_right.hide();
                            }
                        }
                        else {
                            map.mousewheel.show();
                            map.hover_all.show();
                            map.right_info.show();
                            map.right_click.show();
                            map.longpress_info.hide();
                            if (!config.hover_all) {
                                map.hover_handcard.hide();
                                map.hoveration.hide();
                            }
                            else {
                                map.hover_handcard.show();
                                map.hoveration.show();
                            }
                            map.swipe.hide();
                            map.swipe_up.hide();
                            map.swipe_down.hide();
                            map.swipe_left.hide();
                            map.swipe_right.hide();
                        }
                        if (lib.config.enable_drag) {
                            if (lib.config.touchscreen) {
                                map.enable_dragline.hide();
                                map.enable_touchdragline.show();
                            }
                            else {
                                map.enable_dragline.show();
                                map.enable_touchdragline.hide();
                            }
                        }
                        else {
                            map.enable_dragline.hide();
                            map.enable_touchdragline.hide();
                        }
                        if (!get.is.phoneLayout()) {
                            map.round_menu_func.hide();
                        }
                        else {
                            map.round_menu_func.show();
                        }
                        if (!lib.node && lib.device != 'ios') {
                            map.confirm_exit.show();
                        }
                        else {
                            map.confirm_exit.hide();
                        }
                        if (config.dev) {
                            map.errstop.show();
                        }
                        else {
                            map.errstop.hide();
                        }
                    }
                }
            },
            /**
             * 外观设置
             * @name configMenu.appearence
             * @type {!Object}
             */
            appearence: {
                name: '外观',
                config: {
                    theme: {
                        name: '主题',
                        init: 'woodden',
                        item: {},
                        visualMenu: function (node, link) {
                            if (!node.menu) {
                                node.className = 'button character themebutton ' + link;
                                node.menu = ui.create.div(node, '', '<div></div><div></div><div></div><div></div>');
                            }
                        },
                        onclick: function (theme) {
                            game.saveConfig('theme', theme);
                            ui.arena.hide();
                            lib.init.background();
                            if (lib.config.autostyle) {
                                if (theme == 'simple') {
                                    lib.configMenu.appearence.config.player_border.onclick('slim');
                                }
                                else {
                                    lib.configMenu.appearence.config.player_border.onclick('normal');
                                }
                            }
                            setTimeout(function () {
                                var theme = ui.css.theme;
                                ui.css.theme = lib.init.css(lib.assetURL + 'theme/' + lib.config.theme, 'style');
                                theme.remove();
                                setTimeout(function () { ui.arena.show(); }, 100);
                            }, 500);
                        }
                    },
                    /**
                     * 游戏布局
                     * @name configMenu.appearence.layout
                     */
                    layout: {
                        name: '布局',
                        init: 'mobile',
                        item: {
                            "default": '旧版',
                            newlayout: '对称',
                            mobile: '默认',
                            long: '宽屏',
                            long2: '手杀',
                            nova: '新版'
                        },
                        visualMenu: function (node, link) {
                            node.className = 'button character themebutton ' + lib.config.theme;
                            if (!node.created) {
                                node.created = true;
                                node.style.overflow = 'hidden';
                                node.firstChild.style.display = 'none';
                                // node.firstChild.classList.add('shadowed');
                                // node.firstChild.style.width='16px';
                                // node.firstChild.style.height='auto';
                                // node.firstChild.style.padding='2px';
                                // node.firstChild.style.textAlign='center';
                                var me = ui.create.div(node);
                                me.style.top = 'auto';
                                if (link == 'default' || link == 'newlayout') {
                                    me.style.width = 'calc(100% - 6px)';
                                    me.style.left = '3px';
                                    me.style.bottom = '3px';
                                    me.style.height = '25px';
                                    if (link == 'newlayout') {
                                        me.style.height = '23px';
                                        me.style.bottom = '4px';
                                    }
                                }
                                else if (link == 'long2' || link == 'nova') {
                                    me.style.display = 'none';
                                }
                                else {
                                    me.style.width = '120%';
                                    me.style.left = '-10%';
                                    me.style.bottom = '0';
                                    me.style.height = '22px';
                                }
                                me.style.borderRadius = '2px';
                                var list = ['KizunaAI', 'MiraiAkari', 'Siro', 'Nekomasu'];
                                for (var i = 0; i < 4; i++) {
                                    var player = ui.create.div('.fakeplayer', node);
                                    ui.create.div('.avatar', player).setBackground(list.randomRemove(), 'character');
                                    player.style.borderRadius = '2px';
                                    if (i != 3) {
                                        player.style.top = 'auto';
                                    }
                                    if (link == 'default') {
                                        player.style.height = '19px';
                                        player.style.width = '38px';
                                        player.classList.add('oldlayout');
                                    }
                                    else if (link == 'mobile' || link == 'newlayout') {
                                        player.style.width = '24px';
                                        player.style.height = '29px';
                                    }
                                    else if (link == 'nova') {
                                        player.style.width = '20px';
                                        player.style.height = '24px';
                                    }
                                    else {
                                        player.style.width = '20px';
                                        player.style.height = '34px';
                                    }
                                    if (i == 1) {
                                        player.style.left = '3px';
                                    }
                                    if (i == 2) {
                                        player.style.left = 'auto';
                                        player.style.right = '3px';
                                    }
                                    if (i == 3) {
                                        player.style.top = '3px';
                                    }
                                    if (link == 'default') {
                                        if (i == 0) {
                                            player.style.bottom = '6px';
                                        }
                                        if (i == 0 || i == 3) {
                                            player.style.left = 'calc(50% - 18px)';
                                        }
                                        if (i == 1 || i == 2) {
                                            player.style.bottom = '36px';
                                        }
                                    }
                                    else if (link == 'newlayout') {
                                        if (i == 0) {
                                            player.style.bottom = '1px';
                                        }
                                        if (i == 0 || i == 3) {
                                            player.style.left = 'calc(50% - 12px)';
                                        }
                                        if (i == 1 || i == 2) {
                                            player.style.bottom = '32px';
                                        }
                                    }
                                    else if (link == 'mobile') {
                                        if (i == 0 || i == 3) {
                                            player.style.left = 'calc(50% - 12px)';
                                        }
                                        if (i == 1 || i == 2) {
                                            player.style.bottom = '30px';
                                        }
                                    }
                                    else if (link == 'long') {
                                        if (i == 0 || i == 3) {
                                            player.style.left = 'calc(50% - 10px)';
                                        }
                                        if (i == 1 || i == 2) {
                                            player.style.bottom = '45px';
                                        }
                                    }
                                    else if (link == 'long2') {
                                        if (i == 0) {
                                            player.style.bottom = '2px';
                                            player.style.left = '3px';
                                        }
                                        if (i == 3) {
                                            player.style.left = 'calc(50% - 10px)';
                                        }
                                        if (i == 1 || i == 2) {
                                            player.style.bottom = '45px';
                                        }
                                    }
                                    else if (link == 'nova') {
                                        if (i == 0) {
                                            player.style.bottom = '2px';
                                            player.style.left = '3px';
                                        }
                                        if (i == 3) {
                                            player.style.left = 'calc(50% - 10px)';
                                        }
                                        if (i == 1 || i == 2) {
                                            player.style.left = '3px';
                                            player.style.bottom = (i * 30) + 'px';
                                        }
                                    }
                                    if (i == 0 && (link == 'mobile' || link == 'long')) {
                                        player.classList.add('me');
                                        player.style.borderRadius = '0px';
                                        player.style.width = '25px';
                                        player.style.height = '25px';
                                        player.style.bottom = '-3px';
                                        player.style.left = '-3px';
                                    }
                                }
                            }
                        },
                        onclick: function (layout) {
                            if (lib.layoutfixed.contains(lib.config.mode)) {
                                game.saveConfig('layout', layout);
                            }
                            else {
                                lib.init.layout(layout);
                            }
                        }
                    },
                    // fewplayer:{
                    //     name:'启用人数',
                    //     intro:'设置启用新版布局的最小人数（不足时切换至默认布局）',
                    //     init:'3',
                    //     // unfrequent:true,
                    //     item:{
                    //                  '2':'两人',
                    //                  '3':'三人',
                    //                  '4':'四人',
                    //                  '5':'五人',
                    //                  '6':'六人',
                    //                  '7':'七人',
                    //                  '8':'八人',
                    //     },
                    //     onclick:function(item){
                    //                  game.saveConfig('fewplayer',item);
                    //                  if(ui.arena) ui.arena.setNumber(ui.arena.dataset.number);
                    //     }
                    // },
                    player_height: {
                        name: '角色高度',
                        init: 'long',
                        // unfrequent:true,
                        item: {
                            short: '矮',
                            "default": '中',
                            long: '高'
                        },
                        onclick: function (item) {
                            game.saveConfig('player_height', item);
                            ui.arena.dataset.player_height = item;
                        }
                    },
                    player_height_nova: {
                        name: '角色高度',
                        init: 'short',
                        item: {
                            // auto:'自动',
                            short: '矮',
                            "default": '中',
                            long: '高'
                        },
                        onclick: function (item) {
                            game.saveConfig('player_height_nova', item);
                            // if(item=='auto'){
                            //     if(parseInt(ui.arena.dataset.number)>=7){
                            //         ui.arena.dataset.player_height_nova='short';
                            //     }
                            //     else{
                            //         ui.arena.dataset.player_height_nova='default';
                            //     }
                            // }
                            // else{
                            ui.arena.dataset.player_height_nova = item;
                            // }
                        }
                    },
                    // background_color_music:{
                    //     name:'背景色',
                    //     init:'black',
                    //     item:{
                    //         blue:'蓝色',
                    //         black:'黑色',
                    //     },
                    //     onclick:function(color){
                    //         game.saveConfig('background_color_music',color);
                    //         document.body.dataset.background_color_music=color;
                    //     }
                    // },
                    // background_color_wood:{
                    //     name:'背景色',
                    //     init:'blue',
                    //     item:{
                    //         blue:'蓝色',
                    //         black:'黑色',
                    //     },
                    //     onclick:function(color){
                    //         game.saveConfig('background_color_wood',color);
                    //         document.body.dataset.background_color_wood=color;
                    //     }
                    // },
                    // theme_color_music:{
                    //     name:'主题色',
                    //     init:'black',
                    //     item:{
                    //         blue:'蓝色',
                    //         black:'黑色',
                    //     },
                    //     onclick:function(color){
                    //         game.saveConfig('theme_color_music',color);
                    //         document.body.dataset.theme_color_music=color;
                    //     }
                    // },
                    ui_zoom: {
                        name: '界面缩放',
                        unfrequent: true,
                        init: 'normal',
                        item: {
                            esmall: '80%',
                            vsmall: '90%',
                            small: '95%',
                            normal: '100%',
                            big: '105%',
                            vbig: '110%',
                            ebig: '120%'
                        },
                        onclick: function (zoom) {
                            game.saveConfig('ui_zoom', zoom);
                            switch (zoom) {
                                case 'esmall':
                                    zoom = 0.8;
                                    break;
                                case 'vsmall':
                                    zoom = 0.9;
                                    break;
                                case 'small':
                                    zoom = 0.93;
                                    break;
                                case 'big':
                                    zoom = 1.05;
                                    break;
                                case 'vbig':
                                    zoom = 1.1;
                                    break;
                                case 'ebig':
                                    zoom = 1.2;
                                    break;
                                default: zoom = 1;
                            }
                            game.documentZoom = game.deviceZoom * zoom;
                            ui.updatez();
                        }
                    },
                    image_background: {
                        name: '游戏背景',
                        init: 'default',
                        item: {},
                        visualBar: function (node, item, create) {
                            if (node.created) {
                                node.lastChild.classList.remove('active');
                                return;
                            }
                            node.created = true;
                            ui.create.filediv('.menubutton', '添加背景', node, function (file) {
                                if (file) {
                                    var name = file.name;
                                    if (name.indexOf('.') != -1) {
                                        name = name.slice(0, name.indexOf('.'));
                                    }
                                    var link = (game.writeFile ? 'cdv_' : 'custom_') + name;
                                    if (item[link]) {
                                        for (var i = 1; i < 1000; i++) {
                                            if (!item[link + '_' + i]) {
                                                link = link + '_' + i;
                                                break;
                                            }
                                        }
                                    }
                                    item[link] = name;
                                    var callback = function () {
                                        create(link, node.parentNode.defaultNode);
                                        node.parentNode.updateBr();
                                        lib.config.customBackgroundPack.add(link);
                                        game.saveConfig('customBackgroundPack', lib.config.customBackgroundPack);
                                    };
                                    if (game.writeFile) {
                                        game.writeFile(file, 'image/background', link + '.jpg', callback);
                                    }
                                    else {
                                        game.putDB('image', link, file, callback);
                                    }
                                    if (node.lastChild.classList.contains('active')) {
                                        editbg.call(node.lastChild);
                                    }
                                }
                            }).inputNode.accept = 'image/*';
                            var editbg = function () {
                                this.classList.toggle('active');
                                var page = this.parentNode.parentNode;
                                for (var i = 0; i < page.childElementCount; i++) {
                                    if (page.childNodes[i].classList.contains('button')) {
                                        var link = page.childNodes[i]._link;
                                        if (link && link != 'default') {
                                            var str;
                                            if (this.classList.contains('active')) {
                                                if (link.indexOf('custom_') == 0 || link.indexOf('cdv_') == 0) {
                                                    str = '删除';
                                                }
                                                else {
                                                    str = '隐藏';
                                                }
                                            }
                                            else {
                                                str = item[link];
                                            }
                                            page.childNodes[i].firstChild.innerHTML = get.verticalStr(str);
                                        }
                                    }
                                }
                            };
                            ui.create.div('.menubutton', '编辑背景', node, editbg);
                        },
                        visualMenu: function (node, link, name, config) {
                            node.className = 'button character';
                            node.style.backgroundImage = '';
                            node.style.backgroundSize = '';
                            if (node.firstChild) {
                                node.firstChild.innerHTML = get.verticalStr(name);
                            }
                            if (link == 'default' || link.indexOf('custom_') == 0) {
                                node.style.backgroundImage = 'none';
                                node.classList.add('dashedmenubutton');
                                if (link.indexOf('custom_') == 0) {
                                    game.getDB('image', link, function (fileToLoad) {
                                        if (!fileToLoad)
                                            return;
                                        var fileReader = new FileReader();
                                        fileReader.onload = function (fileLoadedEvent) {
                                            var data = fileLoadedEvent.target.result;
                                            node.style.backgroundImage = 'url(' + data + ')';
                                            node.style.backgroundSize = 'cover';
                                            node.classList.remove('dashedmenubutton');
                                        };
                                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                    });
                                }
                                else {
                                    node.parentNode.defaultNode = node;
                                }
                            }
                            else {
                                if (link.indexOf('svg_') == 0) {
                                    node.setBackgroundImage('image/background/' + link.slice(4) + '.svg');
                                }
                                else {
                                    node.setBackgroundImage('image/background/' + link + '.jpg');
                                }
                                node.style.backgroundSize = 'cover';
                            }
                        },
                        onclick: function (background, node) {
                            if (node && node.firstChild) {
                                var menu = node.parentNode;
                                if (node.firstChild.innerHTML == get.verticalStr('隐藏')) {
                                    menu.parentNode.noclose = true;
                                    node.remove();
                                    menu.updateBr();
                                    if (!lib.config.prompt_hidebg) {
                                        alert('隐藏的背景可通过选项-其它-重置隐藏内容恢复');
                                        game.saveConfig('prompt_hidebg', true);
                                    }
                                    lib.config.hiddenBackgroundPack.add(background);
                                    game.saveConfig('hiddenBackgroundPack', lib.config.hiddenBackgroundPack);
                                    delete lib.configMenu.appearence.config.image_background.item[background];
                                    if (lib.config.image_background == background) {
                                        background = 'default';
                                        this.lastChild.innerHTML = '默认';
                                    }
                                    else {
                                        this.lastChild.innerHTML = lib.configMenu.appearence.config.image_background.item[lib.config.image_background];
                                        return;
                                    }
                                }
                                else if (node.firstChild.innerHTML == get.verticalStr('删除')) {
                                    menu.parentNode.noclose = true;
                                    if (confirm('是否删除此背景？（此操作不可撤销）')) {
                                        node.remove();
                                        menu.updateBr();
                                        lib.config.customBackgroundPack.remove(background);
                                        game.saveConfig('customBackgroundPack', lib.config.customBackgroundPack);
                                        if (background.indexOf('cdv_') == 0) {
                                            game.removeFile('image/background/' + background + '.jpg');
                                        }
                                        else {
                                            game.deleteDB('image', background);
                                        }
                                        delete lib.configMenu.appearence.config.image_background.item[background];
                                        if (lib.config.image_background == background) {
                                            background = 'default';
                                            this.lastChild.innerHTML = '默认';
                                        }
                                        else {
                                            this.lastChild.innerHTML = lib.configMenu.appearence.config.image_background.item[lib.config.image_background];
                                            return;
                                        }
                                    }
                                }
                            }
                            var animate = lib.config.image_background == 'default';
                            game.saveConfig('image_background', background);
                            lib.init.background();
                            ui.background["delete"]();
                            ui.background = ui.create.div('.background');
                            if (lib.config.image_background_blur) {
                                ui.background.style.filter = 'blur(8px)';
                                ui.background.style.webkitFilter = 'blur(8px)';
                                ui.background.style.transform = 'scale(1.05)';
                            }
                            else {
                                ui.background.style.filter = '';
                                ui.background.style.webkitFilter = '';
                                ui.background.style.transform = '';
                            }
                            document.body.insertBefore(ui.background, document.body.firstChild);
                            if (animate)
                                ui.background.animate('start');
                            if (lib.config.image_background == 'default') {
                                ui.background.style.backgroundImage = "none";
                            }
                            else if (lib.config.image_background.indexOf('custom_') == 0) {
                                ui.background.style.backgroundImage = "none";
                                game.getDB('image', lib.config.image_background, function (fileToLoad) {
                                    if (!fileToLoad)
                                        return;
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                        var data = fileLoadedEvent.target.result;
                                        ui.background.style.backgroundImage = 'url(' + data + ')';
                                    };
                                    fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                });
                            }
                            else {
                                if (lib.config.image_background.indexOf('svg_') == 0) {
                                    ui.background.setBackgroundImage('image/background/' + lib.config.image_background.slice(4) + '.svg');
                                }
                                else {
                                    ui.background.setBackgroundImage('image/background/' + lib.config.image_background + '.jpg');
                                    ui.backgroundSVG = ui.create.div('.background', ui.background);
                                    ui.backgroundSVG.setBackgroundImage('image/background/' + 'simple1_bg' + '.svg');
                                    ui.backgroundSVG.style.opacity = '.3';
                                }
                            }
                            ui.background.style.backgroundSize = 'cover';
                            ui.background.style.backgroundPosition = '50% 50%';
                        }
                    },
                    image_background_random: {
                        name: '随机背景',
                        init: false,
                        onclick: function (bool) {
                            game.saveConfig('image_background_random', bool);
                            lib.init.background();
                        }
                    },
                    image_background_blur: {
                        name: '背景模糊',
                        init: false,
                        onclick: function (bool) {
                            game.saveConfig('image_background_blur', bool);
                            if (lib.config.image_background_blur) {
                                ui.background.style.filter = 'blur(8px)';
                                ui.background.style.webkitFilter = 'blur(8px)';
                                ui.background.style.transform = 'scale(1.05)';
                            }
                            else {
                                ui.background.style.filter = '';
                                ui.background.style.webkitFilter = '';
                                ui.background.style.transform = '';
                            }
                        }
                    },
                    phonelayout: {
                        name: '触屏布局',
                        init: false,
                        onclick: function (bool) {
                            if (get.is.nomenu('phonelayout', bool))
                                return false;
                            game.saveConfig('phonelayout', bool);
                            if (get.is.phoneLayout()) {
                                ui.css.phone.href = lib.assetURL + 'layout/default/phone.css';
                                ui.arena.classList.add('phone');
                            }
                            else {
                                ui.css.phone.href = '';
                                ui.arena.classList.remove('phone');
                            }
                        }
                    },
                    change_skin: {
                        name: '开启换肤',
                        init: true,
                        intro: '在武将的右键菜单中换肤，皮肤可在选项-文件-图片文件-皮肤图片中添加'
                    },
                    change_skin_auto: {
                        name: '自动换肤',
                        init: 'off',
                        item: {
                            'off': '关闭',
                            '30000': '半分钟',
                            '60000': '一分钟',
                            '120000': '两分钟',
                            '300000': '五分钟'
                        },
                        intro: '游戏每进行一段时间自动为一个随机角色更换皮肤',
                        onclick: function (item) {
                            game.saveConfig('change_skin_auto', item);
                            clearTimeout(_status.skintimeout);
                            if (item != 'off') {
                                _status.skintimeout = setTimeout(ui.click.autoskin, parseInt(item));
                            }
                        }
                    },
                    card_style: {
                        name: '卡牌样式',
                        init: 'default',
                        intro: '设置正面朝上的卡牌的样式',
                        item: {
                            wood: '木纹',
                            music: '音乐',
                            simple: '原版',
                            ol: '手杀',
                            // new:'新版',
                            custom: '自定',
                            "default": '默认'
                        },
                        visualBar: function (node, item, create, switcher) {
                            if (node.created) {
                                return;
                            }
                            var button;
                            for (var i = 0; i < node.parentNode.childElementCount; i++) {
                                if (node.parentNode.childNodes[i]._link == 'custom') {
                                    button = node.parentNode.childNodes[i];
                                }
                            }
                            if (!button) {
                                return;
                            }
                            node.created = true;
                            var deletepic;
                            ui.create.filediv('.menubutton', '添加图片', node, function (file) {
                                if (file) {
                                    game.putDB('image', 'card_style', file, function () {
                                        game.getDB('image', 'card_style', function (fileToLoad) {
                                            if (!fileToLoad)
                                                return;
                                            var fileReader = new FileReader();
                                            fileReader.onload = function (fileLoadedEvent) {
                                                var data = fileLoadedEvent.target.result;
                                                button.style.backgroundImage = 'url(' + data + ')';
                                                button.className = 'button card fullskin';
                                                node.classList.add('showdelete');
                                            };
                                            fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                        });
                                    });
                                }
                            }).inputNode.accept = 'image*';
                            deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
                                if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
                                    game.deleteDB('image', 'card_style');
                                    button.style.backgroundImage = 'none';
                                    button.className = 'button character dashedmenubutton';
                                    node.classList.remove('showdelete');
                                    if (lib.config.card_style == 'custom') {
                                        lib.configMenu.appearence.config.card_style.onclick('default');
                                        switcher.lastChild.innerHTML = '默认';
                                    }
                                    button.classList.add('transparent');
                                }
                            });
                        },
                        visualMenu: function (node, link, name, config) {
                            node.className = 'button card fullskin';
                            node.style.backgroundSize = '100% 100%';
                            switch (link) {
                                case 'default':
                                case 'custom': {
                                    if (lib.config.theme == 'simple') {
                                        node.style.backgroundImage = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4))';
                                        node.className = 'button character';
                                    }
                                    else {
                                        node.style.backgroundImage = 'none';
                                        node.className = 'button character dashedmenubutton';
                                    }
                                    break;
                                }
                                case 'new':
                                    node.setBackgroundImage('theme/style/card/image/new.png');
                                    break;
                                case 'ol':
                                    node.setBackgroundImage('theme/style/card/image/ol.png');
                                    break;
                                case 'wood':
                                    node.setBackgroundImage('theme/woodden/wood.jpg');
                                    node.style.backgroundSize = 'initial';
                                    break;
                                case 'music':
                                    node.setBackgroundImage('theme/music/wood3.png');
                                    break;
                                case 'simple':
                                    node.setBackgroundImage('theme/simple/card.png');
                                    break;
                            }
                            if (link == 'custom') {
                                node.classList.add('transparent');
                                game.getDB('image', 'card_style', function (fileToLoad) {
                                    if (!fileToLoad)
                                        return;
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                        var data = fileLoadedEvent.target.result;
                                        node.style.backgroundImage = 'url(' + data + ')';
                                        node.className = 'button card fullskin';
                                        node.parentNode.lastChild.classList.add('showdelete');
                                    };
                                    fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                });
                            }
                        },
                        onclick: function (layout) {
                            game.saveConfig('card_style', layout);
                            var style = ui.css.card_style;
                            ui.css.card_style = lib.init.css(lib.assetURL + 'theme/style/card', lib.config.card_style);
                            style.remove();
                            if (ui.css.card_stylesheet) {
                                ui.css.card_stylesheet.remove();
                                delete ui.css.card_stylesheet;
                            }
                            if (layout == 'custom') {
                                game.getDB('image', 'card_style', function (fileToLoad) {
                                    if (!fileToLoad)
                                        return;
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                        if (ui.css.card_stylesheet) {
                                            ui.css.card_stylesheet.remove();
                                        }
                                        ui.css.card_stylesheet = lib.init.sheet('.card:not(*:empty){background-image:url(' + fileLoadedEvent.target.result + ')}');
                                    };
                                    fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                });
                            }
                        },
                        unfrequent: true
                    },
                    cardback_style: {
                        name: '卡背样式',
                        intro: '设置背面朝上的卡牌的样式',
                        init: 'default',
                        item: {
                            // wood:'木纹',
                            // music:'音乐',
                            vk: 'V杀',
                            official: '原版',
                            // new:'新版',
                            liusha: '流沙',
                            ol: '手杀',
                            custom: '自定',
                            "default": '默认'
                        },
                        visualBar: function (node, item, create, switcher) {
                            if (node.created) {
                                return;
                            }
                            var button;
                            for (var i = 0; i < node.parentNode.childElementCount; i++) {
                                if (node.parentNode.childNodes[i]._link == 'custom') {
                                    button = node.parentNode.childNodes[i];
                                }
                            }
                            if (!button) {
                                return;
                            }
                            node.created = true;
                            var deletepic;
                            ui.create.filediv('.menubutton', '添加图片', node, function (file) {
                                if (file) {
                                    game.putDB('image', 'cardback_style', file, function () {
                                        game.getDB('image', 'cardback_style', function (fileToLoad) {
                                            if (!fileToLoad)
                                                return;
                                            var fileReader = new FileReader();
                                            fileReader.onload = function (fileLoadedEvent) {
                                                var data = fileLoadedEvent.target.result;
                                                button.style.backgroundImage = 'url(' + data + ')';
                                                button.className = 'button character';
                                                node.classList.add('showdelete');
                                            };
                                            fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                        });
                                    });
                                }
                            }).inputNode.accept = 'image/*';
                            ui.create.filediv('.menubutton.deletebutton.addbutton', '添加翻转图片', node, function (file) {
                                if (file) {
                                    game.putDB('image', 'cardback_style2', file, function () {
                                        node.classList.add('hideadd');
                                    });
                                }
                            }).inputNode.accept = 'image/*';
                            deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
                                if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
                                    game.deleteDB('image', 'cardback_style');
                                    game.deleteDB('image', 'cardback_style2');
                                    button.style.backgroundImage = 'none';
                                    button.className = 'button character dashedmenubutton';
                                    node.classList.remove('showdelete');
                                    node.classList.remove('hideadd');
                                    if (lib.config.cardback_style == 'custom') {
                                        lib.configMenu.appearence.config.cardback_style.onclick('default');
                                        switcher.lastChild.innerHTML = '默认';
                                    }
                                    button.classList.add('transparent');
                                }
                            });
                        },
                        visualMenu: function (node, link, name, config) {
                            node.style.backgroundSize = '100% 100%';
                            switch (link) {
                                case 'default':
                                case 'custom': {
                                    node.style.backgroundImage = 'none';
                                    node.className = 'button character dashedmenubutton';
                                    break;
                                }
                                case 'vk':
                                    node.className = 'button character';
                                    node.setBackgroundImage('theme/style/cardback/image/vk.png');
                                    break;
                                case 'new':
                                    node.className = 'button character';
                                    node.setBackgroundImage('theme/style/cardback/image/new.png');
                                    break;
                                case 'official':
                                    node.className = 'button character';
                                    node.setBackgroundImage('theme/style/cardback/image/official.png');
                                    break;
                                case 'liusha':
                                    node.className = 'button character';
                                    node.setBackgroundImage('theme/style/cardback/image/liusha.png');
                                    break;
                                case 'ol':
                                    node.className = 'button character';
                                    node.setBackgroundImage('theme/style/cardback/image/ol.png');
                                    break;
                                case 'wood':
                                    node.className = 'button card fullskin';
                                    node.setBackgroundImage('theme/woodden/wood.jpg');
                                    node.style.backgroundSize = 'initial';
                                    break;
                                case 'music':
                                    node.className = 'button card fullskin';
                                    node.setBackgroundImage('theme/music/wood3.png');
                                    break;
                            }
                            if (link == 'custom') {
                                node.classList.add('transparent');
                                game.getDB('image', 'cardback_style', function (fileToLoad) {
                                    if (!fileToLoad)
                                        return;
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                        var data = fileLoadedEvent.target.result;
                                        node.style.backgroundImage = 'url(' + data + ')';
                                        node.className = 'button character';
                                        node.parentNode.lastChild.classList.add('showdelete');
                                        game.getDB('image', 'cardback_style2', function (file) {
                                            if (file) {
                                                node.parentNode.lastChild.classList.add('hideadd');
                                            }
                                        });
                                    };
                                    fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                });
                            }
                        },
                        onclick: function (layout) {
                            game.saveConfig('cardback_style', layout);
                            var style = ui.css.cardback_style;
                            ui.css.cardback_style = lib.init.css(lib.assetURL + 'theme/style/cardback', lib.config.cardback_style);
                            style.remove();
                            if (ui.css.cardback_stylesheet) {
                                ui.css.cardback_stylesheet.remove();
                                delete ui.css.cardback_stylesheet;
                            }
                            if (ui.css.cardback_stylesheet2) {
                                ui.css.cardback_stylesheet2.remove();
                                delete ui.css.cardback_stylesheet2;
                            }
                            if (layout == 'custom') {
                                game.getDB('image', 'cardback_style', function (fileToLoad) {
                                    if (!fileToLoad)
                                        return;
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                        if (ui.css.cardback_stylesheet) {
                                            ui.css.cardback_stylesheet.remove();
                                        }
                                        ui.css.cardback_stylesheet = lib.init.sheet('.card:empty,.card.infohidden{background-image:url(' + fileLoadedEvent.target.result + ')}');
                                        game.getDB('image', 'cardback_style2', function (fileToLoad) {
                                            if (!fileToLoad)
                                                return;
                                            var fileReader = new FileReader();
                                            fileReader.onload = function (fileLoadedEvent) {
                                                if (ui.css.cardback_stylesheet2) {
                                                    ui.css.cardback_stylesheet2.remove();
                                                }
                                                ui.css.cardback_stylesheet2 = lib.init.sheet('.card.infohidden:not(.infoflip){background-image:url(' + fileLoadedEvent.target.result + ')}');
                                            };
                                            fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                        });
                                    };
                                    fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                });
                            }
                        },
                        unfrequent: true
                    },
                    hp_style: {
                        name: '体力条样式',
                        init: 'ol',
                        item: {
                            "default": '默认',
                            // official:'勾玉',
                            emotion: '表情',
                            glass: '勾玉',
                            round: '国战',
                            ol: '手杀',
                            xinglass: '双鱼',
                            xinround: 'OL',
                            custom: '自定'
                        },
                        visualBar: function (node, item, create, switcher) {
                            if (node.created) {
                                return;
                            }
                            var button;
                            for (var i = 0; i < node.parentNode.childElementCount; i++) {
                                if (node.parentNode.childNodes[i]._link == 'custom') {
                                    button = node.parentNode.childNodes[i];
                                }
                            }
                            if (!button) {
                                return;
                            }
                            node.created = true;
                            var deletepic;
                            ui.create.filediv('.menubutton.addbutton', '添加图片', node, function (file) {
                                if (file && node.currentDB) {
                                    game.putDB('image', 'hp_style' + node.currentDB, file, function () {
                                        game.getDB('image', 'hp_style' + node.currentDB, function (fileToLoad) {
                                            if (!fileToLoad)
                                                return;
                                            var fileReader = new FileReader();
                                            fileReader.onload = function (fileLoadedEvent) {
                                                var data = fileLoadedEvent.target.result;
                                                button.childNodes[node.currentDB - 1].style.backgroundImage = 'url(' + data + ')';
                                                button.classList.add('shown');
                                                node.classList.add('showdelete');
                                                node.currentDB++;
                                                if (node.currentDB > 4) {
                                                    node.classList.add('hideadd');
                                                    button.classList.remove('transparent');
                                                    delete node.currentDB;
                                                }
                                            };
                                            fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                        });
                                    });
                                }
                            }).inputNode.accept = 'image/*';
                            deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
                                if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
                                    game.deleteDB('image', 'hp_style1');
                                    game.deleteDB('image', 'hp_style2');
                                    game.deleteDB('image', 'hp_style3');
                                    game.deleteDB('image', 'hp_style4');
                                    for (var i = 0; i < button.childElementCount; i++) {
                                        button.childNodes[i].style.backgroundImage = 'none';
                                    }
                                    node.classList.remove('showdelete');
                                    node.classList.remove('hideadd');
                                    if (lib.config.hp_style == 'custom') {
                                        lib.configMenu.appearence.config.hp_style.onclick('default');
                                        switcher.lastChild.innerHTML = '默认';
                                    }
                                    button.classList.add('transparent');
                                    button.classList.remove('shown');
                                    node.currentDB = 1;
                                }
                            });
                        },
                        visualMenu: function (node, link, name, config) {
                            node.className = 'button hpbutton dashedmenubutton';
                            node.innerHTML = '';
                            for (var i = 1; i <= 4; i++) {
                                var div = ui.create.div(node);
                                if (link == 'default') {
                                    ui.create.div(div);
                                }
                                else if (link != 'custom') {
                                    div.setBackgroundImage('theme/style/hp/image/' + link + i + '.png');
                                }
                                if (i == 4) {
                                    div.style.webkitFilter = 'grayscale(1)';
                                }
                            }
                            if (link == 'custom') {
                                node.classList.add('transparent');
                                var getDB = function (num) {
                                    node.parentNode.lastChild.currentDB = num;
                                    game.getDB('image', 'hp_style' + num, function (fileToLoad) {
                                        if (!fileToLoad)
                                            return;
                                        var fileReader = new FileReader();
                                        fileReader.onload = function (fileLoadedEvent) {
                                            var data = fileLoadedEvent.target.result;
                                            node.childNodes[num - 1].style.backgroundImage = 'url(' + data + ')';
                                            node.classList.add('shown');
                                            node.parentNode.lastChild.classList.add('showdelete');
                                            if (num < 4) {
                                                getDB(num + 1);
                                            }
                                            else {
                                                node.parentNode.lastChild.classList.add('hideadd');
                                                node.classList.remove('transparent');
                                                delete node.parentNode.firstChild.currentDB;
                                            }
                                        };
                                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                    });
                                };
                                getDB(1);
                            }
                        },
                        onclick: function (layout) {
                            game.saveConfig('hp_style', layout);
                            var style = ui.css.hp_style;
                            ui.css.hp_style = lib.init.css(lib.assetURL + 'theme/style/hp', lib.config.hp_style);
                            style.remove();
                            if (ui.css.hp_stylesheet1) {
                                ui.css.hp_stylesheet1.remove();
                                delete ui.css.hp_stylesheet1;
                            }
                            if (ui.css.hp_stylesheet2) {
                                ui.css.hp_stylesheet2.remove();
                                delete ui.css.hp_stylesheet2;
                            }
                            if (ui.css.hp_stylesheet3) {
                                ui.css.hp_stylesheet3.remove();
                                delete ui.css.hp_stylesheet3;
                            }
                            if (ui.css.hp_stylesheet4) {
                                ui.css.hp_stylesheet4.remove();
                                delete ui.css.hp_stylesheet4;
                            }
                            if (layout == 'custom') {
                                game.getDB('image', 'hp_style1', function (fileToLoad) {
                                    if (!fileToLoad)
                                        return;
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                        if (ui.css.hp_stylesheet1) {
                                            ui.css.hp_stylesheet1.remove();
                                        }
                                        ui.css.hp_stylesheet1 = lib.init.sheet('.hp:not(.text):not(.actcount)[data-condition="high"]>div:not(.lost){background-image:url(' + fileLoadedEvent.target.result + ')}');
                                    };
                                    fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                });
                                game.getDB('image', 'hp_style2', function (fileToLoad) {
                                    if (!fileToLoad)
                                        return;
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                        if (ui.css.hp_stylesheet2) {
                                            ui.css.hp_stylesheet2.remove();
                                        }
                                        ui.css.hp_stylesheet2 = lib.init.sheet('.hp:not(.text):not(.actcount)[data-condition="mid"]>div:not(.lost){background-image:url(' + fileLoadedEvent.target.result + ')}');
                                    };
                                    fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                });
                                game.getDB('image', 'hp_style3', function (fileToLoad) {
                                    if (!fileToLoad)
                                        return;
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                        if (ui.css.hp_stylesheet3) {
                                            ui.css.hp_stylesheet3.remove();
                                        }
                                        ui.css.hp_stylesheet3 = lib.init.sheet('.hp:not(.text):not(.actcount)[data-condition="low"]>div:not(.lost){background-image:url(' + fileLoadedEvent.target.result + ')}');
                                    };
                                    fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                });
                                game.getDB('image', 'hp_style4', function (fileToLoad) {
                                    if (!fileToLoad)
                                        return;
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                        if (ui.css.hp_stylesheet4) {
                                            ui.css.hp_stylesheet4.remove();
                                        }
                                        ui.css.hp_stylesheet4 = lib.init.sheet('.hp:not(.text):not(.actcount)>.lost{background-image:url(' + fileLoadedEvent.target.result + ')}');
                                    };
                                    fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                });
                            }
                        },
                        unfrequent: true
                    },
                    player_style: {
                        name: '角色背景',
                        init: 'simple',
                        intro: '设置角色的背景图片',
                        item: {
                            wood: '木纹',
                            music: '音乐',
                            simple: '简约',
                            custom: '自定',
                            "default": '默认'
                        },
                        visualBar: function (node, item, create, switcher) {
                            if (node.created) {
                                return;
                            }
                            var button;
                            for (var i = 0; i < node.parentNode.childElementCount; i++) {
                                if (node.parentNode.childNodes[i]._link == 'custom') {
                                    button = node.parentNode.childNodes[i];
                                }
                            }
                            if (!button) {
                                return;
                            }
                            node.created = true;
                            var deletepic;
                            ui.create.filediv('.menubutton', '添加图片', node, function (file) {
                                if (file) {
                                    game.putDB('image', 'player_style', file, function () {
                                        game.getDB('image', 'player_style', function (fileToLoad) {
                                            if (!fileToLoad)
                                                return;
                                            var fileReader = new FileReader();
                                            fileReader.onload = function (fileLoadedEvent) {
                                                var data = fileLoadedEvent.target.result;
                                                button.style.backgroundImage = 'url(' + data + ')';
                                                button.className = 'button character';
                                                button.style.backgroundSize = '100% 100%';
                                                node.classList.add('showdelete');
                                            };
                                            fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                        });
                                    });
                                }
                            }).inputNode.accept = 'image/*';
                            deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
                                if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
                                    game.deleteDB('image', 'player_style');
                                    button.style.backgroundImage = 'none';
                                    button.className = 'button character dashedmenubutton';
                                    node.classList.remove('showdelete');
                                    if (lib.config.player_style == 'custom') {
                                        lib.configMenu.appearence.config.player_style.onclick('default');
                                        switcher.lastChild.innerHTML = '默认';
                                    }
                                    button.classList.add('transparent');
                                }
                            });
                        },
                        visualMenu: function (node, link, name, config) {
                            node.className = 'button character';
                            node.style.backgroundSize = '';
                            node.style.height = '108px';
                            switch (link) {
                                case 'default':
                                case 'custom': {
                                    node.style.backgroundImage = 'none';
                                    node.className = 'button character dashedmenubutton';
                                    break;
                                }
                                case 'wood':
                                    node.setBackgroundImage('theme/woodden/wood.jpg');
                                    break;
                                case 'music':
                                    node.style.backgroundImage = 'linear-gradient(#4b4b4b, #464646)';
                                    break;
                                case 'simple':
                                    node.style.backgroundImage = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4))';
                                    break;
                            }
                            if (link == 'custom') {
                                node.classList.add('transparent');
                                game.getDB('image', 'player_style', function (fileToLoad) {
                                    if (!fileToLoad)
                                        return;
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                        var data = fileLoadedEvent.target.result;
                                        node.style.backgroundImage = 'url(' + data + ')';
                                        node.className = 'button character';
                                        node.parentNode.lastChild.classList.add('showdelete');
                                        node.style.backgroundSize = '100% 100%';
                                    };
                                    fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                });
                            }
                        },
                        onclick: function (layout) {
                            game.saveConfig('player_style', layout);
                            if (ui.css.player_stylesheet) {
                                ui.css.player_stylesheet.remove();
                                delete ui.css.player_stylesheet;
                            }
                            if (layout == 'custom') {
                                game.getDB('image', 'player_style', function (fileToLoad) {
                                    if (!fileToLoad)
                                        return;
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                        if (ui.css.player_stylesheet) {
                                            ui.css.player_stylesheet.remove();
                                        }
                                        ui.css.player_stylesheet = lib.init.sheet('#window .player{background-image:url("' + fileLoadedEvent.target.result + '");background-size:100% 100%;}');
                                    };
                                    fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                });
                            }
                            else if (layout != 'default') {
                                var str = '';
                                switch (layout) {
                                    case 'wood':
                                        str = 'url("' + lib.assetURL + 'theme/woodden/wood.jpg")';
                                        break;
                                    case 'music':
                                        str = 'linear-gradient(#4b4b4b, #464646)';
                                        break;
                                    case 'simple':
                                        str = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4))';
                                        break;
                                }
                                ui.css.player_stylesheet = lib.init.sheet('#window .player{background-image:' + str + '}');
                            }
                        },
                        unfrequent: true
                    },
                    border_style: {
                        name: '角色边框',
                        init: 'default',
                        intro: '设置角色边框的样式，当设为自动时，样式将随着一局游戏中伤害或击杀的数量自动改变',
                        item: {
                            gold: '金框',
                            silver: '银框',
                            bronze: '铜框',
                            dragon_gold: '金龙',
                            dragon_silver: '银龙',
                            dragon_bronze: '玉龙',
                            custom: '自定',
                            auto: '自动',
                            "default": '默认'
                        },
                        visualBar: function (node, item, create, switcher) {
                            if (node.created) {
                                return;
                            }
                            var button;
                            for (var i = 0; i < node.parentNode.childElementCount; i++) {
                                if (node.parentNode.childNodes[i]._link == 'custom') {
                                    button = node.parentNode.childNodes[i];
                                }
                            }
                            if (!button) {
                                return;
                            }
                            node.created = true;
                            var deletepic;
                            ui.create.filediv('.menubutton', '添加图片', node, function (file) {
                                if (file) {
                                    game.putDB('image', 'border_style', file, function () {
                                        game.getDB('image', 'border_style', function (fileToLoad) {
                                            if (!fileToLoad)
                                                return;
                                            var fileReader = new FileReader();
                                            fileReader.onload = function (fileLoadedEvent) {
                                                var data = fileLoadedEvent.target.result;
                                                button.style.backgroundImage = 'url(' + data + ')';
                                                button.className = 'button character';
                                                button.style.backgroundSize = '100% 100%';
                                                node.classList.add('showdelete');
                                            };
                                            fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                        });
                                    });
                                }
                            }).inputNode.accept = 'image/*';
                            deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
                                if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
                                    game.deleteDB('image', 'border_style');
                                    button.style.backgroundImage = 'none';
                                    button.className = 'button character dashedmenubutton';
                                    node.classList.remove('showdelete');
                                    if (lib.config.border_style == 'custom') {
                                        lib.configMenu.appearence.config.border_style.onclick('default');
                                        switcher.lastChild.innerHTML = '默认';
                                    }
                                    button.classList.add('transparent');
                                }
                            });
                        },
                        visualMenu: function (node, link, name, config) {
                            node.className = 'button character';
                            node.style.backgroundSize = '';
                            node.style.height = '108px';
                            node.dataset.decoration = '';
                            if (link == 'default' || link == 'custom' || link == 'auto') {
                                node.style.backgroundImage = 'none';
                                node.className = 'button character dashedmenubutton';
                            }
                            else {
                                if (link.indexOf('dragon_') == 0) {
                                    link = link.slice(7);
                                    node.dataset.decoration = link;
                                }
                                node.setBackgroundImage('theme/style/player/' + link + '1.png');
                                node.style.backgroundSize = '100% 100%';
                            }
                            if (link == 'custom') {
                                node.classList.add('transparent');
                                game.getDB('image', 'border_style', function (fileToLoad) {
                                    if (!fileToLoad)
                                        return;
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                        var data = fileLoadedEvent.target.result;
                                        node.style.backgroundImage = 'url(' + data + ')';
                                        node.className = 'button character';
                                        node.parentNode.lastChild.classList.add('showdelete');
                                        node.style.backgroundSize = '100% 100%';
                                    };
                                    fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                });
                            }
                        },
                        onclick: function (layout) {
                            game.saveConfig('border_style', layout);
                            if (ui.css.border_stylesheet) {
                                ui.css.border_stylesheet.remove();
                                delete ui.css.border_stylesheet;
                            }
                            if (layout == 'custom') {
                                game.getDB('image', 'border_style', function (fileToLoad) {
                                    if (!fileToLoad)
                                        return;
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                        if (ui.css.border_stylesheet) {
                                            ui.css.border_stylesheet.remove();
                                        }
                                        ui.css.border_stylesheet = lib.init.sheet();
                                        ui.css.border_stylesheet.sheet.insertRule('#window .player>.framebg{display:block;background-image:url("' + fileLoadedEvent.target.result + '")}', 0);
                                        ui.css.border_stylesheet.sheet.insertRule('.player>.count{z-index: 3 !important;border-radius: 2px !important;text-align: center !important;}', 0);
                                    };
                                    fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                });
                            }
                            else if (layout != 'default' && layout != 'auto') {
                                ui.css.border_stylesheet = lib.init.sheet();
                                if (layout.indexOf('dragon_') == 0) {
                                    layout = layout.slice(7);
                                    ui.arena.dataset.framedecoration = layout;
                                }
                                else {
                                    ui.arena.dataset.framedecoration = '';
                                }
                                ui.css.border_stylesheet.sheet.insertRule('#window .player>.framebg,#window #arena.long.mobile:not(.fewplayer) .player[data-position="0"]>.framebg{display:block;background-image:url("' + lib.assetURL + 'theme/style/player/' + layout + '1.png")}', 0);
                                ui.css.border_stylesheet.sheet.insertRule('#window #arena.long:not(.fewplayer) .player>.framebg, #arena.oldlayout .player>.framebg{background-image:url("' + lib.assetURL + 'theme/style/player/' + layout + '3.png")}', 0);
                                ui.css.border_stylesheet.sheet.insertRule('.player>.count{z-index: 3 !important;border-radius: 2px !important;text-align: center !important;}', 0);
                            }
                        },
                        unfrequent: true
                    },
                    autoborder_count: {
                        name: '边框升级方式',
                        intro: '<strong>击杀</strong> 每击杀一人，边框提升两级<br><strong>伤害</strong> 每造成两点伤害，边框提升一级<br><strong>混合</strong> 击杀量决定边框颜色，伤害量决定边框装饰',
                        init: 'kill',
                        item: {
                            kill: '击杀',
                            damage: '伤害',
                            mix: '混合'
                        },
                        unfrequent: true
                    },
                    autoborder_start: {
                        name: '基础边框颜色',
                        init: 'bronze',
                        item: {
                            bronze: '铜',
                            silver: '银',
                            gold: '金'
                        },
                        unfrequent: true
                    },
                    player_border: {
                        name: '边框宽度',
                        init: 'normal',
                        intro: '设置角色的边框宽度',
                        unfrequent: true,
                        item: {
                            slim: '细',
                            narrow: '窄',
                            normal: '中',
                            wide: '宽'
                        },
                        onclick: function (item) {
                            game.saveConfig('player_border', item);
                            if (item != 'wide' || game.layout == 'long' || game.layout == 'long2') {
                                ui.arena.classList.add('slim_player');
                            }
                            else {
                                ui.arena.classList.remove('slim_player');
                            }
                            if (item == 'slim') {
                                ui.arena.classList.add('uslim_player');
                            }
                            else {
                                ui.arena.classList.remove('uslim_player');
                            }
                            if (item == 'narrow') {
                                ui.arena.classList.add('mslim_player');
                            }
                            else {
                                ui.arena.classList.remove('mslim_player');
                            }
                            if (item == 'normal' && lib.config.mode != 'brawl' && (game.layout == 'long' || game.layout == 'long2')) {
                                ui.arena.classList.add('lslim_player');
                            }
                            else {
                                ui.arena.classList.remove('lslim_player');
                            }
                            ui.window.dataset.player_border = item;
                        }
                    },
                    menu_style: {
                        name: '菜单背景',
                        init: 'default',
                        item: {
                            wood: '木纹',
                            music: '音乐',
                            simple: '简约',
                            custom: '自定',
                            "default": '默认'
                        },
                        visualBar: function (node, item, create, switcher) {
                            if (node.created) {
                                return;
                            }
                            var button;
                            for (var i = 0; i < node.parentNode.childElementCount; i++) {
                                if (node.parentNode.childNodes[i]._link == 'custom') {
                                    button = node.parentNode.childNodes[i];
                                }
                            }
                            if (!button) {
                                return;
                            }
                            node.created = true;
                            var deletepic;
                            ui.create.filediv('.menubutton', '添加图片', node, function (file) {
                                if (file) {
                                    game.putDB('image', 'menu_style', file, function () {
                                        game.getDB('image', 'menu_style', function (fileToLoad) {
                                            if (!fileToLoad)
                                                return;
                                            var fileReader = new FileReader();
                                            fileReader.onload = function (fileLoadedEvent) {
                                                var data = fileLoadedEvent.target.result;
                                                button.style.backgroundImage = 'url(' + data + ')';
                                                button.style.backgroundSize = 'cover';
                                                button.className = 'button character';
                                                node.classList.add('showdelete');
                                            };
                                            fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                        });
                                    });
                                }
                            }).inputNode.accept = 'image/*';
                            deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
                                if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
                                    game.deleteDB('image', 'menu_style');
                                    button.style.backgroundImage = 'none';
                                    button.style.backgroundSize = 'auto';
                                    button.className = 'button character dashedmenubutton';
                                    node.classList.remove('showdelete');
                                    if (lib.config.menu_style == 'custom') {
                                        lib.configMenu.appearence.config.menu_style.onclick('default');
                                        switcher.lastChild.innerHTML = '默认';
                                    }
                                    button.classList.add('transparent');
                                }
                            });
                        },
                        visualMenu: function (node, link, name, config) {
                            node.className = 'button character';
                            node.style.backgroundSize = 'auto';
                            switch (link) {
                                case 'default':
                                case 'custom': {
                                    node.style.backgroundImage = 'none';
                                    node.classList.add('dashedmenubutton');
                                    break;
                                }
                                case 'wood':
                                    node.setBackgroundImage('theme/woodden/wood2.png');
                                    break;
                                case 'music':
                                    node.style.backgroundImage = 'linear-gradient(#4b4b4b, #464646)';
                                    break;
                                case 'simple':
                                    node.style.backgroundImage = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4))';
                                    break;
                            }
                            if (link == 'custom') {
                                node.classList.add('transparent');
                                game.getDB('image', 'menu_style', function (fileToLoad) {
                                    if (!fileToLoad)
                                        return;
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                        var data = fileLoadedEvent.target.result;
                                        node.style.backgroundImage = 'url(' + data + ')';
                                        node.style.backgroundSize = 'cover';
                                        node.className = 'button character';
                                        node.parentNode.lastChild.classList.add('showdelete');
                                    };
                                    fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                });
                            }
                        },
                        onclick: function (layout) {
                            game.saveConfig('menu_style', layout);
                            if (ui.css.menu_stylesheet) {
                                ui.css.menu_stylesheet.remove();
                                delete ui.css.menu_stylesheet;
                            }
                            if (layout == 'custom') {
                                game.getDB('image', 'menu_style', function (fileToLoad) {
                                    if (!fileToLoad)
                                        return;
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                        if (ui.css.menu_stylesheet) {
                                            ui.css.menu_stylesheet.remove();
                                        }
                                        ui.css.menu_stylesheet = lib.init.sheet('html #window>.dialog.popped,html .menu,html .menubg{background-image:url("' + fileLoadedEvent.target.result + '");background-size:cover}');
                                    };
                                    fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                });
                            }
                            else if (layout != 'default') {
                                var str = '';
                                switch (layout) {
                                    case 'wood':
                                        str = 'url("' + lib.assetURL + 'theme/woodden/wood2.png")';
                                        break;
                                    case 'music':
                                        str = 'linear-gradient(#4b4b4b, #464646);color:white;text-shadow:black 0 0 2px';
                                        break;
                                    case 'simple':
                                        str = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4));color:white;text-shadow:black 0 0 2px';
                                        break;
                                }
                                ui.css.menu_stylesheet = lib.init.sheet('html #window>.dialog.popped,html .menu,html .menubg{background-image:' + str + '}');
                            }
                        },
                        unfrequent: true
                    },
                    control_style: {
                        name: '按钮背景',
                        init: 'default',
                        item: {
                            wood: '木纹',
                            music: '音乐',
                            simple: '简约',
                            custom: '自定',
                            "default": '默认'
                        },
                        visualBar: function (node, item, create, switcher) {
                            if (node.created) {
                                return;
                            }
                            var button;
                            for (var i = 0; i < node.parentNode.childElementCount; i++) {
                                if (node.parentNode.childNodes[i]._link == 'custom') {
                                    button = node.parentNode.childNodes[i];
                                }
                            }
                            if (!button) {
                                return;
                            }
                            node.created = true;
                            var deletepic;
                            ui.create.filediv('.menubutton', '添加图片', node, function (file) {
                                if (file) {
                                    game.putDB('image', 'control_style', file, function () {
                                        game.getDB('image', 'control_style', function (fileToLoad) {
                                            if (!fileToLoad)
                                                return;
                                            var fileReader = new FileReader();
                                            fileReader.onload = function (fileLoadedEvent) {
                                                var data = fileLoadedEvent.target.result;
                                                button.style.backgroundImage = 'url(' + data + ')';
                                                button.className = 'button character controlbutton';
                                                node.classList.add('showdelete');
                                            };
                                            fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                        });
                                    });
                                }
                            }).inputNode.accept = 'image/*';
                            deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
                                if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
                                    game.deleteDB('image', 'control_style');
                                    button.style.backgroundImage = 'none';
                                    button.className = 'button character controlbutton dashedmenubutton';
                                    node.classList.remove('showdelete');
                                    if (lib.config.control_style == 'custom') {
                                        lib.configMenu.appearence.config.control_style.onclick('default');
                                        switcher.lastChild.innerHTML = '默认';
                                    }
                                    button.classList.add('transparent');
                                }
                            });
                        },
                        visualMenu: function (node, link, name, config) {
                            node.className = 'button character controlbutton';
                            node.style.backgroundSize = '';
                            switch (link) {
                                case 'default':
                                case 'custom': {
                                    node.style.backgroundImage = 'none';
                                    node.classList.add('dashedmenubutton');
                                    break;
                                }
                                case 'wood':
                                    node.setBackgroundImage('theme/woodden/wood.jpg');
                                    break;
                                case 'music':
                                    node.style.backgroundImage = 'linear-gradient(#4b4b4b, #464646)';
                                    break;
                                case 'simple':
                                    node.style.backgroundImage = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4))';
                                    break;
                            }
                            if (link == 'custom') {
                                node.classList.add('transparent');
                                game.getDB('image', 'control_style', function (fileToLoad) {
                                    if (!fileToLoad)
                                        return;
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                        var data = fileLoadedEvent.target.result;
                                        node.style.backgroundImage = 'url(' + data + ')';
                                        node.className = 'button character controlbutton';
                                        node.parentNode.lastChild.classList.add('showdelete');
                                    };
                                    fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                });
                            }
                        },
                        onclick: function (layout) {
                            game.saveConfig('control_style', layout);
                            if (ui.css.control_stylesheet) {
                                ui.css.control_stylesheet.remove();
                                delete ui.css.control_stylesheet;
                            }
                            if (layout == 'custom') {
                                game.getDB('image', 'control_style', function (fileToLoad) {
                                    if (!fileToLoad)
                                        return;
                                    var fileReader = new FileReader();
                                    fileReader.onload = function (fileLoadedEvent) {
                                        if (ui.css.control_stylesheet) {
                                            ui.css.control_stylesheet.remove();
                                        }
                                        ui.css.control_stylesheet = lib.init.sheet('#window .control,.menubutton:not(.active):not(.highlight):not(.red):not(.blue),#window #system>div>div{background-image:url("' + fileLoadedEvent.target.result + '")}');
                                    };
                                    fileReader.readAsDataURL(fileToLoad, "UTF-8");
                                });
                            }
                            else if (layout != 'default') {
                                var str = '';
                                switch (layout) {
                                    case 'wood':
                                        str = 'url("' + lib.assetURL + 'theme/woodden/wood.jpg")';
                                        break;
                                    case 'music':
                                        str = 'linear-gradient(#4b4b4b, #464646);color:white;text-shadow:black 0 0 2px';
                                        break;
                                    case 'simple':
                                        str = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4));color:white;text-shadow:black 0 0 2px';
                                        break;
                                }
                                if (layout == 'wood') {
                                    ui.css.control_stylesheet = lib.init.sheet('#window .control,#window .menubutton,#window #system>div>div,#window #system>div>.pressdown2{background-image:' + str + '}');
                                }
                                else {
                                    ui.css.control_stylesheet = lib.init.sheet('#window .control,.menubutton:not(.active):not(.highlight):not(.red):not(.blue),#window #system>div>div{background-image:' + str + '}');
                                }
                            }
                        },
                        unfrequent: true
                    },
                    custom_button: {
                        name: '自定义按钮高度',
                        init: false,
                        unfrequent: true,
                        onclick: function (bool) {
                            if (bool !== 'skip') {
                                game.saveConfig('custom_button', bool);
                            }
                            if (ui.css.buttonsheet) {
                                ui.css.buttonsheet.remove();
                            }
                            if (lib.config.custom_button) {
                                var cbnum1 = 6 + (parseInt(lib.config.custom_button_system_top) || 0);
                                var cbnum2 = 6 + (parseInt(lib.config.custom_button_system_bottom) || 0);
                                var cbnum3 = 3 + (parseInt(lib.config.custom_button_control_top) || 0);
                                var cbnum4 = 3 + (parseInt(lib.config.custom_button_control_bottom) || 0);
                                var cbnum5 = 2;
                                var cbnum6 = 2;
                                if (cbnum3 < 0) {
                                    cbnum5 += cbnum3;
                                    cbnum3 = 0;
                                }
                                if (cbnum4 < 0) {
                                    cbnum6 += cbnum4;
                                    cbnum4 = 0;
                                }
                                ui.css.buttonsheet = lib.init.sheet('#system>div>div, .caption>div>.tdnode{padding-top:' + cbnum1 + 'px !important;padding-bottom:' + cbnum2 + 'px !important}', '#control>.control>div{padding-top:' + cbnum3 + 'px;padding-bottom:' + cbnum4 + 'px}', '#control>.control{padding-top:' + cbnum5 + 'px;padding-bottom:' + cbnum6 + 'px}');
                            }
                        }
                    },
                    custom_button_system_top: {
                        name: '菜单上部高度',
                        init: '0x',
                        item: {
                            '-5x': '-5px',
                            '-4x': '-4px',
                            '-3x': '-3px',
                            '-2x': '-2px',
                            '-1x': '-1px',
                            '0x': '默认',
                            '1x': '1px',
                            '2x': '2px',
                            '3x': '3px',
                            '4x': '4px',
                            '5x': '5px'
                        },
                        unfrequent: true,
                        onclick: function (item) {
                            game.saveConfig('custom_button_system_top', item);
                            lib.configMenu.appearence.config.custom_button.onclick('skip');
                        }
                    },
                    custom_button_system_bottom: {
                        name: '菜单下部高度',
                        init: '0x',
                        item: {
                            '-5x': '-5px',
                            '-4x': '-4px',
                            '-3x': '-3px',
                            '-2x': '-2px',
                            '-1x': '-1px',
                            '0x': '默认',
                            '1x': '1px',
                            '2x': '2px',
                            '3x': '3px',
                            '4x': '4px',
                            '5x': '5px'
                        },
                        unfrequent: true,
                        onclick: function (item) {
                            game.saveConfig('custom_button_system_bottom', item);
                            lib.configMenu.appearence.config.custom_button.onclick('skip');
                        }
                    },
                    custom_button_control_top: {
                        name: '技能上部高度',
                        init: '0x',
                        item: {
                            '-5x': '-5px',
                            '-4x': '-4px',
                            '-3x': '-3px',
                            '-2x': '-2px',
                            '-1x': '-1px',
                            '0x': '默认',
                            '1x': '1px',
                            '2x': '2px',
                            '3x': '3px',
                            '4x': '4px',
                            '5x': '5px'
                        },
                        unfrequent: true,
                        onclick: function (item) {
                            game.saveConfig('custom_button_control_top', item);
                            lib.configMenu.appearence.config.custom_button.onclick('skip');
                        }
                    },
                    custom_button_control_bottom: {
                        name: '技能下部高度',
                        init: '0x',
                        item: {
                            '-5x': '-5px',
                            '-4x': '-4px',
                            '-3x': '-3px',
                            '-2x': '-2px',
                            '-1x': '-1px',
                            '0x': '默认',
                            '1x': '1px',
                            '2x': '2px',
                            '3x': '3px',
                            '4x': '4px',
                            '5x': '5px'
                        },
                        unfrequent: true,
                        onclick: function (item) {
                            game.saveConfig('custom_button_control_bottom', item);
                            lib.configMenu.appearence.config.custom_button.onclick('skip');
                        }
                    },
                    radius_size: {
                        name: '圆角大小',
                        init: 'default',
                        item: {
                            off: '关闭',
                            reduce: '减小',
                            "default": '默认',
                            increase: '增大'
                        },
                        unfrequent: true,
                        onclick: function (item) {
                            game.saveConfig('radius_size', item);
                            ui.window.dataset.radius_size = item;
                        }
                    },
                    glow_phase: {
                        name: '当前回合角色高亮',
                        unfrequent: true,
                        init: 'yellow',
                        intro: '设置当前回合角色的边框颜色',
                        item: {
                            none: '无',
                            yellow: '黄色',
                            green: '绿色',
                            purple: '紫色'
                        },
                        onclick: function (bool) {
                            game.saveConfig('glow_phase', bool);
                            lib.init.cssstyles();
                        }
                    },
                    fold_card: {
                        name: '折叠手牌',
                        init: true,
                        unfrequent: true
                    },
                    fold_mode: {
                        name: '折叠模式菜单',
                        intro: '关闭后模式菜单中“更多”内的项目将直接展开',
                        init: true,
                        unfrequent: true
                    },
                    seperate_control: {
                        name: '分离选项条',
                        init: true,
                        unfrequent: true,
                        intro: '开启后玩家在进行选择时不同的选项将分开，而不是连在一起'
                    },
                    blur_ui: {
                        name: '模糊效果',
                        intro: '在暂停或打开菜单时开启模糊效果',
                        init: false,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('blur_ui', bool);
                            if (bool) {
                                ui.window.classList.add('blur_ui');
                            }
                            else {
                                ui.window.classList.remove('blur_ui');
                            }
                        }
                    },
                    glass_ui: {
                        name: '玻璃主题',
                        intro: '为游戏主题打开玻璃效果（手机暂不支持）',
                        init: false,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('glass_ui', bool);
                            if (bool) {
                                ui.window.classList.add('glass_ui');
                            }
                            else {
                                ui.window.classList.remove('glass_ui');
                            }
                        }
                    },
                    damage_shake: {
                        name: '伤害抖动',
                        intro: '角色受到伤害时的抖动效果',
                        init: true,
                        unfrequent: true
                    },
                    button_press: {
                        name: '按钮效果',
                        intro: '选项条被按下时将有按下效果',
                        init: true,
                        unfrequent: true
                    },
                    jiu_effect: {
                        name: '喝酒效果',
                        init: true,
                        unfrequent: true
                    },
                    animation: {
                        name: '游戏特效',
                        intro: '开启后出现属性伤害、回复体力等情况时会显示动画',
                        init: false,
                        unfrequent: true
                    },
                    skill_animation_type: {
                        name: '技能特效',
                        intro: '开启后觉醒技、限定技将显示全屏文字',
                        init: 'default',
                        unfrequent: true,
                        item: {
                            "default": '默认',
                            old: '旧版',
                            off: '关闭'
                        }
                    },
                    die_move: {
                        name: '阵亡效果',
                        intro: '阵亡后武将的显示效果',
                        init: 'flip',
                        unfrequent: true,
                        item: {
                            off: '关闭',
                            move: '移动',
                            flip: '翻面'
                        }
                    },
                    target_shake: {
                        name: '目标效果',
                        intro: '一名玩家成为卡牌或技能的目标时的显示效果',
                        init: 'off',
                        item: {
                            off: '关闭',
                            zoom: '缩放',
                            shake: '抖动'
                        },
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('target_shake', bool);
                            ui.arena.dataset.target_shake = bool;
                        }
                    },
                    turned_style: {
                        name: '翻面文字',
                        intro: '角色被翻面时显示“翻面”',
                        init: true,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('turned_style', bool);
                            if (bool) {
                                ui.arena.classList.remove('hide_turned');
                            }
                            else {
                                ui.arena.classList.add('hide_turned');
                            }
                        }
                    },
                    link_style2: {
                        name: '横置样式',
                        intro: '设置角色被横置时的样式',
                        init: 'chain',
                        unfrequent: true,
                        item: {
                            chain: '铁索',
                            rotate: '横置',
                            mark: '标记'
                        },
                        onclick: function (style) {
                            var list = [];
                            for (var i = 0; i < game.players.length; i++) {
                                if (game.players[i].isLinked()) {
                                    list.push(game.players[i]);
                                }
                            }
                            game.saveConfig('link_style2', style);
                            for (var i = 0; i < list.length; i++) {
                                if (get.is.linked2(list[i])) {
                                    list[i].classList.add('linked2');
                                    list[i].classList.remove('linked');
                                }
                                else {
                                    list[i].classList.add('linked');
                                    list[i].classList.remove('linked2');
                                }
                            }
                            if (style == 'chain') {
                                ui.arena.classList.remove('nolink');
                            }
                            else {
                                ui.arena.classList.add('nolink');
                            }
                            ui.updatem();
                        }
                    },
                    cardshape: {
                        name: '手牌显示',
                        intro: '将手牌设置为正方形或长方形',
                        init: 'default',
                        unfrequent: true,
                        item: {
                            "default": '默认',
                            oblong: '长方'
                        },
                        onclick: function (item) {
                            var linked = false;
                            if (game.me && game.me.isLinked()) {
                                linked = true;
                            }
                            game.saveConfig('cardshape', item);
                            if (item == 'oblong' && (game.layout == 'long' || game.layout == 'mobile' || game.layout == 'long2' || game.layout == 'nova')) {
                                ui.arena.classList.add('oblongcard');
                                ui.window.classList.add('oblongcard');
                            }
                            else {
                                ui.arena.classList.remove('oblongcard');
                                ui.window.classList.remove('oblongcard');
                            }
                            if (linked) {
                                if (get.is.linked2(game.me)) {
                                    game.me.classList.remove('linked');
                                    game.me.classList.add('linked2');
                                }
                                else {
                                    game.me.classList.add('linked');
                                    game.me.classList.remove('linked2');
                                }
                            }
                        }
                    },
                    cardtempname: {
                        name: '视为卡牌名称显示',
                        intro: '显示强制视为类卡牌（如武魂）等名称的显示方式',
                        init: 'default',
                        unfrequent: true,
                        item: {
                            "default": '纵向',
                            horizon: '横向',
                            off: '禁用'
                        },
                        onclick: function (item) {
                            game.saveConfig('cardtempname', item);
                            if (!game.me || !game.me.getCards)
                                return;
                            var hs = game.me.getCards('h');
                            for (var i = 0; i < hs.length; i++) {
                                if (hs[i]._tempName) {
                                    switch (item) {
                                        case 'default':
                                            var node = hs[i]._tempName;
                                            node.innerHTML = get.verticalStr(node.tempname);
                                            break;
                                        case 'horizon':
                                            var node = hs[i]._tempName;
                                            node.innerHTML = node.tempname;
                                            break;
                                        default:
                                            hs[i]._tempName["delete"]();
                                            delete hs[i]._tempName;
                                    }
                                }
                            }
                        }
                    },
                    textequip: {
                        name: '装备显示',
                        init: 'image',
                        unfrequent: true,
                        item: {
                            image: '图片',
                            text: '文字'
                        },
                        onclick: function (item) {
                            game.saveConfig('textequip', item);
                            if (item == 'text' && (game.layout == 'long' || game.layout == 'mobile')) {
                                ui.arena.classList.add('textequip');
                            }
                            else {
                                ui.arena.classList.remove('textequip');
                            }
                        }
                    },
                    buttoncharacter_style: {
                        name: '选将样式',
                        init: 'default',
                        item: {
                            "default": '默认',
                            simple: '精简',
                            old: '旧版'
                        },
                        unfrequent: true
                    },
                    cursor_style: {
                        name: '鼠标指针',
                        init: 'auto',
                        intro: '设置为固定后鼠标指针将不随移动到的区域而变化',
                        unfrequent: true,
                        item: {
                            auto: '自动',
                            pointer: '固定'
                        },
                        onclick: function (item) {
                            game.saveConfig('cursor_style', item);
                            if (item == 'pointer') {
                                ui.window.classList.add('nopointer');
                            }
                            else {
                                ui.window.classList.remove('nopointer');
                            }
                        }
                    },
                    name_font: {
                        name: '人名字体',
                        init: 'LuoLiTi2',
                        unfrequent: true,
                        item: {},
                        textMenu: function (node, link) {
                            if (link != 'default') {
                                node.style.fontFamily = link;
                            }
                            node.style.fontSize = '20px';
                        },
                        onclick: function (font) {
                            game.saveConfig('name_font', font);
                            lib.init.cssstyles();
                        }
                    },
                    identity_font: {
                        name: '身份字体',
                        init: 'xingkai',
                        unfrequent: true,
                        item: {},
                        textMenu: function (node, link) {
                            if (link != 'default') {
                                node.style.fontFamily = link;
                            }
                            node.style.fontSize = '20px';
                        },
                        onclick: function (font) {
                            game.saveConfig('identity_font', font);
                            lib.init.cssstyles();
                        }
                    },
                    cardtext_font: {
                        name: '卡牌字体',
                        init: 'LuoLiTi2',
                        unfrequent: true,
                        item: {},
                        textMenu: function (node, link) {
                            if (link != 'default') {
                                node.style.fontFamily = link;
                            }
                            node.style.fontSize = '20px';
                        },
                        onclick: function (font) {
                            game.saveConfig('cardtext_font', font);
                            lib.init.cssstyles();
                        }
                    },
                    global_font: {
                        name: '界面字体',
                        init: 'default',
                        unfrequent: true,
                        item: {},
                        textMenu: function (node, link) {
                            if (link != 'default') {
                                node.style.fontFamily = link;
                            }
                            else {
                                node.style.fontFamily = "'STHeiti','SimHei','Microsoft JhengHei','Microsoft YaHei','WenQuanYi Micro Hei',Helvetica,Arial,sans-serif";
                            }
                            node.style.fontSize = '20px';
                        },
                        onclick: function (font) {
                            game.saveConfig('global_font', font);
                            lib.init.cssstyles();
                        }
                    },
                    update: function (config, map) {
                        if (lib.config.custom_button) {
                            map.custom_button_system_top.show();
                            map.custom_button_system_bottom.show();
                            map.custom_button_control_top.show();
                            map.custom_button_control_bottom.show();
                        }
                        else {
                            map.custom_button_system_top.hide();
                            map.custom_button_system_bottom.hide();
                            map.custom_button_control_top.hide();
                            map.custom_button_control_bottom.hide();
                        }
                        if (lib.config.change_skin) {
                            map.change_skin_auto.show();
                        }
                        else {
                            map.change_skin_auto.hide();
                        }
                        if (lib.config.image_background_random) {
                            map.image_background_blur.show();
                            map.image_background.hide();
                            // map.import_background.hide();
                        }
                        else {
                            map.image_background.show();
                            if (lib.config.image_background == 'default') {
                                map.image_background_blur.hide();
                            }
                            else {
                                map.image_background_blur.show();
                            }
                            // if(lib.config.image_background=='custom'&&lib.db){
                            //     map.import_background.show();
                            // }
                            // else{
                            //     map.import_background.hide();
                            // }
                        }
                        if (lib.config.layout == 'long' || lib.config.layout == 'mobile') {
                            map.textequip.show();
                            map.cardshape.show();
                            map.phonelayout.show();
                        }
                        else {
                            map.textequip.hide();
                            if (lib.config.layout == 'long2' || lib.config.layout == 'nova') {
                                map.phonelayout.show();
                                map.cardshape.show();
                            }
                            else {
                                map.phonelayout.hide();
                                map.cardshape.hide();
                            }
                        }
                        if (lib.config.layout == 'long') {
                            // map.fewplayer.show();
                            map.player_height.show();
                        }
                        else {
                            // map.fewplayer.hide();
                            if (lib.config.layout == 'long2') {
                                map.player_height.show();
                            }
                            else {
                                map.player_height.hide();
                            }
                        }
                        if (lib.config.layout == 'nova') {
                            map.player_height_nova.show();
                        }
                        else {
                            map.player_height_nova.hide();
                        }
                        if (lib.config.touchscreen) {
                            map.cursor_style.hide();
                        }
                        else {
                            map.cursor_style.show();
                        }
                        if (lib.config.border_style == 'auto') {
                            map.autoborder_count.show();
                            map.autoborder_start.show();
                        }
                        else {
                            map.autoborder_count.hide();
                            map.autoborder_start.hide();
                        }
                    }
                }
            },
            /**
             * 显示设置
             * @name configMenu.view
             * @type {!Object}
             */
            view: {
                name: '显示',
                config: {
                    update: function (config, map) {
                        if (['versus', 'chess', 'tafang', 'boss', 'richer'].contains(lib.config.mode)) {
                            map.show_handcardbutton.show();
                        }
                        else {
                            map.show_handcardbutton.hide();
                        }
                        if (lib.config.touchscreen) {
                            map.pop_logv.hide();
                        }
                        else {
                            map.pop_logv.show();
                        }
                        if (lib.device) {
                            if (lib.device == 'android') {
                                map.show_statusbar_android.show();
                                map.show_statusbar_ios.hide();
                            }
                            else if (lib.device == 'ios') {
                                map.show_statusbar_ios.show();
                                map.show_statusbar_android.hide();
                            }
                            if (!game.download) {
                                setTimeout(function () {
                                    if (!window.StatusBar) {
                                        map.show_statusbar.hide();
                                    }
                                }, 5000);
                            }
                        }
                        else {
                            map.show_statusbar_ios.hide();
                            map.show_statusbar_android.hide();
                        }
                        if (get.is.phoneLayout()) {
                            map.remember_round_button.show();
                            map.popequip.show();
                            map.filternode_button.show();
                            map.show_pause.hide();
                            map.show_auto.hide();
                            map.show_replay.hide();
                            map.show_round_menu.show();
                        }
                        else {
                            map.show_pause.show();
                            map.show_auto.show();
                            map.show_replay.show();
                            map.show_round_menu.hide();
                            map.remember_round_button.hide();
                            map.popequip.hide();
                            map.filternode_button.hide();
                        }
                        if (lib.config.show_card_prompt) {
                            map.hide_card_prompt_basic.show();
                            map.hide_card_prompt_equip.show();
                        }
                        else {
                            map.hide_card_prompt_basic.hide();
                            map.hide_card_prompt_equip.hide();
                        }
                        if (lib.config.show_log != 'off') {
                            map.clear_log.show();
                        }
                        else {
                            map.clear_log.hide();
                        }
                        if (get.is.phoneLayout()) {
                            map.show_time2.show();
                            map.show_time.hide();
                            if (lib.config.show_time2) {
                                map.watchface.show();
                            }
                            else {
                                map.watchface.hide();
                            }
                        }
                        else {
                            map.show_time2.hide();
                            map.show_time.show();
                            map.watchface.hide();
                        }
                        if (lib.config.show_extensionmaker) {
                            map.show_extensionshare.show();
                        }
                        else {
                            map.show_extensionshare.hide();
                        }
                    },
                    show_history: {
                        name: '出牌记录栏',
                        init: 'off',
                        intro: '在屏幕左侧或右侧显示出牌记录',
                        unfrequent: true,
                        item: {
                            off: '关闭',
                            left: '靠左',
                            right: '靠右'
                        },
                        onclick: function (bool) {
                            if (lib.config.show_history == 'right')
                                ui.window.animate('rightbar2');
                            game.saveConfig('show_history', bool);
                            if (_status.video || !_status.prepareArena)
                                return;
                            if (bool == 'left') {
                                ui.window.classList.add('leftbar');
                                ui.window.classList.remove('rightbar');
                            }
                            else if (bool == 'right') {
                                ui.window.classList.remove('leftbar');
                                ui.window.classList.add('rightbar');
                            }
                            else {
                                ui.window.classList.remove('leftbar');
                                ui.window.classList.remove('rightbar');
                            }
                        }
                    },
                    pop_logv: {
                        name: '自动弹出记录',
                        init: false,
                        unfrequent: true
                    },
                    show_log: {
                        name: '历史记录栏',
                        init: 'off',
                        intro: '在屏幕中部显示出牌文字记录',
                        unfrequent: true,
                        item: {
                            off: '关闭',
                            left: '靠左',
                            center: '居中',
                            right: '靠右'
                        },
                        onclick: function (bool) {
                            game.saveConfig('show_log', bool);
                            if (lib.config.show_log != 'off') {
                                ui.arenalog.style.display = '';
                                ui.arenalog.dataset.position = bool;
                            }
                            else {
                                ui.arenalog.style.display = 'none';
                                ui.arenalog.innerHTML = '';
                            }
                        }
                    },
                    clear_log: {
                        name: '自动清除历史记录',
                        init: false,
                        unfrequent: true,
                        intro: '开启后将定时清除历史记录栏的条目（而不是等记录栏满后再清除）'
                    },
                    log_highlight: {
                        name: '历史记录高亮',
                        init: true,
                        unfrequent: true,
                        intro: '开启后历史记录不同类别的信息将以不同颜色显示'
                    },
                    show_time: {
                        name: '显示时间',
                        intro: '在屏幕顶部显示当前时间',
                        init: false,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('show_time', bool);
                            if (bool) {
                                ui.time.style.display = '';
                            }
                            else {
                                ui.time.style.display = 'none';
                            }
                        }
                    },
                    show_time2: {
                        name: '显示时间',
                        intro: '在触屏按钮处显示当前时间',
                        init: false,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('show_time2', bool);
                            if (bool) {
                                ui.roundmenu.classList.add('clock');
                            }
                            else {
                                ui.roundmenu.classList.remove('clock');
                            }
                        }
                    },
                    watchface: {
                        name: '表盘样式',
                        init: 'none',
                        unfrequent: true,
                        item: {
                            none: '默认',
                            simple: '简约'
                        },
                        onclick: function (item) {
                            game.saveConfig('watchface', item);
                            ui.roundmenu.dataset.watchface = item;
                        }
                    },
                    show_time3: {
                        name: '显示游戏时间',
                        init: false,
                        unfrequent: true
                    },
                    show_statusbar_android: {
                        name: '显示状态栏',
                        init: false,
                        unfrequent: true,
                        content: function (bool) {
                            game.saveConfig('show_statusbar', bool);
                            if (window.StatusBar && lib.device == 'android') {
                                if (bool) {
                                    window.StatusBar.overlaysWebView(false);
                                    window.StatusBar.backgroundColorByName('black');
                                    window.StatusBar.show();
                                }
                                else {
                                    window.StatusBar.hide();
                                }
                            }
                        }
                    },
                    show_statusbar_ios: {
                        name: '显示状态栏',
                        init: 'off',
                        unfrequent: true,
                        item: {
                            "default": '默认',
                            overlay: '嵌入',
                            auto: '自动',
                            off: '关闭'
                        },
                        onclick: function (bool) {
                            game.saveConfig('show_statusbar_ios', bool);
                            if (window.StatusBar && lib.device == 'ios') {
                                if (bool != 'off' && bool != 'auto') {
                                    if (lib.config.show_statusbar_ios == 'default') {
                                        window.StatusBar.overlaysWebView(false);
                                        document.body.classList.remove('statusbar');
                                    }
                                    else {
                                        window.StatusBar.overlaysWebView(true);
                                        document.body.classList.add('statusbar');
                                    }
                                    window.StatusBar.backgroundColorByName('black');
                                    window.StatusBar.show();
                                }
                                else {
                                    document.body.classList.remove('statusbar');
                                    window.StatusBar.hide();
                                }
                            }
                        }
                    },
                    show_card_prompt: {
                        name: '显示出牌信息',
                        intro: '出牌时在使用者上显示卡牌名称',
                        init: true,
                        unfrequent: true
                    },
                    hide_card_prompt_basic: {
                        name: '隐藏基本牌信息',
                        intro: '不显示基本牌名称',
                        init: false,
                        unfrequent: true
                    },
                    hide_card_prompt_equip: {
                        name: '隐藏装备牌信息',
                        intro: '不显示装备牌名称',
                        init: false,
                        unfrequent: true
                    },
                    show_phase_prompt: {
                        name: '显示阶段信息',
                        intro: '在当前回合不同阶段开始时显示阶段名称',
                        init: true,
                        unfrequent: true
                    },
                    show_phaseuse_prompt: {
                        name: '出牌阶段提示',
                        intro: '在你出牌时显示提示文字',
                        init: true,
                        unfrequent: true
                    },
                    auto_popped_config: {
                        name: '自动弹出选项',
                        intro: '鼠标移至选项按钮时弹出模式选择菜单',
                        init: true,
                        unfrequent: true
                    },
                    auto_popped_history: {
                        name: '自动弹出历史',
                        intro: '鼠标移至暂停按钮时弹出历史记录菜单',
                        init: false,
                        unfrequent: true
                    },
                    show_round_menu: {
                        name: '显示触屏按钮',
                        init: true,
                        unfrequent: true,
                        onclick: function (bool) {
                            if (get.is.nomenu('show_round_menu', bool))
                                return false;
                            game.saveConfig('show_round_menu', bool);
                            if (bool && ui.roundmenu) {
                                ui.roundmenu.style.display = '';
                            }
                            else {
                                ui.roundmenu.style.display = 'none';
                                alert('关闭触屏按钮后可通过手势打开菜单（默认为下划）');
                            }
                        }
                    },
                    remember_round_button: {
                        name: '记住按钮位置',
                        intro: '重新开始后触屏按钮将保存的上一局的位置',
                        init: false,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('remember_round_button', bool);
                            if (!bool) {
                                ui.click.resetround();
                            }
                        }
                    },
                    remember_dialog: {
                        name: '记住对话框位置',
                        intro: '移动对话框后新的对话框也将在移动后的位置显示',
                        init: false,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('remember_dialog', bool);
                            if (!bool) {
                                if (ui.dialog) {
                                    var dialog = ui.dialog;
                                    dialog.style.transform = '';
                                    dialog._dragtransform = [0, 0];
                                    dialog.style.transition = 'all 0.3s';
                                    dialog._dragtouches;
                                    dialog._dragorigin;
                                    dialog._dragorigintransform;
                                    setTimeout(function () {
                                        dialog.style.transition = '';
                                    }, 500);
                                }
                                game.saveConfig('dialog_transform', [0, 0]);
                            }
                        }
                    },
                    transparent_dialog: {
                        name: '堆叠对话框虚化',
                        init: false,
                        intro: '当具有static属性的对话框堆叠（如五谷丰登对话框中提示无懈可击）时，将后方的对话框变为半透明',
                        onclick: function (bool) {
                            game.saveConfig('transparent_dialog', bool);
                            if (bool) {
                                for (var i = 0; i < ui.dialogs.length; i++) {
                                    if (ui.dialogs[i] != ui.dialog && ui.dialogs[i].static) {
                                        ui.dialogs[i].unfocus();
                                    }
                                }
                            }
                            else {
                                for (var i = 0; i < ui.dialogs.length; i++) {
                                    if (ui.dialogs[i] != ui.dialog && ui.dialogs[i].static) {
                                        ui.dialogs[i].refocus();
                                    }
                                }
                            }
                        }
                    },
                    show_rarity: {
                        name: '显示武将稀有度',
                        init: false,
                        intro: '仅供娱乐，重启后生效',
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('show_rarity', bool);
                        }
                    },
                    mark_identity_style: {
                        name: '标记身份操作',
                        intro: '设置单击身份按钮时的操作',
                        unfrequent: true,
                        init: 'menu',
                        item: {
                            menu: '菜单',
                            click: '单击'
                        }
                    },
                    character_dialog_tool: {
                        name: '自由选将显示',
                        intro: '点击自由选将时默认显示的条目',
                        init: '最近',
                        item: {
                            '收藏': '收藏',
                            '最近': '最近',
                            'all': '全部'
                        },
                        unfrequent: true
                    },
                    recent_character_number: {
                        name: '最近使用武将',
                        intro: '自由选将对话框中最近使用武将的数量',
                        init: '12',
                        item: {
                            '6': '6',
                            '12': '12',
                            '20': '24',
                            '30': '36'
                        },
                        unfrequent: true
                    },
                    popequip: {
                        name: '触屏装备选择',
                        intro: '设置触屏布局中选择装备的方式',
                        init: true,
                        unfrequent: true
                    },
                    filternode_button: {
                        name: '触屏筛选按钮',
                        intro: '设置自由选将对话框中筛选按钮的样式',
                        init: true,
                        unfrequent: true
                    },
                    show_charactercard: {
                        name: '显示武将资料',
                        intro: '在武将界面单击时弹出武将资料卡',
                        init: true,
                        unfrequent: true
                    },
                    show_favourite: {
                        name: '显示添加收藏',
                        intro: '在角色的右键菜单中显示添加收藏',
                        init: false,
                        unfrequent: true
                    },
                    show_favmode: {
                        name: '显示模式收藏',
                        intro: '快捷菜单中显示收藏模式',
                        init: true,
                        unfrequent: true
                    },
                    show_favourite_menu: {
                        name: '显示收藏菜单',
                        intro: '在选项-武将中显示收藏一栏',
                        init: true,
                        unfrequent: true
                    },
                    show_ban_menu: {
                        name: '显示禁将菜单',
                        intro: '在选项-武将中显示禁将一栏',
                        init: true,
                        unfrequent: true
                    },
                    right_range: {
                        name: '显示距离信息',
                        intro: '在角色的右键菜单中显示距离等信息',
                        init: true,
                        unfrequent: true
                    },
                    replace_image: {
                        name: '替换为原始卡图',
                        intro: '所有V版卡图替换为三国杀原版卡图',
                        init: false,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('replace_image', bool);
                            if (bool) {
                                ui.arena.classList.remove('replace_image');
                            }
                            else {
                                ui.arena.classList.add('replace_image');
                            }
                        }
                    },
                    hide_card_image: {
                        name: '隐藏卡牌背景',
                        intro: '所有卡牌将使用文字作为背景',
                        init: false,
                        unfrequent: true,
                        restart: true
                    },
                    show_name: {
                        name: '显示角色名称',
                        init: false,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('show_name', bool);
                            if (bool) {
                                ui.arena.classList.remove('hide_name');
                            }
                            else {
                                ui.arena.classList.add('hide_name');
                            }
                        }
                    },
                    show_replay: {
                        name: '显示重来按钮',
                        init: false,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('show_replay', bool);
                            if (lib.config.show_replay) {
                                ui.replay.style.display = '';
                            }
                            else {
                                ui.replay.style.display = 'none';
                            }
                        }
                    },
                    show_playerids: {
                        name: '显示身份按钮',
                        init: true,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('show_playerids', bool);
                            if (lib.config.show_playerids) {
                                ui.playerids.style.display = '';
                            }
                            else {
                                ui.playerids.style.display = 'none';
                            }
                        }
                    },
                    show_sortcard: {
                        name: '显示整理手牌按钮',
                        init: true,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('show_sortcard', bool);
                            if (lib.config.show_sortcard) {
                                ui.sortCard.style.display = '';
                            }
                            else {
                                ui.sortCard.style.display = 'none';
                            }
                        }
                    },
                    show_pause: {
                        name: '显示暂停按钮',
                        init: true,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('show_pause', bool);
                            if (lib.config.show_pause) {
                                ui.pause.style.display = '';
                            }
                            else {
                                ui.pause.style.display = 'none';
                            }
                        }
                    },
                    show_auto: {
                        name: '显示托管按钮',
                        init: true,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('show_auto', bool);
                            if (lib.config.show_auto) {
                                ui.auto.style.display = '';
                            }
                            else {
                                ui.auto.style.display = 'none';
                            }
                        }
                    },
                    show_volumn: {
                        name: '显示音量按钮',
                        init: true,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('show_volumn', bool);
                            if (lib.config.show_volumn) {
                                ui.volumn.style.display = '';
                            }
                            else {
                                ui.volumn.style.display = 'none';
                            }
                        }
                    },
                    show_cardpile: {
                        name: '显示牌堆按钮',
                        init: true,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('show_cardpile', bool);
                            if (bool) {
                                ui.cardPileButton.style.display = '';
                            }
                            else {
                                ui.cardPileButton.style.display = 'none';
                            }
                        }
                    },
                    show_cardpile_number: {
                        name: '显示剩余牌数',
                        init: false,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('show_cardpile_number', bool);
                            if (bool) {
                                ui.cardPileNumber.style.display = '';
                            }
                            else {
                                ui.cardPileNumber.style.display = 'none';
                            }
                        }
                    },
                    show_handcardbutton: {
                        name: '显示手牌按钮',
                        init: true,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('show_handcardbutton', bool);
                        }
                    },
                    show_giveup: {
                        name: '显示投降按钮',
                        init: true,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('show_giveup', bool);
                        }
                    },
                    show_wuxie: {
                        name: '显示无懈按钮',
                        intro: '在右上角显示不询问无懈',
                        init: false,
                        unfrequent: true,
                        onclick: function (bool) {
                            game.saveConfig('show_wuxie', bool);
                            if (lib.config.show_wuxie) {
                                ui.wuxie.style.display = '';
                            }
                            else {
                                ui.wuxie.style.display = 'none';
                            }
                        }
                    },
                    wuxie_right: {
                        name: '无懈按钮靠左',
                        init: true,
                        unfrequent: true
                    },
                    show_discardpile: {
                        name: '暂停时显示弃牌堆',
                        init: false,
                        unfrequent: true
                    },
                    show_extensionmaker: {
                        name: '显示制作扩展',
                        init: true,
                        unfrequent: true
                    },
                    show_extensionshare: {
                        name: '显示分享扩展',
                        init: true,
                        unfrequent: true
                    }
                }
            },
            /**
             * 音效设置
             * @name configMenu.audio
             * @type {!Object}
             */
            audio: {
                name: '音效',
                config: {
                    update: function (config, map) {
                        if (lib.config.background_music == 'music_custom' && (lib.device || lib.node)) {
                            map.import_music.show();
                        }
                        else {
                            map.import_music.hide();
                        }
                        map.clear_background_music[get.is.object(lib.config.customBackgroundMusic) ? 'show' : 'hide']();
                        ui.background_music_setting = map.background_music;
                        map.background_music._link.config.updatex.call(map.background_music, []);
                    },
                    background_music: {
                        updatex: function () {
                            this.lastChild.innerHTML = this._link.config.item[lib.config.background_music];
                            var menu = this._link.menu;
                            for (var i = 0; i < menu.childElementCount; i++) {
                                if (!['music_off', 'music_custom', 'music_random'].concat(lib.config.all.background_music).contains(menu.childNodes[i]._link))
                                    menu.childNodes[i]["delete"]();
                            }
                        },
                        name: '背景音乐',
                        init: true,
                        item: {
                            music_default: '默认'
                        },
                        onclick: function (item) {
                            game.saveConfig('background_music', item);
                            game.playBackgroundMusic();
                        }
                    },
                    import_music: {
                        name: '<div style="white-space:nowrap;width:calc(100% - 5px)">' +
                            '<input type="file" style="width:calc(100% - 40px)" accept="audio/*">' +
                            '<button style="width:40px">确定</button></div>',
                        clear: true
                    },
                    background_audio: {
                        name: '游戏音效',
                        init: true
                    },
                    background_speak: {
                        name: '人物配音',
                        init: true
                    },
                    equip_audio: {
                        name: '装备配音',
                        init: false
                    },
                    repeat_audio: {
                        name: '播放重复语音',
                        init: false
                    },
                    volumn_audio: {
                        name: '音效音量',
                        init: 8,
                        item: {
                            '0': '〇',
                            '1': '一',
                            '2': '二',
                            '3': '三',
                            '4': '四',
                            '5': '五',
                            '6': '六',
                            '7': '七',
                            '8': '八'
                        },
                        onclick: function (volume) {
                            game.saveConfig('volumn_audio', parseInt(volume));
                        }
                    },
                    volumn_background: {
                        name: '音乐音量',
                        init: 8,
                        item: {
                            '0': '〇',
                            '1': '一',
                            '2': '二',
                            '3': '三',
                            '4': '四',
                            '5': '五',
                            '6': '六',
                            '7': '七',
                            '8': '八'
                        },
                        onclick: function (volume) {
                            game.saveConfig('volumn_background', parseInt(volume));
                            ui.backgroundMusic.volume = volume / 8;
                        }
                    },
                    clear_background_music: {
                        name: '清除自定义背景音乐',
                        clear: true,
                        onclick: function () {
                            if (confirm('是否清除已导入的所有自定义背景音乐？（该操作不可撤销！）')) {
                                for (var i in lib.config.customBackgroundMusic) {
                                    lib.config.all.background_music.remove(i);
                                    if (i.indexOf('cdv_') == 0) {
                                        game.removeFile('audio/background/' + i + '.mp3');
                                    }
                                    else {
                                        game.deleteDB('audio', i);
                                    }
                                }
                                lib.config.customBackgroundMusic = null;
                                game.saveConfig('customBackgroundMusic', null);
                                game.saveConfig('background_music', 'music_off');
                                if (!_status._aozhan)
                                    game.playBackgroundMusic();
                            }
                        }
                    }
                }
            },
            /**
             * (自动, 禁用)技能设置
             * @name configMenu.skill
             * @type {!Object}
             */
            skill: {
                name: '技能',
                config: {
                    update: function (config, map) {
                        for (var i in map) {
                            if (map[i]._link.config.type == 'autoskill') {
                                if (!lib.config.autoskilllist.contains(i)) {
                                    map[i].classList.add('on');
                                }
                                else {
                                    map[i].classList.remove('on');
                                }
                            }
                            else if (map[i]._link.config.type == 'banskill') {
                                if (!lib.config.forbidlist.contains(i)) {
                                    map[i].classList.add('on');
                                }
                                else {
                                    map[i].classList.remove('on');
                                }
                            }
                        }
                    }
                }
            },
            /**
             * 其他菜单项
             * @name configMenu.others
             * @type {!Object}
             */
            others: {
                name: '其它',
                config: {
                    // reset_database:{
                    //     name:'重置游戏',
                    //     onclick:function(){
                    //         var node=this;
                    //         if(node._clearing){
                    //             if(indexedDB) indexedDB.deleteDatabase(lib.configprefix+'data');
                    //             game.reload();
                    //             return;
                    //         }
                    //         node._clearing=true;
                    //         node.innerHTML='单击以确认 (3)';
                    //         setTimeout(function(){
                    //             node.innerHTML='单击以确认 (2)';
                    //             setTimeout(function(){
                    //                 node.innerHTML='单击以确认 (1)';
                    //                 setTimeout(function(){
                    //                     node.innerHTML='重置游戏录像';
                    //                     delete node._clearing;
                    //                 },1000);
                    //             },1000);
                    //         },1000);
                    //     },
                    //     clear:true
                    // },
                    reset_game: {
                        name: '重置游戏设置',
                        onclick: function () {
                            var node = this;
                            if (node._clearing) {
                                var noname_inited = localStorage.getItem('noname_inited');
                                var onlineKey = localStorage.getItem(lib.configprefix + 'key');
                                localStorage.clear();
                                if (noname_inited) {
                                    localStorage.setItem('noname_inited', noname_inited);
                                }
                                if (onlineKey) {
                                    localStorage.setItem(lib.configprefix + 'key', onlineKey);
                                }
                                game.deleteDB('config');
                                game.deleteDB('data');
                                game.reload();
                                return;
                            }
                            node._clearing = true;
                            node.firstChild.innerHTML = '单击以确认 (3)';
                            setTimeout(function () {
                                node.firstChild.innerHTML = '单击以确认 (2)';
                                setTimeout(function () {
                                    node.firstChild.innerHTML = '单击以确认 (1)';
                                    setTimeout(function () {
                                        node.firstChild.innerHTML = '重置游戏设置';
                                        delete node._clearing;
                                    }, 1000);
                                }, 1000);
                            }, 1000);
                        },
                        clear: true
                    },
                    reset_hiddenpack: {
                        name: '重置隐藏内容',
                        onclick: function () {
                            if (this.firstChild.innerHTML != '已重置') {
                                this.firstChild.innerHTML = '已重置';
                                game.saveConfig('hiddenModePack', []);
                                game.saveConfig('hiddenCharacterPack', []);
                                game.saveConfig('hiddenCardPack', []);
                                game.saveConfig('hiddenPlayPack', []);
                                game.saveConfig('hiddenBackgroundPack', []);
                                var that = this;
                                setTimeout(function () {
                                    that.firstChild.innerHTML = '重置隐藏内容';
                                    setTimeout(function () {
                                        if (confirm('是否重新启动使改变生效？')) {
                                            game.reload();
                                        }
                                    });
                                }, 500);
                            }
                        },
                        clear: true
                    },
                    reset_tutorial: {
                        name: '重置新手向导',
                        onclick: function () {
                            if (this.firstChild.innerHTML != '已重置') {
                                this.firstChild.innerHTML = '已重置';
                                game.saveConfig('new_tutorial', false);
                                game.saveConfig('prompt_hidebg');
                                game.saveConfig('prompt_hidepack');
                                var that = this;
                                setTimeout(function () {
                                    that.firstChild.innerHTML = '重置新手向导';
                                }, 500);
                            }
                        },
                        clear: true
                    },
                    import_data: {
                        name: '导入游戏设置',
                        onclick: function () {
                            ui.import_data_button.classList.toggle('hidden');
                        },
                        clear: true
                    },
                    import_data_button: {
                        name: '<div style="white-space:nowrap;width:calc(100% - 10px)">' +
                            '<input type="file" style="width:calc(100% - 40px)">' +
                            '<button style="width:40px">确定</button></div>',
                        clear: true
                    },
                    export_data: {
                        name: '导出游戏设置',
                        onclick: function () {
                            var data;
                            var export_data = function (data) {
                                game["export"](lib.init.encode(JSON.stringify(data)), '无名杀 - 数据 - ' + (new Date()).toLocaleString());
                            };
                            if (!lib.db) {
                                data = {};
                                for (var i in localStorage) {
                                    if (i.indexOf(lib.configprefix) == 0) {
                                        data[i] = localStorage[i];
                                    }
                                }
                                export_data(data);
                            }
                            else {
                                game.getDB('config', null, function (data1) {
                                    game.getDB('data', null, function (data2) {
                                        export_data({
                                            config: data1,
                                            data: data2
                                        });
                                    });
                                });
                            }
                        },
                        clear: true
                    },
                    redownload_game: {
                        name: '重新下载游戏',
                        onclick: function () {
                            var node = this;
                            if (node._clearing) {
                                localStorage.removeItem('noname_inited');
                                game.reload();
                                return;
                            }
                            node._clearing = true;
                            node.firstChild.innerHTML = '单击以确认 (3)';
                            setTimeout(function () {
                                node.firstChild.innerHTML = '单击以确认 (2)';
                                setTimeout(function () {
                                    node.firstChild.innerHTML = '单击以确认 (1)';
                                    setTimeout(function () {
                                        node.firstChild.innerHTML = '重新下载游戏';
                                        delete node._clearing;
                                    }, 1000);
                                }, 1000);
                            }, 1000);
                        },
                        clear: true
                    },
                    update: function (config, map) {
                        if (lib.device || lib.node) {
                            map.redownload_game.show();
                        }
                        else {
                            map.redownload_game.hide();
                        }
                    }
                    // trim_game:{
                    //     name:'隐藏非官方扩展包',
                    //     onclick:function(){
                    //         if(this.innerHTML!='已隐藏'){
                    //             this.innerHTML='已隐藏';
                    //                               var pack=lib.config.all.cards.slice(0);
                    //                               if(Array.isArray(lib.config.hiddenCardPack)){
                    //                                            for(var i=0;i<lib.config.hiddenCardPack.length;i++){
                    //                                                                  pack.add(lib.config.hiddenCardPack[i]);
                    //                                            }
                    //                               }
                    //                               for(var i=0;i<pack.length;i++){
                    //                                            if(lib.config.all.sgscards.contains(pack[i])){
                    //                                                                  pack.splice(i--,1);
                    //                                            }
                    //                               }
                    //             game.saveConfig('hiddenCardPack',pack);
                    //
                    //                               var pack=lib.config.all.characters.slice(0);
                    //                               if(Array.isArray(lib.config.hiddenCharacterPack)){
                    //                                            for(var i=0;i<lib.config.hiddenCharacterPack.length;i++){
                    //                                                                  pack.add(lib.config.hiddenCharacterPack[i]);
                    //                                            }
                    //                               }
                    //                               for(var i=0;i<pack.length;i++){
                    //                                            if(lib.config.all.sgscharacters.contains(pack[i])){
                    //                                                                  pack.splice(i--,1);
                    //                                            }
                    //                               }
                    //             game.saveConfig('hiddenCharacterPack',pack);
                    //
                    //                               var pack=lib.config.all.mode.slice(0);
                    //                               if(Array.isArray(lib.config.hiddenModePack)){
                    //                                            for(var i=0;i<lib.config.hiddenModePack.length;i++){
                    //                                                                  pack.add(lib.config.hiddenModePack[i]);
                    //                                            }
                    //                               }
                    //                               for(var i=0;i<pack.length;i++){
                    //                                            if(lib.config.all.sgsmodes.contains(pack[i])){
                    //                                                                  pack.splice(i--,1);
                    //                                            }
                    //                               }
                    //             game.saveConfig('hiddenModePack',pack);
                    //
                    //             var that=this;
                    //             setTimeout(function(){
                    //                 that.innerHTML='隐藏非官方扩展包';
                    //             },500);
                    //         }
                    //     },
                    //     clear:true
                    // }
                }
            }
        },
        /**
         * 拓展菜单
         * @name configMenu.extensionMenu
         */
        extensionMenu: {
            cardpile: {
                enable: {
                    name: '开启',
                    init: false,
                    restart: true
                },
                intro: {
                    name: '将杀闪等牌在牌堆中的比例维持在与军争牌堆相同，防止开启扩展包后被过多地稀释',
                    clear: true,
                    nopointer: true
                },
                sha: {
                    name: '杀',
                    init: '1',
                    item: {
                        '1': '补充全部',
                        '0.5': '补充一半',
                        '0': '不补充'
                    }
                },
                huosha: {
                    name: '火杀',
                    init: '1',
                    item: {
                        '1': '补充全部',
                        '0.5': '补充一半',
                        '0': '不补充'
                    }
                },
                leisha: {
                    name: '雷杀',
                    init: '1',
                    item: {
                        '1': '补充全部',
                        '0.5': '补充一半',
                        '0': '不补充'
                    }
                },
                shan: {
                    name: '闪',
                    init: '1',
                    item: {
                        '1': '补充全部',
                        '0.5': '补充一半',
                        '0': '不补充'
                    }
                },
                tao: {
                    name: '桃',
                    init: '0',
                    item: {
                        '1': '补充全部',
                        '0.5': '补充一半',
                        '0': '不补充'
                    }
                },
                jiu: {
                    name: '酒',
                    init: '0',
                    item: {
                        '1': '补充全部',
                        '0.5': '补充一半',
                        '0': '不补充'
                    }
                },
                wuxie: {
                    name: '无懈可击',
                    init: '0.5',
                    item: {
                        '1': '补充全部',
                        '0.5': '补充一半',
                        '0': '不补充'
                    }
                },
                nanman: {
                    name: '南蛮入侵',
                    init: '0',
                    item: {
                        '1': '补充全部',
                        '0.5': '补充一半',
                        '0': '不补充'
                    }
                },
                wanjian: {
                    name: '万箭齐发',
                    init: '0',
                    item: {
                        '1': '补充全部',
                        '0.5': '补充一半',
                        '0': '不补充'
                    }
                },
                guohe: {
                    name: '过河拆桥',
                    init: '0',
                    item: {
                        '1': '补充全部',
                        '0.5': '补充一半',
                        '0': '不补充'
                    }
                },
                shunshou: {
                    name: '顺手牵羊',
                    init: '0',
                    item: {
                        '1': '补充全部',
                        '0.5': '补充一半',
                        '0': '不补充'
                    }
                },
                tiesuo: {
                    name: '铁索连环',
                    init: '0',
                    item: {
                        '1': '补充全部',
                        '0.5': '补充一半',
                        '0': '不补充'
                    }
                },
                hide: {
                    name: '隐藏此扩展',
                    clear: true,
                    onclick: function () {
                        if (this.firstChild.innerHTML == '隐藏此扩展') {
                            this.firstChild.innerHTML = '此扩展将在重启后隐藏';
                            lib.config.hiddenPlayPack.add('cardpile');
                            if (!lib.config.prompt_hidepack) {
                                alert('隐藏的扩展包可通过选项-其它-重置隐藏内容恢复');
                                game.saveConfig('prompt_hidepack', true);
                            }
                        }
                        else {
                            this.firstChild.innerHTML = '隐藏此扩展';
                            lib.config.hiddenPlayPack.remove('cardpile');
                        }
                        game.saveConfig('hiddenPlayPack', lib.config.hiddenPlayPack);
                    }
                }
            },
            // boss: {
            //     enable: {
            //         name: '开启',
            //         init: false,
            //         restart: true,
            //         onswitch: function (bool) {
            //             if (bool) {
            //                 var storage = { boss: {}, versus: {}, translate: {} };
            //                 var loadversus = function () {
            //                     game.loadModeAsync('versus', function (mode) {
            //                         for (var i in mode.translate) {
            //                             storage.translate[i] = mode.translate[i];
            //                         }
            //                         for (var i in mode.jiangeboss) {
            //                             if (mode.jiangeboss[i][4].contains('bossallowed')) {
            //                                 storage.versus[i] = mode.jiangeboss[i];
            //                             }
            //                         }
            //                         localStorage.setItem('boss_storage_playpackconfig', JSON.stringify(storage));
            //                     });
            //                 };
            //                 game.loadModeAsync('boss', function (mode) {
            //                     for (var i in mode.translate) {
            //                         storage.translate[i] = mode.translate[i];
            //                     }
            //                     for (var i in mode.characterPack.mode_boss) {
            //                         if (mode.characterPack.mode_boss[i][4].contains('bossallowed')) {
            //                             storage.boss[i] = mode.characterPack.mode_boss[i];
            //                         }
            //                     }
            //                     loadversus();
            //                 });
            //             }
            //             else {
            //                 localStorage.removeItem('boss_storage_playpackconfig');
            //             }
            //         }
            //     },
            //     intro: {
            //         name: '将剑阁和挑战模式的武将添加到其它模式',
            //         clear: true,
            //         nopointer: true,
            //     },
            //     enableai: {
            //         name: '随机选将可用',
            //         init: false
            //     },
            //     hide: {
            //         name: '隐藏此扩展',
            //         clear: true,
            //         onclick: function () {
            //             if (this.firstChild.innerHTML == '隐藏此扩展') {
            //                 this.firstChild.innerHTML = '此扩展将在重启后隐藏';
            //                 lib.config.hiddenPlayPack.add('boss');
            //                 if (!lib.config.prompt_hidepack) {
            //                     alert('隐藏的扩展包可通过选项-其它-重置隐藏内容恢复');
            //                     game.saveConfig('prompt_hidepack', true);
            //                 }
            //             }
            //             else {
            //                 this.firstChild.innerHTML = '隐藏此扩展';
            //                 lib.config.hiddenPlayPack.remove('boss');
            //             }
            //             game.saveConfig('hiddenPlayPack', lib.config.hiddenPlayPack);
            //         }
            //     },
            // },
            wuxing: {
                enable: {
                    name: '开启',
                    init: false,
                    restart: true
                },
                intro: {
                    name: '每名角色和部分卡牌在游戏开始时随机获得一个属性',
                    clear: true,
                    nopointer: true
                },
                num: {
                    name: '带属性卡牌',
                    init: '0.3',
                    item: {
                        '0.1': '10%',
                        '0.2': '20%',
                        '0.3': '30%',
                        '0.5': '50%'
                    }
                },
                hide: {
                    name: '隐藏此扩展',
                    clear: true,
                    onclick: function () {
                        if (this.firstChild.innerHTML == '隐藏此扩展') {
                            this.firstChild.innerHTML = '此扩展将在重启后隐藏';
                            lib.config.hiddenPlayPack.add('wuxing');
                            if (!lib.config.prompt_hidepack) {
                                alert('隐藏的扩展包可通过选项-其它-重置隐藏内容恢复');
                                game.saveConfig('prompt_hidepack', true);
                            }
                        }
                        else {
                            this.firstChild.innerHTML = '隐藏此扩展';
                            lib.config.hiddenPlayPack.remove('wuxing');
                        }
                        game.saveConfig('hiddenPlayPack', lib.config.hiddenPlayPack);
                    }
                }
            },
            coin: {
                enable: {
                    name: '开启',
                    init: false,
                    restart: true,
                    onclick: function (bool) {
                        if (bool) {
                            lib.config.plays.add('coin');
                        }
                        else {
                            lib.config.plays.remove('coin');
                        }
                        game.saveConfig('plays', lib.config.plays);
                    }
                },
                intro: {
                    name: '每完成一次对局，可获得一定数量的金币；金币可用于购买游戏特效',
                    clear: true,
                    nopointer: true
                },
                display: {
                    name: '金币显示',
                    init: 'text',
                    item: {
                        symbol: '符号',
                        text: '文字'
                    },
                    onclick: function (item) {
                        game.saveConfig('coin_display_playpackconfig', item);
                        if (game.changeCoin)
                            game.changeCoin(0);
                    }
                },
                canvas: {
                    name: '特效置顶',
                    init: false,
                    onclick: function (bool) {
                        game.saveConfig('coin_canvas_playpackconfig', bool);
                        if (bool) {
                            ui.window.classList.add('canvas_top');
                        }
                        else {
                            ui.window.classList.remove('canvas_top');
                        }
                    }
                },
                hide: {
                    name: '隐藏此扩展',
                    clear: true,
                    onclick: function () {
                        if (this.firstChild.innerHTML == '隐藏此扩展') {
                            this.firstChild.innerHTML = '此扩展将在重启后隐藏';
                            lib.config.hiddenPlayPack.add('coin');
                            if (!lib.config.prompt_hidepack) {
                                alert('隐藏的扩展包可通过选项-其它-重置隐藏内容恢复');
                                game.saveConfig('prompt_hidepack', true);
                            }
                        }
                        else {
                            this.firstChild.innerHTML = '隐藏此扩展';
                            lib.config.hiddenPlayPack.remove('coin');
                        }
                        game.saveConfig('hiddenPlayPack', lib.config.hiddenPlayPack);
                    }
                }
            }
        },
        /**
         * 游戏模式菜单
         * @name configMenu.mode
         * @type {!Object}
         */
        mode: {
            //引导
            yindao: {
                name: '引导',
                config: {
                    update: function (config, map) {
                    }
                }
            },
            // richer: {
            //     name: '大富翁',
            //     connect: {
            //         connect_player_number: {
            //             name: '游戏人数',
            //             init: '6',
            //             item: {
            //                 '2': '两人',
            //                 '3': '三人',
            //                 '4': '四人',
            //                 '5': '五人',
            //                 '6': '六人',
            //             },
            //             frequent: true,
            //             restart: true,
            //         },
            //         update: function (config, map) {
            //         },
            //         connect_show_range: {
            //             name: '显示卡牌范围',
            //             init: true,
            //         },
            //         // connect_show_distance:{
            //         // 	name:'显示距离',
            //         // 	init:true,
            //         // },
            //         connect_chessscroll_speed: {
            //             name: '边缘滚动速度',
            //             init: '20',
            //             intro: '鼠标移至屏幕边缘时自动滚屏',
            //             item: {
            //                 '0': '不滚动',
            //                 '10': '10格/秒',
            //                 '20': '20格/秒',
            //                 '30': '30格/秒',
            //             }
            //         },
            //     },
            //     config: {
            //         player_number: {
            //             name: '游戏人数',
            //             init: '6',
            //             item: {
            //                 '2': '两人',
            //                 '3': '三人',
            //                 '4': '四人',
            //                 '5': '五人',
            //                 '6': '六人',
            //             },
            //             frequent: true,
            //             restart: true,
            //         },
            //         update: function (config, map) {
            //             switch (config.player_number) {
            //                 case 4:
            //                 case 6: {
            //                     map.team_number.show();
            //                     break;
            //                 }
            //                 default: {
            //                     map.team_number.hide();
            //                     break;
            //                 }
            //             }
            //         },
            //         show_range: {
            //             name: '显示卡牌范围',
            //             init: true,
            //         },
            //         team_number: {
            //             name: '每队人数',
            //             init: '1',
            //             item: {
            //                 '1': '单人',
            //                 '2': '两人',
            //             },
            //             frequent: true,
            //             restart: true,
            //         },
            //         chessscroll_speed: {
            //             name: '边缘滚动速度',
            //             init: '20',
            //             intro: '鼠标移至屏幕边缘时自动滚屏',
            //             item: {
            //                 '0': '不滚动',
            //                 '10': '10格/秒',
            //                 '20': '20格/秒',
            //                 '30': '30格/秒',
            //             }
            //         },
            //     }
            // },
            identity: {
                name: '身份',
                connect: {
                    update: function (config, map) {
                        if (config.connect_identity_mode == 'zhong') {
                            map.connect_change_choice.hide();
                            map.choice_ex.hide();
                            map.connect_player_number.hide();
                            map.connect_enhance_zhu.hide();
                            map.connect_double_nei.hide();
                            map.connect_zhong_card.show();
                            map.connect_special_identity.hide();
                            map.connect_double_character.show();
                        }
                        else if (config.connect_identity_mode == 'purple') {
                            map.connect_change_choice.hide();
                            map.choice_ex.hide();
                            map.connect_player_number.hide();
                            map.connect_enhance_zhu.hide();
                            map.connect_double_nei.hide();
                            map.connect_zhong_card.hide();
                            map.connect_special_identity.hide();
                            map.connect_double_character.hide();
                        }
                        else {
                            map.connect_change_choice.show();
                            map.choice_ex.show();
                            map.connect_double_character.show();
                            map.connect_player_number.show();
                            map.connect_enhance_zhu.show();
                            if (config.connect_player_number != '2') {
                                map.connect_double_nei.show();
                            }
                            else {
                                map.connect_double_nei.hide();
                            }
                            map.connect_zhong_card.hide();
                            if (config.connect_player_number == '8') {
                                map.connect_special_identity.show();
                            }
                            else {
                                map.connect_special_identity.hide();
                            }
                        }
                    },
                    connect_identity_mode: {
                        name: '游戏模式',
                        init: 'normal',
                        item: {
                            normal: '标准',
                            zhong: '明忠',
                            purple: '3v3v2'
                        },
                        restart: true,
                        frequent: true,
                        intro: '明忠模式和3v3v2模式详见帮助'
                    },
                    connect_player_number: {
                        name: '游戏人数',
                        init: '8',
                        item: {
                            '2': '两人',
                            '3': '三人',
                            '4': '四人',
                            '5': '五人',
                            '6': '六人',
                            '7': '七人',
                            '8': '八人'
                        },
                        frequent: true,
                        restart: true
                    },
                    connect_zhong_card: {
                        name: '明忠卡牌替换',
                        init: true,
                        frequent: true,
                        restart: true
                    },
                    connect_double_nei: {
                        name: '双内奸',
                        init: false,
                        restart: true,
                        // frequent:true,
                        intro: '开启后游戏中将有两个内奸（内奸胜利条件仍为主内1v1时击杀主公）'
                    },
                    connect_double_character: {
                        name: '双将模式',
                        init: false,
                        frequent: true,
                        restart: true
                    },
                    connect_change_card: {
                        name: '启用手气卡',
                        init: false,
                        frequent: true,
                        restart: true
                    },
                    connect_change_choice: {
                        name: '点将模式',
                        init: false,
                        frequent: true,
                        restart: true
                    },
                    connect_special_identity: {
                        name: '特殊身份',
                        init: false,
                        restart: true,
                        frequent: true,
                        intro: '开启后游戏中将增加军师、大将、贼首三个身份'
                    },
                    // connect_ban_weak:{
                    //     name:'屏蔽弱将',
                    //     init:true,
                    //     restart:true,
                    // },
                    // connect_ban_strong:{
                    //     name:'屏蔽强将',
                    //     init:false,
                    //     restart:true,
                    // },
                    connect_enhance_zhu: {
                        name: '加强主公',
                        init: false,
                        restart: true,
                        intro: '为主公增加一个额外技能'
                    },
                    choice_ex: {
                        name: '额外选将框',
                        init: '0',
                        restart: true,
                        item: {
                            '0': '关闭',
                            '1': '一',
                            '3': '三',
                            '5': '五',
                            '7': '七',
                            '9': '九'
                        },
                        intro: '为所有玩家分配额外选将框'
                    },
                    card_remark: {
                        name: '装备回调',
                        init: false,
                        frequent: true,
                        restart: true,
                        intro: '将军争和基础包的装备牌回调至《三国杀》原版'
                    }
                },
                config: {
                    update: function (config, map) {
                        if (config.identity_mode == 'zhong') {
                            map.player_number.hide();
                            map.enhance_zhu.hide();
                            map.double_nei.hide();
                            map.auto_identity.hide();
                            map.choice_ex.hide();
                            map.choice_zhu.hide();
                            map.choice_zhong.hide();
                            map.choice_nei.hide();
                            map.choice_fan.hide();
                            map.ban_identity.hide();
                            map.ban_identity2.hide();
                            map.ban_identity3.hide();
                            map.zhong_card.show();
                            map.special_identity.hide();
                            map.choose_group.show();
                            map.change_choice.show();
                            map.auto_mark_identity.show();
                            map.double_character.show();
                            map.free_choose.show();
                            map.change_identity.show();
                            if (config.double_character) {
                                map.double_hp.show();
                            }
                            else {
                                map.double_hp.hide();
                            }
                            map.continue_game.show();
                        }
                        else if (config.identity_mode == 'purple') {
                            map.player_number.hide();
                            map.enhance_zhu.hide();
                            map.double_nei.hide();
                            map.auto_identity.hide();
                            map.choice_ex.hide();
                            map.choice_zhu.hide();
                            map.choice_zhong.hide();
                            map.choice_nei.hide();
                            map.choice_fan.hide();
                            map.ban_identity.hide();
                            map.ban_identity2.hide();
                            map.ban_identity3.hide();
                            map.zhong_card.hide();
                            map.special_identity.hide();
                            map.double_character.hide();
                            map.double_hp.hide();
                            map.choose_group.hide();
                            map.auto_mark_identity.hide();
                            map.change_choice.hide();
                            map.free_choose.hide();
                            map.change_identity.hide();
                            map.continue_game.hide();
                        }
                        else {
                            map.continue_game.show();
                            map.player_number.show();
                            map.enhance_zhu.show();
                            map.auto_identity.show();
                            if (config.player_number != '2') {
                                map.double_nei.show();
                            }
                            else {
                                map.double_nei.hide();
                            }
                            map.choice_ex.show();
                            map.choice_zhu.show();
                            map.choice_zhong.show();
                            map.choice_nei.show();
                            map.choice_fan.show();
                            map.ban_identity.show();
                            if (config.ban_identity == 'off') {
                                map.ban_identity2.hide();
                            }
                            else {
                                map.ban_identity2.show();
                            }
                            if (config.ban_identity == 'off' || config.ban_identity2 == 'off') {
                                map.ban_identity3.hide();
                            }
                            else {
                                map.ban_identity3.show();
                            }
                            map.zhong_card.hide();
                            map.choose_group.show();
                            map.auto_mark_identity.show();
                            map.change_choice.show();
                            map.free_choose.show();
                            map.change_identity.show();
                            if (config.player_number == '8') {
                                map.special_identity.show();
                            }
                            else {
                                map.special_identity.hide();
                            }
                            map.double_character.show();
                            if (config.double_character) {
                                map.double_hp.show();
                            }
                            else {
                                map.double_hp.hide();
                            }
                        }
                    },
                    identity_mode: {
                        name: '游戏模式',
                        init: 'normal',
                        item: {
                            normal: '标准',
                            zhong: '明忠',
                            purple: '3v3v2'
                        },
                        restart: true,
                        frequent: true,
                        intro: '明忠模式详见帮助'
                    },
                    player_number: {
                        name: '游戏人数',
                        init: '3',
                        item: {
                            '2': '两人',
                            '3': '三人',
                            '4': '四人',
                            '5': '五人',
                            '6': '六人',
                            '7': '七人',
                            '8': '八人'
                        },
                        frequent: true,
                        restart: true
                    },
                    double_nei: {
                        name: '双内奸',
                        init: false,
                        restart: true,
                        frequent: true,
                        intro: '开启后游戏中将有两个内奸（内奸胜利条件仍为主内1v1时击杀主公）'
                    },
                    choose_group: {
                        name: '神武将选择势力',
                        init: true,
                        restart: true,
                        frequent: true,
                        intro: '若开启此选项，选择神武将的玩家需在亮出自己的武将牌之前为自己选择一个势力。'
                    },
                    nei_fullscreenpop: {
                        name: '主内单挑特效',
                        intro: '在进入主内单挑时，弹出全屏文字特效',
                        init: true,
                        unfrequent: true
                    },
                    double_character: {
                        name: '双将模式',
                        init: false,
                        frequent: true,
                        restart: true
                    },
                    special_identity: {
                        name: '特殊身份',
                        init: false,
                        restart: true,
                        frequent: true,
                        intro: '开启后游戏中将增加军师、大将、贼首三个身份'
                    },
                    zhong_card: {
                        name: '明忠卡牌替换',
                        init: true,
                        frequent: true,
                        restart: true
                    },
                    double_hp: {
                        name: '双将体力上限',
                        init: 'pingjun',
                        item: {
                            hejiansan: '和减三',
                            pingjun: '平均值',
                            zuidazhi: '最大值',
                            zuixiaozhi: '最小值',
                            zonghe: '相加'
                        },
                        restart: true
                    },
                    auto_identity: {
                        name: '自动显示身份',
                        item: {
                            off: '关闭',
                            one: '一轮',
                            two: '两轮',
                            three: '三轮',
                            always: '始终'
                        },
                        init: 'off',
                        onclick: function (bool) {
                            game.saveConfig('auto_identity', bool, this._link.config.mode);
                            if (get.config('identity_mode') == 'zhong')
                                return;
                            var num;
                            switch (bool) {
                                case '一轮':
                                    num = 1;
                                    break;
                                case '两轮':
                                    num = 2;
                                    break;
                                case '三轮':
                                    num = 3;
                                    break;
                                default:
                                    num = 0;
                                    break;
                            }
                            if (num & !_status.identityShown && game.phaseNumber > game.players.length * num && game.showIdentity) {
                                _status.identityShown = true;
                                game.showIdentity(false);
                            }
                        },
                        intro: '游戏进行若干轮将自动显示所有角色的身份'
                    },
                    auto_mark_identity: {
                        name: '自动标记身份',
                        init: true,
                        intro: '根据角色的出牌行为自动标记可能的身份'
                    },
                    // ban_weak:{
                    //     name:'屏蔽弱将',
                    //     init:true,
                    //     restart:true,
                    // },
                    // ban_strong:{
                    //     name:'屏蔽强将',
                    //     init:false,
                    //     restart:true,
                    // },
                    enhance_zhu: {
                        name: '加强主公',
                        init: false,
                        restart: true,
                        intro: '为主公增加一个额外技能'
                    },
                    free_choose: {
                        name: '自由选将',
                        init: true,
                        onclick: function (bool) {
                            game.saveConfig('free_choose', bool, this._link.config.mode);
                            if (!_status.event.getParent().showConfig && !_status.event.showConfig)
                                return;
                            if (!ui.cheat2 && get.config('free_choose'))
                                ui.create.cheat2();
                            else if (ui.cheat2 && !get.config('free_choose')) {
                                ui.cheat2.close();
                                delete ui.cheat2;
                            }
                        }
                    },
                    change_identity: {
                        name: '自由选择身份和座位',
                        init: true,
                        onclick: function (bool) {
                            game.saveConfig('change_identity', bool, this._link.config.mode);
                            if (!_status.event.getParent().showConfig && !_status.event.showConfig)
                                return;
                            var dialog;
                            if (ui.cheat2 && ui.cheat2.backup)
                                dialog = ui.cheat2.backup;
                            else
                                dialog = _status.event.dialog;
                            if (!_status.brawl || !_status.brawl.noAddSetting) {
                                if (!dialog.querySelector('table') && get.config('change_identity'))
                                    _status.event.getParent().addSetting(dialog);
                                else
                                    _status.event.getParent().removeSetting(dialog);
                            }
                            ui.update();
                        }
                    },
                    change_choice: {
                        name: '开启换将卡',
                        init: true,
                        onclick: function (bool) {
                            game.saveConfig('change_choice', bool, this._link.config.mode);
                            if (!_status.event.getParent().showConfig && !_status.event.showConfig)
                                return;
                            if (!ui.cheat && get.config('change_choice'))
                                ui.create.cheat();
                            else if (ui.cheat && !get.config('change_choice')) {
                                ui.cheat.close();
                                delete ui.cheat;
                            }
                        }
                    },
                    change_card: {
                        name: '开启手气卡',
                        init: 'disabled',
                        item: {
                            disabled: '禁用',
                            once: '一次',
                            twice: '两次',
                            unlimited: '无限'
                        }
                    },
                    continue_game: {
                        name: '显示再战',
                        init: false,
                        onclick: function (bool) {
                            game.saveConfig('continue_game', bool, this._link.config.mode);
                            if (get.config('continue_game')) {
                                if (!ui.continue_game && _status.over && !_status.brawl && !game.no_continue_game) {
                                    ui.continue_game = ui.create.control('再战', game.reloadCurrent);
                                }
                            }
                            else if (ui.continue_game) {
                                ui.continue_game.close();
                                delete ui.continue_game;
                            }
                        },
                        intro: '游戏结束后可选择用相同的武将再进行一局游戏'
                    },
                    dierestart: {
                        name: '死亡后显示重来',
                        init: true,
                        onclick: function (bool) {
                            game.saveConfig('dierestart', bool, this._link.config.mode);
                            if (get.config('dierestart')) {
                                if (!ui.restart && game.me.isDead() && !_status.connectMode) {
                                    ui.restart = ui.create.control('restart', game.reload);
                                }
                            }
                            else if (ui.restart) {
                                ui.restart.close();
                                delete ui.restart;
                            }
                        }
                    },
                    revive: {
                        name: '死亡后显示复活',
                        init: false,
                        onclick: function (bool) {
                            game.saveConfig('revive', bool, this._link.config.mode);
                            if (get.config('revive')) {
                                if (!ui.revive && game.me.isDead()) {
                                    ui.revive = ui.create.control('revive', ui.click.dierevive);
                                }
                            }
                            else if (ui.revive) {
                                ui.revive.close();
                                delete ui.revive;
                            }
                        }
                    },
                    ban_identity: {
                        name: '屏蔽身份',
                        init: 'off',
                        item: {
                            off: '关闭',
                            zhu: '主公',
                            zhong: '忠臣',
                            nei: '内奸',
                            fan: '反贼'
                        }
                    },
                    ban_identity2: {
                        name: '屏蔽身份2',
                        init: 'off',
                        item: {
                            off: '关闭',
                            zhu: '主公',
                            zhong: '忠臣',
                            nei: '内奸',
                            fan: '反贼'
                        }
                    },
                    ban_identity3: {
                        name: '屏蔽身份3',
                        init: 'off',
                        item: {
                            off: '关闭',
                            zhu: '主公',
                            zhong: '忠臣',
                            nei: '内奸',
                            fan: '反贼'
                        }
                    },
                    ai_strategy: {
                        name: '内奸策略',
                        init: 'ai_strategy_1',
                        item: {
                            ai_strategy_1: '均衡',
                            ai_strategy_2: '偏反',
                            ai_strategy_3: '偏忠',
                            ai_strategy_4: '酱油',
                            ai_strategy_5: '天使',
                            ai_strategy_6: '仇主'
                        },
                        intro: '设置内奸对主忠反的态度'
                    },
                    difficulty: {
                        name: 'AI对人类态度',
                        init: 'normal',
                        item: {
                            easy: '友好',
                            normal: '一般',
                            hard: '仇视'
                        }
                    },
                    choice_ex: {
                        name: '额外选将框',
                        init: '0',
                        restart: true,
                        item: {
                            '0': '关闭',
                            '1': '一',
                            '2': '二',
                            '4': '四',
                            '6': '六',
                            '8': '八'
                        },
                        intro: '为所有玩家分配额外选将框'
                    },
                    choice_zhu: {
                        name: '主公候选武将数',
                        init: '3',
                        restart: true,
                        item: {
                            '3': '三',
                            '4': '四',
                            '5': '五',
                            '6': '六',
                            '8': '八',
                            '10': '十'
                        }
                    },
                    choice_zhong: {
                        name: '忠臣候选武将数',
                        init: '4',
                        restart: true,
                        item: {
                            '3': '三',
                            '4': '四',
                            '5': '五',
                            '6': '六',
                            '8': '八',
                            '10': '十'
                        }
                    },
                    choice_nei: {
                        name: '内奸候选武将数',
                        init: '5',
                        restart: true,
                        item: {
                            '3': '三',
                            '4': '四',
                            '5': '五',
                            '6': '六',
                            '8': '八',
                            '10': '十'
                        }
                    },
                    choice_fan: {
                        name: '反贼候选武将数',
                        init: '3',
                        restart: true,
                        item: {
                            '3': '三',
                            '4': '四',
                            '5': '五',
                            '6': '六',
                            '8': '八',
                            '10': '十'
                        }
                    },
                    card_remark: {
                        name: '装备回调',
                        init: false,
                        frequent: true,
                        restart: true,
                        intro: '将军争和基础包的装备牌回调至《三国杀》原版'
                    }
                }
            },
            guozhan: {
                name: '国战',
                connect: {
                    update: function (config, map) {
                        if (config.connect_onlyguozhan) {
                            map.connect_junzhu.show();
                        }
                        else {
                            map.connect_junzhu.hide();
                        }
                    },
                    connect_guozhan_mode: {
                        name: '游戏模式',
                        init: 'normal',
                        item: {
                            normal: '势备',
                            yingbian: '应变',
                            old: '怀旧'
                        },
                        frequent: true,
                        restart: true,
                        intro: '<li>势备：默认模式，使用线下《君临天下·势备篇》的牌堆进行游戏。<br><li>应变：使用OL的应变国战牌堆进行游戏。<br><li>怀旧：使用传统国战的牌堆进行游戏。'
                    },
                    connect_player_number: {
                        name: '游戏人数',
                        init: '8',
                        item: {
                            '3': '三人',
                            '4': '四人',
                            '5': '五人',
                            '6': '六人',
                            '7': '七人',
                            '8': '八人'
                        },
                        frequent: true,
                        restart: true
                    },
                    connect_initshow_draw: {
                        name: '首亮奖励',
                        item: {
                            'off': '关闭',
                            'draw': '摸牌',
                            'mark': '标记'
                        },
                        init: 'mark',
                        frequent: true,
                        intro: '第一个明置武将牌的角色可获得首亮奖励'
                    },
                    connect_aozhan: {
                        name: '鏖战模式',
                        init: true,
                        intro: '若开启此选项，则将在游戏中引入“鏖战模式”的规则：<br>当游戏中仅剩四名或更少角色时（七人以下游戏时改为三名或更少），若此时全场没有超过一名势力相同的角色，则从一个新的回合开始，游戏进入鏖战模式直至游戏结束。<br>◇在鏖战模式下，【桃】只能当做【杀】或【闪】使用或打出，不能用来回复体力。<br>注：进入鏖战模式后，即使之后有两名或者更多势力相同的角色出现，仍然不会取消鏖战模式。',
                        frequent: true,
                        restart: true
                    },
                    connect_viewnext: {
                        name: '观看下家副将',
                        init: false,
                        intro: '若开启此选项，所有的玩家将在挑选武将后，分发起始手牌之前，分别观看自己下家的副将。'
                    },
                    connect_zhulian: {
                        name: '珠联璧合',
                        init: true,
                        // frequent:true,
                        intro: '主将和副将都明置后，若为特定组合，可获得【珠联璧合】标记'
                    },
                    connect_junzhu: {
                        name: '替换君主',
                        init: true,
                        // frequent:true,
                        restart: true,
                        intro: '若开启此选项，玩家的第一个回合开始时，若其主武将牌有对应的君主武将牌，则其可以将此武将牌替换为对应的君主武将牌，然后重新调整体力上限。若玩家的体力上限因此增大，则玩家回复等量的体力。'
                    },
                    connect_change_card: {
                        name: '启用手气卡',
                        init: false,
                        frequent: true,
                        restart: true
                    },
                    card_remark: {
                        name: '装备回调',
                        init: false,
                        frequent: true,
                        restart: true,
                        intro: '将军争和基础包的装备牌回调至《三国杀》原版'
                    }
                    // connect_ban_weak:{
                    //     name:'屏蔽弱将',
                    //     init:false,
                    //     restart:true,
                    // },
                    // connect_ban_strong:{
                    //     name:'屏蔽强将',
                    //     init:false,
                    //     restart:true,
                    // },
                },
                config: {
                    update: function (config, map) {
                        if (config.onlyguozhan) {
                            map.junzhu.show();
                        }
                        else {
                            map.junzhu.hide();
                        }
                    },
                    guozhan_mode: {
                        name: '游戏模式',
                        init: 'normal',
                        item: {
                            normal: '势备',
                            yingbian: '应变',
                            old: '怀旧',
                            free: '自由'
                        },
                        frequent: true,
                        restart: true,
                        intro: '<li>势备：默认模式，使用线下《君临天下·势备篇》的牌堆进行游戏。<br><li>应变：使用OL的应变国战牌堆进行游戏。<br><li>怀旧：使用传统国战的牌堆进行游戏。<br><li>自由：使用玩家的自定义牌堆进行游戏。'
                    },
                    player_number: {
                        name: '游戏人数',
                        init: '8',
                        item: {
                            '3': '三人',
                            '4': '四人',
                            '5': '五人',
                            '6': '六人',
                            '7': '七人',
                            '8': '八人'
                        },
                        frequent: true,
                        restart: true
                    },
                    initshow_draw: {
                        name: '首亮奖励',
                        item: {
                            'off': '关闭',
                            'draw': '摸牌',
                            'mark': '标记'
                        },
                        init: 'mark',
                        frequent: true,
                        intro: '第一个明置身份牌的角色可获得摸牌奖励'
                    },
                    aozhan: {
                        name: '鏖战模式',
                        init: true,
                        frequent: true,
                        restart: true,
                        intro: '若开启此选项，则将在游戏中引入“鏖战模式”的规则：<br>当游戏中仅剩四名或更少角色时（七人以下游戏时改为三名或更少），若此时全场没有超过一名势力相同的角色，则从一个新的回合开始，游戏进入鏖战模式直至游戏结束。<br>◇在鏖战模式下，【桃】只能当做【杀】或【闪】使用或打出，不能用来回复体力。<br>注：进入鏖战模式后，即使之后有两名或者更多势力相同的角色出现，仍然不会取消鏖战模式。'
                    },
                    viewnext: {
                        name: '观看下家副将',
                        init: false,
                        intro: '若开启此选项，所有的玩家将在挑选武将后，分发起始手牌之前，分别观看自己下家的副将。'
                    },
                    aozhan_bgm: {
                        name: '鏖战背景音乐',
                        item: {
                            disabled: '不启用',
                            online: 'Online',
                            rewrite: 'Rewrite',
                            chaoming: '潮鸣'
                        },
                        init: 'rewrite',
                        onclick: function (item) {
                            game.saveConfig('aozhan_bgm', item, this._link.config.mode);
                            if (_status._aozhan == true)
                                game.playBackgroundMusic();
                        }
                    },
                    zhulian: {
                        name: '珠联璧合',
                        init: true,
                        // frequent:true,
                        intro: '主将和副将都明置后，若为特定组合，可获得【珠联璧合】标记'
                    },
                    changeViceType: {
                        name: '副将变更方式',
                        init: 'default',
                        item: {
                            "default": '发现式',
                            online: '随机式'
                        },
                        frequent: true,
                        restart: true
                    },
                    onlyguozhan: {
                        name: '使用国战武将',
                        init: true,
                        frequent: true,
                        restart: true,
                        intro: '开启武将技能将替换为国战版本并禁用非国战武将'
                    },
                    guozhanSkin: {
                        name: '使用国战皮肤',
                        init: true,
                        frequent: true,
                        restart: true,
                        intro: '开启此选项后，将会把有国战专属皮肤的武将替换为国战皮肤'
                    },
                    junzhu: {
                        name: '替换君主',
                        init: true,
                        // frequent:true,
                        restart: true,
                        intro: '若开启此选项，玩家的第一个回合开始时，若其主武将牌有对应的君主武将牌，则其可以将此武将牌替换为对应的君主武将牌，然后重新调整体力上限。若玩家的体力上限因此增大，则玩家回复等量的体力。'
                    },
                    double_hp: {
                        name: '双将体力上限',
                        init: 'pingjun',
                        item: {
                            hejiansan: '和减三',
                            pingjun: '平均值',
                            zuidazhi: '最大值',
                            zuixiaozhi: '最小值',
                            zonghe: '相加'
                        },
                        restart: true
                    },
                    // ban_weak:{
                    //     name:'屏蔽弱将',
                    //     init:true,
                    //     restart:true,
                    // },
                    // ban_strong:{
                    //     name:'屏蔽强将',
                    //     init:false,
                    //     restart:true,
                    // },
                    free_choose: {
                        name: '自由选将',
                        init: true,
                        onclick: function (bool) {
                            game.saveConfig('free_choose', bool, this._link.config.mode);
                            if (!_status.event.getParent().showConfig && !_status.event.showConfig)
                                return;
                            if (!ui.cheat2 && get.config('free_choose'))
                                ui.create.cheat2();
                            else if (ui.cheat2 && !get.config('free_choose')) {
                                ui.cheat2.close();
                                delete ui.cheat2;
                            }
                        }
                    },
                    onlyguozhanexpand: {
                        name: '默认展开自由选将',
                        init: false,
                        restart: true,
                        intro: '开启后自由选将对话框将默认显示全部武将'
                    },
                    change_identity: {
                        name: '自由选择座位',
                        init: true,
                        onclick: function (bool) {
                            game.saveConfig('change_identity', bool, this._link.config.mode);
                            if (!_status.event.getParent().showConfig && !_status.event.showConfig)
                                return;
                            var dialog;
                            if (ui.cheat2 && ui.cheat2.backup)
                                dialog = ui.cheat2.backup;
                            else
                                dialog = _status.event.dialog;
                            if (!_status.brawl || !_status.brawl.noAddSetting) {
                                if (!dialog.querySelector('table') && get.config('change_identity'))
                                    _status.event.getParent().addSetting(dialog);
                                else
                                    _status.event.getParent().removeSetting(dialog);
                            }
                            ui.update();
                        }
                    },
                    change_choice: {
                        name: '开启换将卡',
                        init: true,
                        onclick: function (bool) {
                            game.saveConfig('change_choice', bool, this._link.config.mode);
                            if (!_status.event.getParent().showConfig && !_status.event.showConfig)
                                return;
                            if (!ui.cheat && get.config('change_choice'))
                                ui.create.cheat();
                            else if (ui.cheat && !get.config('change_choice')) {
                                ui.cheat.close();
                                delete ui.cheat;
                            }
                        }
                    },
                    change_card: {
                        name: '开启手气卡',
                        init: 'disabled',
                        item: {
                            disabled: '禁用',
                            once: '一次',
                            twice: '两次',
                            unlimited: '无限'
                        }
                    },
                    continue_game: {
                        name: '显示再战',
                        init: true,
                        intro: '游戏结束后可选择用相同的武将再进行一局游戏',
                        onclick: function (bool) {
                            game.saveConfig('continue_game', bool, this._link.config.mode);
                            if (get.config('continue_game')) {
                                if (!ui.continue_game && _status.over && !_status.brawl && !game.no_continue_game) {
                                    ui.continue_game = ui.create.control('再战', game.reloadCurrent);
                                }
                            }
                            else if (ui.continue_game) {
                                ui.continue_game.close();
                                delete ui.continue_game;
                            }
                        }
                    },
                    dierestart: {
                        name: '死亡后显示重来',
                        init: true,
                        onclick: function (bool) {
                            game.saveConfig('dierestart', bool, this._link.config.mode);
                            if (get.config('dierestart')) {
                                if (!ui.restart && game.me.isDead() && !_status.connectMode) {
                                    ui.restart = ui.create.control('restart', game.reload);
                                }
                            }
                            else if (ui.restart) {
                                ui.restart.close();
                                delete ui.restart;
                            }
                        }
                    },
                    revive: {
                        name: '死亡后显示复活',
                        init: false,
                        onclick: function (bool) {
                            game.saveConfig('revive', bool, this._link.config.mode);
                            if (get.config('revive')) {
                                if (!ui.revive && game.me.isDead()) {
                                    ui.revive = ui.create.control('revive', ui.click.dierevive);
                                }
                            }
                            else if (ui.revive) {
                                ui.revive.close();
                                delete ui.revive;
                            }
                        }
                    },
                    difficulty: {
                        name: 'AI对人类态度',
                        init: 'normal',
                        item: {
                            easy: '友好',
                            normal: '一般',
                            hard: '仇视'
                        }
                    },
                    choice_num: {
                        name: '候选武将数',
                        init: '7',
                        restart: true,
                        item: {
                            '5': '五',
                            '6': '六',
                            '7': '七',
                            '8': '八',
                            '9': '九',
                            '10': '十'
                        }
                    },
                    card_remark: {
                        name: '装备回调',
                        init: false,
                        frequent: true,
                        restart: true,
                        intro: '将军争和基础包的装备牌回调至《三国杀》原版'
                    }
                }
            },
            versus: {
                name: '对决',
                connect: {
                    update: function (config, map) {
                        if (config.connect_versus_mode == '1v1') {
                            map.connect_choice_num.show();
                            map.connect_replace_number.show();
                        }
                        else {
                            map.connect_choice_num.hide();
                            map.connect_replace_number.hide();
                        }
                        if (config.connect_versus_mode == '2v2' || config.connect_versus_mode == '3v3') {
                            map.connect_replace_handcard.show();
                        }
                        else {
                            map.connect_replace_handcard.hide();
                        }
                    },
                    connect_versus_mode: {
                        name: '游戏模式',
                        init: '1v1',
                        item: {
                            '1v1': '1v1',
                            '2v2': '2v2',
                            '3v3': '3v3',
                            '4v4': '4v4'
                        },
                        frequent: true
                    },
                    connect_replace_handcard: {
                        name: '四号位保护',
                        init: true,
                        frequent: true,
                        intro: '最后行动的角色起始手牌数+1'
                    },
                    connect_choice_num: {
                        name: '侯选武将数',
                        init: '20',
                        frequent: true,
                        item: {
                            '12': '12人',
                            '16': '16人',
                            '20': '20人',
                            '24': '24人',
                            '40': '40人'
                        }
                    },
                    connect_replace_number: {
                        name: '替补人数',
                        init: '2',
                        frequent: true,
                        item: {
                            '0': '无',
                            '1': '1人',
                            '2': '2人',
                            '3': '3人',
                            '4': '4人',
                            '5': '5人'
                        }
                    }
                },
                config: {
                    update: function (config, map) {
                        if (config.versus_mode == 'four') {
                            map.change_choice.hide();
                            map.ladder.show();
                            if (config.ladder) {
                                map.ladder_monthly.show();
                                map.ladder_reset.show();
                            }
                            else {
                                map.ladder_monthly.hide();
                                map.ladder_reset.hide();
                            }
                            map.enable_all.show();
                            map.enable_all_cards_four.show();
                            map.four_assign.show();
                            map.four_phaseswap.show();
                            map.expand_dialog.show();
                            map.fouralign.show();
                        }
                        else {
                            map.change_choice.show();
                            map.ladder.hide();
                            map.ladder_monthly.hide();
                            map.ladder_reset.hide();
                            map.enable_all.hide();
                            map.enable_all_cards_four.hide();
                            map.four_assign.hide();
                            map.four_phaseswap.hide();
                            map.expand_dialog.hide();
                            map.fouralign.hide();
                        }
                        if (config.versus_mode == 'three') {
                            map.edit_character_three.show();
                        }
                        else {
                            map.edit_character_three.hide();
                        }
                        if (config.versus_mode == 'three' || config.versus_mode == 'one') {
                            map.enable_all_three.show();
                            map.enable_all_cards.show();
                        }
                        else {
                            map.enable_all_three.hide();
                            map.enable_all_cards.hide();
                        }
                        if (config.versus_mode == 'jiange' || config.versus_mode == 'two' || config.versus_mode == 'endless' ||
                            config.versus_mode == 'three' || config.versus_mode == 'one' || config.versus_mode == 'siguo') {
                            map.free_choose.show();
                        }
                        else {
                            map.free_choose.hide();
                        }
                        if (config.versus_mode == 'jiange') {
                            map.double_character_jiange.show();
                        }
                        else {
                            map.double_character_jiange.hide();
                        }
                        if (config.versus_mode == 'two') {
                            map.replace_handcard_two.show();
                            map.replace_character_two.show();
                            map.two_assign.show();
                            map.two_phaseswap.show();
                        }
                        else {
                            map.replace_handcard_two.hide();
                            map.replace_character_two.hide();
                            map.two_assign.hide();
                            map.two_phaseswap.hide();
                        }
                        if (config.versus_mode == 'two' || config.versus_mode == 'siguo' || config.versus_mode == 'four') {
                            if (config.versus_mode == 'four' && (config.four_assign || config.four_phaseswap)) {
                                map.change_identity.hide();
                            }
                            else {
                                map.change_identity.show();
                            }
                        }
                        else {
                            map.change_identity.hide();
                        }
                        if (config.versus_mode == 'siguo') {
                            map.siguo_character.show();
                        }
                        else {
                            map.siguo_character.hide();
                        }
                    },
                    versus_mode: {
                        name: '游戏模式',
                        init: 'four',
                        item: {
                            four: '对抗',
                            three: '统率',
                            two: '欢乐',
                            //guandu:'官渡',
                            jiange: '战场',
                            siguo: '四国',
                            standard: '自由'
                            // endless:'无尽',
                            // triple:'血战',
                            // one:'<span style="display:inline-block;width:100%;text-align:center">1v1</span>',
                        },
                        restart: true,
                        frequent: true
                    },
                    ladder: {
                        name: '天梯模式',
                        init: true,
                        frequent: true,
                        restart: true
                    },
                    ladder_monthly: {
                        name: '每月重置天梯',
                        init: true,
                        frequent: true
                    },
                    enable_all: {
                        name: '启用全部武将',
                        init: false,
                        frequent: true,
                        restart: true
                    },
                    enable_all_cards_four: {
                        name: '启用全部卡牌',
                        init: false,
                        frequent: true,
                        restart: true
                    },
                    enable_all_three: {
                        name: '启用全部武将',
                        init: false,
                        frequent: true,
                        restart: true
                    },
                    enable_all_cards: {
                        name: '启用全部卡牌',
                        init: false,
                        frequent: true,
                        restart: true
                    },
                    four_assign: {
                        name: '代替队友选将',
                        init: false,
                        restart: true
                    },
                    four_phaseswap: {
                        name: '代替队友行动',
                        init: false,
                        restart: true
                    },
                    two_assign: {
                        name: '代替队友选将',
                        init: false,
                        restart: true
                    },
                    two_phaseswap: {
                        name: '代替队友行动',
                        init: false,
                        restart: true
                    },
                    free_choose: {
                        name: '自由选将',
                        init: true,
                        frequent: true,
                        onclick: function (bool) {
                            game.saveConfig('free_choose', bool, this._link.config.mode);
                            if (!ui.create.cheat2)
                                return;
                            if (!_status.event.getParent().showConfig && !_status.event.showConfig)
                                return;
                            if (!ui.cheat2 && get.config('free_choose'))
                                ui.create.cheat2();
                            else if (ui.cheat2 && !get.config('free_choose')) {
                                ui.cheat2.close();
                                delete ui.cheat2;
                            }
                        }
                    },
                    fouralign: {
                        name: '自由选择阵型',
                        init: false
                    },
                    change_identity: {
                        name: '自由选择座位',
                        init: true,
                        onclick: function (bool) {
                            game.saveConfig('change_identity', bool, this._link.config.mode);
                            if (!_status.event.getParent().showConfig && !_status.event.showConfig)
                                return;
                            if (_status.mode == 'four') {
                                if (get.config('four_assign') || get.config('four_phaseswap'))
                                    return;
                                if (bool) {
                                    if (_status.event.parent.addSetting) {
                                        _status.event.parent.addSetting();
                                    }
                                }
                                else {
                                    var seats = _status.event.parent.seatsbutton;
                                    if (seats) {
                                        while (seats.length) {
                                            seats.shift().remove();
                                        }
                                        delete _status.event.parent.seatsbutton;
                                    }
                                }
                            }
                            else {
                                var dialog;
                                if (ui.cheat2 && ui.cheat2.backup)
                                    dialog = ui.cheat2.backup;
                                else
                                    dialog = _status.event.dialog;
                                if (!_status.brawl || !_status.brawl.noAddSetting) {
                                    if (!dialog.querySelector('table') && get.config('change_identity'))
                                        _status.event.getParent().addSetting(dialog);
                                    else
                                        _status.event.getParent().removeSetting(dialog);
                                }
                                ui.update();
                            }
                        }
                    },
                    change_choice: {
                        name: '开启换将卡',
                        init: true,
                        onclick: function (bool) {
                            game.saveConfig('change_choice', bool, this._link.config.mode);
                            if (!_status.event.getParent().showConfig && !_status.event.showConfig)
                                return;
                            if (!ui.cheat && get.config('change_choice'))
                                ui.create.cheat();
                            else if (ui.cheat && !get.config('change_choice')) {
                                ui.cheat.close();
                                delete ui.cheat;
                            }
                        },
                        frequent: true
                    },
                    double_character_jiange: {
                        name: '双将模式',
                        init: false,
                        frequent: true
                    },
                    replace_handcard_two: {
                        name: '四号位保护',
                        init: true,
                        frequent: true,
                        intro: '最后行动的角色起始手牌+1'
                    },
                    replace_character_two: {
                        name: '替补模式',
                        init: false,
                        frequent: true,
                        intro: '每个额外选择一名武将，死亡后用该武将代替重新上场，替补武将用完时失败'
                    },
                    expand_dialog: {
                        name: '默认展开选将框',
                        intro: '选将框打开时直接显示全部武将（可能使游戏在开始时卡顿）',
                        init: false
                    },
                    siguo_character: {
                        name: '专属武将出场率',
                        init: 'increase',
                        item: {
                            increase: '大概率',
                            normal: '默认概率',
                            off: '不出现'
                        },
                        frequent: true
                    },
                    // ban_weak:{
                    //     name:'屏蔽弱将',
                    //     init:true,
                    //     restart:true,
                    // },
                    // ban_strong:{
                    //     name:'屏蔽强将',
                    //     init:false,
                    //     restart:true
                    // },
                    ladder_reset: {
                        name: '重置天梯数据',
                        onclick: function () {
                            var node = this;
                            if (node._clearing) {
                                game.save('ladder', {
                                    current: 900,
                                    top: 900,
                                    month: (new Date()).getMonth()
                                });
                                ui.ladder.innerHTML = '卫士五';
                                clearTimeout(node._clearing);
                                node.firstChild.innerHTML = '重置天梯数据';
                                delete node._clearing;
                                return;
                            }
                            node.firstChild.innerHTML = '单击以确认 (3)';
                            node._clearing = setTimeout(function () {
                                node.firstChild.innerHTML = '单击以确认 (2)';
                                node._clearing = setTimeout(function () {
                                    node.firstChild.innerHTML = '单击以确认 (1)';
                                    node._clearing = setTimeout(function () {
                                        node.firstChild.innerHTML = '重置天梯数据';
                                        delete node._clearing;
                                    }, 1000);
                                }, 1000);
                            }, 1000);
                        },
                        clear: true
                    },
                    edit_character_three: {
                        name: '编辑统率将池',
                        clear: true,
                        onclick: function () {
                            if (get.mode() != 'versus') {
                                alert('请进入对决模式，然后再编辑将池');
                                return;
                            }
                            var container = ui.create.div('.popup-container.editor');
                            var editorpage = ui.create.div(container);
                            var discardConfig = ui.create.div('.editbutton', '取消', editorpage, function () {
                                ui.window.classList.remove('shortcutpaused');
                                ui.window.classList.remove('systempaused');
                                container["delete"](null);
                                delete window.saveNonameInput;
                            });
                            var node = container;
                            var map = get.config('character_three') || lib.choiceThree;
                            var str = 'character=[\n    ';
                            for (var i = 0; i < map.length; i++) {
                                str += '"' + map[i] + '",';
                                if (i + 1 < map.length && (i + 1) % 5 == 0)
                                    str += '\n    ';
                            }
                            str += '\n];';
                            node.code = str;
                            ui.window.classList.add('shortcutpaused');
                            ui.window.classList.add('systempaused');
                            var saveInput = function () {
                                var code;
                                if (container.editor) {
                                    code = container.editor.getValue();
                                }
                                else if (container.textarea) {
                                    code = container.textarea.value;
                                }
                                try {
                                    var character = null;
                                    eval(code);
                                    if (!Array.isArray(character)) {
                                        throw ('err');
                                    }
                                }
                                catch (e) {
                                    alert('代码语法有错误，请仔细检查（' + e + '）');
                                    return;
                                }
                                game.saveConfig('character_three', character, 'versus');
                                ui.window.classList.remove('shortcutpaused');
                                ui.window.classList.remove('systempaused');
                                container["delete"]();
                                container.code = code;
                                delete window.saveNonameInput;
                            };
                            window.saveNonameInput = saveInput;
                            var saveConfig = ui.create.div('.editbutton', '保存', editorpage, saveInput);
                            var editor = ui.create.div(editorpage);
                            if (node.aced) {
                                ui.window.appendChild(node);
                                node.editor.setValue(node.code, 1);
                            }
                            else if (lib.device == 'ios') {
                                ui.window.appendChild(node);
                                if (!node.textarea) {
                                    var textarea = document.createElement('textarea');
                                    editor.appendChild(textarea);
                                    node.textarea = textarea;
                                    lib.setScroll(textarea);
                                }
                                node.textarea.value = node.code;
                            }
                            else {
                                var aceReady = function () {
                                    ui.window.appendChild(node);
                                    var mirror = window.CodeMirror(editor, {
                                        value: node.code,
                                        mode: "javascript",
                                        lineWrapping: !lib.config.touchscreen && lib.config.mousewheel,
                                        lineNumbers: true,
                                        indentUnit: 4,
                                        autoCloseBrackets: true,
                                        theme: 'mdn-like'
                                    });
                                    lib.setScroll(editor.querySelector('.CodeMirror-scroll'));
                                    node.aced = true;
                                    node.editor = mirror;
                                };
                                if (!window.ace) {
                                    lib.init.js(lib.assetURL + 'game', 'codemirror', aceReady);
                                    lib.init.css(lib.assetURL + 'layout/default', 'codemirror');
                                }
                                else {
                                    aceReady();
                                }
                            }
                            ;
                        }
                    },
                    reset_character_three: {
                        name: '重置将池',
                        intro: '将统率三军模式下的将池重置为默认将池',
                        clear: true,
                        onclick: function () {
                            if (confirm('该操作不可撤销！是否清除统率三军模式的自定义将池，并将其重置为默认将池？')) {
                                game.saveConfig('character_three', null, 'versus');
                                alert('将池已重置');
                            }
                        }
                    }
                }
            },
            connect: {
                name: '联机',
                config: {
                    connect_nickname: {
                        name: '联机昵称',
                        input: true,
                        frequent: true
                    },
                    connect_avatar: {
                        name: '联机头像',
                        init: 'KizunaAI',
                        item: {},
                        frequent: true,
                        onclick: function (item) {
                            game.saveConfig('connect_avatar', item);
                            game.saveConfig('connect_avatar', item, 'connect');
                        }
                    },
                    hall_ip: {
                        name: '联机大厅',
                        input: true,
                        frequent: true
                    },
                    hall_button: {
                        name: '联机大厅按钮',
                        init: true,
                        frequent: true,
                        onclick: function (bool) {
                            game.saveConfig('hall_button', bool, 'connect');
                            if (ui.hall_button) {
                                if (bool) {
                                    ui.hall_button.style.display = '';
                                }
                                else {
                                    ui.hall_button.style.display = 'none';
                                }
                            }
                        }
                    }
                }
            },
            boss: {
                name: '挑战',
                config: {
                    free_choose: {
                        name: '自由选将',
                        init: true,
                        frequent: true,
                        onclick: function (bool) {
                            game.saveConfig('free_choose', bool, this._link.config.mode);
                            if (!_status.event.getParent().showConfig && !_status.event.showConfig)
                                return;
                            if (!ui.cheat2 && get.config('free_choose'))
                                ui.create.cheat2();
                            else if (ui.cheat2 && !get.config('free_choose')) {
                                ui.cheat2.close();
                                delete ui.cheat2;
                            }
                        }
                    },
                    change_choice: {
                        name: '开启换将卡',
                        init: true,
                        onclick: function (bool) {
                            game.saveConfig('change_choice', bool, this._link.config.mode);
                            if (!_status.event.getParent().showConfig && !_status.event.showConfig)
                                return;
                            if (!ui.cheat && get.config('change_choice'))
                                ui.create.cheat();
                            else if (ui.cheat && !get.config('change_choice')) {
                                ui.cheat.close();
                                delete ui.cheat;
                            }
                        },
                        frequent: true
                    },
                    single_control: {
                        name: '单人控制',
                        init: true,
                        frequent: true,
                        onclick: function (bool) {
                            game.saveConfig('single_control', bool, this._link.config.mode);
                            if (ui.single_swap && game.me != game.boss) {
                                if (bool) {
                                    ui.single_swap.style.display = 'none';
                                }
                                else {
                                    ui.single_swap.style.display = '';
                                }
                            }
                        },
                        intro: '只控制一名角色，其他角色由AI控制'
                    }
                }
            },
            doudizhu: {
                name: '斗地主',
                connect: {
                    update: function (config, map) {
                        if (config.connect_doudizhu_mode == 'online') {
                            map.connect_change_card.hide();
                        }
                        else {
                            map.connect_change_card.show();
                        }
                        if (config.connect_doudizhu_mode != 'normal') {
                            map.connect_double_character.hide();
                        }
                        else {
                            map.connect_double_character.show();
                        }
                    },
                    connect_doudizhu_mode: {
                        name: '游戏模式',
                        init: 'normal',
                        item: {
                            normal: '休闲',
                            kaihei: '开黑',
                            huanle: '欢乐',
                            binglin: '兵临',
                            online: '智斗'
                        },
                        restart: true,
                        frequent: true
                    },
                    connect_double_character: {
                        name: '双将模式',
                        init: false,
                        frequent: true,
                        restart: true
                    },
                    connect_change_card: {
                        name: '启用手气卡',
                        init: false,
                        frequent: true,
                        restart: true
                    }
                },
                config: {
                    update: function (config, map) {
                        if (config.doudizhu_mode == 'online') {
                            map.change_card.hide();
                            map.edit_character.show();
                            map.reset_character.show();
                        }
                        else {
                            map.change_card.show();
                            map.edit_character.hide();
                            map.reset_character.hide();
                        }
                        if (config.doudizhu_mode != 'normal') {
                            map.double_character.hide();
                            map.free_choose.hide();
                            map.change_identity.hide();
                            map.change_choice.hide();
                            map.continue_game.hide();
                            map.dierestart.hide();
                            map.choice_zhu.hide();
                            map.choice_fan.hide();
                            map.revive.hide();
                        }
                        else {
                            map.double_character.show();
                            map.free_choose.show();
                            map.change_identity.show();
                            map.change_choice.show();
                            map.continue_game.show();
                            map.dierestart.show();
                            map.choice_zhu.show();
                            map.choice_fan.show();
                            map.revive.show();
                        }
                        if (config.double_character && config.doudizhu_mode == 'normal') {
                            map.double_hp.show();
                        }
                        else {
                            map.double_hp.hide();
                        }
                    },
                    doudizhu_mode: {
                        name: '游戏模式',
                        init: 'normal',
                        item: {
                            normal: '休闲',
                            kaihei: '开黑',
                            huanle: '欢乐',
                            binglin: '兵临',
                            online: '智斗'
                        },
                        restart: true,
                        frequent: true
                    },
                    double_character: {
                        name: '双将模式',
                        init: false,
                        frequent: true,
                        restart: true
                    },
                    double_hp: {
                        name: '双将体力上限',
                        init: 'pingjun',
                        item: {
                            hejiansan: '和减三',
                            pingjun: '平均值',
                            zuidazhi: '最大值',
                            zuixiaozhi: '最小值',
                            zonghe: '相加'
                        },
                        restart: true
                    },
                    free_choose: {
                        name: '自由选将',
                        init: true,
                        onclick: function (bool) {
                            game.saveConfig('free_choose', bool, this._link.config.mode);
                            if (!_status.event.getParent().showConfig && !_status.event.showConfig)
                                return;
                            if (!ui.cheat2 && get.config('free_choose'))
                                ui.create.cheat2();
                            else if (ui.cheat2 && !get.config('free_choose')) {
                                ui.cheat2.close();
                                delete ui.cheat2;
                            }
                        }
                    },
                    change_identity: {
                        name: '自由选择身份和座位',
                        init: true,
                        onclick: function (bool) {
                            game.saveConfig('change_identity', bool, this._link.config.mode);
                            if (!_status.event.getParent().showConfig && !_status.event.showConfig)
                                return;
                            var dialog;
                            if (ui.cheat2 && ui.cheat2.backup)
                                dialog = ui.cheat2.backup;
                            else
                                dialog = _status.event.dialog;
                            if (!_status.brawl || !_status.brawl.noAddSetting) {
                                if (!dialog.querySelector('table') && get.config('change_identity'))
                                    _status.event.getParent().addSetting(dialog);
                                else
                                    _status.event.getParent().removeSetting(dialog);
                            }
                            ui.update();
                        }
                    },
                    change_choice: {
                        name: '开启换将卡',
                        init: true,
                        onclick: function (bool) {
                            game.saveConfig('change_choice', bool, this._link.config.mode);
                            if (!_status.event.getParent().showConfig && !_status.event.showConfig)
                                return;
                            if (!ui.cheat && get.config('change_choice'))
                                ui.create.cheat();
                            else if (ui.cheat && !get.config('change_choice')) {
                                ui.cheat.close();
                                delete ui.cheat;
                            }
                        }
                    },
                    change_card: {
                        name: '开启手气卡',
                        init: 'disabled',
                        item: {
                            disabled: '禁用',
                            once: '一次',
                            twice: '两次',
                            unlimited: '无限'
                        }
                    },
                    continue_game: {
                        name: '显示再战',
                        init: false,
                        onclick: function (bool) {
                            game.saveConfig('continue_game', bool, this._link.config.mode);
                            if (get.config('continue_game')) {
                                if (!ui.continue_game && _status.over && !_status.brawl && !game.no_continue_game) {
                                    ui.continue_game = ui.create.control('再战', game.reloadCurrent);
                                }
                            }
                            else if (ui.continue_game) {
                                ui.continue_game.close();
                                delete ui.continue_game;
                            }
                        },
                        intro: '游戏结束后可选择用相同的武将再进行一局游戏'
                    },
                    dierestart: {
                        name: '死亡后显示重来',
                        init: true,
                        onclick: function (bool) {
                            game.saveConfig('dierestart', bool, this._link.config.mode);
                            if (get.config('dierestart')) {
                                if (!ui.restart && game.me.isDead() && !_status.connectMode) {
                                    ui.restart = ui.create.control('restart', game.reload);
                                }
                            }
                            else if (ui.restart) {
                                ui.restart.close();
                                delete ui.restart;
                            }
                        }
                    },
                    revive: {
                        name: '死亡后显示复活',
                        init: false,
                        onclick: function (bool) {
                            game.saveConfig('revive', bool, this._link.config.mode);
                            if (get.config('revive')) {
                                if (!ui.revive && game.me.isDead()) {
                                    ui.revive = ui.create.control('revive', ui.click.dierevive);
                                }
                            }
                            else if (ui.revive) {
                                ui.revive.close();
                                delete ui.revive;
                            }
                        }
                    },
                    choice_zhu: {
                        name: '地主候选武将数',
                        init: '3',
                        restart: true,
                        item: {
                            '3': '三',
                            '4': '四',
                            '5': '五',
                            '6': '六',
                            '8': '八',
                            '10': '十'
                        }
                    },
                    choice_fan: {
                        name: '农民候选武将数',
                        init: '3',
                        restart: true,
                        item: {
                            '3': '三',
                            '4': '四',
                            '5': '五',
                            '6': '六',
                            '8': '八',
                            '10': '十'
                        }
                    },
                    edit_character: {
                        name: '编辑将池',
                        clear: true,
                        onclick: function () {
                            if (get.mode() != 'doudizhu') {
                                alert('请进入斗地主模式，然后再编辑将池');
                                return;
                            }
                            var container = ui.create.div('.popup-container.editor');
                            var editorpage = ui.create.div(container);
                            var discardConfig = ui.create.div('.editbutton', '取消', editorpage, function () {
                                ui.window.classList.remove('shortcutpaused');
                                ui.window.classList.remove('systempaused');
                                container["delete"](null);
                                delete window.saveNonameInput;
                            });
                            var node = container;
                            var map = get.config('character_online') || lib.characterOnline;
                            node.code = 'character=' + get.stringify(map) + '\n/*\n    这里是智斗三国模式的武将将池。\n    您可以在这里编辑对武将将池进行编辑，然后点击“保存”按钮即可保存。\n    将池中的Key势力武将，仅同时在没有被禁用的情况下，才会出现在选将框中。\n    而非Key势力的武将，只要所在的武将包没有被隐藏，即可出现在选将框中。\n    该将池为单机模式/联机模式通用将池。在这里编辑后，即使进入联机模式，也依然会生效。\n    但联机模式本身禁用的武将（如神貂蝉）不会出现在联机模式的选将框中。\n*/';
                            ui.window.classList.add('shortcutpaused');
                            ui.window.classList.add('systempaused');
                            var saveInput = function () {
                                var code;
                                if (container.editor) {
                                    code = container.editor.getValue();
                                }
                                else if (container.textarea) {
                                    code = container.textarea.value;
                                }
                                try {
                                    var character = null;
                                    eval(code);
                                    if (!get.is.object(character)) {
                                        throw ('err');
                                    }
                                    var groups = [];
                                    for (var i in character) {
                                        if (!Array.isArray(character[i]))
                                            throw ('type');
                                        if (character[i].length >= 3)
                                            groups.push(i);
                                    }
                                    if (groups.length < 3)
                                        throw ('enough');
                                }
                                catch (e) {
                                    if (e == 'type') {
                                        alert('请严格按照格式填写，不要写入不为数组的数据');
                                    }
                                    else if (e == 'enough') {
                                        alert('请保证至少写入了3个势力，且每个势力至少有3个武将');
                                    }
                                    else if (e == 'err') {
                                        alert('代码格式有错误，请对比示例代码仔细检查');
                                    }
                                    else {
                                        alert('代码语法有错误，请仔细检查（' + e + '）');
                                    }
                                    return;
                                }
                                game.saveConfig('character_online', character, 'doudizhu');
                                ui.window.classList.remove('shortcutpaused');
                                ui.window.classList.remove('systempaused');
                                container["delete"]();
                                container.code = code;
                                delete window.saveNonameInput;
                            };
                            window.saveNonameInput = saveInput;
                            var saveConfig = ui.create.div('.editbutton', '保存', editorpage, saveInput);
                            var editor = ui.create.div(editorpage);
                            if (node.aced) {
                                ui.window.appendChild(node);
                                node.editor.setValue(node.code, 1);
                            }
                            else if (lib.device == 'ios') {
                                ui.window.appendChild(node);
                                if (!node.textarea) {
                                    var textarea = document.createElement('textarea');
                                    editor.appendChild(textarea);
                                    node.textarea = textarea;
                                    lib.setScroll(textarea);
                                }
                                node.textarea.value = node.code;
                            }
                            else {
                                var aceReady = function () {
                                    ui.window.appendChild(node);
                                    var mirror = window.CodeMirror(editor, {
                                        value: node.code,
                                        mode: "javascript",
                                        lineWrapping: !lib.config.touchscreen && lib.config.mousewheel,
                                        lineNumbers: true,
                                        indentUnit: 4,
                                        autoCloseBrackets: true,
                                        theme: 'mdn-like'
                                    });
                                    lib.setScroll(editor.querySelector('.CodeMirror-scroll'));
                                    node.aced = true;
                                    node.editor = mirror;
                                };
                                if (!window.ace) {
                                    lib.init.js(lib.assetURL + 'game', 'codemirror', aceReady);
                                    lib.init.css(lib.assetURL + 'layout/default', 'codemirror');
                                }
                                else {
                                    aceReady();
                                }
                            }
                            ;
                        }
                    },
                    reset_character: {
                        name: '重置将池',
                        intro: '将智斗三国模式下的将池重置为默认将池',
                        clear: true,
                        onclick: function () {
                            if (confirm('该操作不可撤销！是否清除智斗三国模式的自定义将池，并将其重置为默认将池？')) {
                                game.saveConfig('character_online', null, 'doudizhu');
                                alert('将池已重置');
                            }
                        }
                    }
                }
            },
            longlaoguan: {
                name: '龙牢关',
                connect: {
                    update: function (config, map) { },
                    connect_change_card: {
                        name: '启用手气卡',
                        init: false,
                        frequent: true,
                        restart: true
                    }
                },
                config: {
                    update: function (config, map) {
                        if (config.double_character) {
                            map.double_hp.show();
                        }
                        else {
                            map.double_hp.hide();
                        }
                    },
                    double_character: {
                        name: '双将模式',
                        init: false,
                        frequent: true,
                        restart: true
                    },
                    double_hp: {
                        name: '双将体力上限',
                        init: 'pingjun',
                        item: {
                            hejiansan: '和减三',
                            pingjun: '平均值',
                            zuidazhi: '最大值',
                            zuixiaozhi: '最小值',
                            zonghe: '相加'
                        },
                        restart: true
                    },
                    free_choose: {
                        name: '自由选将',
                        init: true,
                        onclick: function (bool) {
                            game.saveConfig('free_choose', bool, this._link.config.mode);
                            if (!_status.event.getParent().showConfig && !_status.event.showConfig)
                                return;
                            if (!ui.cheat2 && get.config('free_choose'))
                                ui.create.cheat2();
                            else if (ui.cheat2 && !get.config('free_choose')) {
                                ui.cheat2.close();
                                delete ui.cheat2;
                            }
                        }
                    },
                    change_identity: {
                        name: '自由选择身份和座位',
                        init: true,
                        onclick: function (bool) {
                            game.saveConfig('change_identity', bool, this._link.config.mode);
                            if (!_status.event.getParent().showConfig && !_status.event.showConfig)
                                return;
                            var dialog;
                            if (ui.cheat2 && ui.cheat2.backup)
                                dialog = ui.cheat2.backup;
                            else
                                dialog = _status.event.dialog;
                            if (!_status.brawl || !_status.brawl.noAddSetting) {
                                if (!dialog.querySelector('table') && get.config('change_identity'))
                                    _status.event.getParent().addSetting(dialog);
                                else
                                    _status.event.getParent().removeSetting(dialog);
                            }
                            ui.update();
                        }
                    },
                    change_choice: {
                        name: '开启换将卡',
                        init: true,
                        onclick: function (bool) {
                            game.saveConfig('change_choice', bool, this._link.config.mode);
                            if (!_status.event.getParent().showConfig && !_status.event.showConfig)
                                return;
                            if (!ui.cheat && get.config('change_choice'))
                                ui.create.cheat();
                            else if (ui.cheat && !get.config('change_choice')) {
                                ui.cheat.close();
                                delete ui.cheat;
                            }
                        }
                    },
                    change_card: {
                        name: '开启手气卡',
                        init: 'disabled',
                        item: {
                            disabled: '禁用',
                            once: '一次',
                            twice: '两次',
                            unlimited: '无限'
                        }
                    },
                    continue_game: {
                        name: '显示再战',
                        init: false,
                        onclick: function (bool) {
                            game.saveConfig('continue_game', bool, this._link.config.mode);
                            if (get.config('continue_game')) {
                                if (!ui.continue_game && _status.over && !_status.brawl) {
                                    ui.continue_game = ui.create.control('再战', game.reloadCurrent);
                                }
                            }
                            else if (ui.continue_game) {
                                ui.continue_game.close();
                                delete ui.continue_game;
                            }
                        },
                        intro: '游戏结束后可选择用相同的武将再进行一局游戏'
                    },
                    dierestart: {
                        name: '死亡后显示重来',
                        init: true,
                        onclick: function (bool) {
                            game.saveConfig('dierestart', bool, this._link.config.mode);
                            if (get.config('dierestart')) {
                                if (!ui.restart && game.me.isDead() && !_status.connectMode) {
                                    ui.restart = ui.create.control('restart', game.reload);
                                }
                            }
                            else if (ui.restart) {
                                ui.restart.close();
                                delete ui.restart;
                            }
                        }
                    },
                    revive: {
                        name: '死亡后显示复活',
                        init: false,
                        onclick: function (bool) {
                            game.saveConfig('revive', bool, this._link.config.mode);
                            if (get.config('revive')) {
                                if (!ui.revive && game.me.isDead()) {
                                    ui.revive = ui.create.control('revive', ui.click.dierevive);
                                }
                            }
                            else if (ui.revive) {
                                ui.revive.close();
                                delete ui.revive;
                            }
                        }
                    },
                    choice_zhu: {
                        name: '龙皇候选武将数',
                        init: '1',
                        restart: true,
                        item: {
                            '1': '一'
                        }
                    },
                    choice_fan: {
                        name: '反抗军候选武将数',
                        init: '5',
                        restart: true,
                        item: {
                            '3': '三',
                            '4': '四',
                            '5': '五',
                            '6': '六',
                            '8': '八',
                            '10': '十'
                        }
                    }
                }
            },
            single: {
                name: '单挑',
                connect: {
                    connect_single_mode: {
                        name: '游戏模式',
                        init: 'dianjiang',
                        item: {
                            dianjiang: '点将单挑'
                        },
                        restart: true,
                        frequent: true
                    },
                    connect_enable_jin: {
                        name: '启用晋势力武将',
                        init: false,
                        restart: true,
                        frequent: true
                    },
                    update: function (config, map) {
                        if (config.connect_single_mode != 'normal') {
                            map.connect_enable_jin.hide();
                        }
                        else {
                            map.connect_enable_jin.show();
                        }
                    }
                },
                config: {
                    single_mode: {
                        name: '游戏模式',
                        init: 'dianjiang',
                        item: {
                            dianjiang: '点将单挑'
                        },
                        restart: true,
                        frequent: true
                    },
                    enable_jin: {
                        name: '启用晋势力武将',
                        init: false,
                        restart: true,
                        frequent: true
                    },
                    update: function (config, map) {
                        if (config.single_mode != 'normal') {
                            map.enable_jin.hide();
                        }
                        else {
                            map.enable_jin.show();
                        }
                    }
                }
            },
            brawl: {
                name: '乱斗',
                config: {
                    huanhuazhizhan: {
                        name: '幻化之战',
                        init: true,
                        frequent: true
                    },
                    qunxionggeju: {
                        name: '群雄割据',
                        init: true,
                        frequent: true
                    },
                    duzhansanguo: {
                        name: '毒战三国',
                        init: true,
                        frequent: true
                    },
                    daoshiyueying: {
                        name: '导师爱璃',
                        init: true,
                        frequent: true
                    },
                    weiwoduzun: {
                        name: '唯我独尊',
                        init: true,
                        frequent: true
                    },
                    tongxingzhizheng: {
                        name: '同姓之争',
                        init: true,
                        frequent: true
                    },
                    jiazuzhizheng: {
                        name: '家族之争',
                        init: true,
                        frequent: true
                    },
                    // tongqueduopao:{
                    // 	name:'铜雀夺袍',
                    // 	init:true,
                    // 	frequent:true
                    // },
                    tongjiangmoshi: {
                        name: '同将模式',
                        init: true,
                        frequent: true
                    },
                    // baiyidujiang:{
                    // 	name:'白衣渡江',
                    // 	init:true,
                    // 	frequent:true
                    // },
                    qianlidanji: {
                        name: '千里单骑',
                        init: true,
                        frequent: true
                    },
                    // liangjunduilei:{
                    // 	name:'两军对垒',
                    // 	init:true,
                    // 	frequent:true
                    // },
                    scene: {
                        name: '创建场景',
                        init: true,
                        frequent: true
                    }
                }
            }
        },
        /**
         * lib状态，储存如delayed、videoId等动态数据
         * @type {!Object}
         */
        status: {
            running: false,
            canvas: false,
            time: 0,
            reload: 0,
            delayed: 0,
            frameId: 0,
            videoId: 0,
            globalId: 0
        },
        /**
         * 帮助菜单
         * @type {!Object}
         */
        help: {
            'FAQ': '<ul><li>Q：关于家长麦技能中的“除外”，有详细的说明吗？<li>A：你不执行奖惩，不能发动技能或使用牌，不能指定目标或被选择为目标（令角色解除除外状态除外）；计算有关全场角色的数据时，不计算你的存在：当你于回合内被除外时，结束你的回合（若当前有卡牌正在结算，则结算后再结束你的回合）。<br>' +
                '<li>Q：若角色有出牌阶段限制次数的技能，则其会因额外的出牌阶段多次发动此技能吗？<li>A：是的，但是一般情况仅限于主动释放的技能（比如下地的『引流』和MEA的『掠财』）。若不做特殊说明，额外出牌阶段结束时，角色回合内的技能使用次数均会清空，而卡牌使用次数不变。<br>' +
                '<li>Q：夜雾和lulu的技能改变出牌效果时，影响牌的使用次数吗？<li>A：不影响，牌的使用次数始终在牌使用或打出时计入。特别的，lulu的技能可以改变牌名，有可能影响牌的后续结算；而夜雾的技能不改变牌名，（虽然效果已经变化）与原牌名关联的效果不会受影响（如【初始服】之于【杀】【万箭】【南蛮】）<br>',
            '游戏操作': '<ul><li>长按/鼠标悬停/右键单击显示信息<li>触屏模式中，双指点击切换暂停；下划显示菜单，上划切换托管<li>键盘快捷键<br>' +
                '<table><tr><td>A<td>切换托管<tr><td>W<td>切换不询问无懈<tr><td>空格<td>暂停</table><li>编辑牌堆<br>在卡牌包中修改牌堆后，将自动创建一个临时牌堆，在所有模式中共用，当保存当前牌堆后，临时牌堆被清除。每个模式可设置不同的已保存牌堆，设置的牌堆优先级大于临时牌堆</ul>',
            // '游戏命令':'<div style="margin:10px">变量名</div><ul style="margin-top:0"><li>场上角色<br>game.players<li>阵亡角色<br>game.dead'+
            // '<li>玩家<br>game.me<li>玩家的上/下家<br>game.me.previous/next'+
            // '<li>玩家的上/下家（含阵亡）<br>game.me.previousSeat/<br>nextSeat'+
            // '<li>牌堆<br>ui.cardPile<li>弃牌堆<br>ui.discardPile</ul>'+
            // '<div style="margin:10px">角色属性</div><ul style="margin-top:0"><li>体力值<br>player.hp'+
            // '<li>体力上限<br>player.maxHp<li>身份<br>player.identity<li>手牌<br>player.getCards("h")<li>装备牌<br>player.getCards("e")<li>判定牌<br>player.getCards("j")'+
            // '<li>是否存活/横置/翻面<br>player.isAlive()/<br>isLinked()/<br>isTurnedOver()</ul>'+
            // '<div style="margin:10px">角色操作</div><ul style="margin-top:0"><li>受到伤害<br>player.damage(source,<br>num)'+
            // '<li>回复体力<br>player.recover(num)<li>摸牌<br>player.draw(num)<li>获得牌<br>player.gain(cards)<li>弃牌<br>player.discard(cards)'+
            // '<li>使用卡牌<br>player.useCard(card,<br>targets)<li>死亡<br>player.die()<li>复活<br>player.revive(hp)</ul>'+
            // '<div style="margin:10px">游戏操作</div><ul style="margin-top:0"><li>在命令框中输出结果<br>game.print(str)<li>清除命令框中的内容<br>cls<li>上一条/下一条输入的内容<br>up/down<li>游戏结束<br>game.over(bool)'+
            // '<li>角色资料<br>lib.character<li>卡牌资料<br>lib.card</ul>',
            '游戏名词': '<ul><li>智囊：无名杀默认为过河拆桥/无懈可击/无中生有/洞烛先机。牌堆中没有的智囊牌会被过滤。可在卡牌设置中自行增减。若没有可用的智囊，则改为随机选取的三种锦囊牌的牌名。' +
                '<li>仁库：部分武将使用的游戏外共通区域。至多包含六张牌。当有新牌注入后，若牌数超过上限，则将最早进入仁库的溢出牌置入弃牌堆。' +
                '<li>护甲：和体力类似，每点护甲可抵挡一点伤害，但不影响手牌上限。' +
                '<li>随从：通过技能获得，拥有独立的技能、手牌区和装备区（共享判定区），出场时替代主武将的位置；随从死亡时自动切换回主武将。' +
                '<li>发现：从三张随机亮出的牌中选择一张，若无特殊说明，则获得此牌。' +
                '<li>蓄力技：发动时可以增大黄色的数字。若如此做，红色数字于技能的结算过程中改为原来的两倍。'
        },
        /**
         * 设置(触屏: 长按[, 点击])|(鼠标: 悬浮, 右击[, 点击])弹窗
         * @name lib.setIntro
         * @param {(HTMLDivElement|PlayerModel)} node 要弹窗的节点
         * @param {?function} func 用于自定义弹窗的回调函数
         * @param {?boolean} left 如果为true，点击事件也能触发弹窗
         * @see {@link get.nodeintro}
         */
        setIntro: function (node, func, left) {
            if (node instanceof PlayerModel) {
                node = node.element;
            }
            if (lib.config.touchscreen) {
                if (left) {
                    node.listen(ui.click.touchintro);
                }
                else {
                    lib.setLongPress(node, ui.click.intro);
                }
            }
            else {
                if (left) {
                    node.listen(ui.click.intro);
                }
                if (lib.config.hover_all) {
                    lib.setHover(node, ui.click.hoverplayer);
                }
                if (lib.config.right_info) {
                    node.oncontextmenu = ui.click.rightplayer;
                }
            }
            // if(!left){
            //     lib.setPressure(node,ui.click.rightpressure);
            // }
            if (func) {
                node._customintro = func;
            }
        },
        // setPressure:function(node,func){
        //     if(window.Pressure){
        //         window.Pressure.set(node,{change: func}, {polyfill: false});
        //     }
        // },
        setPopped: function (node, func, width, height, forceclick, paused2) {
            node._poppedfunc = func;
            node._poppedwidth = width;
            node._poppedheight = height;
            if (forceclick) {
                node.forceclick = true;
            }
            if (lib.config.touchscreen || forceclick) {
                node.listen(ui.click.hoverpopped);
            }
            else {
                node.addEventListener('mouseenter', ui.click.hoverpopped);
                // node.addEventListener('mouseleave',ui.click.hoverpopped_leave);
            }
            if (paused2) {
                node._paused2 = true;
            }
        },
        placePoppedDialog: function (dialog, e) {
            if (dialog._place_text) {
                if (dialog._place_text.firstChild.offsetWidth >= 190 ||
                    dialog._place_text.firstChild.offsetHeight >= 30) {
                    dialog._place_text.style.textAlign = 'left';
                    dialog._place_text.style.marginLeft = '14px';
                }
            }
            if (e.touches && e.touches[0]) {
                e = e.touches[0];
            }
            var height = Math.min(ui.window.offsetHeight - 20, dialog.content.scrollHeight);
            if (dialog._mod_height) {
                height += dialog._mod_height;
            }
            dialog.style.height = height + 'px';
            if (e.clientX / game.documentZoom < ui.window.offsetWidth / 2) {
                dialog.style.left = (e.clientX / game.documentZoom + 10) + 'px';
            }
            else {
                dialog.style.left = (e.clientX / game.documentZoom - dialog.offsetWidth - 10) + 'px';
            }
            var idealtop = (e.clientY || 0) / game.documentZoom - dialog.offsetHeight / 2;
            if (typeof idealtop != 'number' || isNaN(idealtop) || idealtop <= 5) {
                idealtop = 5;
            }
            else if (idealtop + dialog.offsetHeight + 10 > ui.window.offsetHeight) {
                idealtop = ui.window.offsetHeight - 10 - dialog.offsetHeight;
            }
            dialog.style.top = idealtop + 'px';
        },
        /**
         * @callback lib.setHover~callback
         * @param {MouseEvent} e MouseEvent on mouse move
         * @returns {*}TODO
         */
        /**
         * 设置悬浮
         * 监听悬停事件
         * @function
         * @param {!HTMLElement} node
         * @param {?lib.setHover~callback} func 回调函数
         * @param {?number} hoveration 悬停的时间，如果为null，使用默认悬停事件 {@link GameConfig}
         * @param {?number} width 弹窗宽度，为null时不设置
         * @returns {!HTMLElement}
         */
        setHover: function (node, func, hoveration, width) {
            node._hoverfunc = func;
            if (typeof hoveration == 'number') {
                node._hoveration = hoveration;
            }
            if (typeof width == 'number') {
                node._hoverwidth = width;
            }
            node.addEventListener('mouseenter', ui.click.mouseenter);
            node.addEventListener('mouseleave', ui.click.mouseleave);
            node.addEventListener('mousedown', ui.click.mousedown);
            node.addEventListener('mousemove', ui.click.mousemove);
            return node;
        },
        /**
         * 设置滚轮
         * 为节点监听滚动事件
         * @function
         * @param {!HTMLElement} node 要监听滚动事件的节点
         * @returns {!HTMLElement}
         */
        setScroll: function (node) {
            node.ontouchstart = ui.click.touchStart;
            node.ontouchmove = ui.click.touchScroll;
            node.style.WebkitOverflowScrolling = 'touch';
            return node;
        },
        /**
         * 设置鼠标滚轮（用于切换皮肤菜单）
         * 为节点监听鼠标滚轮事件
         * @function
         * @param {!HTMLElement} node 要监听鼠标滚轮事件的节点
         * @returns {!HTMLElement}
         */
        setMousewheel: function (node) {
            if (lib.config.mousewheel)
                node.onmousewheel = ui.click.mousewheel;
        },
        /**
         * 设置长按
         * 监听长按事件
         * @param {!HTMLElement} node 要监听长按事件的节点
         * @param {?function} func 回调事件
         * @returns {!HTMLElement}
         */
        setLongPress: function (node, func) {
            node.addEventListener('touchstart', ui.click.longpressdown);
            node.addEventListener('touchend', ui.click.longpresscancel);
            node._longpresscallback = func;
            return node;
        },
        /**
         * 更新`ui.canvas`
         * @param {!number} time 当前时间
         * @returns {(undefined|false)} 如果没有需要更新的`<canvas>`返回false
         */
        updateCanvas: function (time) {
            if (lib.canvasUpdates.length === 0) {
                lib.status.canvas = false;
                return false;
            }
            ui.canvas.width = ui.arena.offsetWidth;
            ui.canvas.height = ui.arena.offsetHeight;
            var ctx = ui.ctx;
            ctx.shadowBlur = 5;
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.strokeStyle = 'white';
            // ctx.lineCap='round';
            ctx.lineWidth = 3;
            ctx.save();
            for (var i = 0; i < lib.canvasUpdates.length; i++) {
                ctx.restore();
                ctx.save();
                var update = lib.canvasUpdates[i];
                if (!update.starttime) {
                    update.starttime = time;
                }
                if (update(time - update.starttime, ctx) === false) {
                    lib.canvasUpdates.splice(i--, 1);
                }
            }
        },
        /**
         * 一个启动函数，其中循环更新`lib.updates`直至没有需要更新的函数
         * @param {!number} time 当前时间
         */
        run: function (time) {
            lib.status.time = time;
            for (var i = 0; i < lib.updates.length; i++) {
                if (!lib.updates[i].hasOwnProperty('_time')) {
                    lib.updates[i]._time = time;
                }
                if (lib.updates[i](time - lib.updates[i]._time - lib.status.delayed) === false) {
                    lib.updates.splice(i--, 1);
                }
            }
            if (lib.updates.length) {
                lib.status.frameId = requestAnimationFrame(lib.run);
            }
            else {
                lib.status.time = 0;
                lib.status.delayed = 0;
            }
        },
        /**
         * 将date转化为对应的datetime并返回转化后的datetime
         * [recommend] 移到{@link get}中
         * @function
         * @param {Date} date
         * @returns {number} datetime
         * @see {@link get.utc}
         */
        getUTC: function (date) {
            return date.getTime();
        },
        /**
         * 保存录像
         */
        saveVideo: function () {
            if (_status.videoToSave) {
                game["export"](lib.init.encode(JSON.stringify(_status.videoToSave)), '无名杀 - 录像 - ' + _status.videoToSave.name[0] + ' - ' + _status.videoToSave.name[1]);
            }
        },
        /**
         * 初始化
         * @namespace
         */
        init: {
            /**
             * 初始化游戏，向HTMLDivElement和Array的原型链上添加一批方法（比如delete和addArray）
             * 入口函数
             * @function
             */
            init: function () {
                //part: `lib.configprefix` 初始化
                //如果是从PC端（node.js）载入，额外需要`__dirname`的各级文件夹首字母来拼接
                //例如：`__dirname` 为 `'F:\\vtb\\test\\src'`，则`lib.configprefix`为`'noname_0.9_Fvts_'|'vtuberkill_1.9_Fvts_'`
                //BUG: [PC win10] 路径使用`\`时，只获取了盘符
                if (typeof __dirname === 'string' && __dirname.length) {
                    var dirsplit = __dirname.split('/');
                    for (var i = 0; i < dirsplit.length; i++) {
                        if (dirsplit[i]) {
                            var c = dirsplit[i][0];
                            lib.configprefix += /[A-Z]|[a-z]/.test(c) ? c : '_';
                        }
                    }
                    lib.configprefix += '_';
                }
                window.resetGameTimeout = setTimeout(lib.init.reset, parseInt(localStorage.getItem(lib.configprefix + 'loadtime')) || 5000);
                //part: `cordovaLoadTimeout`的创建，在 ../app/redirect.js
                if (window.cordovaLoadTimeout) {
                    clearTimeout(window.cordovaLoadTimeout);
                    delete window.cordovaLoadTimeout;
                }
                //part: 从html中，删除首次启动使用的样式（css）
                var links = document.head.querySelectorAll('link');
                for (var i = 0; i < links.length; i++) {
                    if (links[i].href.indexOf('app/color.css') != -1) {
                        links[i].remove();
                        break;
                    }
                }
                //part: 如果是phantom，则禁用indexedDB
                var index = window.location.href.indexOf('index.html?server=');
                if (index != -1) {
                    /**
                     * 服务器ID
                     * @type {string}
                     * @global
                     */
                    window.isNonameServer = window.location.href.slice(index + 18);
                    /**
                     * 禁用indexedDB，为真值时禁用
                     * @type {boolean}
                     * @global
                     */
                    window.nodb = true;
                }
                else {
                    //??
                    index = localStorage.getItem(lib.configprefix + 'asserver');
                    if (index) {
                        window.isNonameServer = index;
                        window.isNonameServerIp = lib.hallURL;
                    }
                }
                //part: 设置背景图
                var htmlbg = localStorage.getItem(lib.configprefix + 'background');
                if (htmlbg) {
                    if (htmlbg[0] == '[') {
                        try {
                            htmlbg = JSON.parse(htmlbg);
                            htmlbg = htmlbg[get.rand(htmlbg.length)];
                            if (htmlbg.indexOf('custom_') == 0) {
                                throw ('err');
                            }
                            _status.htmlbg = htmlbg;
                        }
                        catch (e) {
                            htmlbg = null;
                        }
                    }
                    if (htmlbg) {
                        if (htmlbg.indexOf('svg_') == 0) {
                            document.documentElement.style.backgroundImage = 'url("' + lib.assetURL + 'image/background/' + htmlbg.slice(4) + '.svg")';
                        }
                        else {
                            document.documentElement.style.backgroundImage = 'url("' + lib.assetURL + 'image/background/' + htmlbg + '.jpg")';
                            document.documentElement.style.backgroundSize = 'cover';
                            document.documentElement.style.backgroundPosition = '50% 50%';
                        }
                    }
                }
                //part: get, ui, ai, game 引用到 lib对象
                lib.get = get;
                lib.ui = ui;
                lib.ai = ai;
                lib.game = game;
                //part: 拓展 HTMLDivElement.
                //#region 
                HTMLDivElement.prototype.animate = function (name, time) {
                    var that;
                    if (get.is.mobileMe(this) && name == 'target') {
                        that = ui.mebg;
                    }
                    else {
                        that = this;
                    }
                    that.classList.add(name);
                    setTimeout(function () {
                        that.classList.remove(name);
                    }, time || 1000);
                    return this;
                };
                HTMLDivElement.prototype.hide = function () {
                    this.classList.add('hidden');
                    return this;
                };
                HTMLDivElement.prototype.unfocus = function () {
                    if (lib.config.transparent_dialog)
                        this.classList.add('transparent');
                    return this;
                };
                HTMLDivElement.prototype.refocus = function () {
                    this.classList.remove('transparent');
                    return this;
                };
                HTMLDivElement.prototype.show = function () {
                    this.classList.remove('hidden');
                    return this;
                };
                HTMLDivElement.prototype["delete"] = function (time, callback) {
                    if (this.timeout) {
                        clearTimeout(this.timeout);
                        delete this.timeout;
                    }
                    if (!this._listeningEnd || this._transitionEnded) {
                        if (typeof time != 'number')
                            time = 500;
                        this.classList.add('removing');
                        var that = this;
                        this.timeout = setTimeout(function () {
                            that.remove();
                            that.classList.remove('removing');
                            if (typeof callback == 'function') {
                                callback();
                            }
                        }, time);
                    }
                    else {
                        this._onEndDelete = true;
                    }
                    return this;
                };
                HTMLDivElement.prototype.goto = function (position, time) {
                    if (this.timeout) {
                        clearTimeout(this.timeout);
                        delete this.timeout;
                    }
                    if (typeof time != 'number')
                        time = 500;
                    this.classList.add('removing');
                    var that = this;
                    this.timeout = setTimeout(function () {
                        if (!that.destroyed) {
                            position.appendChild(that);
                        }
                        that.classList.remove('removing');
                        delete that.destiny;
                    }, time);
                    this.destiny = position;
                    return this;
                };
                HTMLDivElement.prototype.fix = function () {
                    clearTimeout(this.timeout);
                    delete this.timeout;
                    delete this.destiny;
                    this.classList.remove('removing');
                    return this;
                };
                HTMLDivElement.prototype.setBackground = function (name, type, ext, subfolder) {
                    if (!name)
                        return;
                    var src;
                    if (ext == 'noskin') {
                        ext = '.jpg';
                    }
                    ext = ext || '.jpg';
                    subfolder = subfolder || 'default';
                    if (type) {
                        var dbimage = null, extimage = null, modeimage = null;
                        var nameinfo;
                        var gzbool = false;
                        var mode = get.mode();
                        if (type == 'character') {
                            if (lib.characterPack['mode_' + mode] && lib.characterPack['mode_' + mode][name]) {
                                if (mode == 'guozhan') {
                                    nameinfo = lib.character[name];
                                    if (name.indexOf('gz_shibing') == 0) {
                                        name = name.slice(3, 11);
                                    }
                                    else {
                                        if (lib.config.mode_config.guozhan.guozhanSkin && lib.character[name] && lib.character[name][4].contains('gzskin'))
                                            gzbool = true;
                                        name = name.slice(3);
                                    }
                                }
                                else {
                                    modeimage = mode;
                                }
                            }
                            else if (lib.character[name]) {
                                nameinfo = lib.character[name];
                            }
                            else if (name.indexOf('::') != -1) {
                                name = name.split('::');
                                modeimage = name[0];
                                name = name[1];
                            }
                        }
                        if (!modeimage && nameinfo && nameinfo[4]) {
                            for (var i = 0; i < nameinfo[4].length; i++) {
                                if (nameinfo[4][i].indexOf('ext:') == 0) {
                                    extimage = nameinfo[4][i];
                                    break;
                                }
                                else if (nameinfo[4][i].indexOf('db:') == 0) {
                                    dbimage = nameinfo[4][i];
                                    break;
                                }
                                else if (nameinfo[4][i].indexOf('mode:') == 0) {
                                    modeimage = nameinfo[4][i].slice(5);
                                    break;
                                }
                                else if (nameinfo[4][i].indexOf('character:') == 0) {
                                    name = nameinfo[4][i].slice(10);
                                    break;
                                }
                            }
                        }
                        if (extimage) {
                            src = extimage.replace(/ext:/, 'extension/');
                        }
                        else if (dbimage) {
                            this.setBackgroundDB(dbimage.slice(3));
                            return this;
                        }
                        else if (modeimage) {
                            src = 'image/mode/' + modeimage + '/character/' + name + ext;
                        }
                        else if (type == 'character' && lib.config.skin[name] && arguments[2] != 'noskin') {
                            src = 'image/skin/' + name + '/' + lib.config.skin[name] + ext;
                        }
                        else {
                            if (type == 'character') {
                                src = 'image/character/' + (gzbool ? 'gz_' : '') + name + ext;
                            }
                            else {
                                src = 'image/' + type + '/' + subfolder + '/' + name + ext;
                            }
                        }
                    }
                    else {
                        src = 'image/' + name + ext;
                    }
                    this.setBackgroundImage(src);
                    this.style.backgroundSize = "cover";
                    return this;
                };
                HTMLDivElement.prototype.setBackgroundDB = function (img) {
                    var node = this;
                    game.getDB('image', img, function (src) {
                        node.style.backgroundImage = "url('" + src + "')";
                        node.style.backgroundSize = "cover";
                    });
                };
                HTMLDivElement.prototype.setBackgroundImage = function (img) {
                    this.style.backgroundImage = 'url("' + lib.assetURL + img + '")';
                },
                    HTMLDivElement.prototype.listen = function (func) {
                        if (lib.config.touchscreen) {
                            this.addEventListener('touchend', function (e) {
                                if (!_status.dragged) {
                                    func.call(this, e);
                                }
                            });
                            var fallback = function (e) {
                                if (!_status.touchconfirmed) {
                                    func.call(this, e);
                                }
                                else {
                                    this.removeEventListener('click', fallback);
                                }
                            };
                            this.addEventListener('click', fallback);
                        }
                        else {
                            this.addEventListener('click', func);
                        }
                        return this;
                    };
                HTMLDivElement.prototype.listenTransition = function (func, time) {
                    var that = this;
                    var done = false;
                    var callback = function () {
                        if (!done) {
                            func.call(that);
                            done = true;
                        }
                    };
                    this.addEventListener('webkitTransitionEnd', callback);
                    return setTimeout(callback, time || 1000);
                };
                HTMLDivElement.prototype.setPosition = function () {
                    var position;
                    if (arguments.length == 4) {
                        position = [];
                        for (var i = 0; i < arguments.length; i++)
                            position.push(arguments[i]);
                    }
                    else if (arguments.length == 1 && Array.isArray(arguments[0]) && arguments[0].length == 4) {
                        position = arguments[0];
                    }
                    else {
                        return this;
                    }
                    var top = 'calc(' + position[0] + '% ';
                    if (position[1] > 0)
                        top += '+ ' + position[1] + 'px)';
                    else
                        top += '- ' + Math.abs(position[1]) + 'px)';
                    var left = 'calc(' + position[2] + '% ';
                    if (position[3] > 0)
                        left += '+ ' + position[3] + 'px)';
                    else
                        left += '- ' + Math.abs(position[3]) + 'px)';
                    this.style.top = top;
                    this.style.left = left;
                    return this;
                };
                HTMLDivElement.prototype.css = function (style) {
                    for (var i in style) {
                        if (i == 'innerHTML') {
                            this.innerHTML = style[i];
                        }
                        else {
                            this.style[i] = style[i];
                        }
                    }
                    return this;
                };
                //#endregion
                //part: 拓展 HTMLTableElement
                //#region
                HTMLTableElement.prototype.get = function (row, col) {
                    if (row < this.childNodes.length) {
                        return this.childNodes[row].childNodes[col];
                    }
                };
                //#endregion
                //part: 拓展数组
                //#region
                Array.prototype.numOf = function (item) {
                    var num = 0;
                    for (var i = 0; i < this.length; i++) {
                        if (this[i] == item)
                            num++;
                    }
                    return num;
                };
                Array.prototype.filterInD = function (pos) {
                    if (!pos)
                        pos = 'o';
                    var list = [];
                    for (var i = 0; i < this.length; i++) {
                        if (pos.indexOf(get.position(this[i], true)) != -1)
                            list.push(this[i]);
                    }
                    return list;
                };
                Array.prototype.find = function (item) {
                    return this.indexOf(item);
                };
                Array.prototype.contains = function (item) {
                    return this.indexOf(item) != -1;
                };
                Array.prototype.add = function () {
                    for (var i = 0; i < arguments.length; i++) {
                        if (this.contains(arguments[i])) {
                            return false;
                        }
                        this.push(arguments[i]);
                    }
                    return this;
                };
                Array.prototype.addArray = function (arr) {
                    for (var i = 0; i < arr.length; i++) {
                        this.add(arr[i]);
                    }
                    return this;
                };
                Array.prototype.remove = function (item) {
                    if (Array.isArray(item)) {
                        for (var i = 0; i < item.length; i++)
                            this.remove(item[i]);
                        return;
                    }
                    var pos = this.find(item);
                    if (pos == -1) {
                        return false;
                    }
                    this.splice(pos, 1);
                    return this;
                };
                Array.prototype.removeArray = function (arr) {
                    for (var i = 0; i < arr.length; i++) {
                        this.remove(arr[i]);
                    }
                    return this;
                };
                Array.prototype.randomGet = function () {
                    var arr = this.slice(0);
                    for (var i = 0; i < arguments.length; i++)
                        arr.remove(arguments[i]);
                    return arr[Math.floor(Math.random() * arr.length)];
                };
                Array.prototype.randomRemove = function (num) {
                    if (typeof num == 'number') {
                        var list = [];
                        for (var i = 0; i < num; i++) {
                            if (this.length) {
                                list.push(this.randomRemove());
                            }
                            else {
                                break;
                            }
                        }
                        return list;
                    }
                    else {
                        return this.splice(Math.floor(Math.random() * this.length), 1)[0];
                    }
                };
                Array.prototype.randomSort = function () {
                    var list = [];
                    while (this.length) {
                        list.push(this.randomRemove());
                    }
                    for (var i = 0; i < list.length; i++) {
                        this.push(list[i]);
                    }
                    return this;
                };
                Array.prototype.randomGets = function (num) {
                    if (num > this.length) {
                        num = this.length;
                    }
                    var arr = this.slice(0);
                    var list = [];
                    for (var i = 0; i < num; i++) {
                        list.push(arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
                    }
                    return list;
                };
                Array.prototype.sortBySeat = function (target) {
                    lib.tempSortSeat = target;
                    this.sort(lib.sort.seat);
                    delete lib.tempSortSeat;
                    return this;
                };
                if (!Array.from) {
                    Array.from = function (args) {
                        var list = [];
                        if (args && args.length) {
                            for (var i = 0; i < args.length; i++) {
                                list.push(args[i]);
                            }
                        }
                        return list;
                    };
                }
                //#endregion
                //part: 设置全局window.onkeydown, window.onload, window.onerror，直到关闭网页（退出游戏）
                /**
                 * 监听键盘按下事件
                 * @function
                 * @global
                 * @param {KeyboardEvent} e - 键盘事件
                 * @listens KeyboardEvent
                 */
                window.onkeydown = function (e) {
                    if (!ui.menuContainer || !ui.menuContainer.classList.contains('hidden')) {
                        if (e.keyCode == 116 || ((e.ctrlKey || e.metaKey) && e.keyCode == 82)) {
                            if (e.shiftKey) {
                                if (confirm('是否重置游戏？')) {
                                    var noname_inited = localStorage.getItem('noname_inited');
                                    var onlineKey = localStorage.getItem(lib.configprefix + 'key');
                                    localStorage.clear();
                                    if (noname_inited) {
                                        localStorage.setItem('noname_inited', noname_inited);
                                    }
                                    if (onlineKey) {
                                        localStorage.setItem(lib.configprefix + 'key', onlineKey);
                                    }
                                    if (indexedDB)
                                        indexedDB.deleteDatabase(lib.configprefix + 'data');
                                    game.reload();
                                    return;
                                }
                            }
                            else {
                                game.reload();
                            }
                        }
                        else if (e.keyCode == 83 && (e.ctrlKey || e.metaKey)) {
                            if (window.saveNonameInput) {
                                window.saveNonameInput();
                            }
                            e.preventDefault();
                            e.stopPropagation();
                            return false;
                        }
                        else if (e.keyCode == 74 && (e.ctrlKey || e.metaKey) && lib.node) {
                            lib.node.debug();
                        }
                    }
                    else {
                        game.closePopped();
                        var dialogs = document.querySelectorAll('#window>.dialog.popped:not(.static)');
                        for (var i = 0; i < dialogs.length; i++) {
                            dialogs[i]["delete"]();
                        }
                        if (e.keyCode == 32) {
                            var node = ui.window.querySelector('pausedbg');
                            if (node) {
                                node.click();
                            }
                            else {
                                ui.click.pause();
                            }
                        }
                        else if (e.keyCode == 65) {
                            if (ui.auto)
                                ui.auto.click();
                        }
                        else if (e.keyCode == 87) {
                            if (ui.wuxie && ui.wuxie.style.display != 'none') {
                                ui.wuxie.classList.toggle('glow');
                            }
                            else if (ui.tempnowuxie) {
                                ui.tempnowuxie.classList.toggle('glow');
                            }
                        }
                        else if (e.keyCode == 116 || ((e.ctrlKey || e.metaKey) && e.keyCode == 82)) {
                            if (e.shiftKey) {
                                if (confirm('是否重置游戏？')) {
                                    var noname_inited = localStorage.getItem('noname_inited');
                                    var onlineKey = localStorage.getItem(lib.configprefix + 'key');
                                    localStorage.clear();
                                    if (noname_inited) {
                                        localStorage.setItem('noname_inited', noname_inited);
                                    }
                                    if (onlineKey) {
                                        localStorage.setItem(lib.configprefix + 'key', onlineKey);
                                    }
                                    if (indexedDB)
                                        indexedDB.deleteDatabase(lib.configprefix + 'data');
                                    game.reload();
                                    return;
                                }
                            }
                            else {
                                game.reload();
                            }
                        }
                        else if (e.keyCode == 83 && (e.ctrlKey || e.metaKey)) {
                            e.preventDefault();
                            e.stopPropagation();
                            return false;
                        }
                        else if (e.keyCode == 74 && (e.ctrlKey || e.metaKey) && lib.node) {
                            lib.node.debug();
                        }
                        // else if(e.keyCode==27){
                        //     if(!ui.arena.classList.contains('paused')) ui.click.config();
                        // }
                    }
                };
                /**
                 * window加载结束时调用
                 * @function
                 * @global
                 */
                window.onload = function () {
                    if (lib.device) {
                        var script = document.createElement('script');
                        script.src = 'cordova.js';
                        document.body.appendChild(script);
                        document.addEventListener('deviceready', function () {
                            if (lib.init.cordovaReady) {
                                lib.init.cordovaReady();
                                delete lib.init.cordovaReady;
                            }
                        });
                    }
                    if (_status.packLoaded) {
                        delete _status.packLoaded;
                        lib.init.onload();
                    }
                    else {
                        /**
                         * 当onload调用先于包的加载时，标志onload已经运行完毕，直至包全部加载完毕则删除该标志
                         * @private
                         * @default
                         */
                        _status.windowLoaded = true;
                    }
                };
                /**
                 * 触发错误时调用
                 * @function
                 * @global
                 * @param {string} msg - 错误信息
                 * @param {string} src - 引发错误的脚本URL
                 * @param {string} line - 引发错误的行号
                 * @param {string} column - 发生错误的行的列号
                 * @param {Error} err - 错误对象
                 */
                window.onerror = function (msg, src, line, column, err) {
                    var str = msg;
                    if (window._status && _status.event) {
                        var evt = _status.event;
                        str += ('\n' + evt.name + ': ' + evt.step);
                        if (evt.parent)
                            str += '\n' + evt.parent.name + ': ' + evt.parent.step;
                        if (evt.parent && evt.parent.parent)
                            str += '\n' + evt.parent.parent.name + ': ' + evt.parent.parent.step;
                        if (evt.player || evt.target || evt.source || evt.skill || evt.card) {
                            str += '\n-------------';
                        }
                        if (evt.player) {
                            str += '\nplayer: ' + evt.player.name;
                        }
                        if (evt.target) {
                            str += '\ntarget: ' + evt.target.name;
                        }
                        if (evt.source) {
                            str += '\nsource: ' + evt.source.name;
                        }
                        if (evt.skill) {
                            str += '\nskill: ' + evt.skill.name;
                        }
                        if (evt.card) {
                            str += '\ncard: ' + evt.card.name;
                        }
                    }
                    str += '\n-------------';
                    str += '\n' + line;
                    str += '\n' + column;
                    if (err && err.stack)
                        str += '\n' + err.stack;
                    alert(str);
                    window.ea = Array.from(arguments);
                    window.em = msg;
                    window.el = line;
                    window.ec = column;
                    window.eo = err;
                    game.print(msg);
                    game.print(line);
                    game.print(column);
                    game.print(err.stack);
                    if (!lib.config.errstop) {
                        _status.withError = true;
                        game.loop();
                    }
                };
                //part: 更新内容，window.nogame_update，创建于config.js
                if (window.noname_update) {
                    lib.version = window.noname_update.version;
                    lib.changeLog = window.noname_update.changeLog;
                    if (window.noname_update.players) {
                        lib.changeLog.push('players://' + JSON.stringify(window.noname_update.players));
                    }
                    if (window.noname_update.cards) {
                        lib.changeLog.push('cards://' + JSON.stringify(window.noname_update.cards));
                    }
                    delete window.noname_update;
                }
                //part: 如果是移动端，设置移动设备信息lib.device, 资源根路径lib.assetURL
                var noname_inited = localStorage.getItem('noname_inited');
                if (noname_inited && noname_inited !== 'nodejs') {
                    var ua = navigator.userAgent.toLowerCase();
                    if (ua.indexOf('android') != -1) {
                        lib.device = 'android';
                    }
                    else if (ua.indexOf('iphone') != -1 || ua.indexOf('ipad') != -1) {
                        lib.device = 'ios';
                    }
                    lib.assetURL = noname_inited;
                }
                //part: flag变量，标志`ui.css`是否加载完成，完成时设置为true；如果其他UI和config数据加载完成时`ui.css`未加载完毕，寄存config数据于`config3`，并在css加载完成时调用
                var config3 = null;
                var proceed = function (config2) {
                    //[recommend] 移到`init`函数结尾更好，`proceed`函数更整洁
                    if (config3 === null) {
                        config3 = config2;
                        return;
                    }
                    //part: 如果`config2.mode`存在，则直接进入游戏的`config2.mode`；模式初始化`lib.config.mode_config`
                    if (config2.mode)
                        lib.config.mode = config2.mode;
                    if (lib.config.mode_config[lib.config.mode] == undefined)
                        lib.config.mode_config[lib.config.mode] = {};
                    for (var i in lib.config.mode_config.global) {
                        if (lib.config.mode_config[lib.config.mode][i] == undefined) {
                            lib.config.mode_config[lib.config.mode][i] = lib.config.mode_config.global[i];
                        }
                    }
                    //part: defaultcharacters
                    if (lib.config.characters) {
                        lib.config.defaultcharacters = lib.config.characters.slice(0);
                    }
                    //part: defaultcards
                    if (lib.config.cards) {
                        lib.config.defaultcards = lib.config.cards.slice(0);
                    }
                    //part: 从`config2`加载`lib.config`和`lib.mode_config`的数据
                    for (var i in config2) {
                        if (i.indexOf('_mode_config') != -1) {
                            var thismode = i.substr(i.indexOf('_mode_config') + 13);
                            if (!lib.config.mode_config[thismode]) {
                                lib.config.mode_config[thismode] = {};
                            }
                            lib.config.mode_config[thismode][i.substr(0, i.indexOf('_mode_config'))] = config2[i];
                        }
                        else {
                            lib.config[i] = config2[i];
                        }
                    }
                    //part: 从`lib.config.translate`拷贝到`lib.translate`
                    for (var i in lib.config.translate) {
                        lib.translate[i] = lib.config.translate[i];
                    }
                    lib.config.all.characters = [];
                    lib.config.all.cards = [];
                    lib.config.all.plays = [];
                    lib.config.all.mode = [];
                    //part: 如果测试模式已开启，重置资源列表
                    if (lib.config.debug) {
                        lib.init.js(lib.assetURL + 'game', 'asset', function () {
                            lib.skin = window.noname_skin_list;
                            delete window.noname_skin_list;
                            delete window.noname_asset_list;
                        });
                    }
                    if (window.isNonameServer) {
                        lib.config.mode = 'connect';
                    }
                    //part: `window.noname_package`，创建于package.js
                    var pack = window.noname_package;
                    delete window.noname_package;
                    for (i in pack.character) {
                        if (lib.config.hiddenCharacterPack.indexOf(i) == -1) {
                            lib.config.all.characters.push(i);
                            lib.translate[i + '_character_config'] = pack.character[i];
                        }
                    }
                    for (i in pack.card) {
                        if (lib.config.hiddenCardPack.indexOf(i) == -1) {
                            lib.config.all.cards.push(i);
                            lib.translate[i + '_card_config'] = pack.card[i];
                        }
                    }
                    for (i in pack.play) {
                        lib.config.all.plays.push(i);
                        lib.translate[i + '_play_config'] = pack.play[i];
                    }
                    for (i in pack.submode) {
                        for (var j in pack.submode[i]) {
                            lib.translate[i + '|' + j] = pack.submode[i][j];
                        }
                    }
                    if (!lib.config.gameRecord) {
                        lib.config.gameRecord = {};
                    }
                    for (i in pack.mode) {
                        if (lib.config.hiddenModePack.indexOf(i) == -1) {
                            lib.config.all.mode.push(i);
                            lib.translate[i] = pack.mode[i];
                            if (!lib.config.gameRecord[i]) {
                                lib.config.gameRecord[i] = { data: {} };
                            }
                        }
                    }
                    //??
                    if (lib.config.all.mode.length == 0) {
                        lib.config.all.mode.push('identity');
                        lib.translate.identity = '身份';
                        if (!lib.config.gameRecord.identity) {
                            lib.config.gameRecord.identity = { data: {} };
                        }
                    }
                    if (pack.background) {
                        for (i in pack.background) {
                            if (lib.config.hiddenBackgroundPack.contains(i))
                                continue;
                            lib.configMenu.appearence.config.image_background.item[i] = pack.background[i];
                        }
                        for (var i = 0; i < lib.config.customBackgroundPack.length; i++) {
                            var link = lib.config.customBackgroundPack[i];
                            lib.configMenu.appearence.config.image_background.item[link] = link.slice(link.indexOf('_') + 1);
                        }
                        lib.configMenu.appearence.config.image_background.item["default"] = '默认';
                    }
                    if (pack.music) {
                        if (lib.device || typeof window.require == 'function') {
                            lib.configMenu.audio.config.background_music.item.music_custom = '自定义音乐';
                        }
                        lib.config.all.background_music = ['music_diaochan'];
                        for (i in pack.music) {
                            lib.config.all.background_music.push(i);
                            lib.configMenu.audio.config.background_music.item[i] = pack.music[i];
                        }
                        if (lib.config.customBackgroundMusic) {
                            for (i in lib.config.customBackgroundMusic) {
                                lib.config.all.background_music.push(i);
                                lib.configMenu.audio.config.background_music.item[i] = lib.config.customBackgroundMusic[i];
                            }
                        }
                        lib.configMenu.audio.config.background_music.item.music_random = '随机播放';
                        lib.configMenu.audio.config.background_music.item.music_off = '关闭';
                    }
                    if (pack.theme) {
                        for (i in pack.theme) {
                            lib.configMenu.appearence.config.theme.item[i] = pack.theme[i];
                        }
                    }
                    if (lib.config.extension_sources) {
                        for (i in lib.config.extension_sources) {
                            lib.configMenu.general.config.extension_source.item[i] = i;
                        }
                    }
                    if (pack.font) {
                        ui.css.fontsheet = lib.init.sheet();
                        for (i in pack.font) {
                            lib.configMenu.appearence.config.name_font.item[i] = pack.font[i];
                            lib.configMenu.appearence.config.identity_font.item[i] = pack.font[i];
                            lib.configMenu.appearence.config.cardtext_font.item[i] = pack.font[i];
                            lib.configMenu.appearence.config.global_font.item[i] = pack.font[i];
                            ui.css.fontsheet.sheet.insertRule("@font-face {font-family: '" + i + "';src: url('" + lib.assetURL + "font/" + i + ".ttf');}", 0);
                        }
                        lib.configMenu.appearence.config.cardtext_font.item["default"] = '默认';
                        lib.configMenu.appearence.config.global_font.item["default"] = '默认';
                    }
                    //part: touch, layout, scroll config
                    var ua = navigator.userAgent.toLowerCase();
                    if ('ontouchstart' in document) {
                        //移动端
                        if (!lib.config.totouched) {
                            game.saveConfig('totouched', true);
                            if (lib.device) {
                                //移动端通过客户端访问
                                game.saveConfig('low_performance', true);
                                game.saveConfig('confirm_exit', true);
                                game.saveConfig('touchscreen', true);
                                game.saveConfig('fold_mode', false);
                                if (ua.indexOf('ipad') == -1) {
                                    game.saveConfig('phonelayout', true);
                                }
                                else if (lib.device == 'ios') {
                                    game.saveConfig('show_statusbar_ios', 'overlay');
                                }
                            }
                            else if (confirm('是否切换到触屏模式？（触屏模式可提高触屏设备的响应速度，但无法使用鼠标）')) {
                                //移动端通过网页访问
                                game.saveConfig('touchscreen', true);
                                if (ua.indexOf('iphone') != -1 || ua.indexOf('android') != -1) {
                                    game.saveConfig('phonelayout', true);
                                }
                                game.reload();
                            }
                        }
                    }
                    else if (lib.config.touchscreen) { //非移动端，如果触屏模式开启，就设置关闭
                        game.saveConfig('touchscreen', false);
                    }
                    if (!lib.config.toscrolled && ua.indexOf('macintosh') != -1) {
                        game.saveConfig('toscrolled', true);
                        game.saveConfig('mousewheel', false);
                    }
                    //part: 是否打开开始界面
                    var show_splash = lib.config.show_splash;
                    if (show_splash == 'off') {
                        show_splash = false;
                    }
                    else if (show_splash == 'init') {
                        if (localStorage.getItem('show_splash_off')) {
                            show_splash = false;
                        }
                    }
                    localStorage.removeItem('show_splash_off');
                    //part: extension list
                    //??
                    //[never executed]
                    var extensionlist = [];
                    if (!localStorage.getItem(lib.configprefix + 'disable_extension')) {
                        if (lib.config.extensions && lib.config.extensions.length) {
                            window.resetExtension = function () {
                                for (var i = 0; i < lib.config.extensions.length; i++) {
                                    game.saveConfig('extension_' + lib.config.extensions[i] + '_enable', false);
                                }
                                localStorage.setItem(lib.configprefix + 'disable_extension', true);
                            };
                        }
                        for (var i = 0; i < lib.config.plays.length; i++) {
                            if (lib.config.all.plays.indexOf(lib.config.plays[i]) != -1) {
                                extensionlist.push(lib.config.plays[i]);
                            }
                        }
                        for (var i = 0; i < lib.config.extensions.length; i++) {
                            var extcontent = localStorage.getItem(lib.configprefix + 'extension_' + lib.config.extensions[i]);
                            if (extcontent) {
                                _status.evaluatingExtension = true;
                                try {
                                    eval(extcontent);
                                }
                                catch (e) {
                                    console.log(e);
                                }
                                _status.evaluatingExtension = false;
                            }
                            else if (lib.config.mode != 'connect' || (!localStorage.getItem(lib.configprefix + 'directstart') && show_splash)) {
                                extensionlist.push(lib.config.extensions[i]);
                            }
                        }
                    }
                    else {
                        if (lib.config.mode != 'connect' || (!localStorage.getItem(lib.configprefix + 'directstart') && show_splash)) {
                            for (var i = 0; i < lib.config.extensions.length; i++) {
                                game["import"]('extension', { name: lib.config.extensions[i] });
                            }
                        }
                    }
                    //用于加载包的函数
                    var loadPack = function () {
                        var toLoad = lib.config.all.cards.length + lib.config.all.characters.length + 1;
                        var packLoaded = function () {
                            toLoad--;
                            if (toLoad == 0) {
                                if (_status.windowLoaded) {
                                    delete _status.windowLoaded;
                                    lib.init.onload();
                                }
                                else {
                                    /**
                                     * 当包加载完毕先于window.onload时，标志包已经加载完毕，直至onload加载完毕则删除该标志
                                     * @private
                                     * @default
                                     */
                                    _status.packLoaded = true;
                                }
                            }
                        };
                        if (localStorage.getItem(lib.configprefix + 'playback')) {
                            toLoad++;
                            lib.init.js(lib.assetURL + 'mode', lib.config.mode, packLoaded, packLoaded);
                        }
                        else if ((localStorage.getItem(lib.configprefix + 'directstart') || !show_splash) &&
                            lib.config.all.mode.indexOf(lib.config.mode) != -1) {
                            toLoad++;
                            lib.init.js(lib.assetURL + 'mode', lib.config.mode, packLoaded, packLoaded);
                        }
                        lib.init.js(lib.assetURL + 'card', lib.config.all.cards, packLoaded, packLoaded);
                        lib.init.js(lib.assetURL + 'character', lib.config.all.characters, packLoaded, packLoaded);
                        lib.init.js(lib.assetURL + 'character', 'rank', packLoaded, packLoaded);
                        // if(lib.device!='ios'&&lib.config.enable_pressure) lib.init.js(lib.assetURL+'game','pressure');
                    };
                    //part: 检查layout并设置`game.layout = layout`
                    var layout = lib.config.layout;
                    if (lib.layoutfixed.indexOf(lib.config.mode) !== -1) {
                        layout = 'mobile';
                    }
                    if (layout == 'phone') {
                        layout = 'mobile';
                        game.saveConfig('layout', 'mobile');
                        game.saveConfig('phonelayout', true);
                    }
                    game.layout = layout;
                    //part: 随机选取背景或选择_status.htmlbg作为背景图像
                    if (lib.config.image_background_random) {
                        if (_status.htmlbg) {
                            game.saveConfig('image_background', _status.htmlbg);
                        }
                        else {
                            var list = [];
                            for (var i in lib.configMenu.appearence.config.image_background.item) {
                                if (i == 'default')
                                    continue;
                                list.push(i);
                            }
                            game.saveConfig('image_background', list.randomGet(lib.config.image_background));
                        }
                        lib.init.background();
                    }
                    delete _status.htmlbg;
                    //part: game to window.game
                    // window.game = game;//[todo delete]
                    //part: 加载js(卡牌, 角色, 模式拓展等)以及css(UI布局, 样式)
                    var styleToLoad = 6;
                    var styleLoaded = function () {
                        styleToLoad--;
                        if (styleToLoad == 0) {
                            if (extensionlist.length && (lib.config.mode != 'connect' || show_splash)) {
                                var extToLoad = extensionlist.length;
                                var extLoaded = function () {
                                    extToLoad--;
                                    if (extToLoad == 0) {
                                        loadPack();
                                    }
                                };
                                for (var i = 0; i < extensionlist.length; i++) {
                                    lib.init.js(lib.assetURL + 'extension/' + extensionlist[i], 'extension', extLoaded, (function (i) {
                                        return function () {
                                            game.removeExtension(i);
                                            extToLoad--;
                                            if (extToLoad == 0) {
                                                loadPack();
                                            }
                                        };
                                    }(extensionlist[i])));
                                }
                            }
                            else {
                                loadPack();
                            }
                        }
                    };
                    //css.layout
                    if (lib.config.layout != 'default') {
                        ui.css.layout = lib.init.css(lib.assetURL + 'layout/' + layout, 'layout', styleLoaded);
                    }
                    else {
                        ui.css.layout = lib.init.css();
                        styleToLoad--;
                    }
                    //css.phone
                    if (get.is.phoneLayout()) {
                        ui.css.phone = lib.init.css(lib.assetURL + 'layout/default', 'phone', styleLoaded);
                    }
                    else {
                        ui.css.phone = lib.init.css();
                        styleToLoad--;
                    }
                    //css.theme
                    ui.css.theme = lib.init.css(lib.assetURL + 'theme/' + lib.config.theme, 'style', styleLoaded);
                    //css.card_style
                    ui.css.card_style = lib.init.css(lib.assetURL + 'theme/style/card', lib.config.card_style, styleLoaded);
                    //css_cardpack_style
                    ui.css.cardback_style = lib.init.css(lib.assetURL + 'theme/style/cardback', lib.config.cardback_style, styleLoaded);
                    //css.hp_style
                    ui.css.hp_style = lib.init.css(lib.assetURL + 'theme/style/hp', lib.config.hp_style, styleLoaded);
                    //part: 通过配置创建`<link>`, 设置角色牌的背景、边框、边饰、文本样式
                    if (lib.config.player_style && lib.config.player_style != 'default' && lib.config.player_style != 'custom') {
                        var str = '';
                        switch (lib.config.player_style) {
                            case 'wood':
                                str = 'url("' + lib.assetURL + 'theme/woodden/wood.jpg")';
                                break;
                            case 'music':
                                str = 'linear-gradient(#4b4b4b, #464646)';
                                break;
                            case 'simple':
                                str = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4))';
                                break;
                        }
                        ui.css.player_stylesheet = lib.init.sheet('#window .player{background-image:' + str + '}');
                    }
                    if (lib.config.border_style && lib.config.border_style != 'default' && lib.config.border_style != 'custom' && lib.config.border_style != 'auto') {
                        ui.css.border_stylesheet = lib.init.sheet();
                        var bstyle = lib.config.border_style;
                        if (bstyle.indexOf('dragon_') == 0) {
                            bstyle = bstyle.slice(7);
                        }
                        ui.css.border_stylesheet.sheet.insertRule('#window .player>.framebg,#window #arena.long.mobile:not(.fewplayer) .player[data-position="0"]>.framebg{display:block;background-image:url("' + lib.assetURL + 'theme/style/player/' + bstyle + '1.png")}', 0);
                        ui.css.border_stylesheet.sheet.insertRule('#window #arena.long:not(.fewplayer) .player>.framebg, #arena.oldlayout .player>.framebg{background-image:url("' + lib.assetURL + 'theme/style/player/' + bstyle + '3.png")}', 0);
                        ui.css.border_stylesheet.sheet.insertRule('.player>.count{z-index: 3 !important;border-radius: 2px !important;text-align: center !important;}', 0);
                    }
                    if (lib.config.control_style && lib.config.control_style != 'default' && lib.config.control_style != 'custom') {
                        var str = '';
                        switch (lib.config.control_style) {
                            case 'wood':
                                str = 'url("' + lib.assetURL + 'theme/woodden/wood.jpg")';
                                break;
                            case 'music':
                                str = 'linear-gradient(#4b4b4b, #464646);color:white;text-shadow:black 0 0 2px';
                                break;
                            case 'simple':
                                str = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4));color:white;text-shadow:black 0 0 2px';
                                break;
                        }
                        if (lib.config.control_style == 'wood') {
                            ui.css.control_stylesheet = lib.init.sheet('#window .control,#window .menubutton,#window #system>div>div,#window #system>div>.pressdown2{background-image:' + str + '}');
                        }
                        else {
                            ui.css.control_stylesheet = lib.init.sheet('#window .control,.menubutton:not(.active):not(.highlight):not(.red):not(.blue),#window #system>div>div{background-image:' + str + '}');
                        }
                    }
                    if (lib.config.menu_style && lib.config.menu_style != 'default' && lib.config.menu_style != 'custom') {
                        var str = '';
                        switch (lib.config.menu_style) {
                            case 'wood':
                                str = 'url("' + lib.assetURL + 'theme/woodden/wood2.png")';
                                break;
                            case 'music':
                                str = 'linear-gradient(#4b4b4b, #464646);color:white;text-shadow:black 0 0 2px';
                                break;
                            case 'simple':
                                str = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4));color:white;text-shadow:black 0 0 2px';
                                break;
                        }
                        ui.css.menu_stylesheet = lib.init.sheet('html #window>.dialog.popped,html .menu,html .menubg{background-image:' + str + '}');
                    }
                    //part: ??
                    lib.config.duration = 500;
                    //part: add mouse/touch event listeners to document.
                    if (!lib.config.touchscreen) {
                        document.addEventListener('mousewheel', ui.click.windowmousewheel, { passive: true });
                        document.addEventListener('mousemove', ui.click.windowmousemove);
                        document.addEventListener('mousedown', ui.click.windowmousedown);
                        document.addEventListener('mouseup', ui.click.windowmouseup);
                        document.addEventListener('contextmenu', ui.click.right);
                    }
                    else {
                        document.addEventListener('touchstart', ui.click.touchconfirm);
                        document.addEventListener('touchstart', ui.click.windowtouchstart);
                        document.addEventListener('touchend', ui.click.windowtouchend);
                        document.addEventListener('touchmove', ui.click.windowtouchmove);
                    }
                };
                var proceed2 = function () {
                    if (config3) {
                        proceed(config3);
                    }
                    else {
                        config3 = true;
                    }
                };
                //part: 初始化ui.css.menu和ui.css.default样式
                ui.css = {
                    menu: lib.init.css(lib.assetURL + 'layout/default', 'menu', function () {
                        ui.css["default"] = lib.init.css(lib.assetURL + 'layout/default', 'layout');
                        proceed2();
                    })
                };
                //part: config for different type of devices(PC, mobile devices).
                if (lib.device) {
                    //移动端，window加载完成时被调用
                    lib.init.cordovaReady = function () {
                        if (lib.device == 'android') {
                            document.addEventListener("pause", function () {
                                if (!_status.paused2 && (typeof _status.event.isMine == 'function' && !_status.event.isMine())) {
                                    ui.click.pause();
                                }
                                if (ui.backgroundMusic) {
                                    ui.backgroundMusic.pause();
                                }
                            });
                            document.addEventListener("resume", function () {
                                if (ui.backgroundMusic) {
                                    ui.backgroundMusic.play();
                                }
                            });
                            document.addEventListener("backbutton", function () {
                                if (ui.arena && ui.arena.classList.contains('menupaused')) {
                                    if (window.saveNonameInput) {
                                        window.saveNonameInput();
                                    }
                                    else {
                                        ui.click.configMenu();
                                    }
                                }
                                else if (lib.config.confirm_exit) {
                                    navigator.notification.confirm('是否退出游戏？', function (index) {
                                        switch (index) {
                                            case 2:
                                                game.saveConfig('null');
                                                game.reload();
                                                break;
                                            case 3:
                                                navigator.app.exitApp();
                                                break;
                                        }
                                    }, '确认退出', ['取消', '重新开始', '退出']);
                                }
                                else {
                                    navigator.app.exitApp();
                                }
                            });
                        }
                        game.download = function (url, folder, onsuccess, onerror, dev, onprogress) {
                            if (url.indexOf('http') != 0) {
                                url = get.url(dev) + url;
                            }
                            var fileTransfer = new FileTransfer();
                            folder = lib.assetURL + folder;
                            if (onprogress) {
                                fileTransfer.onprogress = function (progressEvent) {
                                    onprogress(progressEvent.loaded, progressEvent.total);
                                };
                            }
                            lib.config.brokenFile.add(folder);
                            game.saveConfigValue('brokenFile');
                            fileTransfer.download(encodeURI(url), encodeURI(folder), function () {
                                lib.config.brokenFile.remove(folder);
                                game.saveConfigValue('brokenFile');
                                if (onsuccess) {
                                    onsuccess();
                                }
                            }, onerror);
                        };
                        game.readFile = function (filename, callback, onerror) {
                            window.resolveLocalFileSystemURL(lib.assetURL, function (entry) {
                                entry.getFile(filename, {}, function (fileEntry) {
                                    fileEntry.file(function (fileToLoad) {
                                        var fileReader = new FileReader();
                                        fileReader.onload = function (e) {
                                            callback(e.target.result);
                                        };
                                        fileReader.readAsArrayBuffer(fileToLoad, "UTF-8");
                                    }, onerror);
                                }, onerror);
                            }, onerror);
                        };
                        game.writeFile = function (data, path, name, callback) {
                            game.ensureDirectory(path, function () { });
                            if (Object.prototype.toString.call(data) == '[object File]') {
                                var fileReader = new FileReader();
                                fileReader.onload = function (e) {
                                    game.writeFile(e.target.result, path, name, callback);
                                };
                                fileReader.readAsArrayBuffer(data, "UTF-8");
                            }
                            else {
                                window.resolveLocalFileSystemURL(lib.assetURL + path, function (entry) {
                                    entry.getFile(name, { create: true }, function (fileEntry) {
                                        fileEntry.createWriter(function (fileWriter) {
                                            fileWriter.onwriteend = callback;
                                            fileWriter.write(data);
                                        });
                                    });
                                });
                            }
                        };
                        game.removeFile = function (dir, callback) {
                            window.resolveLocalFileSystemURL(lib.assetURL, function (entry) {
                                entry.getFile(dir, {}, function (fileEntry) {
                                    fileEntry.remove();
                                    if (callback) {
                                        callback();
                                    }
                                });
                            });
                        };
                        game.getFileList = function (dir, callback) {
                            var files = [], folders = [];
                            window.resolveLocalFileSystemURL(lib.assetURL + dir, function (entry) {
                                var dirReader = entry.createReader();
                                var entries = [];
                                var readEntries = function () {
                                    dirReader.readEntries(function (results) {
                                        if (!results.length) {
                                            entries.sort();
                                            for (var i = 0; i < entries.length; i++) {
                                                if (entries[i].isDirectory) {
                                                    folders.push(entries[i].name);
                                                }
                                                else {
                                                    files.push(entries[i].name);
                                                }
                                            }
                                            callback(folders, files);
                                        }
                                        else {
                                            entries = entries.concat(Array.from(results));
                                            readEntries();
                                        }
                                    });
                                };
                                readEntries();
                            });
                        };
                        game.ensureDirectory = function (list, callback, file) {
                            var directorylist;
                            var num = 0;
                            if (file) {
                                num = 1;
                            }
                            if (typeof list == 'string') {
                                directorylist = [list];
                            }
                            else {
                                var directorylist = list.slice(0);
                            }
                            window.resolveLocalFileSystemURL(lib.assetURL, function (rootEntry) {
                                var access = function (entry, dir, callback) {
                                    if (dir.length <= num) {
                                        callback();
                                    }
                                    else {
                                        var str = dir.shift();
                                        entry.getDirectory(str, { create: false }, function (entry) {
                                            access(entry, dir, callback);
                                        }, function () {
                                            entry.getDirectory(str, { create: true }, function (entry) {
                                                access(entry, dir, callback);
                                            });
                                        });
                                    }
                                };
                                var createDirectory = function () {
                                    if (directorylist.length) {
                                        access(rootEntry, directorylist.shift().split('/'), createDirectory);
                                    }
                                    else {
                                        callback();
                                    }
                                };
                                createDirectory();
                            });
                        };
                        if (ui.updateUpdate) {
                            ui.updateUpdate();
                        }
                        var showbar = function () {
                            if (window.StatusBar) {
                                if (lib.device == 'android') {
                                    if (lib.config.show_statusbar_android) {
                                        window.StatusBar.overlaysWebView(false);
                                        window.StatusBar.backgroundColorByName('black');
                                        window.StatusBar.show();
                                    }
                                }
                                else if (lib.device == 'ios') {
                                    if (lib.config.show_statusbar_ios != 'off' && lib.config.show_statusbar_ios != 'auto') {
                                        if (lib.config.show_statusbar_ios == 'default') {
                                            window.StatusBar.overlaysWebView(false);
                                        }
                                        else {
                                            window.StatusBar.overlaysWebView(true);
                                        }
                                        window.StatusBar.backgroundColorByName('black');
                                        window.StatusBar.show();
                                    }
                                }
                            }
                        };
                        if (lib.arenaReady) {
                            lib.arenaReady.push(showbar);
                        }
                        else {
                            showbar();
                        }
                    };
                }
                else if (typeof window.require == 'function') {
                    //part: PC端
                    lib.node = {
                        fs: require('fs'),
                        debug: function () {
                            require('electron').remote.getCurrentWindow().toggleDevTools();
                        }
                    };
                    game.download = function (url, folder, onsuccess, onerror, dev, onprogress) {
                        if (url.indexOf('http') != 0) {
                            url = get.url(dev) + url;
                        }
                        game.ensureDirectory(folder, function () {
                            try {
                                var file = lib.node.fs.createWriteStream(__dirname + '/' + folder);
                            }
                            catch (e) {
                                onerror();
                            }
                            lib.config.brokenFile.add(folder);
                            game.saveConfigValue('brokenFile');
                            if (!lib.node.http)
                                lib.node.http = require('http');
                            if (!lib.node.https)
                                lib.node.https = require('https');
                            var opts = require('url').parse(encodeURI(url));
                            opts.headers = { 'User-Agent': 'AppleWebkit' };
                            var request = (url.indexOf('https') == 0 ? lib.node.https : lib.node.http).get(opts, function (response) {
                                var stream = response.pipe(file);
                                stream.on('finish', function () {
                                    lib.config.brokenFile.remove(folder);
                                    game.saveConfigValue('brokenFile');
                                    if (onsuccess) {
                                        onsuccess();
                                    }
                                });
                                stream.on('error', onerror);
                                if (onprogress) {
                                    var streamInterval = setInterval(function () {
                                        if (stream.closed) {
                                            clearInterval(streamInterval);
                                        }
                                        else {
                                            onprogress(stream.bytesWritten);
                                        }
                                    }, 200);
                                }
                            });
                        }, true);
                    };
                    game.readFile = function (filename, callback, onerror) {
                        lib.node.fs.readFile(__dirname + '/' + filename, function (err, data) {
                            if (err) {
                                onerror(err);
                            }
                            else {
                                callback(data);
                            }
                        });
                    };
                    game.writeFile = function (data, path, name, callback) {
                        game.ensureDirectory(path, function () { });
                        if (Object.prototype.toString.call(data) == '[object File]') {
                            var fileReader = new FileReader();
                            fileReader.onload = function (e) {
                                game.writeFile(e.target.result, path, name, callback);
                            };
                            fileReader.readAsArrayBuffer(data, "UTF-8");
                        }
                        else {
                            get.zip(function (zip) {
                                zip.file('i', data);
                                lib.node.fs.writeFile(__dirname + '/' + path + '/' + name, zip.files.i.asNodeBuffer(), null, callback);
                            });
                        }
                    };
                    game.removeFile = function (filename, callback) {
                        lib.node.fs.unlink(__dirname + '/' + filename, callback || function () { });
                    };
                    game.getFileList = function (dir, callback) {
                        var files = [], folders = [];
                        dir = __dirname + '/' + dir;
                        lib.node.fs.readdir(dir, function (err, filelist) {
                            for (var i = 0; i < filelist.length; i++) {
                                if (filelist[i][0] != '.' && filelist[i][0] != '_') {
                                    if (lib.node.fs.statSync(dir + '/' + filelist[i]).isDirectory()) {
                                        folders.push(filelist[i]);
                                    }
                                    else {
                                        files.push(filelist[i]);
                                    }
                                }
                            }
                            callback(folders, files);
                        });
                    };
                    game.ensureDirectory = function (list, callback, file) {
                        var directorylist;
                        var num = 0;
                        if (file) {
                            num = 1;
                        }
                        if (typeof list == 'string') {
                            directorylist = [list];
                        }
                        else {
                            var directorylist = list.slice(0);
                        }
                        var access = function (str, dir, callback) {
                            if (dir.length <= num) {
                                callback();
                            }
                            else {
                                str += '/' + dir.shift();
                                lib.node.fs.access(__dirname + str, function (e) {
                                    if (e) {
                                        try {
                                            lib.node.fs.mkdir(__dirname + str, function () {
                                                access(str, dir, callback);
                                            });
                                        }
                                        catch (e) {
                                            console.log(e);
                                        }
                                    }
                                    else {
                                        access(str, dir, callback);
                                    }
                                });
                            }
                        };
                        var createDirectory = function () {
                            if (directorylist.length) {
                                access('', directorylist.shift().split('/'), createDirectory);
                            }
                            else {
                                callback();
                            }
                        };
                        createDirectory();
                    };
                    if (ui.updateUpdate) {
                        ui.updateUpdate();
                    }
                }
                else {
                    //part: 网页端
                    window.onbeforeunload = function () {
                        if (lib.config.confirm_exit && !_status.reloading) {
                            return '是否离开游戏？';
                        }
                        else {
                            return null;
                        }
                    };
                }
                //part: 游戏设置信息，window.config，创建于config.js
                lib.config = window.config;
                //part: 联机部分的设置
                lib.configOL = {};
                delete window.config;
                var config2;
                if (localStorage.getItem(lib.configprefix + 'nodb')) {
                    window.nodb = true;
                }
                //part: 持久化数据
                //`config2` 在这里从indexedDB/localStorage加载config数据，存入`config2`；`config2`，可能是`{}`，`false`或者读取到的config对象
                //如果config加载完成时，`ui.css`未加载完成，则暂存`config2`于`config3`中，等到完成再调用`proceed`
                if (window.indexedDB && !window.nodb) {
                    //part: indexedDB
                    var request = window.indexedDB.open(lib.configprefix + 'data', 4);
                    request.onupgradeneeded = function (e) {
                        var db = e.target.result;
                        if (!db.objectStoreNames.contains('video')) {
                            db.createObjectStore('video', { keyPath: 'time' });
                        }
                        if (!db.objectStoreNames.contains('image')) {
                            db.createObjectStore('image');
                        }
                        if (!db.objectStoreNames.contains('audio')) {
                            db.createObjectStore('audio');
                        }
                        if (!db.objectStoreNames.contains('config')) {
                            db.createObjectStore('config');
                        }
                        if (!db.objectStoreNames.contains('data')) {
                            db.createObjectStore('data');
                        }
                    };
                    request.onsuccess = function (e) {
                        lib.db = e.target.result;
                        //part: indexedDB 读取config对象
                        game.getDB('config', null, function (obj) {
                            if (!obj.storageImported) {
                                try {
                                    config2 = JSON.parse(localStorage.getItem(lib.configprefix + 'config'));
                                    if (!config2 || typeof config2 != 'object')
                                        throw 'err';
                                }
                                catch (err) {
                                    config2 = {};
                                }
                                for (var i in config2) {
                                    game.saveConfig(i, config2[i]);
                                }
                                for (var i in lib.mode) {
                                    try {
                                        config2 = JSON.parse(localStorage.getItem(lib.configprefix + i));
                                        if (!config2 || typeof config2 != 'object' || get.is.empty(config2))
                                            throw 'err';
                                    }
                                    catch (err) {
                                        config2 = false;
                                    }
                                    localStorage.removeItem(lib.configprefix + i);
                                    if (config2) {
                                        game.putDB('data', i, config2);
                                    }
                                }
                                game.saveConfig('storageImported', true);
                                //init background
                                lib.init.background();
                                localStorage.removeItem(lib.configprefix + 'config');
                            }
                            else {
                                config2 = obj;
                            }
                            proceed(config2);
                        });
                    };
                }
                else {
                    //part: localStorage
                    try {
                        config2 = JSON.parse(localStorage.getItem(lib.configprefix + 'config'));
                        if (!config2 || typeof config2 != 'object')
                            throw 'err';
                    }
                    catch (err) {
                        config2 = {};
                        localStorage.setItem(lib.configprefix + 'config', JSON.stringify({}));
                    }
                    proceed(config2);
                }
            },
            /**
             * 重置游戏
             * 在游戏初始载入过程中超时的回调函数，发出弹窗询问是否重置（重启）游戏。
             * @function
             */
            reset: function () {
                if (window.inSplash)
                    return;
                if (window.resetExtension) {
                    if (confirm('游戏似乎未正常载入，是否禁用扩展并重新打开？')) {
                        window.resetExtension();
                        window.location.reload();
                    }
                }
                else {
                    if (lib.device) {
                        if (navigator.notification) {
                            navigator.notification.confirm('游戏似乎未正常载入，是否重置游戏？', function (index) {
                                if (index == 2) {
                                    localStorage.removeItem('noname_inited');
                                    window.location.reload();
                                }
                                else if (index == 3) {
                                    var noname_inited = localStorage.getItem('noname_inited');
                                    var onlineKey = localStorage.getItem(lib.configprefix + 'key');
                                    localStorage.clear();
                                    if (noname_inited) {
                                        localStorage.setItem('noname_inited', noname_inited);
                                    }
                                    if (onlineKey) {
                                        localStorage.setItem(lib.configprefix + 'key', onlineKey);
                                    }
                                    if (indexedDB)
                                        indexedDB.deleteDatabase(lib.configprefix + 'data');
                                    setTimeout(function () {
                                        window.location.reload();
                                    }, 200);
                                }
                            }, '确认退出', ['取消', '重新下载', '重置设置']);
                        }
                        else {
                            if (confirm('游戏似乎未正常载入，是否重置游戏？')) {
                                localStorage.removeItem('noname_inited');
                                window.location.reload();
                            }
                        }
                    }
                    else {
                        if (confirm('游戏似乎未正常载入，是否重置游戏？')) {
                            var onlineKey = localStorage.getItem(lib.configprefix + 'key');
                            localStorage.clear();
                            if (onlineKey) {
                                localStorage.setItem(lib.configprefix + 'key', onlineKey);
                            }
                            if (indexedDB)
                                indexedDB.deleteDatabase(lib.configprefix + 'data');
                            setTimeout(function () {
                                window.location.reload();
                            }, 200);
                        }
                    }
                }
            },
            /**
             * 游戏初始载入成功时被调用，加载游戏样式数据，并载入开始界面。
             * @function
             */
            onload: function () {
                ui.updated();
                /**
                 * 文档缩放比例
                 * @type {number}
                 */
                game.documentZoom = game.deviceZoom;
                if (game.documentZoom != 1) {
                    ui.updatez();
                }
                ui.background = ui.create.div('.background');
                ui.background.style.backgroundSize = "cover";
                ui.background.style.backgroundPosition = '50% 50%';
                if (lib.config.image_background && lib.config.image_background != 'default' && lib.config.image_background.indexOf('custom_') != 0) {
                    if (lib.config.image_background.indexOf('svg_') == 0) {
                        ui.background.setBackgroundImage('image/background/' + lib.config.image_background.slice(4) + '.svg');
                    }
                    else {
                        ui.background.setBackgroundImage('image/background/' + lib.config.image_background + '.jpg');
                        ui.backgroundSVG = ui.create.div('.background', ui.background);
                        ui.backgroundSVG.setBackgroundImage('image/background/' + 'simple1_bg' + '.svg');
                        ui.backgroundSVG.style.opacity = '.3';
                    }
                    if (lib.config.image_background_blur) {
                        ui.background.style.filter = 'blur(8px)';
                        ui.background.style.webkitFilter = 'blur(8px)';
                        ui.background.style.transform = 'scale(1.05)';
                    }
                }
                document.documentElement.style.backgroundImage = '';
                document.documentElement.style.backgroundSize = '';
                document.documentElement.style.backgroundPosition = '';
                document.body.insertBefore(ui.background, document.body.firstChild);
                document.body.onresize = ui.updatexr;
                if (lib.config.touchscreen) {
                    document.body.addEventListener('touchstart', function (e) {
                        this.startX = e.touches[0].clientX / game.documentZoom;
                        this.startY = e.touches[0].clientY / game.documentZoom;
                        _status.dragged = false;
                    });
                    document.body.addEventListener('touchmove', function (e) {
                        if (_status.dragged)
                            return;
                        if (Math.abs(e.touches[0].clientX / game.documentZoom - this.startX) > 10 ||
                            Math.abs(e.touches[0].clientY / game.documentZoom - this.startY) > 10) {
                            _status.dragged = true;
                        }
                    });
                }
                if (lib.config.image_background.indexOf('custom_') == 0) {
                    ui.background.style.backgroundImage = "none";
                    game.getDB('image', lib.config.image_background, function (fileToLoad) {
                        if (!fileToLoad)
                            return;
                        var fileReader = new FileReader();
                        fileReader.onload = function (fileLoadedEvent) {
                            var data = fileLoadedEvent.target.result;
                            ui.background.style.backgroundImage = 'url(' + data + ')';
                            if (lib.config.image_background_blur) {
                                ui.background.style.filter = 'blur(8px)';
                                ui.background.style.webkitFilter = 'blur(8px)';
                                ui.background.style.transform = 'scale(1.05)';
                            }
                        };
                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                    });
                }
                if (lib.config.card_style == 'custom') {
                    game.getDB('image', 'card_style', function (fileToLoad) {
                        if (!fileToLoad)
                            return;
                        var fileReader = new FileReader();
                        fileReader.onload = function (fileLoadedEvent) {
                            if (ui.css.card_stylesheet) {
                                ui.css.card_stylesheet.remove();
                            }
                            ui.css.card_stylesheet = lib.init.sheet('.card:not(*:empty){background-image:url(' + fileLoadedEvent.target.result + ')}');
                        };
                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                    });
                }
                if (lib.config.cardback_style == 'custom') {
                    game.getDB('image', 'cardback_style', function (fileToLoad) {
                        if (!fileToLoad)
                            return;
                        var fileReader = new FileReader();
                        fileReader.onload = function (fileLoadedEvent) {
                            if (ui.css.cardback_stylesheet) {
                                ui.css.cardback_stylesheet.remove();
                            }
                            ui.css.cardback_stylesheet = lib.init.sheet('.card:empty,.card.infohidden{background-image:url(' + fileLoadedEvent.target.result + ')}');
                        };
                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                    });
                    game.getDB('image', 'cardback_style2', function (fileToLoad) {
                        if (!fileToLoad)
                            return;
                        var fileReader = new FileReader();
                        fileReader.onload = function (fileLoadedEvent) {
                            if (ui.css.cardback_stylesheet2) {
                                ui.css.cardback_stylesheet2.remove();
                            }
                            ui.css.cardback_stylesheet2 = lib.init.sheet('.card.infohidden:not(.infoflip){background-image:url(' + fileLoadedEvent.target.result + ')}');
                        };
                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                    });
                }
                if (lib.config.hp_style == 'custom') {
                    game.getDB('image', 'hp_style1', function (fileToLoad) {
                        if (!fileToLoad)
                            return;
                        var fileReader = new FileReader();
                        fileReader.onload = function (fileLoadedEvent) {
                            if (ui.css.hp_stylesheet1) {
                                ui.css.hp_stylesheet1.remove();
                            }
                            ui.css.hp_stylesheet1 = lib.init.sheet('.hp:not(.text):not(.actcount)[data-condition="high"]>div:not(.lost){background-image:url(' + fileLoadedEvent.target.result + ')}');
                        };
                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                    });
                    game.getDB('image', 'hp_style2', function (fileToLoad) {
                        if (!fileToLoad)
                            return;
                        var fileReader = new FileReader();
                        fileReader.onload = function (fileLoadedEvent) {
                            if (ui.css.hp_stylesheet2) {
                                ui.css.hp_stylesheet2.remove();
                            }
                            ui.css.hp_stylesheet2 = lib.init.sheet('.hp:not(.text):not(.actcount)[data-condition="mid"]>div:not(.lost){background-image:url(' + fileLoadedEvent.target.result + ')}');
                        };
                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                    });
                    game.getDB('image', 'hp_style3', function (fileToLoad) {
                        if (!fileToLoad)
                            return;
                        var fileReader = new FileReader();
                        fileReader.onload = function (fileLoadedEvent) {
                            if (ui.css.hp_stylesheet3) {
                                ui.css.hp_stylesheet3.remove();
                            }
                            ui.css.hp_stylesheet3 = lib.init.sheet('.hp:not(.text):not(.actcount)[data-condition="low"]>div:not(.lost){background-image:url(' + fileLoadedEvent.target.result + ')}');
                        };
                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                    });
                    game.getDB('image', 'hp_style4', function (fileToLoad) {
                        if (!fileToLoad)
                            return;
                        var fileReader = new FileReader();
                        fileReader.onload = function (fileLoadedEvent) {
                            if (ui.css.hp_stylesheet4) {
                                ui.css.hp_stylesheet4.remove();
                            }
                            ui.css.hp_stylesheet4 = lib.init.sheet('.hp:not(.text):not(.actcount)>.lost{background-image:url(' + fileLoadedEvent.target.result + ')}');
                        };
                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                    });
                }
                if (lib.config.player_style == 'custom') {
                    ui.css.player_stylesheet = lib.init.sheet('#window .player{background-image:none;background-size:100% 100%;}');
                    game.getDB('image', 'player_style', function (fileToLoad) {
                        if (!fileToLoad)
                            return;
                        var fileReader = new FileReader();
                        fileReader.onload = function (fileLoadedEvent) {
                            if (ui.css.player_stylesheet) {
                                ui.css.player_stylesheet.remove();
                            }
                            ui.css.player_stylesheet = lib.init.sheet('#window .player{background-image:url("' + fileLoadedEvent.target.result + '");background-size:100% 100%;}');
                        };
                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                    });
                }
                if (lib.config.border_style == 'custom') {
                    game.getDB('image', 'border_style', function (fileToLoad) {
                        if (!fileToLoad)
                            return;
                        var fileReader = new FileReader();
                        fileReader.onload = function (fileLoadedEvent) {
                            if (ui.css.border_stylesheet) {
                                ui.css.border_stylesheet.remove();
                            }
                            ui.css.border_stylesheet = lib.init.sheet();
                            ui.css.border_stylesheet.sheet.insertRule('#window .player>.framebg{display:block;background-image:url("' + fileLoadedEvent.target.result + '")}', 0);
                            ui.css.border_stylesheet.sheet.insertRule('.player>.count{z-index: 3 !important;border-radius: 2px !important;text-align: center !important;}', 0);
                        };
                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                    });
                }
                if (lib.config.control_style == 'custom') {
                    game.getDB('image', 'control_style', function (fileToLoad) {
                        if (!fileToLoad)
                            return;
                        var fileReader = new FileReader();
                        fileReader.onload = function (fileLoadedEvent) {
                            if (ui.css.control_stylesheet) {
                                ui.css.control_stylesheet.remove();
                            }
                            ui.css.control_stylesheet = lib.init.sheet('#window .control,.menubutton:not(.active):not(.highlight):not(.red):not(.blue),#window #system>div>div{background-image:url("' + fileLoadedEvent.target.result + '")}');
                        };
                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                    });
                }
                if (lib.config.menu_style == 'custom') {
                    game.getDB('image', 'menu_style', function (fileToLoad) {
                        if (!fileToLoad)
                            return;
                        var fileReader = new FileReader();
                        fileReader.onload = function (fileLoadedEvent) {
                            if (ui.css.menu_stylesheet) {
                                ui.css.menu_stylesheet.remove();
                            }
                            ui.css.menu_stylesheet = lib.init.sheet('html #window>.dialog.popped,html .menu,html .menubg{background-image:url("' + fileLoadedEvent.target.result + '");background-size:cover}');
                        };
                        fileReader.readAsDataURL(fileToLoad, "UTF-8");
                    });
                }
                var proceed2 = function () {
                    var mode = lib.imported.mode;
                    var card = lib.imported.card;
                    var character = lib.imported.character;
                    var play = lib.imported.play;
                    // delete window.game;//[todo delete]
                    var i, j, k;
                    for (i in mode[lib.config.mode].element) {
                        if (!lib.element[i])
                            lib.element[i] = [];
                        mixin(PlayerModel.prototype, mode[lib.config.mode].element.player);
                        for (j in mode[lib.config.mode].element[i]) {
                            if (j == 'init') {
                                if (!lib.element[i].inits)
                                    lib.element[i].inits = [];
                                lib.element[i].inits.push(mode[lib.config.mode].element[i][j]);
                            }
                            else {
                                lib.element[i][j] = mode[lib.config.mode].element[i][j];
                            }
                        }
                    }
                    for (i in mode[lib.config.mode].ai) {
                        if (typeof mode[lib.config.mode].ai[i] == 'object') {
                            if (ai[i] == undefined)
                                ai[i] = {};
                            for (j in mode[lib.config.mode].ai[i]) {
                                ai[i][j] = mode[lib.config.mode].ai[i][j];
                            }
                        }
                        else {
                            ai[i] = mode[lib.config.mode].ai[i];
                        }
                    }
                    for (i in mode[lib.config.mode].ui) {
                        if (typeof mode[lib.config.mode].ui[i] == 'object') {
                            if (ui[i] == undefined)
                                ui[i] = {};
                            for (j in mode[lib.config.mode].ui[i]) {
                                ui[i][j] = mode[lib.config.mode].ui[i][j];
                            }
                        }
                        else {
                            ui[i] = mode[lib.config.mode].ui[i];
                        }
                    }
                    for (i in mode[lib.config.mode].game) {
                        game[i] = mode[lib.config.mode].game[i];
                    }
                    for (i in mode[lib.config.mode].get) {
                        get[i] = mode[lib.config.mode].get[i];
                    }
                    lib.init.start = mode[lib.config.mode].start;
                    lib.init.startBefore = mode[lib.config.mode].startBefore;
                    if (game.onwash) {
                        lib.onwash.push(game.onwash);
                        delete game.onwash;
                    }
                    if (game.onover) {
                        lib.onover.push(game.onover);
                        delete game.onover;
                    }
                    lib.config.banned = lib.config[lib.config.mode + '_banned'] || [];
                    lib.config.bannedcards = lib.config[lib.config.mode + '_bannedcards'] || [];
                    lib.rank = window.noname_character_rank;
                    delete window.noname_character_rank;
                    for (i in mode[lib.config.mode]) {
                        if (i == 'element')
                            continue;
                        if (i == 'game')
                            continue;
                        if (i == 'ai')
                            continue;
                        if (i == 'ui')
                            continue;
                        if (i == 'get')
                            continue;
                        if (i == 'config')
                            continue;
                        if (i == 'onreinit')
                            continue;
                        if (i == 'start')
                            continue;
                        if (i == 'startBefore')
                            continue;
                        if (lib[i] == undefined)
                            lib[i] = (Array.isArray(mode[lib.config.mode][i])) ? [] : {};
                        for (j in mode[lib.config.mode][i]) {
                            lib[i][j] = mode[lib.config.mode][i][j];
                        }
                    }
                    if (typeof mode[lib.config.mode].init == 'function') {
                        mode[lib.config.mode].init();
                    }
                    var connectCharacterPack = [];
                    var connectCardPack = [];
                    for (i in character) {
                        if (character[i].character) {
                            lib.characterPack[i] = character[i].character;
                        }
                        for (j in character[i]) {
                            if (j == 'mode' || j == 'forbid')
                                continue;
                            if (j == 'connect') {
                                connectCharacterPack.push(i);
                                continue;
                            }
                            if (j == 'character' && !lib.config.characters.contains(i) && lib.config.mode != 'connect') {
                                if (lib.config.mode == 'chess' && get.config('chess_mode') == 'leader' && get.config('chess_leader_allcharacter')) {
                                    for (k in character[i][j]) {
                                        lib.hiddenCharacters.push(k);
                                    }
                                }
                                else if (lib.config.mode != 'boss' || i != 'boss') {
                                    continue;
                                }
                            }
                            if (Array.isArray(lib[j]) && Array.isArray(character[i][j])) {
                                lib[j].addArray(character[i][j]);
                                continue;
                            }
                            for (k in character[i][j]) {
                                if (j == 'character') {
                                    if (!character[i][j][k][4]) {
                                        character[i][j][k][4] = [];
                                    }
                                    if (character[i][j][k][4].contains('boss') ||
                                        character[i][j][k][4].contains('hiddenboss')) {
                                        lib.config.forbidai.add(k);
                                    }
                                    if (lib.config.forbidai_user && lib.config.forbidai_user.contains(k)) {
                                        lib.config.forbidai.add(k);
                                    }
                                    for (var l = 0; l < character[i][j][k][3].length; l++) {
                                        lib.skilllist.add(character[i][j][k][3][l]);
                                    }
                                }
                                if (j == 'skill' && k[0] == '_' && (lib.config.mode != 'connect' ? (!lib.config.characters.contains(i)) : (!character[i].connect))) {
                                    continue;
                                }
                                if (j == 'translate' && k == i) {
                                    lib[j][k + '_character_config'] = character[i][j][k];
                                }
                                else {
                                    if (lib[j][k] == undefined) {
                                        if (j == 'skill' && !character[i][j][k].forceLoad && lib.config.mode == 'connect' && !character[i].connect) {
                                            lib[j][k] = {
                                                nopop: character[i][j][k].nopop,
                                                derivation: character[i][j][k].derivation
                                            };
                                        }
                                        else {
                                            lib[j][k] = character[i][j][k];
                                        }
                                        if (j == 'card' && lib[j][k].derivation) {
                                            if (!lib.cardPack.mode_derivation) {
                                                lib.cardPack.mode_derivation = [k];
                                            }
                                            else {
                                                lib.cardPack.mode_derivation.push(k);
                                            }
                                        }
                                    }
                                    else if (Array.isArray(lib[j][k]) && Array.isArray(character[i][j][k])) {
                                        lib[j][k].addArray(character[i][j][k]);
                                    }
                                    else {
                                        console.log('dublicate ' + j + ' in character ' + i + ':\n' + k + '\n' + ': ' + lib[j][k] + '\n' + character[i][j][k]);
                                    }
                                }
                            }
                        }
                    }
                    var connect_avatar_list = [];
                    for (var i in lib.character) {
                        connect_avatar_list.push(i);
                    }
                    connect_avatar_list.sort(lib.sort.capt);
                    for (var i = 0; i < connect_avatar_list.length; i++) {
                        var ia = connect_avatar_list[i];
                        lib.mode.connect.config.connect_avatar.item[ia] = lib.translate[ia];
                    }
                    if (lib.config.mode != 'connect') {
                        var pilecfg = lib.config.customcardpile[get.config('cardpilename') || '当前牌堆'];
                        if (pilecfg) {
                            lib.config.bannedpile = get.copy(pilecfg[0] || {});
                            lib.config.addedpile = get.copy(pilecfg[1] || {});
                        }
                        else {
                            lib.config.bannedpile = {};
                            lib.config.addedpile = {};
                        }
                    }
                    else {
                        lib.cardPackList = {};
                    }
                    for (i in card) {
                        lib.cardPack[i] = [];
                        if (card[i].card) {
                            for (var j in card[i].card) {
                                if (!card[i].card[j].hidden && card[i].translate[j + '_info']) {
                                    lib.cardPack[i].push(j);
                                }
                            }
                        }
                        for (j in card[i]) {
                            if (j == 'mode' || j == 'forbid')
                                continue;
                            if (j == 'connect') {
                                connectCardPack.push(i);
                                continue;
                            }
                            if (j == 'list') {
                                if (lib.config.mode == 'connect') {
                                    lib.cardPackList[i] = card[i][j];
                                }
                                else {
                                    if (lib.config.cards.contains(i)) {
                                        var pile;
                                        if (typeof card[i][j] == 'function') {
                                            pile = card[i][j]();
                                        }
                                        else {
                                            pile = card[i][j];
                                        }
                                        lib.cardPile[i] = pile.slice(0);
                                        if (lib.config.bannedpile[i]) {
                                            for (var k = 0; k < lib.config.bannedpile[i].length; k++) {
                                                pile[lib.config.bannedpile[i][k]] = null;
                                            }
                                        }
                                        for (var k = 0; k < pile.length; k++) {
                                            if (!pile[k]) {
                                                pile.splice(k--, 1);
                                            }
                                        }
                                        if (lib.config.addedpile[i]) {
                                            for (var k = 0; k < lib.config.addedpile[i].length; k++) {
                                                pile.push(lib.config.addedpile[i][k]);
                                            }
                                        }
                                        lib.card.list = lib.card.list.concat(pile);
                                    }
                                }
                            }
                            else {
                                for (k in card[i][j]) {
                                    if (j == 'skill' && k[0] == '_' && !card[i][j][k].forceLoad && (lib.config.mode != 'connect' ? (!lib.config.cards.contains(i)) : (!card[i].connect))) {
                                        continue;
                                    }
                                    if (j == 'translate' && k == i) {
                                        lib[j][k + '_card_config'] = card[i][j][k];
                                    }
                                    else {
                                        if (lib[j][k] == undefined) {
                                            if (j == 'skill' && !card[i][j][k].forceLoad && lib.config.mode == 'connect' && !card[i].connect) {
                                                lib[j][k] = {
                                                    nopop: card[i][j][k].nopop,
                                                    derivation: card[i][j][k].derivation
                                                };
                                            }
                                            else {
                                                lib[j][k] = card[i][j][k];
                                            }
                                        }
                                        else
                                            console.log('dublicate ' + j + ' in card ' + i + ':\n' + k + '\n' + lib[j][k] + '\n' + card[i][j][k]);
                                        if (j == 'card' && lib[j][k].derivation) {
                                            if (!lib.cardPack.mode_derivation) {
                                                lib.cardPack.mode_derivation = [k];
                                            }
                                            else {
                                                lib.cardPack.mode_derivation.push(k);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (lib.cardPack.mode_derivation) {
                        for (var i = 0; i < lib.cardPack.mode_derivation.length; i++) {
                            if (typeof lib.card[lib.cardPack.mode_derivation[i]].derivation == 'string' && !lib.character[lib.card[lib.cardPack.mode_derivation[i]].derivation]) {
                                lib.cardPack.mode_derivation.splice(i--, 1);
                            }
                            else if (typeof lib.card[lib.cardPack.mode_derivation[i]].derivationpack == 'string' && !lib.config.cards.contains(lib.card[lib.cardPack.mode_derivation[i]].derivationpack)) {
                                lib.cardPack.mode_derivation.splice(i--, 1);
                            }
                        }
                        if (lib.cardPack.mode_derivation.length == 0) {
                            delete lib.cardPack.mode_derivation;
                        }
                    }
                    if (lib.config.mode != 'connect') {
                        for (i in play) {
                            if (lib.config.hiddenPlayPack.contains(i))
                                continue;
                            if (play[i].forbid && play[i].forbid.contains(lib.config.mode))
                                continue;
                            if (play[i].mode && play[i].mode.contains(lib.config.mode) == false)
                                continue;
                            for (j in play[i].element) {
                                if (!lib.element[j])
                                    lib.element[j] = [];
                                for (k in play[i].element[j]) {
                                    if (k == 'init') {
                                        if (!lib.element[j].inits)
                                            lib.element[j].inits = [];
                                        lib.element[j].inits.push(play[i].element[j][k]);
                                    }
                                    else {
                                        lib.element[j][k] = play[i].element[j][k];
                                    }
                                }
                            }
                            for (j in play[i].ui) {
                                if (typeof play[i].ui[j] == 'object') {
                                    if (ui[j] == undefined)
                                        ui[j] = {};
                                    for (k in play[i].ui[j]) {
                                        ui[j][k] = play[i].ui[j][k];
                                    }
                                }
                                else {
                                    ui[j] = play[i].ui[j];
                                }
                            }
                            for (j in play[i].game) {
                                game[j] = play[i].game[j];
                            }
                            for (j in play[i].get) {
                                get[j] = play[i].get[j];
                            }
                            for (j in play[i]) {
                                if (j == 'mode' || j == 'forbid' || j == 'init' || j == 'element' ||
                                    j == 'game' || j == 'get' || j == 'ui' || j == 'arenaReady')
                                    continue;
                                for (k in play[i][j]) {
                                    if (j == 'translate' && k == i) {
                                        // lib[j][k+'_play_config']=play[i][j][k];
                                    }
                                    else {
                                        if (lib[j][k] != undefined) {
                                            console.log('dublicate ' + j + ' in play ' + i + ':\n' + k + '\n' + ': ' + lib[j][k] + '\n' + play[i][j][k]);
                                        }
                                        lib[j][k] = play[i][j][k];
                                    }
                                }
                            }
                            if (typeof play[i].init == 'function')
                                play[i].init();
                            if (typeof play[i].arenaReady == 'function')
                                lib.arenaReady.push(play[i].arenaReady);
                        }
                    }
                    lib.connectCharacterPack = [];
                    lib.connectCardPack = [];
                    for (var i = 0; i < lib.config.all.characters.length; i++) {
                        var packname = lib.config.all.characters[i];
                        if (connectCharacterPack.contains(packname)) {
                            lib.connectCharacterPack.push(packname);
                        }
                    }
                    for (var i = 0; i < lib.config.all.cards.length; i++) {
                        var packname = lib.config.all.cards[i];
                        if (connectCardPack.contains(packname)) {
                            lib.connectCardPack.push(packname);
                        }
                    }
                    if (lib.config.mode != 'connect') {
                        for (i = 0; i < lib.card.list.length; i++) {
                            if (lib.card.list[i][2] == 'huosha') {
                                lib.card.list[i] = lib.card.list[i].slice(0);
                                lib.card.list[i][2] = 'sha';
                                lib.card.list[i][3] = 'fire';
                            }
                            else if (lib.card.list[i][2] == 'leisha') {
                                lib.card.list[i] = lib.card.list[i].slice(0);
                                lib.card.list[i][2] = 'sha';
                                lib.card.list[i][3] = 'thunder';
                            }
                            else if (lib.card.list[i][2] == 'haisha') {
                                lib.card.list[i] = lib.card.list[i].slice(0);
                                lib.card.list[i][2] = 'sha';
                                lib.card.list[i][3] = 'ocean';
                            }
                            else if (lib.card.list[i][2] == 'yamisha') {
                                lib.card.list[i] = lib.card.list[i].slice(0);
                                lib.card.list[i][2] = 'sha';
                                lib.card.list[i][3] = 'yami';
                            }
                            if (lib.card.list[i][2] == 'haitao') {
                                lib.card.list[i] = lib.card.list[i].slice(0);
                                lib.card.list[i][2] = 'tao';
                                lib.card.list[i][3] = 'ocean';
                            }
                            if (lib.card.list[i][2] == 'haijiu') {
                                lib.card.list[i] = lib.card.list[i].slice(0);
                                lib.card.list[i][2] = 'jiu';
                                lib.card.list[i][3] = 'ocean';
                            }
                            if (!lib.card[lib.card.list[i][2]]) {
                                lib.card.list.splice(i, 1);
                                i--;
                            }
                            else if (lib.card[lib.card.list[i][2]].mode &&
                                lib.card[lib.card.list[i][2]].mode.contains(lib.config.mode) == false) {
                                lib.card.list.splice(i, 1);
                                i--;
                            }
                        }
                    }
                    if (lib.config.mode == 'connect') {
                        _status.connectMode = true;
                    }
                    if (window.isNonameServer) {
                        lib.cheat.i();
                    }
                    else if (lib.config.dev && (!_status.connectMode || lib.config.debug)) {
                        lib.cheat.i();
                    }
                    lib.config.sort_card = get.sortCard(lib.config.sort);
                    delete lib.imported.character;
                    delete lib.imported.card;
                    delete lib.imported.mode;
                    delete lib.imported.play;
                    for (var i in lib.init) {
                        if (i.indexOf('setMode_') == 0) {
                            delete lib.init[i];
                        }
                    }
                    if (!_status.connectMode) {
                        for (var i = 0; i < lib.extensions.length; i++) {
                            try {
                                _status.extension = lib.extensions[i][0];
                                _status.evaluatingExtension = lib.extensions[i][3];
                                lib.extensions[i][1](lib.extensions[i][2], lib.extensions[i][4]);
                                if (lib.extensions[i][4]) {
                                    if (lib.extensions[i][4].character) {
                                        for (var j in lib.extensions[i][4].character.character) {
                                            game.addCharacterPack(get.copy(lib.extensions[i][4].character));
                                            break;
                                        }
                                    }
                                    if (lib.extensions[i][4].card) {
                                        for (var j in lib.extensions[i][4].card.card) {
                                            game.addCardPack(get.copy(lib.extensions[i][4].card));
                                            break;
                                        }
                                    }
                                    if (lib.extensions[i][4].skill) {
                                        for (var j in lib.extensions[i][4].skill.skill) {
                                            game.addSkill(j, lib.extensions[i][4].skill.skill[j], lib.extensions[i][4].skill.translate[j], lib.extensions[i][4].skill.translate[j + '_info']);
                                        }
                                    }
                                }
                                delete _status.extension;
                                delete _status.evaluatingExtension;
                            }
                            catch (e) {
                                console.log(e);
                            }
                        }
                    }
                    delete lib.extensions;
                    if (lib.init.startBefore) {
                        lib.init.startBefore();
                        delete lib.init.startBefore;
                    }
                    ui.create.arena();
                    game.createEvent('game', false).setContent(lib.init.start);
                    if (lib.mode[lib.config.mode] && lib.mode[lib.config.mode].fromextension) {
                        var startstr = mode[lib.config.mode].start.toString();
                        if (startstr.indexOf('onfree') == -1) {
                            setTimeout(lib.init.onfree, 500);
                        }
                    }
                    delete lib.init.start;
                    game.loop();
                };
                var proceed = function () {
                    if (!lib.db) {
                        try {
                            lib.storage = JSON.parse(localStorage.getItem(lib.configprefix + lib.config.mode));
                            if (typeof lib.storage != 'object')
                                throw ('err');
                            if (lib.storage == null)
                                throw ('err');
                        }
                        catch (err) {
                            lib.storage = {};
                            localStorage.setItem(lib.configprefix + lib.config.mode, "{}");
                        }
                        proceed2();
                    }
                    else {
                        game.getDB('data', lib.config.mode, function (obj) {
                            lib.storage = obj || {};
                            proceed2();
                        });
                    }
                };
                if (!lib.imported.mode || !lib.imported.mode[lib.config.mode]) {
                    window.inSplash = true;
                    clearTimeout(window.resetGameTimeout);
                    delete window.resetGameTimeout;
                    var clickedNode = false;
                    var clickNode = function () {
                        if (clickedNode)
                            return;
                        this.classList.add('clicked');
                        clickedNode = true;
                        lib.config.mode = this.link;
                        game.saveConfig('mode', this.link);
                        if (this.link == 'connect') {
                            localStorage.setItem(lib.configprefix + 'directstart', true);
                            game.reload();
                        }
                        else {
                            if (game.layout != 'mobile' && lib.layoutfixed.indexOf(lib.config.mode) !== -1) {
                                game.layout = 'mobile';
                                ui.css.layout.href = lib.assetURL + 'layout/' + game.layout + '/layout.css';
                            }
                            else if (game.layout == 'mobile' && lib.config.layout != 'mobile' && lib.layoutfixed.indexOf(lib.config.mode) === -1) {
                                game.layout = lib.config.layout;
                                if (game.layout == 'default') {
                                    ui.css.layout.href = '';
                                }
                                else {
                                    ui.css.layout.href = lib.assetURL + 'layout/' + game.layout + '/layout.css';
                                }
                            }
                            splash["delete"](1000);
                            delete window.inSplash;
                            window.resetGameTimeout = setTimeout(lib.init.reset, 5000);
                            this.listenTransition(function () {
                                lib.init.js(lib.assetURL + 'mode', lib.config.mode, proceed);
                            }, 500);
                        }
                    };
                    var downNode = function () {
                        this.classList.add('glow');
                    };
                    var upNode = function () {
                        this.classList.remove('glow');
                    };
                    var splash = ui.create.div('#splash', document.body);
                    if (lib.config.touchscreen) {
                        splash.classList.add('touch');
                        lib.setScroll(splash);
                    }
                    if (lib.config.player_border != 'wide') {
                        splash.classList.add('slim');
                    }
                    splash.dataset.radius_size = lib.config.radius_size;
                    for (var i = 0; i < lib.config.all.mode.length; i++) {
                        var node = ui.create.div('.hidden', splash, clickNode);
                        node.link = lib.config.all.mode[i];
                        ui.create.div(node, '.splashtext', get.verticalStr(get.translation(lib.config.all.mode[i])));
                        if (lib.config.all.stockmode.indexOf(lib.config.all.mode[i]) != -1) {
                            ui.create.div(node, '.avatar').setBackgroundImage('image/splash/' + lib.config.all.mode[i] + '.jpg');
                        }
                        else {
                            var avatarnode = ui.create.div(node, '.avatar');
                            var avatarbg = lib.mode[lib.config.all.mode[i]].splash;
                            if (avatarbg.indexOf('ext:') == 0) {
                                avatarnode.setBackgroundImage(avatarbg.replace(/ext:/, 'extension/'));
                            }
                            else {
                                avatarnode.setBackgroundDB(avatarbg);
                            }
                        }
                        if (!lib.config.touchscreen) {
                            node.addEventListener('mousedown', downNode);
                            node.addEventListener('mouseup', upNode);
                            node.addEventListener('mouseleave', upNode);
                        }
                        setTimeout((function (node) {
                            return function () {
                                node.show();
                            };
                        }(node)), i * 100);
                    }
                    if (lib.config.mousewheel) {
                        splash.onmousewheel = ui.click.mousewheel;
                    }
                }
                else {
                    proceed();
                }
                localStorage.removeItem(lib.configprefix + 'directstart');
                delete lib.init.init; //??
            },
            startOnline: function () {
                'step 0';
                event._resultid = null;
                event._result = null;
                game.pause();
                'step 1';
                if (result) {
                    if (event._resultid) {
                        result.id = event._resultid;
                    }
                    game.send('result', result);
                }
                event.goto(0);
            },
            /**
             * 闲时执行，一般选择角色后开始执行这个方法
             * @function
             */
            onfree: function () {
                if (lib.onfree) {
                    clearTimeout(window.resetGameTimeout);
                    delete window.resetGameTimeout;
                    if (!game.syncMenu) {
                        delete window.resetExtension;
                        localStorage.removeItem(lib.configprefix + 'disable_extension');
                    }
                    if (game.removeFile && lib.config.brokenFile.length) {
                        while (lib.config.brokenFile.length) {
                            game.removeFile(lib.config.brokenFile.shift());
                        }
                        game.saveConfigValue('brokenFile');
                    }
                    var onfree = lib.onfree;
                    delete lib.onfree;
                    var loop = function () {
                        if (onfree.length) {
                            (onfree.shift())();
                            setTimeout(loop, 100);
                        }
                    };
                    setTimeout(loop, 500);
                }
            },
            connection: function (ws) {
                var client = {
                    ws: ws,
                    id: ws.wsid || get.id(),
                    closed: false
                };
                lib.node.clients.push(client);
                for (var i in lib.element.client) {
                    client[i] = lib.element.client[i];
                }
                if (window.isNonameServer) {
                    document.querySelector('#server_count').innerHTML = lib.node.clients.length;
                }
                ws.on('message', function (messagestr) {
                    var message;
                    try {
                        message = JSON.parse(messagestr);
                        if (!Array.isArray(message) ||
                            typeof lib.message.server[message[0]] !== 'function') {
                            throw ('err');
                        }
                        for (var i = 1; i < message.length; i++) {
                            message[i] = get.parsedResult(message[i]);
                        }
                    }
                    catch (e) {
                        console.log(e);
                        console.log('invalid message: ' + messagestr);
                        return;
                    }
                    lib.message.server[message.shift()].apply(client, message);
                });
                ws.on('close', function () {
                    client.close();
                });
                client.send('opened');
            },
            /**
             * 创建（并插入文档）新的`<style>`
             * @function
             * @param {...string} rules css rules
             * @returns {!HTMLStyleElement} 新的`<style>`
             */
            sheet: function () {
                var style = document.createElement('style');
                document.head.appendChild(style);
                for (var i = 0; i < arguments.length; i++) {
                    if (typeof arguments[i] == 'string') {
                        style.sheet.insertRule(arguments[i], 0);
                    }
                }
                return style;
            },
            /**
             * 读取一个css文件
             * 于文档中创建（并插入文档中）新的`<link>`，如果设置路径则先加载再返回，否则直接返回空`<link>`
             * @function lib.init.css
             * @param {string} [path=null] 要加载的css文件所在目录, 如果为null，不设置生成的`<link>`的href值
             * @param {string} file 文件名（不包括拓展名），自动添加后缀.css；如果path为null，则被忽略
             * @param {function():void} [before] 可选，onload回调函数，在新`<link>`加载完成时被调用
             */
            /**
             * 读取一个css文件
             * 于文档中创建（并插入文档中）新的`<link>`，如果设置路径则先加载再返回，否则直接返回空`<link>`
             * @function lib.init.css
             * @variation 2
             * @param {string} [path=null] 要加载的css文件所在目录, 如果为null，不设置生成的`<link>`的href值
             * @param {string} file 文件名（不包括拓展名），自动添加后缀.css；如果path为null，则被忽略
             * @param {HTMLLinkElement} [before] 可选，一个{@link HTMLLinkElement}对象，新`<link>`会插入到`before`前
             * @returns {HTMLLinkElement} 新的`<link>`
             */
            css: function (path, file, before) {
                var style = document.createElement("link");
                style.rel = "stylesheet";
                if (path) {
                    style.href = path + '/' + file + ".css";
                }
                if (typeof before == 'function') {
                    style.addEventListener('load', before);
                    document.head.appendChild(style);
                }
                else if (before) {
                    document.head.insertBefore(style, before);
                }
                else {
                    document.head.appendChild(style);
                }
                return style;
            },
            /**
             * 读取一个js文件
             * 于文档中创建新的`<script>`对象
             * @function lib.init.js
             * @param {!string} dir 要加载的js文件所在目录, 如果为null，不设置生成的`<link>`的href值
             * @param {!string} file 文件名（不包括拓展名），自动添加后缀.js；如果path为null，则被忽略
             * @param {function():void} [onload] 可选，onload回调函数
             * @param {function():void} [onerror] 可选，onerror回调函数
             * @returns {!HTMLScriptElement} 新的`<script>`
             */
            /**
             * 读取一个js文件
             * 于文档中创建新的`<script>`对象
             * @function lib.init.js
             * @variation 2
             * @param {!string} path 要加载的js文件所在路径, 如果为null，不设置生成的`<link>`的href值
             * @param {null} file 文件名（无拓展名），自动添加后缀.js
             * @param {function():void} [onload] 可选，onload回调函数
             * @param {function():void} [onerror] 可选，onerror回调函数
             * @returns {!HTMLScriptElement} 新的`<script>`
             */
            /**
             * 读取一个js文件
             * 于文档中创建一组新的`<script>`对象
             * @function lib.init.js
             * @variation 3
             * @param {!string} path 要加载的js文件所在路径, 如果为null，不设置生成的`<link>`的href值
             * @param {Array<string>} files 文件名数组
             * @param {?function():void} [onload] 可选，onload回调函数，对每个新的`<script>`调用
             * @param {?function():void} [onerror] 可选，onerror回调函数，对每个新的`<script>`调度
             */
            js: function (path, file, onload, onerror) {
                if (path[path.length - 1] == '/') {
                    path = path.slice(0, path.length - 1);
                }
                //??
                if (path == lib.assetURL + 'mode' && lib.config.all.stockmode.indexOf(file) == -1) {
                    lib.init['setMode_' + file]();
                    onload();
                    return;
                }
                if (Array.isArray(file)) {
                    for (var i = 0; i < file.length; i++) {
                        lib.init.js(path, file[i], onload, onerror);
                    }
                }
                else {
                    var script = document.createElement('script');
                    if (!file) {
                        script.src = path;
                    }
                    else {
                        script.src = path + '/' + file + ".js";
                    }
                    if (path.indexOf('http') == 0) {
                        script.src += '?rand=' + get.id();
                        script.addEventListener('load', function () {
                            script.remove();
                        });
                    }
                    document.head.appendChild(script);
                    if (typeof onload == 'function') {
                        script.addEventListener('load', onload);
                        script.addEventListener('error', onerror);
                    }
                    return script;
                }
            },
            req: function (str, onload, onerror, master) {
                var sScriptURL;
                if (str.indexOf('http') == 0) {
                    sScriptURL = str;
                }
                else {
                    var url = get.url(master);
                    if (url[url.length - 1] != '/') {
                        url += '/';
                    }
                    sScriptURL = url + str;
                }
                var oReq = new XMLHttpRequest();
                if (onload)
                    oReq.addEventListener("load", onload);
                if (onerror)
                    oReq.addEventListener("error", onerror);
                oReq.open("GET", sScriptURL);
                oReq.send();
            },
            /**
             * 读取一个json文件
             * @function
             * @param {!string} url url路径
             * @param {function(Object):void} onload 成功时的回调函数
             * @param {function():void} onerror 失败时回调函数
             */
            json: function (url, onload, onerror) {
                var oReq = new XMLHttpRequest();
                if (onload)
                    oReq.addEventListener("load", function () {
                        var result;
                        try {
                            result = JSON.parse(this.responseText);
                            if (!result) {
                                throw ('err');
                            }
                        }
                        catch (e) {
                            onerror();
                            return;
                        }
                        onload(result);
                    });
                if (onerror)
                    oReq.addEventListener("error", onerror);
                oReq.open("GET", url);
                oReq.send();
            },
            /**
             * 初始化角色字体样式和边缘样式
             * @function
             */
            cssstyles: function () {
                if (ui.css.styles) {
                    ui.css.styles.remove();
                }
                ui.css.styles = lib.init.sheet();
                ui.css.styles.sheet.insertRule('#arena .player>.name,#arena .button.character>.name {font-family: ' + (lib.config.name_font || 'xinwei') + ',xinwei}', 0);
                ui.css.styles.sheet.insertRule('#arena .player .identity>div {font-family: ' + (lib.config.identity_font || 'huangcao') + ',xinwei}', 0);
                ui.css.styles.sheet.insertRule('.button.character.newstyle>.identity {font-family: ' + (lib.config.identity_font || 'huangcao') + ',xinwei}', 0);
                if (lib.config.cardtext_font && lib.config.cardtext_font != 'default') {
                    ui.css.styles.sheet.insertRule('.card div:not(.info):not(.background) {font-family: ' + lib.config.cardtext_font + ';}', 0);
                }
                if (lib.config.global_font && lib.config.global_font != 'default') {
                    ui.css.styles.sheet.insertRule('#window {font-family: ' + lib.config.global_font + ',xinwei}', 0);
                    ui.css.styles.sheet.insertRule('#window #control{font-family: STHeiti,SimHei,Microsoft JhengHei,Microsoft YaHei,WenQuanYi Micro Hei,Helvetica,Arial,sans-serif}', 0);
                }
                switch (lib.config.glow_phase) {
                    case 'yellow':
                        ui.css.styles.sheet.insertRule('#arena .player:not(.selectable):not(.selected).glow_phase {box-shadow: rgba(0, 0, 0, 0.3) 0 0 0 1px, rgb(217, 152, 62) 0 0 15px, rgb(217, 152, 62) 0 0 15px !important;}', 0);
                        break;
                    case 'green':
                        ui.css.styles.sheet.insertRule('#arena .player:not(.selectable):not(.selected).glow_phase {box-shadow: rgba(0, 0, 0, 0.3) 0 0 0 1px, rgba(10, 155, 67, 1) 0 0 15px, rgba(10, 155, 67, 1) 0 0 15px !important;}', 0);
                        break;
                    case 'purple':
                        ui.css.styles.sheet.insertRule('#arena .player:not(.selectable):not(.selected).glow_phase {box-shadow: rgba(0, 0, 0, 0.3) 0 0 0 1px, rgb(189, 62, 170) 0 0 15px, rgb(189, 62, 170) 0 0 15px !important;}', 0);
                        break;
                }
            },
            /**
             * 初始化布局
             * @function
             * @param {string} layout 布局类型
             * @param {boolean} nosave 是否保存
             */
            layout: function (layout, nosave) {
                if (!nosave)
                    game.saveConfig('layout', layout);
                game.layout = layout;
                ui.arena.hide();
                setTimeout(function () {
                    if (game.layout == 'default') {
                        ui.css.layout.href = '';
                    }
                    else {
                        ui.css.layout.href = lib.assetURL + 'layout/' + game.layout + '/layout.css';
                    }
                    if (game.layout == 'mobile' || game.layout == 'long') {
                        ui.arena.classList.add('mobile');
                    }
                    else {
                        ui.arena.classList.remove('mobile');
                    }
                    if (game.layout == 'mobile' || game.layout == 'long' || game.layout == 'long2' || game.layout == 'nova') {
                        if (game.me && game.me.node.handcards2.childNodes.length) {
                            while (game.me.node.handcards2.childNodes.length) {
                                game.me.node.handcards1.appendChild(game.me.node.handcards2.firstChild);
                            }
                        }
                    }
                    if (game.layout == 'default') {
                        ui.arena.classList.add('oldlayout');
                    }
                    else {
                        ui.arena.classList.remove('oldlayout');
                    }
                    if (lib.config.cardshape == 'oblong' && (game.layout == 'long' || game.layout == 'mobile' || game.layout == 'long2' || game.layout == 'nova')) {
                        ui.arena.classList.add('oblongcard');
                        ui.window.classList.add('oblongcard');
                    }
                    else {
                        ui.arena.classList.remove('oblongcard');
                        ui.window.classList.remove('oblongcard');
                    }
                    if (lib.config.textequip == 'text' && (game.layout == 'long' || game.layout == 'mobile')) {
                        ui.arena.classList.add('textequip');
                    }
                    else {
                        ui.arena.classList.remove('textequip');
                    }
                    if (get.is.phoneLayout()) {
                        ui.css.phone.href = lib.assetURL + 'layout/default/phone.css';
                        ui.arena.classList.add('phone');
                    }
                    else {
                        ui.css.phone.href = '';
                        ui.arena.classList.remove('phone');
                    }
                    for (var i = 0; i < game.players.length; i++) {
                        if (get.is.linked2(game.players[i])) {
                            if (game.players[i].classList.contains('linked')) {
                                game.players[i].classList.remove('linked');
                                game.players[i].classList.add('linked2');
                            }
                        }
                        else {
                            if (game.players[i].classList.contains('linked2')) {
                                game.players[i].classList.remove('linked2');
                                game.players[i].classList.add('linked');
                            }
                        }
                    }
                    if (game.layout == 'long' || game.layout == 'long2') {
                        ui.arena.classList.add('long');
                    }
                    else {
                        ui.arena.classList.remove('long');
                    }
                    if (lib.config.player_border != 'wide' || game.layout == 'long' || game.layout == 'long2') {
                        ui.arena.classList.add('slim_player');
                    }
                    else {
                        ui.arena.classList.remove('slim_player');
                    }
                    if (lib.config.player_border == 'normal' && lib.config.mode != 'brawl' && (game.layout == 'long' || game.layout == 'long2')) {
                        ui.arena.classList.add('lslim_player');
                    }
                    else {
                        ui.arena.classList.remove('lslim_player');
                    }
                    if (lib.config.player_border == 'slim') {
                        ui.arena.classList.add('uslim_player');
                    }
                    else {
                        ui.arena.classList.remove('uslim_player');
                    }
                    if (lib.config.player_border == 'narrow') {
                        ui.arena.classList.add('mslim_player');
                    }
                    else {
                        ui.arena.classList.remove('mslim_player');
                    }
                    ui.updatej();
                    ui.updatem();
                    setTimeout(function () {
                        ui.arena.show();
                        if (game.me)
                            game.me.update();
                        setTimeout(function () {
                            ui.updatex();
                        }, 500);
                        setTimeout(function () {
                            ui.updatec();
                        }, 1000);
                    }, 100);
                }, 500);
            },
            /**
             * 保存当前的背景图片
             * @function
             */
            background: function () {
                if (lib.config.image_background_random) {
                    var list = [];
                    for (var i in lib.configMenu.appearence.config.image_background.item) {
                        if (i == 'default')
                            continue;
                        list.push(i);
                    }
                    list.remove(lib.config.image_background);
                    localStorage.setItem(lib.configprefix + 'background', JSON.stringify(list));
                }
                else if (lib.config.image_background && lib.config.image_background != 'default' && lib.config.image_background.indexOf('custom_') != 0) {
                    localStorage.setItem(lib.configprefix + 'background', lib.config.image_background);
                }
                else if (lib.config.image_background == 'default' && lib.config.theme == 'simple') {
                    localStorage.setItem(lib.configprefix + 'background', 'ol_bg');
                }
                else {
                    localStorage.removeItem(lib.configprefix + 'background');
                }
            },
            parsex: function (func) {
                var k;
                var str = '(';
                str += func.toString();
                if (str.indexOf('step 0') == -1) {
                    str = str.replace(/\{/, '{{if(event.step==1) {event.finish();return;}');
                }
                else {
                    for (k = 1; k < 99; k++) {
                        if (str.indexOf('step ' + k) == -1)
                            break;
                        str = str.replace(new RegExp("'step " + k + "'", 'g'), "break;case " + k + ":");
                        str = str.replace(new RegExp('"step ' + k + '"', 'g'), "break;case " + k + ":");
                    }
                    str = str.replace(/'step 0'|"step 0"/, 'if(event.step==' + k + ') {event.finish();return;}switch(step){case 0:');
                }
                str += '})';
                return str;
            },
            parse: function (func) {
                var str = func.toString();
                //galgame调整
                str = str.replace(/(?!\.)galgame/g, 'game.galgame');
                str = str.slice(str.indexOf('{') + 1);
                if (str.indexOf('step 0') == -1) {
                    str = '{if(event.step==1) {event.finish();return;}' + str;
                }
                else {
                    for (var k = 1; k < 99; k++) {
                        if (str.indexOf('step ' + k) == -1)
                            break;
                        str = str.replace(new RegExp("'step " + k + "'", 'g'), "break;case " + k + ":");
                        str = str.replace(new RegExp('"step ' + k + '"', 'g'), "break;case " + k + ":");
                    }
                    str = str.replace(/'step 0'|"step 0"/, 'if(event.step==' + k + ') {event.finish();return;}switch(step){case 0:');
                }
                return (new Function('event', 'step', 'source', 'player', 'target', 'targets', 'card', 'cards', 'skill', 'forced', 'num', 'trigger', 'result', '_status', 'lib', 'game', 'ui', 'get', 'ai', str));
            },
            /**
             * 执行一个，或一组无参函数，并返回结果；如果是`{a:function(){}, b:function(){}}`的形式，返回`{a: any, b: any}`作为结果
             * @function
             * @param {(function():any|Object<string, function():any>)} func 要执行的函数/函数组
             * @returns {(any|Object<string, any>)}
             */
            eval: function (func) {
                if (typeof func == 'function') {
                    return eval('(' + func.toString() + ')');
                }
                else if (typeof func == 'object') {
                    for (var i in func) {
                        if (func.hasOwnProperty(i)) {
                            func[i] = lib.init.eval(func[i]);
                        }
                    }
                }
                return func;
            },
            /**
             * 加密文本
             * @function
             * @param {string} strUni 原文本
             * @returns 加密文本
             */
            encode: function (strUni) {
                var strUtf = strUni.replace(/[\u0080-\u07ff]/g, function (c) {
                    var cc = c.charCodeAt(0);
                    return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);
                });
                strUtf = strUtf.replace(/[\u0800-\uffff]/g, function (c) {
                    var cc = c.charCodeAt(0);
                    return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);
                });
                return btoa(strUtf);
            },
            /**
             * 解密
             * @function
             * @param {string} str 加密文本
             * @returns {string} 原文本
             */
            decode: function (str) {
                var strUtf = atob(str);
                var strUni = strUtf.replace(/[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g, function (c) {
                    var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);
                    return String.fromCharCode(cc);
                });
                strUni = strUni.replace(/[\u00c0-\u00df][\u0080-\u00bf]/g, function (c) {
                    var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;
                    return String.fromCharCode(cc);
                });
                return strUni;
            },
            /**
             * js对象转为json字符串
             * @function
             * @returns {!string}
             */
            stringify: function (obj) {
                var str = '{';
                for (var i in obj) {
                    str += '"' + i + '":';
                    if (Object.prototype.toString.call(obj[i]) == '[object Object]') {
                        str += lib.init.stringify(obj[i]);
                    }
                    else if (typeof obj[i] == 'function') {
                        str += obj[i].toString();
                    }
                    else {
                        str += JSON.stringify(obj[i]);
                    }
                    str += ',';
                }
                str += '}';
                return str;
            },
            /**
             * 技能对象转为json字符串
             * @function
             * @returns {!string}
             */
            stringifySkill: function (obj) {
                var str = '';
                for (var i in obj) {
                    str += i + ':';
                    if (Object.prototype.toString.call(obj[i]) == '[object Object]') {
                        str += '{\n' + lib.init.stringifySkill(obj[i]) + '}';
                    }
                    else if (typeof obj[i] == 'function') {
                        str += obj[i].toString().replace(/\t/g, '');
                    }
                    else {
                        str += JSON.stringify(obj[i]);
                    }
                    str += ',\n';
                }
                return str;
            }
        },
        /**
         * 测试用作弊方法
         * @name cheat
         */
        cheat: {
            i: function () {
                window.cheat = lib.cheat;
                // window.game = game;//[todo delete]
                window.ui = ui;
                window.get = get;
                window.ai = ai;
                window.lib = lib;
                window._status = _status;
            },
            dy: function () {
                var next = game.me.next;
                for (var i = 0; i < 10; i++) {
                    if (next.identity != 'zhu') {
                        break;
                    }
                    next = next.next;
                }
                next.die();
            },
            x: function () {
                var gl = function (dir, callback) {
                    var files = [], folders = [];
                    dir = '/Users/widget/Documents/extension/' + dir;
                    lib.node.fs.readdir(dir, function (err, filelist) {
                        for (var i = 0; i < filelist.length; i++) {
                            if (filelist[i][0] != '.' && filelist[i][0] != '_') {
                                if (lib.node.fs.statSync(dir + '/' + filelist[i]).isDirectory()) {
                                    folders.push(filelist[i]);
                                }
                                else {
                                    files.push(filelist[i]);
                                }
                            }
                        }
                        callback(folders, files);
                    });
                };
                var args = Array.from(arguments);
                for (var i = 0; i < args.length; i++) {
                    args[i] = args[i][0];
                }
                gl('', function (list) {
                    if (args.length) {
                        for (var i = 0; i < list.length; i++) {
                            if (!args.contains(list[i][0])) {
                                list.splice(i--, 1);
                            }
                        }
                    }
                    if (list.length) {
                        for (var i = 0; i < list.length; i++) {
                            (function (str) {
                                gl(str, function (folders, files) {
                                    if (files.length > 1) {
                                        for (var i = 0; i < files.length; i++) {
                                            if (files[i].indexOf('extension.js') != -1) {
                                                files.splice(i--, 1);
                                            }
                                            else {
                                                if (i % 5 == 0) {
                                                    str += '\n\t\t\t';
                                                }
                                                str += '"' + files[i] + '",';
                                            }
                                        }
                                        console.log(str.slice(0, str.length - 1));
                                    }
                                });
                            }(list[i]));
                        }
                    }
                });
            },
            cfg: function () {
                var mode = lib.config.all.mode.slice(0);
                mode.remove('connect');
                mode.remove('brawl');
                var banned = ['shen_guanyu', 'shen_caocao', 'caopi', 're_daqiao', 'caorui',
                    'daqiao', 'lingcao', 'liuzan', 'lusu', 'luxun', 'yanwen', 'zhouyu', 'ns_wangyue', 'gw_yenaifa',
                    'old_caozhen', 'swd_jiangziya', 'xuhuang', 'maliang', 'guojia', 'simayi', 'swd_kangnalishi', 'hs_siwangzhiyi', 'hs_nozdormu', 'old_zhuzhi'];
                var bannedcards = ['zengbin'];
                var favs = ["hs_tuoqi", "hs_siwangxianzhi", "hs_xukongzhiying", "hs_hsjiasha", "gjqt_xieyi", "gjqt_yunwuyue", "gjqt_beiluo",
                    "gjqt_cenying", "shen_lvmeng", "shen_zhaoyun", "shen_zhugeliang", "ow_ana", "chenlin", "ns_guanlu", "hs_guldan", "swd_guyue",
                    "pal_jiangyunfan", "mtg_jiesi", "swd_lanyin", "pal_liumengli", "swd_muyun", "pal_nangonghuang", "swd_muyue", "pal_murongziying",
                    "swd_qiner", "pal_shenqishuang", "hs_taisi", "wangji", "pal_xingxuan", "xunyou", "hs_yelise", "pal_yuejinzhao", "pal_yueqi",
                    "gjqt_yuewuyi", "swd_yuxiaoxue", "ow_zhaliya", "zhangchunhua", "hs_zhihuanhua", "swd_zhiyin", "old_zhonghui", "gjqt_bailitusu",
                    "hs_barnes", "ow_dva", "swd_hengai", "pal_jushifang", "hs_kazhakusi", "hs_lafamu", "ow_liekong", "hs_lreno", "pal_mingxiu",
                    "swd_murongshi", "gw_oudimu", "gjqt_ouyangshaogong", "hs_pyros", "qinmi", "gw_sanhanya", "hs_selajin", "swd_shuwaner",
                    "swd_situqiang", "hs_xialikeer", "pal_xuejian", "swd_yuchiyanhong", "swd_yuwentuo", "swd_zhaoyun", "zhugeliang", "gw_aigeleisi",
                    "gw_aimin", "gjqt_aruan", "hs_aya", "swd_cheyun", "swd_chenjingchou", "gw_diandian", "swd_huzhongxian", "hs_jinglinglong",
                    "hs_kaituozhe", "hs_kalimosi", "gw_linjing", "ow_luxiao", "re_luxun", "hs_morgl", "swd_sikongyu", "hs_sthrall", "sunquan",
                    "sunshangxiang", "gw_yioufeisisp", "gw_yisilinni", "hs_yogg", "hs_ysera", "pal_yuntianhe", "zhugejin", "zhugeke", "gw_zhuoertan",
                    "hs_anduin", "swd_anka", "ow_banzang", "ow_chanyata", "diaochan", "swd_duguningke", "sp_diaochan", "hetaihou", "ns_huamulan",
                    "swd_huanglei", "swd_huanyuanzhi", "re_huatuo", "gw_huoge", "pal_jiangcheng", "yj_jushou", "swd_kendi", "yxs_libai",
                    "mtg_lilianna", "xin_liru", "liuxie", "pal_lixiaoyao", "pal_longkui", "ns_nanhua", "swd_qi", "swd_septem", "gw_shasixiwusi",
                    "ow_tianshi", "swd_weida", "gjqt_xiayize", "swd_xiyan", "hs_xsylvanas", "hs_yelinlonghou", "ow_yuanshi", "zuoci"];
                var vintage = ['tianjian', 'shuiyun', 'zhuyue', 'zhimeng', 'poyun', 'qianfang', 'xfenxin', 'danqing', 'ywuhun', 'tianwu', 'xuelu',
                    'shahun', 'yuling', 'duhun', 'liaoyuan', 'touxi', 'wangchen', 'poyue', 'kunlunjing', 'huanhun', 'yunchou', 'tuzhen', 'cyqiaoxie',
                    'mufeng', 'duanyi', 'guozao', 'yaotong', 'pozhen', 'tanlin', 'susheng', 'jikong', 'shouyin', 'jilve', 'hxunzhi', 'huodan', 'shanxian',
                    'ziyu', 'kuoyin', 'feiren', 'zihui', 'jidong', 'baoxue', 'aqianghua', 'maoding', 'bfengshi', 'zhongdun', 'pingzhang', 'maichong',
                    'guozai', 'jingxiang', 'yuelu', 'liechao', 'fengnu', 'hanshuang', 'enze', 'malymowang', 'xshixin', 'qingzun'];
                var favmodes = ["versus|three", "versus|four", "versus|two", "chess|combat"];
                for (var i = 0; i < mode.length; i++) {
                    game.saveConfig(mode[i] + '_banned', banned);
                    game.saveConfig(mode[i] + '_bannedcards', bannedcards);
                }
                var characters = lib.config.all.characters.slice(0);
                characters.remove('standard');
                characters.remove('old');
                game.saveConfig('vintageSkills', vintage);
                game.saveConfig('favouriteCharacter', favs);
                game.saveConfig('favouriteMode', favmodes);
                game.saveConfig('theme', 'simple');
                game.saveConfig('player_border', 'slim');
                game.saveConfig('cards', lib.config.all.cards);
                game.saveConfig('characters', characters);
                game.saveConfig('change_skin', false);
                game.saveConfig('show_splash', 'off');
                game.saveConfig('show_favourite', false);
                game.saveConfig('animation', false);
                game.saveConfig('hover_all', false);
                game.saveConfig('asset_version', 'v1.9');
                // game.saveConfig('characters',lib.config.all.characters);
                // game.saveConfig('cards',lib.config.all.cards);
                game.saveConfig('plays', ['cardpile']);
                game.saveConfig('skip_shan', false);
                game.saveConfig('tao_enemy', true);
                game.saveConfig('layout', 'long2');
                game.saveConfig('hp_style', 'ol');
                game.saveConfig('background_music', 'music_off');
                game.saveConfig('background_audio', false);
                game.saveConfig('background_speak', false);
                game.saveConfig('show_volumn', false);
                game.saveConfig('show_replay', true);
                game.saveConfig('autostyle', true);
                game.saveConfig('debug', true);
                game.saveConfig('dev', true);
                if (!lib.device) {
                    game.saveConfig('sync_speed', false);
                }
                game.reload();
            },
            o: function () {
                ui.arena.classList.remove('observe');
            },
            pt: function () {
                var list = Array.from(arguments);
                while (list.length) {
                    var card = cheat.gn(list.pop());
                    if (card)
                        ui.cardPile.insertBefore(card, ui.cardPile.firstChild);
                }
            },
            q: function () {
                // if(lib.config.layout!='mobile') lib.init.layout('mobile');
                if (arguments.length == 0) {
                    var style = ui.css.card_style;
                    if (lib.config.card_style != 'simple') {
                        lib.config.card_style = 'simple';
                        ui.css.card_style = lib.init.css(lib.assetURL + 'theme/style/card', 'simple');
                    }
                    else {
                        lib.config.card_style = 'default';
                        ui.css.card_style = lib.init.css(lib.assetURL + 'theme/style/card', 'default');
                    }
                    style.remove();
                }
                else {
                    for (var i = 0; i < arguments.length; i++) {
                        cheat.g(arguments[i]);
                    }
                }
                ui.arena.classList.remove('selecting');
                ui.arena.classList.remove('tempnoe');
            },
            p: function (name, i, skin) {
                var list = ['swd', 'hs', 'pal', 'gjqt', 'ow', 'gw'];
                if (!lib.character[name]) {
                    for (var j = 0; j < list.length; j++) {
                        if (lib.character[list[j] + '_' + name]) {
                            name = list[j] + '_' + name;
                            break;
                        }
                    }
                }
                if (skin) {
                    lib.config.skin[name] = skin;
                }
                var target;
                if (typeof i == 'number') {
                    target = game.players[i];
                }
                else {
                    target = game.me.next;
                }
                if (!lib.character[name]) {
                    target.node.avatar.setBackground(name, 'character');
                    target.node.avatar.show();
                }
                else {
                    target.init(name);
                }
                if (i === true) {
                    if (lib.config.layout == 'long2') {
                        lib.init.layout('mobile');
                    }
                    else {
                        lib.init.layout('long2');
                    }
                }
            },
            e: function () {
                var cards = [], target;
                for (var i = 0; i < arguments.length; i++) {
                    if (get.itemtype(arguments[i]) == 'player') {
                        target = arguments[i];
                    }
                    else {
                        cards.push(game.createCard(arguments[i]));
                    }
                }
                if (!cards.length) {
                    cards.push(game.createCard('qilin'));
                    cards.push(game.createCard('bagua'));
                    cards.push(game.createCard('dilu'));
                    cards.push(game.createCard('chitu'));
                    cards.push(game.createCard('muniu'));
                }
                target = target || game.me;
                for (var i = 0; i < cards.length; i++) {
                    var card = target.getEquip(cards[i]);
                    if (card) {
                        card.discard();
                        target.removeEquipTrigger(card);
                    }
                    target.$equip(cards[i]);
                }
            },
            c: function () {
                // (function () {
                //     var a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
                //     var sa = 0, sb = 0, sc = 0, sd = 0, se = 0, sf = 0, sg = 0, sh = 0, si = 0, sj = 0, sk = 0, sl = 0, sm = 0;
                //     for (var i in lib.character) {
                //         switch (lib.character[i][1]) {
                //             case 'wei': a++; if (lib.config.banned.contains(i)) sa++; break;
                //             case 'shu': b++; if (lib.config.banned.contains(i)) sb++; break;
                //             case 'wu': c++; if (lib.config.banned.contains(i)) sc++; break;
                //             case 'qun': d++; if (lib.config.banned.contains(i)) sd++; break;
                //             case 'western': e++; if (lib.config.banned.contains(i)) se++; break;
                //             case 'key': f++; if (lib.config.banned.contains(i)) sf++; break;
                //             case 'holo': g++; if (lib.config.banned.contains(i)) sg++; break;
                //             case 'nijisanji': h++; if (lib.config.banned.contains(i)) sh++; break;
                //             case 'VirtuaReal': i++; if (lib.config.banned.contains(i)) si++; break;
                //             case 'HappyElements': i++; if (lib.config.banned.contains(i)) si++; break;
                //             case 'upd8': j++; if (lib.config.banned.contains(i)) sj++; break;
                //             case 'dotlive': k++; if (lib.config.banned.contains(i)) sk++; break;
                //             case 'eilene': l++; if (lib.config.banned.contains(i)) sl++; break;
                //             case 'paryi': m++; if (lib.config.banned.contains(i)) sm++; break;
                //             case 'kagura': n++; if (lib.config.banned.contains(i)) sn++; break;
                //             case 'nanashi': o++; if (lib.config.banned.contains(i)) so++; break;
                //             case 'psp': p++; if (lib.config.banned.contains(i)) sp++; break;
                //             case 'asoul': q++; if (lib.config.banned.contains(i)) sq++; break;
                //             case 'nori': r++; if (lib.config.banned.contains(i)) sr++; break;
                //             case 'vwp': s++; if (lib.config.banned.contains(i)) ss++; break;
                //             case 'vshojo': t++; if (lib.config.banned.contains(i)) st++; break;
                //             case 'xuyan': u++; if (lib.config.banned.contains(i)) su++; break;
                //             case 'chaos': v++; if (lib.config.banned.contains(i)) sv++; break;
                //             case 'xuefeng': w++; if (lib.config.banned.contains(i)) sw++; break;
                //             case 'ego': w++; if (lib.config.banned.contains(i)) sw++; break;
                //             case 'chidori': w++; if (lib.config.banned.contains(i)) sw++; break;
                //         }
                //     }
                //     console.log('魏：' + (a - sa) + '/' + a);
                //     console.log('蜀：' + (b - sb) + '/' + b);
                //     console.log('吴：' + (c - sc) + '/' + c);
                //     console.log('群：' + (d - sd) + '/' + d);
                //     console.log('西：' + (e - se) + '/' + e);
                //     console.log('键：' + (f - sf) + '/' + f);
                //     console.log('杏：' + (g - sg) + '/' + g);
                //     console.log('虹：' + (h - sh) + '/' + h);
                //     console.log('U：' + (j - sj) + '/' + j);
                //     console.log('点：' + (k - sk) + '/' + k);
                //     console.log('已启用：' + ((a + b + c + d + e + f + g + h + i + j + k + l + m) - (sa + sb + sc + sd + se + sf + sg + sh + hi + sj + sk + sl + sm)) + '/' + (a + b + c + d + e + f + g + h + i + j + k + l + m));
                // }());
                (function () {
                    var a = 0, b = 0, c = 0, d = 0;
                    var aa = 0, bb = 0, cc = 0, dd = 0;
                    var sa = 0, sb = 0, sc = 0, sd = 0;
                    var sha = 0, shan = 0, tao = 0, jiu = 0, wuxie = 0, heisha = 0, hongsha = 0;
                    var num = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0, 13: 0 };
                    for (var i in lib.card) {
                        if (get.objtype(lib.card[i]) == 'object' && lib.translate[i + '_info']) {
                            switch (lib.card[i].type) {
                                case 'basic':
                                    a++;
                                    break;
                                case 'trick':
                                    b++;
                                    break;
                                case 'equip':
                                    c++;
                                    break;
                                default:
                                    d++;
                                    break;
                            }
                        }
                    }
                    for (var i = 0; i < lib.card.list.length; i++) {
                        if (typeof lib.card[lib.card.list[i][2]] == 'object') {
                            switch (lib.card[lib.card.list[i][2]].type) {
                                case 'basic':
                                    aa++;
                                    break;
                                case 'trick':
                                case 'delay':
                                    bb++;
                                    break;
                                case 'equip':
                                    cc++;
                                    break;
                                default:
                                    dd++;
                                    break;
                            }
                            switch (lib.card.list[i][0]) {
                                case 'heart':
                                    sa++;
                                    break;
                                case 'diamond':
                                    sb++;
                                    break;
                                case 'club':
                                    sc++;
                                    break;
                                case 'spade':
                                    sd++;
                                    break;
                            }
                            if (lib.card.list[i][2] == 'sha') {
                                sha++;
                                if (lib.card.list[i][0] == 'club' || lib.card.list[i][0] == 'spade') {
                                    heisha++;
                                }
                                else {
                                    hongsha++;
                                }
                            }
                            if (lib.card.list[i][2] == 'shan') {
                                shan++;
                            }
                            if (lib.card.list[i][2] == 'tao') {
                                tao++;
                            }
                            if (lib.card.list[i][2] == 'jiu') {
                                jiu++;
                            }
                            if (lib.card.list[i][2] == 'wuxie') {
                                wuxie++;
                            }
                            num[lib.card.list[i][1]]++;
                        }
                    }
                    var str = '基本牌' + aa + '； ' + '锦囊牌' + bb + '； ' + '装备牌' + cc + '； ' + '其它牌' + dd;
                    console.log(str);
                    str = '红桃牌' + sa + '； ' + '方片牌' + sb + '； ' + '梅花牌' + sc + '； ' + '黑桃牌' + sd;
                    console.log(str);
                    str = '杀' + sha + '； ' + '黑杀' + heisha + '； ' + '红杀' + hongsha + '； ' + '闪' + shan + '； ' + '桃' + tao + '； ' + '酒' + jiu + '； ' + '无懈' + wuxie;
                    console.log(str);
                    if (arguments[1]) {
                        for (var i = 1; i <= 13; i++) {
                            if (i < 10) {
                                console.log(i + ' ', num[i]);
                            }
                            else {
                                console.log(i, num[i]);
                            }
                        }
                    }
                    var arr = [];
                    for (var i = 1; i <= 13; i++) {
                        arr.push(num[i]);
                    }
                    console.log.apply(console, __spreadArray([(a + b + c + d) + '/' + (aa + bb + cc + dd)], arr, false));
                }());
            },
            id: function () {
                game.showIdentity();
            },
            b: function () {
                if (!ui.dialog || !ui.dialog.buttons)
                    return;
                for (var i = 0; i < Math.min(arguments.length, ui.dialog.buttons.length); i++) {
                    ui.dialog.buttons[i].link = arguments[i];
                }
            },
            uy: function (me) {
                if (me) {
                    game.me.useCard({ name: 'spell_yexinglanghun' }, game.me);
                }
                else {
                    var enemy = game.me.getEnemy();
                    enemy.useCard({ name: 'spell_yexinglanghun' }, enemy);
                }
            },
            gs: function (name, act) {
                var card = game.createCard('spell_' + (name || 'yexinglanghun'));
                game.me.node.handcards1.appendChild(card);
                if (!act) {
                    game.me.actused = -99;
                }
                ui.updatehl();
                delete _status.event._cardChoice;
                delete _status.event._targetChoice;
                delete _status.event._skillChoice;
                setTimeout(game.check, 300);
            },
            gc: function (name, act) {
                var card = game.createCard('stone_' + (name || 'falifulong') + '_stonecharacter');
                game.me.node.handcards1.appendChild(card);
                if (!act) {
                    game.me.actused = -99;
                }
                ui.updatehl();
                delete _status.event._cardChoice;
                delete _status.event._targetChoice;
                delete _status.event._skillChoice;
                setTimeout(game.check, 300);
            },
            a: function (bool) {
                if (lib.config.test_game) {
                    game.saveConfig('test_game');
                }
                else {
                    if (bool) {
                        if (typeof bool === 'string') {
                            game.saveConfig('test_game', bool);
                        }
                        else {
                            game.saveConfig('test_game', '_');
                        }
                    }
                    else {
                        game.saveConfig('test_game', true);
                    }
                }
                game.reload();
            },
            as: function () {
                ui.window.classList.remove('testing');
                var bg = ui.window.querySelector('.pausedbg');
                if (bg) {
                    bg.remove();
                }
            },
            uj: function () {
                cheat.e('qilin');
                game.me.next.useCard({ name: 'jiedao' }, [game.me, game.me.previous]);
            },
            u: function () {
                var card = { name: 'sha' }, source = game.me.next, targets = [];
                for (var i = 0; i < arguments.length; i++) {
                    if (get.itemtype(arguments[i]) == 'player') {
                        source = arguments[i];
                    }
                    else if (Array.isArray(arguments[i])) {
                        targets = arguments[i];
                    }
                    else if (typeof arguments[i] == 'object' && arguments[i]) {
                        card = arguments[i];
                    }
                    else if (typeof arguments[i] == 'string') {
                        card = { name: arguments[i] };
                    }
                }
                if (!targets.length)
                    targets.push(game.me);
                source.useCard(game.createCard(card.name, card.suit, card.number, card.nature), targets);
            },
            r: function (bool) {
                var list = ['s', 'ap', 'a', 'am', 'bp', 'b', 'bm', 'c', 'd'];
                var str = '';
                for (var i = 0; i < list.length; i++) {
                    if (str)
                        str += ' 、 ';
                    str += list[i] + '-' + lib.rank[list[i]].length;
                }
                console.log(str);
                for (var i in lib.characterPack) {
                    if (!bool && lib.config.all.sgscharacters.contains(i))
                        continue;
                    var map = {};
                    var str = '';
                    for (var j in lib.characterPack[i]) {
                        var rank = get.rank(j);
                        if (!map[rank]) {
                            map[rank] = 1;
                        }
                        else {
                            map[rank]++;
                        }
                    }
                    for (var j = 0; j < list.length; j++) {
                        if (map[list[j]]) {
                            if (str)
                                str += ' 、 ';
                            str += list[j] + '-' + map[list[j]];
                        }
                    }
                    if (str) {
                        console.log(lib.translate[i + '_character_config'] + '：' + str);
                    }
                }
                var list = lib.rank.s.concat(lib.rank.ap).concat(lib.rank.a).concat(lib.rank.am).
                    concat(lib.rank.bp).concat(lib.rank.b).concat(lib.rank.bm).concat(lib.rank.c).concat(lib.rank.d);
                for (var i in lib.character) {
                    if (lib.config.forbidai.contains(i))
                        continue;
                    if (i.indexOf('boss_') != 0 && i.indexOf('tafang_') != 0 && !list.contains(i))
                        console.log(get.translation(i), i);
                }
            },
            h: function (player) {
                console.log(get.translation(player.getCards('h')));
            },
            g: function () {
                for (var i = 0; i < arguments.length; i++) {
                    if (i > 0 && typeof arguments[i] == 'number') {
                        for (var j = 0; j < arguments[i] - 1; j++) {
                            cheat.gx(arguments[i - 1]);
                        }
                    }
                    else {
                        cheat.gx(arguments[i]);
                    }
                }
            },
            ga: function (type) {
                for (var i in lib.card) {
                    if (lib.card[i].type == type || lib.card[i].subtype == type) {
                        cheat.g(i);
                    }
                }
            },
            gg: function () {
                for (var i = 0; i < game.players.length; i++) {
                    for (var j = 0; j < arguments.length; j++) {
                        cheat.gx(arguments[j], game.players[i]);
                    }
                }
            },
            gx: function (name, target) {
                target = target || game.me;
                var card = cheat.gn(name);
                if (!card)
                    return;
                target.node.handcards1.appendChild(card);
                delete _status.event._cardChoice;
                delete _status.event._targetChoice;
                delete _status.event._skillChoice;
                game.check();
                target.update();
                ui.updatehl();
            },
            gn: function (name) {
                var nature = null;
                var suit = null;
                var suits = ['club', 'spade', 'diamond', 'heart'];
                for (var i = 0; i < suits.length; i++) {
                    if (name.indexOf(suits[i]) == 0) {
                        suit = suits[i];
                        name = name.slice(suits[i].length);
                        break;
                    }
                }
                if (name.indexOf('red') == 0) {
                    name = name.slice(3);
                    suit = ['diamond', 'heart'].randomGet();
                }
                if (name.indexOf('black') == 0) {
                    name = name.slice(5);
                    suit = ['spade', 'club'].randomGet();
                }
                if (name == 'huosha') {
                    name = 'sha';
                    nature = 'fire';
                }
                else if (name == 'leisha') {
                    name = 'sha';
                    nature = 'thunder';
                }
                else if (name == 'haisha') {
                    name = 'sha';
                    nature = 'ocean';
                }
                else if (name == 'yamisha') {
                    name = 'sha';
                    nature = 'yami';
                }
                else if (name == 'haitao') {
                    name = 'tao';
                    nature = 'ocean';
                }
                if (!lib.card[name]) {
                    return null;
                }
                return game.createCard(name, suit, null, nature);
            },
            ge: function (target) {
                if (target) {
                    cheat.gx('zhuge', target);
                    cheat.gx('qinglong', target);
                    cheat.gx('bagua', target);
                    cheat.gx('dilu', target);
                    cheat.gx('chitu', target);
                    cheat.gx('muniu', target);
                }
                else {
                    cheat.g('zhuge');
                    cheat.g('qinglong');
                    cheat.g('bagua');
                    cheat.g('dilu');
                    cheat.g('chitu');
                    cheat.g('muniu');
                }
            },
            gj: function () {
                cheat.g('shandian');
                cheat.g('huoshan');
                cheat.g('hongshui');
                cheat.g('lebu');
                cheat.g('bingliang');
                cheat.g('guiyoujie');
            },
            gf: function () {
                for (var i in lib.card) {
                    if (lib.card[i].type == 'food') {
                        cheat.g(i);
                    }
                }
            },
            d: function (num, target) {
                if (num == undefined)
                    num = 1;
                var cards = get.cards(num);
                for (var i = 0; i < num; i++) {
                    var card = cards[i];
                    game.me.node.handcards1.appendChild(card);
                    delete _status.event._cardChoice;
                    delete _status.event._targetChoice;
                    delete _status.event._skillChoice;
                    game.check();
                    game.me.update();
                    ui.updatehl();
                }
            },
            s: function () {
                for (var i = 0; i < arguments.length; i++) {
                    game.me.addSkill(arguments[i], true);
                }
                delete _status.event._cardChoice;
                delete _status.event._targetChoice;
                delete _status.event._skillChoice;
                game.check();
            },
            t: function (num) {
                if (game.players.contains(num)) {
                    num = game.players.indexOf(num);
                }
                if (num == undefined) {
                    for (var i = 0; i < game.players.length; i++)
                        cheat.t(i);
                    return;
                }
                var player = game.players[num];
                var cards = player.getCards('hej');
                for (var i = 0; i < cards.length; i++) {
                    cards[i].discard();
                }
                player.removeEquipTrigger();
                player.update();
            },
            to: function () {
                for (var i = 0; i < game.players.length; i++) {
                    if (game.players[i] != game.me) {
                        cheat.t(i);
                    }
                }
            },
            tm: function () {
                for (var i = 0; i < game.players.length; i++) {
                    if (game.players[i] == game.me) {
                        cheat.t(i);
                    }
                }
            },
            k: function (i) {
                if (i == undefined)
                    i = 1;
                game.players[i].hp = 1;
                cheat.t(i);
                cheat.g('juedou');
            },
            z: function (name) {
                switch (name) {
                    case 'cc':
                        name = 're_caocao';
                        break;
                    case 'lb':
                        name = 're_liubei';
                        break;
                    case 'sq':
                        name = 'sunquan';
                        break;
                    case 'dz':
                        name = 'dongzhuo';
                        break;
                    case 'ys':
                        name = 're_yuanshao';
                        break;
                    case 'zj':
                        name = 'sp_zhangjiao';
                        break;
                    case 'ls':
                        name = 'liushan';
                        break;
                    case 'sc':
                        name = 'sunce';
                        break;
                    case 'cp':
                        name = 'caopi';
                        break;
                    case 'cr':
                        name = 'caorui';
                        break;
                    case 'sx':
                        name = 'sunxiu';
                        break;
                    case 'lc':
                        name = 'liuchen';
                        break;
                    case 'sh':
                        name = 'sunhao';
                        break;
                }
                game.zhu.init(name);
                game.zhu.maxHp++;
                game.zhu.hp++;
                game.zhu.update();
            }
        },
        /**
         * 词汇翻译
         * 翻译文本
         * @type {!Object}
         */
        translate: {
            sc: '打钱',
            ship: '上舰',
            flower: '鲜花',
            egg: '鸡蛋',
            wine: '酒杯',
            shoe: '拖鞋',
            yuxisx: '玉玺',
            shoukao: '枷锁',
            junk: '平凡',
            common: '普通',
            rare: '精品',
            epic: '史诗',
            legend: '传说',
            beginner: '简单',
            "default": "默认",
            special: '特殊',
            zhenfa: '阵法',
            aozhan: "鏖战",
            mode_derivation_card_config: '衍生',
            mode_banned_card_config: '禁卡',
            mode_favourite_character_config: '收藏',
            mode_banned_character_config: '禁将',
            suit: '花色',
            heart: "♥︎",
            diamond: "♦︎",
            spade: "♠︎",
            club: "♣︎",
            ghujia: '护甲',
            ghujia_bg: '甲',
            heart2: "红桃",
            diamond2: "方片",
            spade2: "黑桃",
            club2: "梅花",
            color: '颜色',
            red: '红色',
            black: '黑色',
            none: '无色',
            number: '点数',
            cardname: '牌名',
            ok: "确定",
            ok2: "确定",
            cancel: "取消",
            cancel2: "取消",
            restart: "重新开始",
            setting: "设置",
            start: "开始",
            random: "随机",
            _out: '无效',
            agree: '同意',
            refuse: '拒绝',
            fire: "火",
            thunder: "雷",
            poison: "毒",
            kami: '神',
            ocean: '海',
            ice: '冰',
            yami: '暗',
            fire_ab: '火焰',
            thunder_ab: '雷电',
            ocean_ab: '海洋',
            ice_ab: '冰冻',
            yami_ab: '暗影',
            vtuber: '企',
            clubs: '社',
            vtuber2: '企业联合',
            clubs2: '社团联合',
            wei: '魏',
            shu: '蜀',
            wu: '吴',
            qun: '群',
            shen: '皇',
            western: '西',
            key: 'N',
            holo: '杏',
            dotlive: '点',
            nijisanji: '虹',
            VirtuaReal: '维阿',
            HappyElements: '乐',
            NetEase: '网',
            upd8: 'U',
            eilene: '艾琳',
            paryi: '帕',
            kagura: '神楽',
            nanashi: '774',
            psp: 'P',
            asoul: 'A',
            nori: '苔',
            vwp: '神椿',
            vshojo: 'V',
            xuyan: '虚',
            chaos: 'C',
            xuefeng: '雪',
            hunmiao: '魂',
            ego: '复',
            chidori: '鸟',
            lucca: 'L',
            double: '多',
            wei2: '魏国',
            shu2: '蜀国',
            wu2: '吴国',
            qun2: '群雄',
            shen2: '特典',
            western2: '西方',
            key2: 'KEY',
            holo2: 'Hololive',
            upd82: 'Upd8',
            dotlive2: '.live',
            nijisanji2: 'Nijisanji',
            VirtuaReal2: 'VirtuaReal',
            HappyElements2: '乐元素',
            NetEase2: '网易',
            eilene2: '艾琳一家',
            paryi2: '帕里坡',
            kagura2: '神楽组',
            nanashi2: '774inc',
            psp2: 'psplive',
            asoul2: 'A_SOUL',
            nori2: 'Noripro',
            vwp2: '神椿市',
            vshojo2: 'Vshojo',
            xuyan2: '虚研社',
            chaos2: 'ChaosLive',
            xuefeng2: '雪风军团',
            hunmiao2: '魂喵科技',
            ego2: 'Egolive',
            chidori2: '千鸟战队',
            lucca2: 'Lucca事务所',
            double2: '多势力',
            male: '男',
            female: '女',
            mad: '混乱',
            mad_bg: '疯',
            hp: '体力',
            draw_card: '摸牌',
            discard_card: '弃牌',
            take_damage: '受伤害',
            reset_character: '复原武将牌',
            recover_hp: '回复体力',
            lose_hp: '流失体力',
            get_damage: '受伤害',
            weiColor: "#b0d0e2",
            shuColor: "#ffddb9",
            wuColor: "#b2d9a9",
            qunColor: "#f6f6f6",
            shenColor: "#ffe14c",
            westernColor: "#ffe14c",
            jinColor: "#ffe14c",
            keyColor: "#c9b1fd",
            holoColor: "#38ABE0",
            nijisanjiColor: "#b0d0e2",
            dotliveColor: "#b2d9a9",
            upd8Color: "#ffe14c",
            eileneColor: "#DB7093",
            paryiColor: "#DDAAAF",
            VirtuaRealColor: "#77aaee",
            HappyElementsColor: "#60ACC8",
            kaguraColor: "#55deef",
            nanashiColor: "#e27b6b",
            pspColor: "#4d3d11",
            asoulColor: "#ffddcc",
            noriColor: "#a8ddaa",
            basic: '基本',
            equip: '装备',
            trick: '锦囊',
            delay: '延时锦囊',
            character: '角色',
            revive: '复活',
            equip1: '武器',
            equip2: '防具',
            equip3: '防御载具',
            equip4: '攻击载具',
            equip5: '宝物',
            equip6: '坐骑',
            zero: '零',
            one: '一',
            two: '二',
            three: '三',
            four: '四',
            five: '五',
            six: '六',
            seven: '七',
            eight: '八',
            nine: '九',
            ten: '十',
            _chongzhu: '重铸',
            _lianhuan: '连环',
            _lianhuan2: '连环',
            _kamisha: '神杀',
            _oceansha: '海杀',
            _icesha: '冰杀',
            _yamisha: '暗杀',
            _yamisha2: '暗影',
            _shengjie: '升阶',
            qianxing: '潜行',
            mianyi: '免疫',
            fengyin: '封印',
            baiban: '白板',
            _disableJudge: "判定区",
            pileTop: '牌堆顶',
            pileBottom: '牌堆底',
            xiaowu_emotion: '小无表情',
            guojia_emotion: '郭嘉表情',
            zhenji_emotion: '甄姬表情',
            shibing_emotion: '士兵表情',
            xiaosha_emotion: '小杀表情',
            xiaotao_emotion: '小桃表情',
            xiaojiu_emotion: '小酒表情',
            Diana_emotion: '嘉然表情',
            pause: '暂停',
            config: '选项',
            auto: '托管',
            unknown: '未知',
            unknown0: '一号位',
            unknown1: '二号位',
            unknown2: '三号位',
            unknown3: '四号位',
            unknown4: '五号位',
            unknown5: '六号位',
            unknown6: '七号位',
            unknown7: '八号位',
            feichu_equip1: "已废除",
            feichu_equip1_info: "武器栏已废除",
            feichu_equip2: "已废除",
            feichu_equip2_info: "防具栏已废除",
            feichu_equip3: "已废除",
            feichu_equip3_info: "防御坐骑栏已废除",
            feichu_equip4: "已废除",
            feichu_equip4_info: "攻击坐骑栏已废除",
            feichu_equip5: "已废除",
            feichu_equip5_info: "宝物栏已废除",
            feichu_equip1_bg: "废",
            feichu_equip2_bg: "废",
            feichu_equip3_bg: "废",
            feichu_equip4_bg: "废",
            feichu_equip5_bg: "废",
            disable_judge: '已废除',
            disable_judge_info: '判定区已废除',
            disable_judge_bg: '废',
            pss: '手势',
            pss_paper: '布',
            pss_scissor: '剪刀',
            pss_stone: '石头',
            pss_paper_info: '石头剪刀布时的一种手势。克制石头，但被剪刀克制。',
            pss_scissor_info: '石头剪刀布时的一种手势。克制布，但被石头克制。',
            pss_stone_info: '石头剪刀布时的一种手势。克制剪刀，但被布克制。',
            group_wei: "魏势力",
            group_shu: "蜀势力",
            group_wu: "吴势力",
            group_jin: "晋势力",
            group_qun: "群势力",
            group_key: "键势力",
            group_holo: "杏势力",
            group_nijisanji: "虹势力",
            group_VirtuaReal: "维势力",
            group_upd8: "U势力",
            group_paryi: "帕势力",
            group_kagura: "神楽势力",
            group_nanashi: "7势力",
            group_psp: "P势力",
            group_asoul: "魂势力",
            group_nori: "苔势力",
            group_vwp: "神椿势力",
            group_chaos: "混沌势力",
            group_xuyan: "虚势力",
            group_xuefeng: "雪风势力",
            group_wei_bg: "魏",
            group_shu_bg: "蜀",
            group_wu_bg: "吴",
            group_qun_bg: "群",
            group_jin_bg: "晋",
            group_key_bg: "键",
            group_holo_bg: "杏",
            group_nijisanji_bg: "虹",
            group_VirtuaReal_bg: "维",
            group_upd8_bg: "U",
            group_paryi_bg: "帕",
            group_kagura_bg: "咩",
            group_nanashi_bg: "な",
            group_psp_bg: "な",
            group_asoul_bg: "魂",
            group_nori_bg: "苔",
            group_vwp_bg: "椿",
            group_chaos_bg: "潮",
            group_xuyan_bg: "虚",
            group_xuefeng_bg: "雪"
        },
        /**
         * 游戏基础对象和状态机
         * @name element
         * @namespace
         * @see {@link content}
         * @see {@link lib.element.player}
         * @see {@link lib.element.card}
         */
        element: {
            /**
             * 内容方法，setContent所调用的方法，即事件的具体内容
             * 状态机
             * @name content
             * @namespace
             * @global
             */
            content: {
                resetRound: function () {
                    var skill = event.resetSkill || event.name.slice(0, event.name.indexOf('_roundcount'));
                    if (!player || !lib.skill[skill])
                        return;
                    var roundname = skill + '_roundcount';
                    if (player.storage[roundname] > 0) {
                        player.storage[roundname]--;
                    }
                    if (player.storage[roundname] > 0) {
                        player.updateMarks();
                    }
                    else {
                        player.unmarkSkill(roundname);
                    }
                },
                //崭新出炉
                chooseShengjie: function () {
                    'step 0';
                    var list = [];
                    if (!lib.cardPack.mode_derivation || !lib.cardPack.mode_derivation.length)
                        event.finish();
                    for (var i = 0; i < lib.cardPack.mode_derivation.length; i++) {
                        var info = lib.card[lib.cardPack.mode_derivation[i]];
                        if (info && info.materials && (typeof info.materials == 'function' || Array.isArray(info.materials)))
                            list.push(lib.cardPack.mode_derivation[i]);
                    }
                    if (event.filterProduct)
                        list = list.filter(event.filterProduct);
                    event.list = list;
                    'step 1';
                    var next = player.chooseButton([event.prompt, [event.list, 'vcard'], '素材区', [event.materials, 'card'], 'hidden'], event.forced);
                    next.set('filterButton', function (button) {
                        var ub = ui.selected.buttons;
                        if (get.itemtype(button.link) == 'card') {
                            if (!ub.length)
                                return false;
                            var card = button.link;
                            var scards = ub.slice(1).map(function (scard) {
                                return scard.link;
                            });
                            var product = ub[0].link[2];
                            scards = scards.filter(function (scard) {
                                return get.itemtype(scard) == 'card';
                            });
                            if (_status.event.filterMaterial && !_status.event.filterMaterial(button.link, scards))
                                return false;
                            var filter = get.info({ name: product }).materials;
                            if (Array.isArray(filter)) {
                                if (filter.length > scards.length) {
                                    var mate = filter.slice(0);
                                    var smate = [];
                                    for (var j = 0; j < mate.length; j++) {
                                        for (var _i = 0, scards_1 = scards; _i < scards_1.length; _i++) {
                                            var k = scards_1[_i];
                                            if (!smate.contains(k)) {
                                                if (get.is.filterCardBy(k, mate[j])) {
                                                    smate.push(k);
                                                    mate.splice(j--, 1);
                                                }
                                            }
                                        }
                                    }
                                    for (var j = 0; j < mate.length; j++) {
                                        if (get.is.filterCardBy(card, mate[j])) {
                                            return true;
                                        }
                                    }
                                }
                                return false;
                            }
                            return true;
                        }
                        if (ub.length)
                            return false;
                        return true;
                    });
                    next.set('selectButton', function () {
                        var ub = ui.selected.buttons;
                        if (ub.length) {
                            var scards = ub.slice(1).map(function (scard) {
                                return scard.link;
                            });
                            var product = ub[0].link[2];
                            var filter = get.info({ name: product }).materials;
                            if (Array.isArray(filter)) {
                                if (filter.length == scards.length) {
                                    var mate = filter.slice(0);
                                    for (var j = 0; j < mate.length; j++) {
                                        for (var _i = 0, scards_2 = scards; _i < scards_2.length; _i++) {
                                            var k = scards_2[_i];
                                            if (get.is.filterCardBy(k, mate[j])) {
                                                mate.splice(j--, 1);
                                            }
                                        }
                                    }
                                    if (mate.length == 0)
                                        return ub.length;
                                }
                            }
                        }
                        return [ub.length + 1, ub.length + 2];
                    });
                    next.set('filterMaterial', event.filterMaterial);
                    'step 2';
                    if (result.bool) {
                        var cards = result.links.slice(1);
                        var star = game.createCard2(result.links[0][2], get.suit3(cards).randomGet(), 14);
                        event.result = {
                            bool: true,
                            cards: cards,
                            materials: cards,
                            star: star
                        };
                    }
                    else
                        event.result = { bool: false };
                },
                emptyEvent: function () {
                    event.trigger(event.name);
                },
                showCharacter: function () {
                    'step 0';
                    event.trigger('showCharacterEnd');
                    'step 1';
                    event.trigger('showCharacterAfter');
                    if (get.mode() == 'identity' && player.isZhu)
                        event.trigger('zhuUpdate');
                },
                removeCharacter: function () {
                    player.$removeCharacter(event.num);
                },
                chooseUseTarget: function () {
                    'step 0';
                    if (get.is.object(card) && !event.viewAs)
                        card.isCard = true;
                    if (cards && get.itemtype(card) != 'card') {
                        card = get.copy(card);
                        card.cards = cards.slice(0);
                        event.card = card;
                    }
                    if (!lib.filter.cardEnabled(card, player) || (event.addCount !== false && !lib.filter.cardUsable(card, player))) {
                        event.result = { bool: false };
                        event.finish();
                        return;
                    }
                    var info = get.info(card);
                    var range;
                    if (!info.notarget) {
                        var select = get.copy(info.selectTarget);
                        if (select == undefined) {
                            range = [1, 1];
                        }
                        else if (typeof select == 'number')
                            range = [select, select];
                        else if (get.itemtype(select) == 'select')
                            range = select;
                        else if (typeof select == 'function')
                            range = select(card, player);
                        game.checkMod(card, player, range, 'selectTarget', player);
                    }
                    if (info.notarget || range[1] == -1) {
                        if (!info.notarget && range[1] == -1) {
                            for (var i = 0; i < targets.length; i++) {
                                if (!player.canUse(card, targets[i], event.nodistance ? false : null, event.addCount === false ? null : true)) {
                                    targets.splice(i--, 1);
                                }
                            }
                            if (targets.length) {
                                event.targets2 = targets;
                            }
                            else {
                                event.finish();
                                return;
                            }
                        }
                        else
                            event.targets2 = [];
                        if (event.forced) {
                            event._result = { bool: true };
                        }
                        else {
                            var next = player.chooseBool();
                            next.set('prompt', event.prompt || ('是否' + (event.targets2.length ? '对' : '') + get.translation(event.targets2) + '使用' + get.translation(card) + '?'));
                            if (event.hsskill)
                                next.setHiddenSkill(event.hsskill);
                            if (event.prompt2)
                                next.set('prompt2', event.prompt2);
                            next.ai = function () {
                                var eff = 0;
                                for (var i = 0; i < event.targets2.length; i++) {
                                    eff += get.effect(event.targets2[i], card, player, player);
                                }
                                return eff > 0;
                            };
                        }
                    }
                    else {
                        var next = player.chooseTarget();
                        next.set('_get_card', card);
                        next.set('filterTarget', function (card, player, target) {
                            if (!_status.event.targets.contains(target))
                                return false;
                            if (!_status.event.nodistance && !lib.filter.targetInRange(card, player, target))
                                return false;
                            return lib.filter.targetEnabledx(card, player, target);
                        });
                        next.set('ai', event.ai || get.effect_use);
                        next.set('selectTarget', event.selectTarget || lib.filter.selectTarget);
                        if (event.nodistance)
                            next.set('nodistance', true);
                        if (event.forced)
                            next.set('forced', true);
                        if (event.addCount !== false)
                            next.set('addCount_extra', true);
                        next.set('targets', targets);
                        next.set('prompt', event.prompt || ('选择' + get.translation(card) + '的目标'));
                        if (event.prompt2)
                            next.set('prompt2', event.prompt2);
                        if (event.hsskill)
                            next.setHiddenSkill(event.hsskill);
                    }
                    'step 1';
                    if (result.bool) {
                        event.result = {
                            bool: true,
                            targets: event.targets2 || result.targets
                        };
                        var next = player.useCard(card, event.targets2 || result.targets);
                        next.oncard = event.oncard;
                        if (cards)
                            next.cards = cards.slice(0);
                        if (event.nopopup)
                            next.nopopup = true;
                        if (event.animate === false)
                            next.animate = false;
                        if (event["throw"] === false)
                            next["throw"] = false;
                        if (event.addCount === false)
                            next.addCount = false;
                        if (event.noTargetDelay)
                            next.targetDelay = false;
                        if (event.nodelayx)
                            next.delayx = false;
                        if (event.logSkill) {
                            if (typeof event.logSkill == 'string') {
                                next.skill = event.logSkill;
                            }
                            else if (Array.isArray(event.logSkill)) {
                                player.logSkill.apply(player, event.logSkill);
                            }
                        }
                    }
                    else
                        event.result = { bool: false };
                },
                chooseToDuiben: function () {
                    'step 0';
                    game.log(player, '对', target, '发起了', '#y对策');
                    if (_status.connectMode) {
                        player.chooseButtonOL([
                            [player, ['对策：请选择一种防御对策', [[['', '', 'db_def2'], ['', '', 'db_def1']], 'vcard']], true],
                            [target, ['对策：请选择一种进攻之策', [[['', '', 'db_atk1'], ['', '', 'db_atk2']], 'vcard']], true]
                        ], function () { }, function () { return 1 + Math.random(); }).set('switchToAuto', function () {
                            _status.event.result = 'ai';
                        }).set('processAI', function () {
                            var buttons = _status.event.dialog.buttons;
                            return {
                                bool: true,
                                links: [buttons.randomGet().link]
                            };
                        });
                    }
                    'step 1';
                    if (_status.connectMode) {
                        event.mes = result[player.playerid].links[0][2];
                        event.tes = result[target.playerid].links[0][2];
                        event.goto(4);
                    }
                    else {
                        player.chooseButton(['对策：请选择一种防御对策', [[['', '', 'db_def2'], ['', '', 'db_def1']], 'vcard']], true).ai = function () { return 1 + Math.random(); };
                    }
                    'step 2';
                    event.mes = result.links[0][2];
                    target.chooseButton(['对策：请选择一种进攻之策', [[['', '', 'db_atk1'], ['', '', 'db_atk2']], 'vcard']], true).ai = function () { return 1 + Math.random(); };
                    'step 3';
                    event.tes = result.links[0][2];
                    'step 4';
                    game.broadcast(function () {
                        ui.arena.classList.add('thrownhighlight');
                    });
                    ui.arena.classList.add('thrownhighlight');
                    game.addVideo('thrownhighlight1');
                    target.$compare(game.createCard(event.tes, '', ''), player, game.createCard(event.mes, '', ''));
                    game.log(target, '选择的进攻之策为', '#g' + get.translation(event.tes));
                    game.log(player, '选择的防御对策为', '#g' + get.translation(event.mes));
                    game.delay(0, 1500);
                    'step 5';
                    var mes = event.mes.slice(6);
                    var tes = event.tes.slice(6);
                    var str;
                    if (mes == tes) {
                        str = get.translation(player) + '对策成功';
                        player.popup('胜', 'wood');
                        target.popup('负', 'fire');
                        game.log(player, '#g胜');
                        event.result = { bool: true };
                    }
                    else {
                        str = get.translation(player) + '对策失败';
                        target.popup('胜', 'wood');
                        player.popup('负', 'fire');
                        game.log(target, '#g胜');
                        event.result = { bool: false };
                    }
                    game.broadcastAll(function (str) {
                        var dialog = ui.create.dialog(str);
                        dialog.classList.add('center');
                        setTimeout(function () {
                            dialog.close();
                        }, 1000);
                    }, str);
                    game.delay(2);
                    'step 6';
                    game.broadcastAll(function () {
                        ui.arena.classList.remove('thrownhighlight');
                    });
                    game.addVideo('thrownhighlight2');
                    if (event.clear !== false) {
                        game.broadcastAll(ui.clear);
                    }
                },
                chooseToPSS: function () {
                    'step 0';
                    game.log(player, '对', target, '发起了猜拳');
                    if (_status.connectMode) {
                        player.chooseButtonOL([
                            [player, ['猜拳：请选择一种手势', [[['', '', 'pss_stone'], ['', '', 'pss_scissor'], ['', '', 'pss_paper']], 'vcard']], true],
                            [target, ['猜拳：请选择一种手势', [[['', '', 'pss_stone'], ['', '', 'pss_scissor'], ['', '', 'pss_paper']], 'vcard']], true]
                        ], function () { }, function () { return 1 + Math.random(); }).set('switchToAuto', function () {
                            _status.event.result = 'ai';
                        }).set('processAI', function () {
                            var buttons = _status.event.dialog.buttons;
                            return {
                                bool: true,
                                links: [buttons.randomGet().link]
                            };
                        });
                    }
                    'step 1';
                    if (_status.connectMode) {
                        event.mes = result[player.playerid].links[0][2];
                        event.tes = result[target.playerid].links[0][2];
                        event.goto(4);
                    }
                    else {
                        player.chooseButton(['猜拳：请选择一种手势', [[['', '', 'pss_stone'], ['', '', 'pss_scissor'], ['', '', 'pss_paper']], 'vcard']], true).ai = function () { return 1 + Math.random(); };
                    }
                    'step 2';
                    event.mes = result.links[0][2];
                    target.chooseButton(['猜拳：请选择一种手势', [[['', '', 'pss_stone'], ['', '', 'pss_scissor'], ['', '', 'pss_paper']], 'vcard']], true).ai = function () { return 1 + Math.random(); };
                    'step 3';
                    event.tes = result.links[0][2];
                    'step 4';
                    game.broadcast(function () {
                        ui.arena.classList.add('thrownhighlight');
                    });
                    ui.arena.classList.add('thrownhighlight');
                    game.addVideo('thrownhighlight1');
                    player.$compare(game.createCard(event.mes, '', ''), target, game.createCard(event.tes, '', ''));
                    game.log(player, '选择的手势为', '#g' + get.translation(event.mes));
                    game.log(target, '选择的手势为', '#g' + get.translation(event.tes));
                    game.delay(0, 1500);
                    'step 5';
                    var mes = event.mes.slice(4);
                    var tes = event.tes.slice(4);
                    var str;
                    if (mes == tes) {
                        str = '二人平局';
                        player.popup('平', 'metal');
                        target.popup('平', 'metal');
                        game.log('猜拳的结果为', '#g平局');
                        event.result = { tie: true };
                    }
                    else {
                        if ({ paper: 'stone', scissor: 'paper', stone: 'scissor' }[mes] == tes) {
                            str = get.translation(player) + '胜利';
                            player.popup('胜', 'wood');
                            target.popup('负', 'fire');
                            game.log(player, '#g胜');
                            event.result = { bool: true, winner: mes };
                        }
                        else {
                            str = get.translation(target) + '胜利';
                            target.popup('胜', 'wood');
                            player.popup('负', 'fire');
                            game.log(target, '#g胜');
                            event.result = { bool: false, winner: tes };
                        }
                    }
                    game.broadcastAll(function (str) {
                        var dialog = ui.create.dialog(str);
                        dialog.classList.add('center');
                        setTimeout(function () {
                            dialog.close();
                        }, 1000);
                    }, str);
                    game.delay(2);
                    'step 6';
                    game.broadcastAll(function () {
                        ui.arena.classList.remove('thrownhighlight');
                    });
                    game.addVideo('thrownhighlight2');
                    if (event.clear !== false) {
                        game.broadcastAll(ui.clear);
                    }
                },
                cardsDiscard: function () {
                    game.getGlobalHistory().cardMove.push(event);
                    for (var i = 0; i < cards.length; i++) {
                        cards[i].discard();
                    }
                },
                orderingDiscard: function () {
                    var cards = event.relatedEvent.orderingCards;
                    for (var i = 0; i < cards.length; i++) {
                        if (get.position(cards[i], true) != 'o')
                            cards.splice(i--, 1);
                    }
                    if (cards.length)
                        game.cardsDiscard(cards);
                },
                cardsGotoOrdering: function () {
                    game.getGlobalHistory().cardMove.push(event);
                    for (var i = 0; i < cards.length; i++) {
                        cards[i].fix();
                        ui.ordering.appendChild(cards[i]);
                    }
                    var evt = event.relatedEvent || event.getParent();
                    if (!evt.orderingCards)
                        evt.orderingCards = [];
                    if (!event.noOrdering && !event.cardsOrdered) {
                        event.cardsOrdered = true;
                        var next = game.createEvent('orderingDiscard', false, evt.getParent());
                        next.relatedEvent = evt;
                        next.setContent('orderingDiscard');
                    }
                    if (!event.noOrdering)
                        evt.orderingCards.addArray(cards);
                },
                cardsGotoSpecial: function () {
                    game.getGlobalHistory().cardMove.push(event);
                    for (var i = 0; i < cards.length; i++) {
                        cards[i].fix();
                        ui.special.appendChild(cards[i]);
                    }
                    if (event.notrigger !== true)
                        event.trigger('addCardToStorage');
                },
                chooseToEnable: function () {
                    'step 0';
                    var list = [];
                    for (var i = 1; i < 6; i++) {
                        if (!player.isDisabled(i))
                            continue;
                        list.push('equip' + i);
                    }
                    if (!list.length)
                        event.finish();
                    else {
                        event.list = list;
                        var next = player.chooseControl(list);
                        next.set('prompt', '请选择恢复一个装备栏');
                        if (!event.ai)
                            event.ai = function (event, player, list) {
                                return list.randomGet();
                            };
                        event.ai = event.ai(event.getParent(), player, list);
                        next.ai = function () {
                            return event.ai;
                        };
                    }
                    'step 1';
                    event.result = { control: result.control };
                    player.enableEquip(result.control);
                },
                chooseToDisable: function () {
                    'step 0';
                    var list = [];
                    for (var i = 1; i < 7; i++) {
                        if ((i == 3 || i == 4) && event.horse)
                            continue;
                        if (i == 6 && !event.horse)
                            continue;
                        if (player.isDisabled(i))
                            continue;
                        list.push('equip' + i);
                    }
                    if (!list.length)
                        event.finish();
                    else {
                        event.list = list;
                        var next = player.chooseControl(list);
                        next.set('prompt', '请选择废除一个装备栏');
                        if (!event.ai)
                            event.ai = function (event, player, list) {
                                return list.randomGet();
                            };
                        event.ai = event.ai(event.getParent(), player, list);
                        next.ai = function () {
                            return event.ai;
                        };
                    }
                    'step 1';
                    event.result = { control: result.control };
                    if (result.control == 'equip6') {
                        player.disableEquip(3);
                        player.disableEquip(4);
                    }
                    else
                        player.disableEquip(result.control);
                },
                swapEquip: function () {
                    "step 0";
                    game.log(player, '和', target, '交换了装备区中的牌');
                    var e1 = player.getCards('e');
                    var todis1 = [];
                    for (var i = 0; i < e1.length; i++) {
                        if (target.isDisabled(get.subtype(e1[i])))
                            todis1.push(e1[i]);
                    }
                    player.discard(todis1);
                    var e2 = target.getCards('e');
                    var todis2 = [];
                    for (var i = 0; i < e2.length; i++) {
                        if (player.isDisabled(get.subtype(e2[i])))
                            todis2.push(e2[i]);
                    }
                    target.discard(todis2);
                    "step 1";
                    event.cards = [player.getCards('e'), target.getCards('e')];
                    player.lose(event.cards[0], ui.ordering, 'visible');
                    target.lose(event.cards[1], ui.ordering, 'visible');
                    if (event.cards[0].length)
                        player.$give(event.cards[0], target, false);
                    if (event.cards[1].length)
                        target.$give(event.cards[1], player, false);
                    "step 2";
                    for (var i = 0; i < event.cards[1].length; i++) {
                        player.equip(event.cards[1][i]);
                    }
                    for (var i = 0; i < event.cards[0].length; i++) {
                        target.equip(event.cards[0][i]);
                    }
                },
                disableEquip: function () {
                    if (!player.isDisabled(event.pos)) {
                        var cards = player.getCards('e', function (card) {
                            var subtype = get.subtype(card);
                            if (subtype == event.pos)
                                return true;
                            if (subtype == 'equip6' && ['equip3', 'equip4'].contains(event.pos))
                                return true;
                            return false;
                        });
                        if (cards.length)
                            player.discard(cards).delay = false;
                        game.log(player, '废除了', get.translation(event.pos), '栏');
                        player.$disableEquip(event.pos);
                    }
                },
                enableEquip: function () {
                    if (player.isDisabled(event.pos)) {
                        player.syncStorage('_disableEquip');
                        game.log(player, '恢复了', get.translation(event.pos), '栏');
                        player.$enableEquip(event.pos);
                    }
                    ;
                },
                disableJudge: function () {
                    'step 0';
                    game.log(player, '废除了判定区');
                    var js = player.getCards('j');
                    if (js.length)
                        player.discard(js);
                    player.storage._disableJudge = true;
                    //player.markSkill('_disableJudge');
                    'step 1';
                    game.broadcastAll(function (player, card) {
                        player.$disableJudge();
                    }, player);
                },
                enableJudge: function () {
                    if (!player.storage._disableJudge)
                        return;
                    game.log(player, '恢复了判定区');
                    game.broadcastAll(function (player) {
                        player.$enableJudge();
                    }, player);
                },
                /*----分界线----*/
                phasing: function () {
                    'step 0';
                    while (ui.dialogs.length) {
                        ui.dialogs[0].close();
                    }
                    if (!player.noPhaseDelay && lib.config.show_phase_prompt) {
                        player.popup('回合开始');
                    }
                    if (lib.config.glow_phase) {
                        if (_status.currentPhase) {
                            _status.currentPhase.classList.remove('glow_phase');
                            game.broadcast(function (player) {
                                player.classList.remove('glow_phase');
                            }, _status.currentPhase);
                        }
                        player.classList.add('glow_phase');
                        game.broadcast(function (player) {
                            player.classList.add('glow_phase');
                        }, player);
                    }
                    _status.currentPhase = player;
                    _status.discarded = [];
                    game.phaseNumber++;
                    player.phaseNumber++;
                    game.syncState();
                    game.addVideo('phaseChange', player);
                    if (game.phaseNumber == 1 && lib.configOL.observe) {
                        lib.configOL.observeReady = true;
                        game.send('server', 'config', lib.configOL);
                    }
                    game.log();
                    game.log(player, '的回合开始');
                    player._noVibrate = true;
                    if (get.config('identity_mode') != 'zhong' && get.config('identity_mode') != 'purple' && !_status.connectMode) {
                        var num;
                        switch (get.config('auto_identity')) {
                            case 'one':
                                num = 1;
                                break;
                            case 'two':
                                num = 2;
                                break;
                            case 'three':
                                num = 3;
                                break;
                            case 'always':
                                num = -1;
                                break;
                            default:
                                num = 0;
                                break;
                        }
                        if (num && !_status.identityShown && game.phaseNumber > game.players.length * num && game.showIdentity) {
                            if (!_status.video)
                                player.popup('显示身份');
                            _status.identityShown = true;
                            game.showIdentity(false);
                        }
                    }
                    player.ai.tempIgnore = [];
                    _status.globalHistory.push({
                        cardMove: [],
                        custom: []
                    });
                    game.countPlayer2(function (current) {
                        current.actionHistory.push({ useCard: [], respond: [], skipped: [], lose: [], gain: [], sourceDamage: [], damage: [], changeHujia: [], custom: [] });
                        current.stat.push({ card: {}, skill: {} });
                        if (event.parent._roundStart) {
                            current.getHistory().isRound = true;
                            current.getStat().isRound = true;
                        }
                    });
                    player.getHistory().isMe = true;
                    player.getStat().isMe = true;
                    if (event.parent._roundStart) {
                        game.getGlobalHistory().isRound = true;
                    }
                    if (ui.land && ui.land.player == player) {
                        game.addVideo('destroyLand');
                        ui.land.destroy();
                    }
                    'step 1';
                    event.trigger('phaseBeginStart');
                },
                /**
                 * 更换随从
                 * @name content.toggleSubPlayer
                 * @type {GameCores.Bases.StateMachine}
                 */
                toggleSubPlayer: function () {
                    'step 0';
                    var list = event.list || player.storage.subplayer.skills.slice(0);
                    list.remove(player.storage.subplayer.name2);
                    event.list = list;
                    if (!event.directresult) {
                        if (list.length > 1) {
                            var dialog = ui.create.dialog('更换一个随从', 'hidden');
                            dialog.add([list, 'character']);
                            player.chooseButton(dialog, true);
                        }
                        else if (list.length == 1) {
                            event.directresult = list[0];
                        }
                        else {
                            event.finish();
                        }
                    }
                    else {
                        if (!list.contains(event.directresult)) {
                            event.finish();
                        }
                    }
                    'step 1';
                    if (!event.directresult) {
                        if (result && result.bool && result.links[0]) {
                            event.directresult = result.links[0];
                        }
                        else {
                            event.finish();
                            return;
                        }
                    }
                    if (player.storage.subplayer) {
                        var current = player.storage.subplayer.name2;
                        if (event.directresult == current) {
                            event.finish();
                            return;
                        }
                        player.storage[current].hp = player.hp;
                        player.storage[current].maxHp = player.maxHp;
                        player.storage[current].hs = player.getCards('h');
                        player.storage[current].es = player.getCards('e');
                        player.lose(player.getCards('he'), ui.special)._triggered = null;
                        var cfg = player.storage[event.directresult];
                        player.storage.subplayer.name2 = event.directresult;
                        player.reinit(current, event.directresult, [
                            cfg.hp,
                            cfg.maxHp
                        ]);
                        if (cfg.hs.length)
                            player.directgain(cfg.hs);
                        if (cfg.es.length)
                            player.directequip(cfg.es);
                    }
                },
                /**
                 * 结束调遣随从
                 * @name content.callSubPlayer
                 * @type {GameCores.Bases.StateMachine}
                 */
                exitSubPlayer: function () {
                    'step 0';
                    if (player.storage.subplayer) {
                        var current = player.storage.subplayer.name2;
                        if (event.remove) {
                            player.lose(player.getCards('he'), ui.discardPile)._triggered = null;
                        }
                        else {
                            player.storage[current].hp = player.hp;
                            player.storage[current].maxHp = player.maxHp;
                            player.storage[current].hs = player.getCards('h');
                            player.storage[current].es = player.getCards('e');
                            player.lose(player.getCards('he'), ui.special)._triggered = null;
                        }
                        player.reinit(current, player.storage.subplayer.name, [
                            player.storage.subplayer.hp,
                            player.storage.subplayer.maxHp
                        ]);
                        player.update();
                        if (event.remove) {
                            if (player.storage[current].onremove) {
                                player.storage[current].onremove(player);
                            }
                            delete player.storage[current];
                            player.storage.subplayer.skills.remove(current);
                            game.log(player, '牺牲了随从', '#g' + current);
                        }
                        else {
                            game.log(player, '收回了随从', '#g' + current);
                        }
                        player.addSkill(player.storage.subplayer.skills);
                    }
                    'step 1';
                    if (player.storage.subplayer) {
                        player.directgain(player.storage.subplayer.hs);
                        player.directequip(player.storage.subplayer.es);
                    }
                    player.removeSkill('subplayer');
                    'step 2';
                    if (event.remove) {
                        event.trigger('subPlayerDie');
                    }
                },
                /**
                 * 调遣随从
                 * @name content.callSubPlayer
                 * @type {GameCores.Bases.StateMachine}
                 */
                callSubPlayer: function () {
                    'step 0';
                    var list = player.getSubPlayers(event.tag);
                    event.list = list;
                    if (!event.directresult) {
                        if (list.length > 1) {
                            var dialog = ui.create.dialog('调遣一个随从', 'hidden');
                            dialog.add([list, 'character']);
                            player.chooseButton(dialog, true);
                        }
                        else if (list.length == 1) {
                            event.directresult = list[0];
                        }
                        else {
                            event.finish();
                        }
                    }
                    else {
                        if (!list.contains(event.directresult)) {
                            event.finish();
                        }
                    }
                    'step 1';
                    if (!event.directresult) {
                        if (result && result.bool && result.links[0]) {
                            event.directresult = result.links[0];
                        }
                        else {
                            event.finish();
                            return;
                        }
                    }
                    if (event.directresult) {
                        var cfg = player.storage[event.directresult];
                        var source = cfg.source || player.name;
                        var name = event.directresult;
                        game.log(player, '调遣了随从', '#g' + name);
                        player.storage.subplayer = {
                            name: source,
                            name2: event.directresult,
                            hp: player.hp,
                            maxHp: player.maxHp,
                            skills: event.list.slice(0),
                            hs: player.getCards('h'),
                            es: player.getCards('e'),
                            intro2: cfg.intro2
                        };
                        player.removeSkill(event.list);
                        player.reinit(source, name, [cfg.hp, cfg.maxHp]);
                        player.addSkill('subplayer');
                        player.lose(player.getCards('he'), ui.special)._triggered = null;
                        if (cfg.hs.length)
                            player.directgain(cfg.hs);
                        if (cfg.es.length)
                            player.directequip(cfg.es);
                    }
                    'step 2';
                    game.delay();
                },
                /**
                 * 反转结算顺序
                 * @name content.reverseOrder
                 * @type {GameCores.Bases.StateMachine}
                 */
                reverseOrder: function () {
                    "step 0";
                    game.delay();
                    "step 1";
                    var choice;
                    if (get.tag(card, 'multineg')) {
                        choice = (player.previous.side == player.side) ? '逆时针' : '顺时针';
                    }
                    else {
                        choice = (player.next.side == player.side) ? '逆时针' : '顺时针';
                    }
                    player.chooseControl('顺时针', '逆时针', function (event, player) {
                        return _status.event.choice || '逆时针';
                    }).set('prompt', '选择' + get.translation(card) + '的结算方向').set('choice', choice).set('forceDie', true);
                    "step 2";
                    if (result && result.control == '顺时针') {
                        var evt = event.getParent();
                        evt.fixedSeat = true;
                        evt.targets.sortBySeat();
                        evt.targets.reverse();
                        if (evt.targets[evt.targets.length - 1] == player) {
                            evt.targets.unshift(evt.targets.pop());
                        }
                    }
                },
                /**
                 * 使用判定牌
                 * @name content.addJudgeCard
                 * @type {GameCores.Bases.StateMachine}
                 */
                addJudgeCard: function () {
                    if (lib.filter.judge(card, player, target) && cards.length && get.position(cards[0], true) == 'o')
                        target.addJudge(card, cards);
                },
                /**
                 * 使用装备牌
                 * @name content.equipCard
                 * @type {GameCores.Bases.StateMachine}
                 */
                equipCard: function () {
                    if (cards.length && get.position(cards[0], true) == 'o')
                        target.equip(card, cards[0]);
                },
                /**
                 * 游戏开始前分牌
                 * @name content.gameDraw
                 * @type {GameCores.Bases.StateMachine}
                 */
                gameDraw: function () {
                    "step 0";
                    if (_status.brawl && _status.brawl.noGameDraw) {
                        event.finish();
                        return;
                    }
                    var end = player;
                    var numx = num;
                    do {
                        if (typeof num == 'function') {
                            numx = num(player);
                        }
                        if (player.getTopCards)
                            player.directgain(player.getTopCards(numx));
                        else
                            player.directgain(get.cards(numx));
                        if (player.singleHp === true && get.mode() != 'guozhan' && (lib.config.mode != 'doudizhu' || _status.mode != 'online')) {
                            player.doubleDraw();
                        }
                        player = player.next;
                    } while (player != end);
                    event.changeCard = get.config('change_card');
                    if (_status.connectMode || (lib.config.mode == 'doudizhu' && _status.mode == 'online') || lib.config.mode != 'identity' && lib.config.mode != 'guozhan' && lib.config.mode != 'doudizhu' && lib.config.mode != 'longlaoguan') {
                        event.changeCard = 'disabled';
                    }
                    "step 1";
                    if (event.changeCard != 'disabled' && !_status.auto) {
                        event.dialog = ui.create.dialog('是否使用手气卡？');
                        ui.create.confirm('oc');
                        event.custom.replace.confirm = function (bool) {
                            _status.event.bool = bool;
                            game.resume();
                        };
                    }
                    else {
                        event.finish();
                    }
                    "step 2";
                    if (event.changeCard == 'once') {
                        event.changeCard = 'disabled';
                    }
                    else if (event.changeCard == 'twice') {
                        event.changeCard = 'once';
                    }
                    else if (event.changeCard == 'disabled') {
                        event.bool = false;
                        return;
                    }
                    _status.imchoosing = true;
                    event.switchToAuto = function () {
                        _status.event.bool = false;
                        game.resume();
                    };
                    game.pause();
                    "step 3";
                    _status.imchoosing = false;
                    if (event.bool) {
                        if (game.changeCoin) {
                            game.changeCoin(-3);
                        }
                        var hs = game.me.getCards('h');
                        game.addVideo('lose', game.me, [get.cardsInfo(hs), [], [], []]);
                        for (var i = 0; i < hs.length; i++) {
                            hs[i].discard(false);
                        }
                        game.me.directgain(get.cards(hs.length));
                        var ss = game.me.getCards('s');
                        game.addVideo('lose', game.me, [get.cardsInfo(ss), [], [], []]);
                        for (var i = 0; i < ss.length; i++) {
                            ss[i].discard(false);
                        }
                        game.me.directgains(get.cards(ss.length));
                        event.goto(2);
                    }
                    else {
                        if (event.dialog)
                            event.dialog.close();
                        if (ui.confirm)
                            ui.confirm.close();
                        event.finish();
                    }
                },
                /**
                 * 阶段循环
                 * @name content.phaseLoop
                 * @type {GameCores.Bases.StateMachine}
                 */
                phaseLoop: function () {
                    "step 0";
                    for (var i = 0; i < lib.onphase.length; i++) {
                        lib.onphase[i]();
                    }
                    player.phase();
                    "step 1";
                    if (!game.players.contains(event.player.next)) {
                        event.player = game.findNext(event.player.next);
                    }
                    else {
                        event.player = event.player.next;
                    }
                    event.goto(0);
                },
                /**
                 * 加载包
                 * @name content.loadPackage
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Array<Object>} event.packages 包名数组，用于加载
                 * @property {string} event.packages[].0 包目录，相对`lib.assetURL`路径
                 * @property {string} event.packages[].1 包名
                 */
                loadPackage: function () {
                    'step 0';
                    if (event.packages.length) {
                        // window.game = game;//[todo delete]
                        var pack = event.packages.shift().split('/');
                        lib.init.js(lib.assetURL + pack[0], pack[1], game.resume);
                        game.pause();
                    }
                    else {
                        event.finish();
                    }
                    'step 1';
                    // if (!lib.config.dev) delete window.game;//[todo delete]
                    var character = lib.imported.character;
                    var card = lib.imported.card;
                    var i, j, k;
                    for (i in character) {
                        if (character[i].character) {
                            lib.characterPack[i] = character[i].character;
                        }
                        if (character[i].forbid && character[i].forbid.contains(lib.config.mode))
                            continue;
                        if (character[i].mode && character[i].mode.contains(lib.config.mode) == false)
                            continue;
                        if (Array.isArray(lib[j]) && Array.isArray(character[i][j])) {
                            lib[j].addArray(character[i][j]);
                            continue;
                        }
                        for (j in character[i]) {
                            if (j == 'mode' || j == 'forbid' || j == 'characterSort')
                                continue;
                            for (k in character[i][j]) {
                                if (j == 'character') {
                                    if (!character[i][j][k][4]) {
                                        character[i][j][k][4] = [];
                                    }
                                    if (character[i][j][k][4].contains('boss') ||
                                        character[i][j][k][4].contains('hiddenboss')) {
                                        lib.config.forbidai.add(k);
                                    }
                                    if (lib.config.forbidai_user && lib.config.forbidai_user.contains(k)) {
                                        lib.config.forbidai.add(k);
                                    }
                                    for (var l = 0; l < character[i][j][k][3].length; l++) {
                                        lib.skilllist.add(character[i][j][k][3][l]);
                                    }
                                }
                                if (j == 'translate' && k == i) {
                                    lib[j][k + '_character_config'] = character[i][j][k];
                                }
                                else {
                                    if (lib[j][k] == undefined) {
                                        lib[j][k] = character[i][j][k];
                                    }
                                    else if (Array.isArray(lib[j][k]) && Array.isArray(character[i][j][k])) {
                                        lib[j][k].addArray(character[i][j][k]);
                                    }
                                    else {
                                        console.log('dublicate ' + j + ' in character ' + i + ':\n' + k + '\n' + ': ' + lib[j][k] + '\n' + character[i][j][k]);
                                    }
                                }
                            }
                        }
                    }
                    for (i in card) {
                        lib.cardPack[i] = [];
                        if (card[i].card) {
                            for (var j in card[i].card) {
                                if (!card[i].card[j].hidden && card[i].translate[j + '_info']) {
                                    lib.cardPack[i].push(j);
                                }
                            }
                        }
                        for (j in card[i]) {
                            if (j == 'mode' || j == 'forbid')
                                continue;
                            if (j == 'list')
                                continue;
                            for (k in card[i][j]) {
                                if (j == 'skill' && k[0] == '_' && !lib.config.cards.contains(i)) {
                                    continue;
                                }
                                if (j == 'translate' && k == i) {
                                    lib[j][k + '_card_config'] = card[i][j][k];
                                }
                                else {
                                    if (lib[j][k] == undefined)
                                        lib[j][k] = card[i][j][k];
                                    else
                                        console.log('dublicate ' + j + ' in card ' + i + ':\n' + k + '\n' + lib[j][k] + '\n' + card[i][j][k]);
                                }
                            }
                        }
                    }
                    event.goto(0);
                },
                /**
                 * 加载模组
                 * @name content.loadMode
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!string} event.mode 要加载的mode名
                 * @property {?Object} event.result 如果加载成功返回加载的模组，如果失败则返回未指定(undefined)结果
                 */
                loadMode: function () {
                    'step 0';
                    // window.game = game;//[todo delete]
                    lib.init.js(lib.assetURL + 'mode', event.mode, game.resume);
                    game.pause();
                    'step 1';
                    // if (!lib.config.dev) delete window.game;//[todo delete]
                    event.result = lib.imported.mode[event.mode];
                    delete lib.imported.mode[event.mode];
                },
                /**
                 * 强制结束
                 * @name content.forceOver
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {?string} event.bool 是否调用{@link game.over}，如果为'noover'，则不调用
                 * @property {?function():void} [event.callback] 回调函数，在事件结束前调用
                 */
                forceOver: function () {
                    'step 0';
                    while (ui.controls.length) {
                        ui.controls[0].close();
                    }
                    while (ui.dialogs.length) {
                        ui.dialogs[0].close();
                    }
                    'step 1';
                    if (event.bool != 'noover') {
                        game.over(event.bool);
                    }
                    if (event.callback) {
                        event.callback();
                    }
                },
                /**
                 * 事件触发调度状态机
                 * @name content.arrangeTrigger
                 * @type {GameCores.Bases.StateMachine}
                 */
                arrangeTrigger: function () {
                    'step 0';
                    event.filter1 = function (info) {
                        if (info[1].isDead() && !lib.skill[info[0]].forceDie)
                            return false;
                        return lib.filter.filterTrigger(trigger, info[1], event.triggername, info[0]);
                    };
                    event.filter2 = function (info2) {
                        var info = lib.skill[info2[0]];
                        if (!lib.translate[info2[0]] || info.popup === false || info.silent)
                            return false;
                        return true;
                    };
                    event.filter3 = function (info, info2) {
                        return event.filter2(info2) && event.filter1(info2) && info2[1] == info[1] && info[2] == info2[2] && (lib.skill.global.contains(info2[0]) || info[1].hasSkill(info2[0], true));
                    };
                    'step 1';
                    if (trigger.filterStop && trigger.filterStop()) {
                        event.finish();
                    }
                    else if (event.list.length) {
                        var info = event.list.shift();
                        game.createTrigger(event.triggername, info[0], info[1], trigger);
                        event.redo();
                    }
                    'step 2';
                    if (!event.map.length) {
                        if (event.list2.length) {
                            var info = event.list2.shift();
                            game.createTrigger(event.triggername, info[0], info[1], trigger);
                            event.redo();
                        }
                        else {
                            if (trigger._triggering == this) {
                                delete trigger._triggering;
                            }
                            event.finish();
                            return;
                        }
                    }
                    ;
                    event.doing = event.map.shift();
                    'step 3';
                    event.num = 0;
                    var bool = false;
                    var list = event.doing.list;
                    for (var i = 0; i < list.length; i++) {
                        if (event.filter1(list[i])) {
                            event.num = i;
                            bool = true;
                            break;
                        }
                    }
                    if (!bool) {
                        event.goto(2);
                        return;
                    }
                    var priority = list[event.num][2];
                    for (var i = 0; i < event.num; i++) {
                        if (event.doing.list[i][2] > priority) {
                            event.doing.list.splice(i--, 1);
                            event.num--;
                        }
                    }
                    event.choice = [];
                    if (event.num < event.doing.list.length - 1 && event.filter2(event.doing.list[event.num])) {
                        var current = event.doing.list[event.num];
                        event.choice.push(current);
                        for (var i = event.num + 1; i < event.doing.list.length; i++) {
                            if (event.filter3(current, event.doing.list[i]))
                                event.choice.push(event.doing.list[i]);
                        }
                    }
                    if (event.choice.length < 2)
                        event.goto(6);
                    'step 4';
                    var controls = [];
                    event.current = event.choice[0][1];
                    for (var i = 0; i < event.choice.length; i++) {
                        controls.push(event.choice[i][0]);
                    }
                    event.current.chooseControl(controls).set('prompt', '选择下一个触发的技能').set('forceDie', true).set('arrangeSkill', true);
                    'step 5';
                    if (result.control) {
                        for (var i = 0; i < event.doing.list.length; i++) {
                            if (event.doing.list[i][0] == result.control && event.doing.list[i][1] == event.current) {
                                event.num = i;
                                break;
                            }
                        }
                    }
                    'step 6';
                    var info = event.doing.list[event.num];
                    if (info) {
                        event.doing.list2.push(info);
                        event.doing.list.splice(event.num, 1);
                        game.createTrigger(event.triggername, info[0], info[1], trigger);
                    }
                    'step 7';
                    if (trigger.filterStop && trigger.filterStop()) {
                        event.finish();
                    }
                    else
                        event.goto(event.doing.list.length ? 3 : 2);
                },
                /**
                 * 检测时机并让玩家选择是否发动触发类技能
                 * 创建触发器
                 * @name content.createTrigger
                 * @type {GameCores.Bases.StateMachine}
                 */
                createTrigger: function () {
                    "step 0";
                    if (lib.filter.filterTrigger(trigger, player, event.triggername, event.skill)) {
                        var fullskills = game.expandSkills(player.getSkills().concat(lib.skill.global));
                        if (!fullskills.contains(event.skill)) {
                            var info = get.info(event.skill);
                            var hidden = player.hiddenSkills.slice(0);
                            game.expandSkills(hidden);
                            if (hidden.contains(event.skill)) {
                                if (!info.silent && player.hasSkillTag('nomingzhi', false, null, true)) {
                                    event.finish();
                                }
                                else if (!info.direct) {
                                    event.trigger('triggerHidden');
                                }
                                else {
                                    event.skillHidden = true;
                                }
                            }
                            else {
                                var keep = false;
                                for (var i in player.additionalSkills) {
                                    if (i.indexOf('hidden:') == 0 && game.expandSkills(player.additionalSkills[i]).contains(event.skill)) {
                                        keep = true;
                                        break;
                                    }
                                }
                                if (!keep) {
                                    event.finish();
                                }
                            }
                        }
                    }
                    else {
                        event.finish();
                    }
                    "step 1";
                    if (event.cancelled) {
                        event.finish();
                        return;
                    }
                    var info = get.info(event.skill);
                    if (!event.revealed && !info.forced) {
                        var checkFrequent = function (info) {
                            if (player.hasSkillTag('nofrequent', false, event.skill))
                                return false;
                            if (typeof info.frequent == 'boolean')
                                return info.frequent;
                            if (typeof info.frequent == 'function')
                                return info.frequent(trigger, player);
                            if (info.frequent == 'check' && typeof info.check == 'function')
                                return info.check(trigger, player);
                            return false;
                        };
                        if (info.direct && player.isUnderControl()) {
                            game.swapPlayerAuto(player);
                            event._result = { bool: true };
                            event._direct = true;
                        }
                        else if (info.direct) {
                            event._result = { bool: true };
                            event._direct = true;
                        }
                        else if (info.direct && player.isOnline()) {
                            event._result = { bool: true };
                            event._direct = true;
                        }
                        else {
                            if (checkFrequent(info)) {
                                event.frequentSkill = true;
                            }
                            var str;
                            var check = info.check;
                            if (info.prompt)
                                str = info.prompt;
                            else {
                                if (typeof info.logTarget == 'string') {
                                    str = get.prompt(event.skill, trigger[info.logTarget], player);
                                }
                                else if (typeof info.logTarget == 'function') {
                                    str = get.prompt(event.skill, info.logTarget(trigger, player), player);
                                }
                                else {
                                    str = get.prompt(event.skill, null, player);
                                }
                            }
                            if (typeof str == 'function') {
                                str = str(trigger, player);
                            }
                            var next = player.chooseBool(str);
                            if (event.frequentSkill)
                                next.set('frequentSkill', event.skill);
                            next.set('forceDie', true);
                            next.ai = function () {
                                return !check || check(trigger, player);
                            };
                            if (typeof info.prompt2 == 'function') {
                                next.set('prompt2', info.prompt2(trigger, player));
                            }
                            else if (typeof info.prompt2 == 'string') {
                                next.set('prompt2', info.prompt2);
                            }
                            else if (info.prompt2 != false) {
                                if (lib.dynamicTranslate[event.skill] || lib.translate[event.skill + '_info'])
                                    next.set('prompt2', get.skillInfoTranslation(event.skill, player));
                            }
                            if (trigger.skillwarn) {
                                if (next.prompt2) {
                                    next.set('prompt2', '<span class="thundertext">' + trigger.skillwarn + '。</span>' + next.prompt2);
                                }
                                else {
                                    next.set('prompt2', trigger.skillwarn);
                                }
                            }
                            if (info.addDialog) {
                                var createDialog = [str, 'small'];
                                if (next.prompt2)
                                    createDialog.push(next.prompt2);
                                createDialog.push(info.addDialog(trigger, player));
                                next.set('createDialog', createDialog);
                            }
                        }
                    }
                    "step 2";
                    var info = get.info(event.skill);
                    if (result && result.bool != false) {
                        var autodelay = info.autodelay;
                        if (typeof autodelay == 'function') {
                            autodelay = autodelay(trigger, player);
                        }
                        if (autodelay && (info.forced || !event.isMine())) {
                            if (typeof autodelay == 'number') {
                                game.delayx(autodelay);
                            }
                            else {
                                game.delayx();
                            }
                        }
                    }
                    "step 3";
                    var info = get.info(event.skill);
                    if (result && result.bool == false) {
                        if (info.oncancel)
                            info.oncancel(trigger, player);
                        event.finish();
                        return;
                    }
                    var next = game.createEvent(event.skill);
                    if (typeof info.usable == 'number') {
                        player.addSkill('counttrigger');
                        if (!player.storage.counttrigger) {
                            player.storage.counttrigger = {};
                        }
                        if (!player.storage.counttrigger[event.skill]) {
                            player.storage.counttrigger[event.skill] = 1;
                        }
                        else {
                            player.storage.counttrigger[event.skill]++;
                        }
                    }
                    next.player = player;
                    next._trigger = trigger;
                    next.triggername = event.triggername;
                    next.setContent(info.content);
                    next.skillHidden = event.skillHidden;
                    if (info.forceDie)
                        next.forceDie = true;
                    if (info.popup != false && !info.direct) {
                        if (info.popup) {
                            player.popup(info.popup);
                            game.log(player, '发动了', '#p『' + get.skillTranslation(event.skill, player) + '』');
                        }
                        else {
                            if (info.logTarget && info.logLine !== false) {
                                if (typeof info.logTarget == 'string') {
                                    player.logSkill(event.skill, trigger[info.logTarget], info.line);
                                }
                                else if (typeof info.logTarget == 'function') {
                                    player.logSkill(event.skill, info.logTarget(trigger, player), info.line);
                                }
                            }
                            else {
                                player.logSkill(event.skill, false, info.line);
                            }
                        }
                    }
                    "step 4";
                    if (player._hookTrigger) {
                        for (var i = 0; i < player._hookTrigger.length; i++) {
                            var info = lib.skill[player._hookTrigger[i]].hookTrigger;
                            if (info) {
                                if (info.after && info.after(event, player, event.triggername)) {
                                    event.trigger('triggerAfter');
                                    break;
                                }
                            }
                        }
                    }
                },
                /**
                 * Play video
                 * @name content.playVideoContent
                 * @type {GameCores.Bases.StateMachine}
                 */
                playVideoContent: function () {
                    'step 0';
                    game.delay(0, 500);
                    'step 1';
                    if (!game.chess) {
                        ui.control.innerHTML = '';
                        var nodes = [];
                        for (var i = 0; i < ui.arena.childNodes.length; i++) {
                            nodes.push(ui.arena.childNodes[i]);
                        }
                        for (var i = 0; i < nodes.length; i++) {
                            if (nodes[i] == ui.canvas)
                                continue;
                            if (nodes[i] == ui.control)
                                continue;
                            if (nodes[i] == ui.mebg)
                                continue;
                            if (nodes[i] == ui.me)
                                continue;
                            if (nodes[i] == ui.roundmenu)
                                continue;
                            nodes[i].remove();
                        }
                        ui.sidebar.innerHTML = '';
                        ui.cardPile.innerHTML = '';
                        ui.discardPile.innerHTML = '';
                        ui.special.innerHTML = '';
                        ui.ordering.innerHTML = '';
                    }
                    ui.system.firstChild.innerHTML = '';
                    ui.system.lastChild.innerHTML = '';
                    ui.system.firstChild.appendChild(ui.config2);
                    if (ui.updateVideoMenu) {
                        ui.updateVideoMenu();
                    }
                    _status.videoDuration = 1;
                    ui.create.system('返回', function () {
                        var mode = localStorage.getItem(lib.configprefix + 'playbackmode');
                        if (mode) {
                            game.saveConfig('mode', mode);
                        }
                        game.reload();
                    });
                    ui.create.system('重播', function () {
                        _status.replayvideo = true;
                        game.playVideo(_status.playback, lib.config.mode);
                    });
                    ui.create.system('暂停', ui.click.pause, true).id = 'pausebutton';
                    var slow = ui.create.system('减速', function () {
                        _status.videoDuration *= 1.5;
                        updateDuration();
                    }, true);
                    var fast = ui.create.system('加速', function () {
                        _status.videoDuration /= 1.5;
                        updateDuration();
                    }, true);
                    var updateDuration = function () {
                        if (_status.videoDuration > 1) {
                            slow.classList.add('glow');
                        }
                        else {
                            slow.classList.remove('glow');
                        }
                        if (_status.videoDuration < 1) {
                            fast.classList.add('glow');
                        }
                        else {
                            fast.classList.remove('glow');
                        }
                    };
                    ui.system.style.display = '';
                    ui.refresh(ui.system);
                    ui.system.show();
                    ui.window.show();
                    if (lib.config.mode != 'versus' && lib.config.mode != 'boss') {
                        ui.arena.style.display = '';
                        ui.refresh(ui.arena);
                        ui.arena.show();
                    }
                    if (!game.chess) {
                        game.playerMap = {};
                    }
                    game.finishCards();
                    'step 2';
                    if (event.video.length) {
                        var content = event.video.shift();
                        // console.log(content);
                        if (content.type == 'delay') {
                            game.delay(content.content);
                        }
                        else if (content.type == 'play') {
                            window.play = {};
                            if (!event.playtoload) {
                                event.playtoload = 1;
                            }
                            else {
                                event.playtoload++;
                            }
                            var script = lib.init.js(lib.assetURL + 'play', content.name);
                            script.addEventListener('load', function () {
                                var play = window.play[content.name];
                                if (play && play.video) {
                                    play.video(content.init);
                                }
                                event.playtoload--;
                                if (event.playtoload == 0) {
                                    delete window.play;
                                }
                            });
                        }
                        else if (typeof content.player == 'string' && game.playerMap[content.player] &&
                            game.playerMap[content.player].classList &&
                            !game.playerMap[content.player].classList.contains('obstacle')) {
                            game.videoContent[content.type](game.playerMap[content.player], content.content);
                        }
                        else {
                            game.videoContent[content.type](content.content);
                        }
                        if (event.video.length) {
                            game.delay(0, _status.videoDuration * Math.min(2000, event.video[0].delay));
                        }
                        event.redo();
                    }
                    else {
                        _status.over = true;
                        ui.system.lastChild.hide();
                        setTimeout(function () {
                            ui.system.lastChild.innerHTML = '';
                        }, 500);
                    }
                },
                /**
                 * wait for player
                 * @name content.waitForPlayer
                 * @type {GameCores.Bases.StateMachine}
                 */
                waitForPlayer: function () {
                    'step 0';
                    ui.auto.hide();
                    ui.pause.hide();
                    game.createServer();
                    if (!lib.translate.zhu) {
                        lib.translate.zhu = '主';
                    }
                    if (event.func) {
                        event.func();
                    }
                    if (!lib.configOL.number) {
                        lib.configOL.number = parseInt(lib.configOL.player_number);
                    }
                    if (game.onlineroom) {
                        game.send('server', 'config', lib.configOL);
                    }
                    ui.create.connectPlayers(game.ip);
                    if (!window.isNonameServer) {
                        var me = game.connectPlayers[0];
                        me.setIdentity('zhu');
                        me.initOL(get.connectNickname(), lib.config.connect_avatar);
                        me.playerid = '1';
                        game.onlinezhu = '1';
                    }
                    _status.waitingForPlayer = true;
                    if (window.isNonameServer) {
                        document.querySelector('#server_status').innerHTML = '等待中';
                    }
                    game.pause();
                    'step 1';
                    _status.waitingForPlayer = false;
                    lib.configOL.gameStarted = true;
                    if (window.isNonameServer) {
                        document.querySelector('#server_status').innerHTML = '游戏中';
                    }
                    if (game.onlineroom) {
                        game.send('server', 'config', lib.configOL);
                    }
                    for (var i = 0; i < game.connectPlayers.length; i++) {
                        game.connectPlayers[i]["delete"]();
                    }
                    delete game.connectPlayers;
                    if (ui.roomInfo) {
                        ui.roomInfo.remove();
                        delete ui.roomInfo;
                    }
                    if (ui.exitroom) {
                        ui.exitroom.remove();
                        delete ui.exitroom;
                    }
                    game.broadcast('gameStart');
                    game.delay(2);
                    ui.auto.show();
                    ui.pause.show();
                    if (lib.config.show_cardpile) {
                        ui.cardPileButton.style.display = '';
                    }
                },
                /**
                 * 置换手牌(单机)
                 * @name content.replaceHandcards
                 * @type {GameCores.Bases.StateMachine}
                 */
                replaceHandcards: function () {
                    'step 0';
                    if (event.players.contains(game.me)) {
                        game.me.chooseBool('是否置换手牌？');
                    }
                    else {
                        event.finish();
                    }
                    'step 1';
                    if (result && result.bool) {
                        var hs = game.me.getCards('h');
                        for (var i = 0; i < hs.length; i++) {
                            hs[i].discard(false);
                        }
                        game.me.directgain(get.cards(hs.length));
                    }
                },
                /**
                 * 置换手牌[support online]
                 * @name content.replaceHandcards
                 * @type {GameCores.Bases.StateMachine}
                 */
                replaceHandcardsOL: function () {
                    'step 0';
                    var send = function () {
                        game.me.chooseBool('是否置换手牌？');
                        game.resume();
                    };
                    var sendback = function (result, player) {
                        if (result && result.bool) {
                            var hs = player.getCards('h');
                            game.broadcastAll(function (player, hs) {
                                game.addVideo('lose', player, [get.cardsInfo(hs), [], [], []]);
                                for (var i = 0; i < hs.length; i++) {
                                    hs[i].discard(false);
                                }
                            }, player, hs);
                            player.directgain(get.cards(hs.length));
                        }
                    };
                    for (var i = 0; i < event.players.length; i++) {
                        if (event.players[i].isOnline()) {
                            event.withol = true;
                            event.players[i].send(send);
                            event.players[i].wait(sendback);
                        }
                        else if (event.players[i] == game.me) {
                            event.withme = true;
                            game.me.chooseBool('是否置换手牌？');
                            game.me.wait(sendback);
                        }
                    }
                    'step 1';
                    if (event.withme) {
                        game.me.unwait(result);
                    }
                    'step 2';
                    if (event.withol && !event.resultOL) {
                        game.pause();
                    }
                },
                /**
                 * 一个完整的回合
                 * @name content.phase
                 * @type {GameCores.Bases.StateMachine}
                 */
                phase: function () {
                    "step 0";
                    if (!event.stageList || !event.stageList.length)
                        event.stageList = lib.phaseName;
                    event.stepNum = 0;
                    "step 1";
                    if (typeof player[event.stageList[event.stepNum]] == 'function')
                        player[event.stageList[event.stepNum]]();
                    "step 2";
                    if (event.stageList[event.stepNum] == 'phaseDraw') {
                        if (!player.noPhaseDelay) {
                            if (player == game.me) {
                                game.delay();
                            }
                            else {
                                game.delayx();
                            }
                        }
                    }
                    if (event.stageList[event.stepNum] == 'phaseUse') {
                        game.broadcastAll(function () {
                            if (ui.tempnowuxie) {
                                ui.tempnowuxie.close();
                                delete ui.tempnowuxie;
                            }
                        });
                    }
                    if (event.stageList[event.stepNum] == 'phaseDiscard') {
                        if (!player.noPhaseDelay)
                            game.delayx();
                        delete player._noSkill;
                    }
                    "step 3";
                    event.trigger('phaseNext');
                    if (event.stageList[++event.stepNum]) {
                        event.trigger('stepNext');
                        event.goto(1);
                    }
                },
                /**
                 * 判定阶段
                 * @name content.phaseJudge
                 * @type {GameCores.Bases.StateMachine}
                 */
                phaseJudge: function () {
                    "step 0";
                    event.cards = player.getCards('j');
                    if (!event.cards.length)
                        event.finish();
                    "step 1";
                    if (cards.length && player.getCards('j').contains(cards[0])) {
                        event.card = cards.shift();
                        if (event.card.classList.contains('removing')) {
                            event.card.remove();
                            delete event.card;
                            event.redo();
                        }
                        else if (event.card.classList.contains('feichu')) {
                            event.finish();
                            return;
                        }
                        else {
                            player.lose(event.card, 'visible', ui.ordering);
                            player.$phaseJudge(event.card);
                            event.cancelled = false;
                            event.trigger('phaseJudge');
                            var name = event.card.viewAs || event.card.name;
                            player.popup(name, 'thunder');
                            if (!lib.card[name].effect) {
                                game.delay();
                                event.redo();
                            }
                            else if (!lib.card[name].judge) {
                                game.delay();
                                event.nojudge = true;
                            }
                        }
                    }
                    else
                        event.finish();
                    "step 2";
                    if (!event.cancelled && !event.nojudge)
                        player.judge(event.card).set('type', 'phase');
                    "step 3";
                    var name = event.card.viewAs || event.card.name;
                    if (event.cancelled && !event.direct) {
                        if (lib.card[name].cancel) {
                            var next = game.createEvent(name + 'Cancel');
                            next.setContent(lib.card[name].cancel);
                            next.card = event.card;
                            next.cards = [event.card];
                            next.player = player;
                        }
                    }
                    else {
                        var next = game.createEvent(name);
                        next.setContent(lib.card[name].effect);
                        next._result = result;
                        next.card = event.card;
                        next.cards = [event.card];
                        next.player = player;
                    }
                    ui.clear();
                    event.goto(1);
                },
                /**
                 * 摸牌阶段
                 * @name content.phaseDraw
                 * @type {GameCores.Bases.StateMachine}
                 */
                phaseDraw: function () {
                    "step 0";
                    event.trigger("phaseDrawBegin1");
                    "step 1";
                    event.trigger("phaseDrawBegin2");
                    "step 2";
                    if (game.modPhaseDraw) {
                        game.modPhaseDraw(player, event.num);
                    }
                    else {
                        if (event.num > 0) {
                            var num = event.num;
                            if (event.attachDraw) {
                                for (var i = 0; i < event.attachDraw.length; i++) {
                                    ui.cardPile.insertBefore(event.attachDraw[i], ui.cardPile.firstChild);
                                }
                                num += event.attachDraw.length;
                            }
                            var next = player.draw(num);
                            if (event.attachDraw) {
                                next.minnum = event.attachDraw.length;
                            }
                        }
                    }
                    "step 3";
                    if (Array.isArray(result)) {
                        event.cards = result;
                    }
                },
                /**
                 * 出牌阶段
                 * @name content.phaseUse
                 * @type {GameCores.Bases.StateMachine}
                 */
                phaseUse: function () {
                    "step 0";
                    var next = player.chooseToUse();
                    if (!lib.config.show_phaseuse_prompt) {
                        next.set('prompt', false);
                    }
                    next.set('type', 'phase');
                    "step 1";
                    if (result.bool && !event.skipped) {
                        event.goto(0);
                    }
                    game.broadcastAll(function () {
                        if (ui.tempnowuxie) {
                            ui.tempnowuxie.close();
                            delete ui.tempnowuxie;
                        }
                    });
                    "step 2";
                    var stat = player.getStat();
                    for (var i in stat.skill) {
                        var bool = false;
                        var info = lib.skill[i];
                        if (!info)
                            continue;
                        if (info.enable != undefined) {
                            if (typeof info.enable == 'string' && info.enable == 'phaseUse')
                                bool = true;
                            else if (typeof info.enable == 'object' && info.enable.contains('phaseUse'))
                                bool = true;
                        }
                        if (bool)
                            stat.skill[i] = 0;
                    }
                    for (var i in stat.card) {
                        var bool = false;
                        var info = lib.card[i];
                        if (!info)
                            continue;
                        if (info.updateUsable == 'phaseUse')
                            stat.card[i] = 0;
                    }
                },
                /**
                 * 弃牌阶段
                 * @name content.phaseDiscard
                 * @type {GameCores.Bases.StateMachine}
                 */
                phaseDiscard: function () {
                    "step 0";
                    if (!event.num)
                        event.num = player.needsToDiscard();
                    if (event.num <= 0)
                        event.finish();
                    else {
                        if (lib.config.show_phase_prompt) {
                            player.popup('弃牌阶段');
                        }
                    }
                    event.trigger('phaseDiscard');
                    "step 1";
                    player.chooseToDiscard(num, true);
                    "step 2";
                    event.cards = result.cards;
                },
                /**
                 * 选择以使用(牌|技能)
                 * @name content.chooseToUse
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                chooseToUse: function () {
                    "step 0";
                    if (event.responded)
                        return;
                    if (game.modeSwapPlayer && !_status.auto && player.isUnderControl() && !lib.filter.wuxieSwap(event)) {
                        game.modeSwapPlayer(player);
                    }
                    var skills = player.getSkills(true);
                    game.expandSkills(skills);
                    for (var i = 0; i < skills.length; i++) {
                        var info = lib.skill[skills[i]];
                        if (info && info.onChooseToUse) {
                            info.onChooseToUse(event);
                        }
                    }
                    _status.noclearcountdown = true;
                    if (event.type == 'phase') {
                        if (event.isMine()) {
                            if (lib.config.mode == 'richer' && lib.skill._chessmove.filter(true, player) && player.getStat().skill && !player.getStat().skill._chessmove) {
                                event.endButton = ui.create.control('请进行移动', 'stayleft', function () { });
                            }
                            else {
                                event.endButton = ui.create.control('结束回合', 'stayleft', function () {
                                    if (_status.event.skill) {
                                        ui.click.cancel();
                                    }
                                    ui.click.cancel();
                                });
                            }
                            event.fakeforce = true;
                        }
                        else {
                            if (event.endButton) {
                                event.endButton.close();
                                delete event.endButton;
                            }
                            event.fakeforce = false;
                        }
                    }
                    if (event.player.isUnderControl() && !_status.auto) {
                        event.result = {
                            bool: false
                        };
                        return;
                    }
                    else if (event.isMine()) {
                        if (event.hsskill && !event.forced && _status.prehidden_skills.contains(event.hsskill)) {
                            ui.click.cancel();
                            return;
                        }
                        if (event.type == 'wuxie') {
                            if (ui.tempnowuxie) {
                                var triggerevent = event.getTrigger();
                                if (triggerevent && triggerevent.targets && triggerevent.num == triggerevent.targets.length - 1) {
                                    ui.tempnowuxie.close();
                                }
                            }
                            if (lib.filter.wuxieSwap(event)) {
                                event.result = {
                                    bool: false
                                };
                                return;
                            }
                        }
                        var ok = game.check();
                        if (!ok || !lib.config.auto_confirm) {
                            game.pause();
                            if (lib.config.enable_vibrate && player._noVibrate) {
                                delete player._noVibrate;
                                game.vibrate();
                            }
                        }
                        if (!ok) {
                            if (typeof event.prompt == 'string') {
                                if (event.openskilldialog) {
                                    event.skillDialog = ui.create.dialog(event.openskilldialog);
                                    delete event.openskilldialog;
                                    event.dialog = event.prompt;
                                }
                                else {
                                    event.dialog = ui.create.dialog(event.prompt);
                                    if (event.prompt2) {
                                        event.dialog.addText(event.prompt2);
                                    }
                                }
                            }
                            else if (event.prompt == 'function') {
                                event.dialog = ui.create.dialog(event.prompt(event));
                            }
                            else if (event.prompt == undefined) {
                                var str;
                                if (typeof event.filterCard == 'object') {
                                    var filter = event.filterCard;
                                    str = '请使用' + get.cnNumber(event.selectCard[0]) + '张';
                                    if (filter.name) {
                                        str += get.translation(filter.name);
                                    }
                                    else {
                                        str += '牌';
                                    }
                                }
                                else {
                                    str = '请选择要使用的牌';
                                }
                                if (event.openskilldialog) {
                                    event.skillDialog = ui.create.dialog(event.openskilldialog);
                                    delete event.openskilldialog;
                                    event.dialog = str;
                                }
                                else if (typeof event.skillDialog != 'string') {
                                    event.dialog = ui.create.dialog(str);
                                }
                                else {
                                    event.dialog = str;
                                }
                            }
                        }
                    }
                    else if (event.isOnline()) {
                        event.send();
                    }
                    else {
                        event.result = 'ai';
                    }
                    "step 1";
                    if (event.result == 'ai') {
                        var ok = game.check();
                        if (ok) {
                            ui.click.ok();
                        }
                        else if (ai.basic.chooseCard(event.ai1)) {
                            if (ai.basic.chooseTarget(event.ai2)) {
                                ui.click.ok();
                                event._aiexcludeclear = true;
                            }
                            else {
                                if (!event.norestore) {
                                    if (event.skill) {
                                        var skill = event.skill;
                                        ui.click.cancel();
                                        event._aiexclude.add(skill);
                                        var info = get.info(skill);
                                        if (info.sourceSkill) {
                                            event._aiexclude.add(info.sourceSkill);
                                        }
                                    }
                                    else {
                                        get.card(true).aiexclude();
                                        game.uncheck();
                                    }
                                    event.redo();
                                    game.resume();
                                }
                                else {
                                    ui.click.cancel();
                                }
                            }
                        }
                        else if (event.skill && !event.norestore) {
                            var skill = event.skill;
                            ui.click.cancel();
                            event._aiexclude.add(skill);
                            var info = get.info(skill);
                            if (info.sourceSkill) {
                                event._aiexclude.add(info.sourceSkill);
                            }
                            event.redo();
                            game.resume();
                        }
                        else {
                            ui.click.cancel();
                        }
                        if (event.aidelay && event.result && event.result.bool) {
                            game.delayx();
                        }
                    }
                    "step 2";
                    if (event.endButton) {
                        event.endButton.close();
                        delete event.endButton;
                    }
                    event.resume();
                    if (event.result) {
                        if (event.result.skill) {
                            var info = get.info(event.result.skill);
                            if (info && info.chooseButton) {
                                if (event.dialog && typeof event.dialog == 'object')
                                    event.dialog.close();
                                var dialog = info.chooseButton.dialog(event, player);
                                if (info.chooseButton.chooseControl) {
                                    var next = player.chooseControl(info.chooseButton.chooseControl(event, player));
                                    next.dialog = dialog;
                                    next.set('ai', info.chooseButton.check || function () { return 0; });
                                }
                                else {
                                    var next = player.chooseButton(dialog);
                                    next.set('ai', info.chooseButton.check || function () { return 1; });
                                    next.set('filterButton', info.chooseButton.filter || function () { return true; });
                                    next.set('selectButton', info.chooseButton.select || 1);
                                }
                                event.buttoned = event.result.skill;
                            }
                            else if (info && info.precontent && !game.online && !event.nouse) {
                                var next = game.createEvent('pre_' + event.result.skill);
                                next.setContent(info.precontent);
                                next.set('result', event.result);
                                next.set('player', player);
                            }
                        }
                    }
                    "step 3";
                    if (event.buttoned) {
                        if (result.bool || result.control && result.control != 'cancel2') {
                            var info = get.info(event.buttoned).chooseButton;
                            lib.skill[event.buttoned + '_backup'] = info.backup(info.chooseControl ? result : result.links, player);
                            lib.skill[event.buttoned + '_backup'].sourceSkill = event.buttoned;
                            if (game.online) {
                                event._sendskill = [event.buttoned + '_backup', lib.skill[event.buttoned + '_backup']];
                            }
                            event.backup(event.buttoned + '_backup');
                            if (info.prompt) {
                                event.openskilldialog = info.prompt(info.chooseControl ? result : result.links, player);
                            }
                        }
                        else {
                            ui.control.animate('nozoom', 100);
                            event._aiexclude.add(event.buttoned);
                        }
                        event.goto(0);
                        delete event.buttoned;
                    }
                    "step 4";
                    if (event._aiexcludeclear) {
                        delete event._aiexcludeclear;
                        event._aiexclude.length = 0;
                    }
                    delete _status.noclearcountdown;
                    if (event.skillDialog && get.objtype(event.skillDialog) == 'div') {
                        event.skillDialog.close();
                    }
                    if (event.result && event.result.bool && !game.online && !event.nouse) {
                        player.useResult(event.result, event);
                    }
                    else if (event._sendskill) {
                        event.result._sendskill = event._sendskill;
                    }
                    if (event.dialog && typeof event.dialog == 'object')
                        event.dialog.close();
                    if (!_status.noclearcountdown) {
                        game.stopCountChoose();
                    }
                    "step 5";
                    if (event._result && event.result) {
                        event.result.result = event._result;
                    }
                },
                /**
                 * 选择以响应(牌|技能)
                 * @name content.chooseToUse
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                chooseToRespond: function () {
                    "step 0";
                    if (event.responded) {
                        delete event.dialog;
                        return;
                    }
                    var skills = player.getSkills(true);
                    game.expandSkills(skills);
                    for (var i = 0; i < skills.length; i++) {
                        var info = lib.skill[skills[i]];
                        if (info && info.onChooseToRespond) {
                            info.onChooseToRespond(event);
                        }
                    }
                    _status.noclearcountdown = true;
                    if (!_status.connectMode && lib.config.skip_shan && event.autochoose && event.autochoose()) {
                        event.result = { bool: false };
                    }
                    else {
                        if (game.modeSwapPlayer && !_status.auto && player.isUnderControl()) {
                            game.modeSwapPlayer(player);
                        }
                        if (event.isMine()) {
                            if (event.hsskill && !event.forced && _status.prehidden_skills.contains(event.hsskill)) {
                                ui.click.cancel();
                                return;
                            }
                            var ok = game.check();
                            if (!ok) {
                                game.pause();
                                if (event.openskilldialog) {
                                    event.skillDialog = ui.create.dialog(event.openskilldialog);
                                    delete event.openskilldialog;
                                    event.dialog = event.prompt;
                                }
                                else {
                                    if (event.prompt)
                                        event.dialog = ui.create.dialog(event.prompt);
                                    if (event.prompt2)
                                        event.dialog.addText(event.prompt2);
                                }
                            }
                        }
                        else if (event.isOnline()) {
                            event.send();
                        }
                        else {
                            event.result = 'ai';
                        }
                    }
                    "step 1";
                    if (event.result == 'ai') {
                        var ok = game.check();
                        if (ok) {
                            ui.click.ok();
                        }
                        else if (ai.basic.chooseCard(event.ai)) {
                            ui.click.ok();
                            event._aiexcludeclear = true;
                        }
                        else if (event.skill && !event.norestore) {
                            var skill = event.skill;
                            ui.click.cancel();
                            event._aiexclude.add(skill);
                            var info = get.info(skill);
                            if (info.sourceSkill) {
                                event._aiexclude.add(info.sourceSkill);
                            }
                            event.redo();
                            game.resume();
                        }
                        else {
                            ui.click.cancel();
                        }
                        if (event.aidelay && event.result && event.result.bool) {
                            game.delayx();
                        }
                    }
                    "step 2";
                    event.resume();
                    if (event.result) {
                        if (event.result.skill) {
                            var info = get.info(event.result.skill);
                            if (info && info.chooseButton) {
                                if (event.dialog && typeof event.dialog == 'object')
                                    event.dialog.close();
                                var dialog = info.chooseButton.dialog(event, player);
                                if (info.chooseButton.chooseControl) {
                                    var next = player.chooseControl(info.chooseButton.chooseControl(event, player));
                                    next.dialog = dialog;
                                    next.set('ai', info.chooseButton.check || function () { return 0; });
                                }
                                else {
                                    var next = player.chooseButton(dialog);
                                    next.set('ai', info.chooseButton.check || function () { return 1; });
                                    next.set('filterButton', info.chooseButton.filter || function () { return true; });
                                    next.set('selectButton', info.chooseButton.select || 1);
                                }
                                event.buttoned = event.result.skill;
                            }
                            else if (info && info.precontent && !game.online) {
                                var next = game.createEvent('pre_' + event.result.skill);
                                next.setContent(info.precontent);
                                next.set('result', event.result);
                                next.set('player', player);
                            }
                        }
                    }
                    "step 3";
                    if (event.buttoned) {
                        if (result.bool || result.control && result.control != 'cancel2') {
                            var info = get.info(event.buttoned).chooseButton;
                            lib.skill[event.buttoned + '_backup'] = info.backup(info.chooseControl ? result : result.links, player);
                            lib.skill[event.buttoned + '_backup'].sourceSkill = event.buttoned;
                            if (game.online) {
                                event._sendskill = [event.buttoned + '_backup', lib.skill[event.buttoned + '_backup']];
                            }
                            event.backup(event.buttoned + '_backup');
                            if (info.prompt) {
                                event.openskilldialog = info.prompt(info.chooseControl ? result : result.links, player);
                            }
                        }
                        else {
                            ui.control.animate('nozoom', 100);
                            event._aiexclude.add(event.buttoned);
                        }
                        event.goto(0);
                        delete event.buttoned;
                    }
                    "step 4";
                    delete _status.noclearcountdown;
                    if (event.skillDialog && get.objtype(event.skillDialog) == 'div') {
                        event.skillDialog.close();
                    }
                    if (event.result.bool && !game.online) {
                        if (event.result._sendskill) {
                            lib.skill[event.result._sendskill[0]] = event.result._sendskill[1];
                        }
                        var info = get.info(event.result.skill);
                        if (event.onresult) {
                            event.onresult(event.result);
                        }
                        if (event.result.skill) {
                            if (info.direct && !info.clearTime) {
                                _status.noclearcountdown = true;
                            }
                        }
                        if (event.logSkill) {
                            if (typeof event.logSkill == 'string') {
                                player.logSkill(event.logSkill);
                            }
                            else if (Array.isArray(event.logSkill)) {
                                player.logSkill.apply(player, event.logSkill);
                            }
                        }
                        if (!event.result.card && event.result.skill) {
                            event.result.used = event.result.skill;
                            player.useSkill(event.result.skill, event.result.cards, event.result.targets);
                        }
                        else {
                            if (info && info.prerespond) {
                                info.prerespond(event.result, player);
                            }
                            var next = player.respond(event.result.cards, event.result.card, event.animate, event.result.skill, event.source);
                            if (event.result.noanimate)
                                next.animate = false;
                            if (event.parent.card && event.parent.type == 'card') {
                                next.set('respondTo', [event.parent.player, event.parent.card]);
                            }
                            if (event.noOrdering)
                                next.noOrdering = true;
                        }
                    }
                    else if (event._sendskill) {
                        event.result._sendskill = event._sendskill;
                    }
                    if (event.dialog && event.dialog.close)
                        event.dialog.close();
                    if (!_status.noclearcountdown) {
                        game.stopCountChoose();
                    }
                },
                /**
                 * 选择以弃置牌
                 * @name content.chooseToDiscard
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                chooseToDiscard: function () {
                    "step 0";
                    if (event.autochoose()) {
                        event.result = {
                            bool: true,
                            autochoose: true,
                            cards: player.getCards(event.position),
                            rawcards: player.getCards(event.position)
                        };
                        for (var i = 0; i < event.result.cards.length; i++) {
                            if (!lib.filter.cardDiscardable(event.result.cards[i], player, event)) {
                                event.result.cards.splice(i--, 1);
                            }
                        }
                    }
                    else {
                        // &&!lib.filter.wuxieSwap(trigger)
                        if (game.modeSwapPlayer && !_status.auto && player.isUnderControl()) {
                            game.modeSwapPlayer(player);
                        }
                        event.rangecards = player.getCards(event.position);
                        for (var i = 0; i < event.rangecards.length; i++) {
                            if (lib.filter.cardDiscardable(event.rangecards[i], player, event)) {
                                event.rangecards.splice(i--, 1);
                            }
                            else {
                                event.rangecards[i].uncheck('chooseToDiscard');
                            }
                        }
                        var range = get.select(event.selectCard);
                        game.check();
                        if (event.isMine()) {
                            if (event.hsskill && !event.forced && _status.prehidden_skills.contains(event.hsskill)) {
                                ui.click.cancel();
                                return;
                            }
                            game.pause();
                            if (range[1] > 1 && typeof event.selectCard != 'function') {
                                event.promptdiscard = ui.create.control('提示', function () {
                                    ai.basic.chooseCard(event.ai);
                                    if (_status.event.custom.add.card) {
                                        _status.event.custom.add.card();
                                    }
                                    for (var i = 0; i < ui.selected.cards.length; i++) {
                                        ui.selected.cards[i].updateTransform(true);
                                    }
                                });
                            }
                            if (Array.isArray(event.dialog)) {
                                event.dialog = ui.create.dialog.apply(this, event.dialog);
                                event.dialog.open();
                                event.dialog.classList.add('noselect');
                            }
                            else if (event.prompt != false) {
                                var str;
                                if (typeof (event.prompt) == 'string')
                                    str = event.prompt;
                                else {
                                    str = '请弃置';
                                    if (range[0] == range[1])
                                        str += get.cnNumber(range[0]);
                                    else if (range[1] == Infinity)
                                        str += '至少' + get.cnNumber(range[0]);
                                    else
                                        str += get.cnNumber(range[0]) + '至' + get.cnNumber(range[1]);
                                    str += '张';
                                    if (event.position == 'h' || event.position == undefined)
                                        str += '手';
                                    if (event.position == 'e')
                                        str += '装备';
                                    str += '牌';
                                }
                                event.dialog = ui.create.dialog(str);
                                if (event.prompt2) {
                                    event.dialog.addText(event.prompt2, event.prompt2.length <= 20);
                                }
                                if (Array.isArray(event.selectCard)) {
                                    event.promptbar = event.dialog.add('0/' + get.numStr(event.selectCard[1], 'card'));
                                    event.custom.add.card = function () {
                                        _status.event.promptbar.innerHTML =
                                            ui.selected.cards.length + '/' + get.numStr(_status.event.selectCard[1], 'card');
                                    };
                                }
                            }
                            else if (get.itemtype(event.dialog) == 'dialog') {
                                event.dialog.style.display = '';
                                event.dialog.open();
                            }
                        }
                        else if (event.isOnline()) {
                            event.send();
                        }
                        else {
                            event.result = 'ai';
                        }
                    }
                    "step 1";
                    if (event.result == 'ai') {
                        game.check();
                        if (ai.basic.chooseCard(event.ai) || forced) {
                            ui.click.ok();
                        }
                        else if (event.skill) {
                            var skill = event.skill;
                            ui.click.cancel();
                            event._aiexclude.add(skill);
                            event.redo();
                            game.resume();
                        }
                        else {
                            ui.click.cancel();
                        }
                    }
                    if (event.rangecards) {
                        for (var i = 0; i < event.rangecards.length; i++) {
                            event.rangecards[i].recheck('chooseToDiscard');
                        }
                    }
                    "step 2";
                    event.resume();
                    if (event.promptdiscard) {
                        event.promptdiscard.close();
                    }
                    "step 3";
                    if (event.result.bool && event.result.cards && event.result.cards.length &&
                        !game.online && event.autodelay && !event.isMine()) {
                        if (typeof event.autodelay == 'number') {
                            game.delayx(event.autodelay);
                        }
                        else {
                            game.delayx();
                        }
                    }
                    "step 4";
                    if (event.logSkill && event.result.bool && !game.online) {
                        if (typeof event.logSkill == 'string') {
                            player.logSkill(event.logSkill);
                        }
                        else if (Array.isArray(event.logSkill)) {
                            player.logSkill.apply(player, event.logSkill);
                        }
                    }
                    if (!game.online) {
                        if (typeof event.delay == 'boolean') {
                            event.done = player.discard(event.result.cards).set('delay', event.delay);
                        }
                        else {
                            event.done = player.discard(event.result.cards);
                        }
                    }
                    if (event.dialog && event.dialog.close)
                        event.dialog.close();
                },
                /**
                 * 拼点失败
                 * @name content.chooseToCompareLose
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                chooseToCompareLose: function () {
                    for (var i = 0; i < event.lose_list.length; i++) {
                        var next = event.lose_list[i][0].lose(event.lose_list[i][1], ui.ordering);
                        next.relatedEvent = event.getParent();
                        next.getlx = false;
                    }
                },
                /**
                 * 多人拼点
                 * @name content.chooseToCompareMultiple
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                chooseToCompareMultiple: function () {
                    "step 0";
                    if (player.countCards('h') == 0) {
                        event.result = { cancelled: true, bool: false };
                        event.finish();
                        return;
                    }
                    for (var i = 0; i < targets.length; i++) {
                        if (targets[i].countCards('h') == 0) {
                            event.result = { cancelled: true, bool: false };
                            event.finish();
                            return;
                        }
                    }
                    if (!event.multitarget) {
                        targets.sort(lib.sort.seat);
                    }
                    game.log(player, '对', targets, '发起拼点');
                    "step 1";
                    event._result = [];
                    event.list = targets.filter(function (current) {
                        return !event.fixedResult || !event.fixedResult[current.playerid];
                    });
                    if (event.list.length || !event.fixedResult || !event.fixedResult[player.playerid]) {
                        if (!event.fixedResult || !event.fixedResult[player.playerid])
                            event.list.unshift(player);
                        player.chooseCardOL(event.list, '请选择拼点牌', true).set('type', 'compare').set('ai', event.ai).set('source', player).aiCard = function (target) {
                            var hs = target.getCards('h');
                            var event = _status.event;
                            event.player = target;
                            hs.sort(function (a, b) {
                                return event.ai(b) - event.ai(a);
                            });
                            delete event.player;
                            return { bool: true, cards: [hs[0]] };
                        };
                    }
                    "step 2";
                    var cards = [];
                    var lose_list = [];
                    if (event.fixedResult && event.fixedResult[player.playerid]) {
                        event.list.unshift(player);
                        result.unshift({ bool: true, cards: [event.fixedResult[player.playerid]] });
                        lose_list.push([player, [event.fixedResult[player.playerid]]]);
                    }
                    else {
                        if (result[0].skill && lib.skill[result[0].skill] && lib.skill[result[0].skill].onCompare) {
                            player.logSkill(result[0].skill);
                            result[0].cards = lib.skill[result[0].skill].onCompare(player);
                        }
                        else
                            lose_list.push([player, result[0].cards]);
                    }
                    ;
                    for (var j = 0; j < targets.length; j++) {
                        if (event.list.contains(targets[j])) {
                            var i = event.list.indexOf(targets[j]);
                            if (result[i].skill && lib.skill[result[i].skill] && lib.skill[result[i].skill].onCompare) {
                                event.list[i].logSkill(result[i].skill);
                                result[i].cards = lib.skill[result[i].skill].onCompare(event.list[i]);
                            }
                            else
                                lose_list.push([targets[j], result[i].cards]);
                            cards.push(result[i].cards[0]);
                        }
                        else if (event.fixedResult && event.fixedResult[targets[j].playerid]) {
                            cards.push(event.fixedResult[targets[j].playerid]);
                            lose_list.push([targets[j], [event.fixedResult[targets[j].playerid]]]);
                        }
                    }
                    if (lose_list.length) {
                        game.loseAsync({
                            lose_list: lose_list
                        }).setContent('chooseToCompareLose');
                    }
                    event.cardlist = cards;
                    event.cards = cards;
                    event.card1 = result[0].cards[0];
                    event.num1 = event.card1.number;
                    event.iwhile = 0;
                    event.result = {
                        player: event.card1,
                        targets: event.cardlist.slice(0),
                        num1: [],
                        num2: []
                    };
                    game.log(player, '的拼点牌为', event.card1);
                    "step 3";
                    if (event.iwhile < targets.length) {
                        event.target = targets[event.iwhile];
                        event.target.animate('target');
                        player.animate('target');
                        event.card2 = event.cardlist[event.iwhile];
                        event.num2 = event.card2.number;
                        game.log(event.target, '的拼点牌为', event.card2);
                        player.line(event.target);
                        player.$compare(event.card1, event.target, event.card2);
                        event.trigger('compare');
                        game.delay(0, 1500);
                    }
                    else {
                        event.goto(7);
                    }
                    "step 4";
                    event.result.num1[event.iwhile] = event.num1;
                    event.result.num2[event.iwhile] = event.num2;
                    var str;
                    if (event.num1 > event.num2) {
                        event.result.winner = player;
                        event.result.loser = target;
                        str = get.translation(player) + '拼点成功';
                        player.popup('胜');
                        target.popup('负');
                    }
                    else {
                        str = get.translation(player) + '拼点失败';
                        if (event.num1 == event.num2) {
                            event.result.tie = true;
                            player.popup('平');
                            target.popup('平');
                        }
                        else {
                            event.result.winner = target;
                            event.result.loser = player;
                            player.popup('负');
                            target.popup('胜');
                        }
                    }
                    game.broadcastAll(function (str) {
                        var dialog = ui.create.dialog(str);
                        dialog.classList.add('center');
                        setTimeout(function () {
                            dialog.close();
                        }, 1000);
                    }, str);
                    game.delay(2);
                    "step 5";
                    if (event.callback) {
                        game.broadcastAll(function (card1, card2) {
                            if (card1.clone)
                                card1.clone.style.opacity = 0.5;
                            if (card2.clone)
                                card2.clone.style.opacity = 0.5;
                        }, event.card1, event.card2);
                        var next = game.createEvent('compareMultiple');
                        next.player = player;
                        next.target = event.target;
                        next.card1 = event.card1;
                        next.card2 = event.card2;
                        next.num1 = event.num1;
                        next.num2 = event.num2;
                        next.winner = event.result.winner;
                        next.setContent(event.callback);
                    }
                    "step 6";
                    game.broadcastAll(ui.clear);
                    event.iwhile++;
                    event.goto(3);
                    "step 7";
                    event.cards.add(event.card1);
                },
                /**
                 * 两人拼点
                 * @name content.chooseToCompare
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                chooseToCompare: function () {
                    "step 0";
                    if (player.countCards('h') == 0 || target.countCards('h') == 0) {
                        event.result = { cancelled: true, bool: false };
                        event.finish();
                        return;
                    }
                    game.log(player, '对', target, '发起拼点');
                    event.lose_list = [];
                    "step 1";
                    var sendback = function () {
                        if (_status.event != event) {
                            return function () {
                                event.resultOL = _status.event.resultOL;
                            };
                        }
                    };
                    if (event.fixedResult && event.fixedResult[player.playerid]) {
                        event.card1 = event.fixedResult[player.playerid];
                        event.lose_list.push([player, event.card1]);
                    }
                    else if (player.isOnline()) {
                        player.wait(sendback);
                        event.ol = true;
                        player.send(function (ai) {
                            game.me.chooseCard('请选择拼点牌', true).set('type', 'compare').set('glow_result', true).ai = ai;
                            game.resume();
                        }, event.ai);
                    }
                    else {
                        event.localPlayer = true;
                        player.chooseCard('请选择拼点牌', true).set('type', 'compare').set('glow_result', true).ai = event.ai;
                    }
                    if (event.fixedResult && event.fixedResult[target.playerid]) {
                        event.card2 = event.fixedResult[target.playerid];
                        event.lose_list.push([target, event.card2]);
                    }
                    else if (target.isOnline()) {
                        target.wait(sendback);
                        event.ol = true;
                        target.send(function (ai) {
                            game.me.chooseCard('请选择拼点牌', true).set('type', 'compare').set('glow_result', true).ai = ai;
                            game.resume();
                        }, event.ai);
                    }
                    else {
                        event.localTarget = true;
                    }
                    "step 2";
                    if (event.localPlayer) {
                        if (result.skill && lib.skill[result.skill] && lib.skill[result.skill].onCompare) {
                            result.cards = lib.skill[result.skill].onCompare(player);
                            player.logSkill(result.skill);
                        }
                        else
                            event.lose_list.push([player, result.cards[0]]);
                        event.card1 = result.cards[0];
                    }
                    if (event.localTarget) {
                        target.chooseCard('请选择拼点牌', true).set('type', 'compare').set('glow_result', true).ai = event.ai;
                    }
                    "step 3";
                    if (event.localTarget) {
                        if (result.skill && lib.skill[result.skill] && lib.skill[result.skill].onCompare) {
                            target.logSkill(result.skill);
                            result.cards = lib.skill[result.skill].onCompare(target);
                        }
                        else
                            event.lose_list.push([target, result.cards[0]]);
                        event.card2 = result.cards[0];
                    }
                    if (!event.resultOL && event.ol) {
                        game.pause();
                    }
                    "step 4";
                    try {
                        if (!event.card1) {
                            if (event.resultOL[player.playerid].skill && lib.skill[event.resultOL[player.playerid].skill] && lib.skill[event.resultOL[player.playerid].skill].onCompare) {
                                player.logSkill(event.resultOL[player.playerid].skill);
                                event.resultOL[player.playerid].cards = lib.skill[event.resultOL[player.playerid].skill].onCompare(player);
                            }
                            else
                                event.lose_list.push([player, event.resultOL[player.playerid].cards[0]]);
                            event.card1 = event.resultOL[player.playerid].cards[0];
                        }
                        ;
                        if (!event.card2) {
                            if (event.resultOL[target.playerid].skill && lib.skill[event.resultOL[target.playerid].skill] && lib.skill[event.resultOL[target.playerid].skill].onCompare) {
                                target.logSkill(event.resultOL[target.playerid].skill);
                                event.resultOL[target.playerid].cards = lib.skill[event.resultOL[target.playerid].skill].onCompare(player);
                            }
                            else
                                event.lose_list.push([target, event.resultOL[target.playerid].cards[0]]);
                            event.card2 = event.resultOL[target.playerid].cards[0];
                        }
                        if (!event.card1 || !event.card2) {
                            throw ('err');
                        }
                    }
                    catch (e) {
                        console.log(e);
                        game.print(e);
                        event.finish();
                        return;
                    }
                    if (event.card2.number >= 10 || event.card2.number <= 4) {
                        if (target.countCards('h') > 2) {
                            event.addToAI = true;
                        }
                    }
                    if (event.lose_list.length) {
                        game.loseAsync({
                            lose_list: event.lose_list
                        }).setContent('chooseToCompareLose');
                    }
                    "step 5";
                    game.broadcast(function () {
                        ui.arena.classList.add('thrownhighlight');
                    });
                    ui.arena.classList.add('thrownhighlight');
                    game.addVideo('thrownhighlight1');
                    player.$compare(event.card1, target, event.card2);
                    game.log(player, '的拼点牌为', event.card1);
                    game.log(target, '的拼点牌为', event.card2);
                    event.num1 = event.card1.number;
                    event.num2 = event.card2.number;
                    event.trigger('compare');
                    game.delay(0, 1500);
                    "step 6";
                    event.result = {
                        player: event.card1,
                        target: event.card2,
                        num1: event.num1,
                        num2: event.num2
                    };
                    var str;
                    if (event.num1 > event.num2) {
                        event.result.bool = true;
                        event.result.winner = player;
                        event.result.loser = target;
                        str = get.translation(player) + '拼点成功';
                        player.popup('胜');
                        target.popup('负');
                    }
                    else {
                        event.result.bool = false;
                        str = get.translation(player) + '拼点失败';
                        if (event.num1 == event.num2) {
                            event.result.tie = true;
                            player.popup('平');
                            target.popup('平');
                        }
                        else {
                            event.result.winner = target;
                            event.result.loser = player;
                            player.popup('负');
                            target.popup('胜');
                        }
                    }
                    game.broadcastAll(function (str) {
                        var dialog = ui.create.dialog(str);
                        dialog.classList.add('center');
                        setTimeout(function () {
                            dialog.close();
                        }, 1000);
                    }, str);
                    game.delay(2);
                    "step 7";
                    if (typeof event.target.ai.shown == 'number' && event.target.ai.shown <= 0.85 && event.addToAI) {
                        event.target.ai.shown += 0.1;
                    }
                    game.broadcastAll(function () {
                        ui.arena.classList.remove('thrownhighlight');
                    });
                    game.addVideo('thrownhighlight2');
                    if (event.clear !== false) {
                        game.broadcastAll(ui.clear);
                    }
                    if (typeof event.preserve == 'function') {
                        event.preserve = event.preserve(event.result);
                    }
                    else if (event.preserve == 'win') {
                        event.preserve = event.result.bool;
                    }
                    else if (event.preserve == 'lose') {
                        event.preserve = !event.result.bool;
                    }
                },
                /**
                 * 选择以获得一项技能
                 * @name content.discoverSkill
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                discoverSkill: function () {
                    'step 0';
                    var num = event.num || 3;
                    var choice;
                    if (typeof event.list == 'string' || typeof event.list == 'function') {
                        choice = get.gainableSkills(event.list).randomGets(num);
                    }
                    else if (Array.isArray(event.list)) {
                        choice = event.list.randomGets(num);
                    }
                    else {
                        choice = Array.from(event.list).randomGets(num);
                    }
                    if (!choice.length) {
                        event.finish();
                        event.result = { bool: false };
                        return;
                    }
                    event.skillai = event.ai || function (list) {
                        return get.max(list, get.skillRank, 'item');
                    };
                    if (_status.connectMode) {
                        if (choice.length == 1)
                            event._result = { control: list[0] };
                        else
                            player.chooseControl(choice).set('prompt', '选择获得一个技能').set('forceDie', true).set('ai', function () {
                                return event.skillai(choice);
                            });
                    }
                    else if (event.isMine()) {
                        game.check();
                        game.pause();
                        event.dialog = ui.create.dialog('forcebutton');
                        event.dialog.add(event.prompt || '选择获得一项技能');
                        var clickItem = function () {
                            _status.event._result = this.link;
                            game.resume();
                        };
                        for (i = 0; i < choice.length; i++) {
                            if (lib.translate[choice[i] + '_info']) {
                                var translation = get.translation(choice[i]);
                                if (translation[0] == '新' && translation.length == 3) {
                                    translation = translation.slice(1, 3);
                                }
                                else {
                                    translation = translation.slice(0, 2);
                                }
                                var item = event.dialog.add('<div class="popup pointerdiv" style="width:80%;display:inline-block"><div class="skill">' +
                                    translation + '</div><div>' + lib.translate[choice[i] + '_info'] + '</div></div>');
                                item.firstChild.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', clickItem);
                                item.firstChild.link = choice[i];
                            }
                        }
                        event.dialog.add(ui.create.div('.placeholder'));
                        event.switchToAuto = function () {
                            event._result = event.skillai(event.choice);
                            game.resume();
                        };
                        if (event.isMine() || event.dialogdisplay) {
                            event.dialog.style.display = '';
                            event.dialog.open();
                        }
                        game.countChoose();
                        event.choosing = true;
                    }
                    else if (event.isOnline()) {
                        event.send();
                    }
                    else {
                        event._result = event.skillai(choice);
                    }
                    'step 1';
                    if (_status.connectMode) {
                        event.result = { bool: true, skill: result.control };
                    }
                    else {
                        if (event.dialog) {
                            event.dialog.close();
                        }
                        event.choosing = false;
                        event.result = { bool: true, skill: result };
                    }
                },
                /**
                 * 选择以获得一项技能
                 * @name content.chooseSkill
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                chooseSkill: function () {
                    'step 0';
                    var list;
                    if (typeof event.target == 'string') {
                        list = get.gainableSkillsName(event.target, event.func);
                    }
                    else {
                        list = event.target.getGainableSkills(event.func);
                    }
                    if (!list.length) {
                        event.finish();
                        event.result = { bool: false };
                        return;
                    }
                    event.skillai = function (list) {
                        return get.max(list, get.skillRank, 'item');
                    };
                    if (event.isMine()) {
                        var dialog = ui.create.dialog('forcebutton');
                        dialog.add(event.prompt || '选择获得一项技能');
                        _status.event.list = list;
                        var clickItem = function () {
                            _status.event._result = this.link;
                            game.resume();
                        };
                        for (i = 0; i < list.length; i++) {
                            if (lib.translate[list[i] + '_info']) {
                                var translation = get.translation(list[i]);
                                if (translation[0] == '新' && translation.length == 3) {
                                    translation = translation.slice(1, 3);
                                }
                                else {
                                    translation = translation.slice(0, 2);
                                }
                                var item = dialog.add('<div class="popup pointerdiv" style="width:80%;display:inline-block"><div class="skill">' +
                                    translation + '</div><div>' + lib.translate[list[i] + '_info'] + '</div></div>');
                                item.firstChild.addEventListener('click', clickItem);
                                item.firstChild.link = list[i];
                            }
                        }
                        dialog.add(ui.create.div('.placeholder'));
                        event.dialog = dialog;
                        event.switchToAuto = function () {
                            event._result = event.skillai(event.list);
                            game.resume();
                        };
                        _status.imchoosing = true;
                        game.pause();
                    }
                    else {
                        event._result = event.skillai(list);
                    }
                    'step 1';
                    _status.imchoosing = false;
                    if (event.dialog) {
                        event.dialog.close();
                    }
                    event.result = { bool: true, skill: result };
                },
                /**
                 * 选择以(获得|使用)牌
                 * @name content.chooseSkill
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                discoverCard: function () {
                    'step 0';
                    var num = event.num || 3;
                    var choice;
                    if (typeof event.list == 'string' || typeof event.list == 'function') {
                        choice = get.inpile(event.list).randomGets(num);
                    }
                    else if (Array.isArray(event.list)) {
                        choice = event.list.randomGets(num);
                    }
                    else {
                        choice = Array.from(event.list).randomGets(num);
                    }
                    if (choice.length) {
                        var prompt = event.prompt;
                        if (!prompt) {
                            prompt = '选择一张牌';
                            if (event.use) {
                                prompt += '使用之';
                            }
                            else if (!event.nogain) {
                                prompt += '获得之';
                            }
                        }
                        if (typeof choice[0] === 'string') {
                            var next = player.chooseVCardButton(choice, prompt, event.forced);
                            if (event.ai) {
                                next.set('ai', event.ai);
                            }
                        }
                        else if (get.itemtype(choice[0]) == 'card') {
                            var next = player.chooseCardButton(choice, prompt, event.forced);
                            if (event.ai) {
                                next.set('ai', event.ai);
                            }
                        }
                        else {
                            event.finish();
                        }
                    }
                    else {
                        event.finish();
                    }
                    'step 1';
                    event.result = {
                        bool: result.bool,
                        card: null,
                        choice: null
                    };
                    if (result.bool && result.links.length) {
                        var link = result.links[0];
                        var togain = null;
                        if (get.itemtype(link) == 'card') {
                            event.result.card = link;
                            togain = link;
                        }
                        else if (Array.isArray(link)) {
                            event.result.choice = link[2];
                            togain = game.createCard(link[2]);
                        }
                        if (togain) {
                            if (event.use) {
                                player.chooseUseTarget(togain);
                            }
                            else if (!event.nogain) {
                                player.gain(togain, 'draw');
                                game.log(player, '获得了一张牌');
                            }
                        }
                    }
                },
                /**
                 * 选择项(按钮)
                 * @name content.chooseButton
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                chooseButton: function () {
                    "step 0";
                    if (typeof event.dialog == 'number') {
                        event.dialog = get.idDialog(event.dialog);
                    }
                    if (event.createDialog && !event.dialog) {
                        if (Array.isArray(event.createDialog)) {
                            event.createDialog.add('hidden');
                            event.dialog = ui.create.dialog.apply(this, event.createDialog);
                        }
                        event.closeDialog = true;
                    }
                    if (event.dialog == undefined)
                        event.dialog = ui.dialog;
                    if (event.isMine() || event.dialogdisplay) {
                        event.dialog.style.display = '';
                        event.dialog.open();
                    }
                    game.check();
                    if (event.isMine()) {
                        if (event.hsskill && !event.forced && _status.prehidden_skills.contains(event.hsskill)) {
                            ui.click.cancel();
                            return;
                        }
                        game.pause();
                    }
                    else if (event.isOnline()) {
                        event.send();
                        delete event.callback;
                    }
                    else {
                        event.result = 'ai';
                    }
                    if (event.onfree) {
                        lib.init.onfree();
                    }
                    "step 1";
                    if (event.result == 'ai') {
                        if (event.processAI) {
                            event.result = event.processAI();
                        }
                        else {
                            game.check();
                            if (ai.basic.chooseButton(event.ai) || forced)
                                ui.click.ok();
                            else
                                ui.click.cancel();
                        }
                    }
                    if (event.closeDialog) {
                        event.dialog.close();
                    }
                    if (event.callback) {
                        event.callback(event.player, event.result);
                    }
                    event.resume();
                },
                /**
                 * 多人选择牌
                 * @name content.chooseCardOL
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                chooseCardOL: function () {
                    'step 0';
                    event.targets = event.list.slice(0);
                    if (!_status.connectMode) {
                        event.result = [];
                        event.goto(7);
                    }
                    else {
                        for (var i = 0; i < event.list.length; i++) {
                            var target = event.list[i];
                            target.wait();
                            if (target.isOnline()) {
                                target.send(function (args, set) {
                                    game.me.chooseCard.apply(game.me, args).set(set);
                                    game.resume();
                                }, event._args, event._set);
                                event.list.splice(i--, 1);
                            }
                            else if (target == game.me) {
                                event.withme = true;
                                event.list.splice(i--, 1);
                            }
                        }
                    }
                    'step 1';
                    if (event.list.length) {
                        event.target = event.list.shift();
                        event.target.chooseCard.apply(event.target, event._args).set(event._set);
                    }
                    else {
                        event.goto(3);
                    }
                    'step 2';
                    event.target.unwait(result);
                    event.goto(1);
                    'step 3';
                    if (event.withme) {
                        game.me.chooseCard.apply(game.me, event._args).set(event._set);
                    }
                    else {
                        event.goto(5);
                    }
                    'step 4';
                    game.me.unwait(result);
                    'step 5';
                    if (!event.resultOL) {
                        game.pause();
                    }
                    'step 6';
                    event.result = [];
                    for (var i = 0; i < event.targets.length; i++) {
                        event.result[i] = event.resultOL[event.targets[i].playerid] || {};
                        if (event.result[i] == 'ai' && event.aiCard) {
                            event.result[i] = event.aiCard(event.targets[i]);
                        }
                    }
                    event.finish();
                    'step 7';
                    if (event.list.length) {
                        event.target = event.list.shift();
                        event.target.chooseCard.apply(event.target, event._args).set(event._set);
                    }
                    else {
                        for (var i = 0; i < event.targets.length; i++) {
                            if (!event.result[i]) {
                                event.result[i] = {};
                            }
                        }
                        event.finish();
                    }
                    'step 8';
                    event.result[event.targets.indexOf(event.target)] = result;
                    event.goto(7);
                },
                /**
                 * 多人选择项(按钮)
                 * @name content.chooseButtonOL
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                chooseButtonOL: function () {
                    'step 0';
                    ui.arena.classList.add('markhidden');
                    for (var i = 0; i < event.list.length; i++) {
                        var current = event.list[i];
                        current[0].wait();
                        if (current[0].isOnline()) {
                            var target = current.shift();
                            target.send(function (args, callback, switchToAuto, processAI) {
                                ui.arena.classList.add('markhidden');
                                var next = game.me.chooseButton.apply(game.me, args);
                                next.callback = callback;
                                next.switchToAuto = switchToAuto;
                                next.processAI = processAI;
                                next.complexSelect = true;
                                game.resume();
                            }, current, event.callback, event.switchToAuto, event.processAI);
                            target._choose_button_ol = current;
                            event.list.splice(i--, 1);
                        }
                        else if (current[0] == game.me) {
                            event.last = current;
                            event.last.shift();
                            event.list.splice(i--, 1);
                        }
                    }
                    'step 1';
                    if (event.list.length) {
                        var current = event.list.shift();
                        if (current.length)
                            event.target = current.shift();
                        else {
                            event.target = current;
                            current = null;
                        }
                        var next = event.target.chooseButton.apply(event.target, current);
                        next.callback = event.callback;
                        next.switchToAuto = event.switchToAuto;
                        next.processAI = event.processAI;
                    }
                    else {
                        event.goto(3);
                    }
                    'step 2';
                    event.target.unwait(result);
                    event.goto(1);
                    'step 3';
                    if (event.last) {
                        var next = game.me.chooseButton.apply(game.me, event.last);
                        next.callback = event.callback;
                        next.switchToAuto = event.switchToAuto;
                        next.processAI = event.processAI;
                    }
                    else {
                        event.goto(5);
                    }
                    'step 4';
                    game.me.unwait(result);
                    'step 5';
                    if (!event.resultOL) {
                        game.pause();
                    }
                    'step 6';
                    game.broadcastAll(function () {
                        ui.arena.classList.remove('markhidden');
                    });
                    event.result = event.resultOL;
                },
                /**
                 * 选择牌
                 * @name content.chooseCard
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                chooseCard: function () {
                    "step 0";
                    if (event.directresult) {
                        event.result = {
                            buttons: [],
                            cards: event.directresult.slice(0),
                            targets: [],
                            confirm: 'ok',
                            bool: true,
                            links: []
                        };
                    }
                    else {
                        game.check();
                        if (event.isMine()) {
                            game.pause();
                            if (event.hsskill && !event.forced && _status.prehidden_skills.contains(event.hsskill)) {
                                ui.click.cancel();
                                return;
                            }
                            if (event.prompt != false) {
                                var str;
                                if (typeof event.prompt == 'string')
                                    str = event.prompt;
                                else {
                                    str = '请选择';
                                    var range = get.select(event.selectCard);
                                    if (range[0] == range[1])
                                        str += get.cnNumber(range[0]);
                                    else if (range[1] == Infinity)
                                        str += '至少' + get.cnNumber(range[0]);
                                    else
                                        str += get.cnNumber(range[0]) + '至' + get.cnNumber(range[1]);
                                    str += '张';
                                    if (event.position == 'h' || event.position == undefined)
                                        str += '手';
                                    if (event.position == 'e')
                                        str += '装备';
                                    str += '牌';
                                }
                                event.dialog = ui.create.dialog(str);
                                if (event.prompt2) {
                                    event.dialog.addText(event.prompt2, event.prompt2.length <= 20);
                                }
                                if (Array.isArray(event.promptx)) {
                                    for (var i = 0; i < event.promptx.length; i++) {
                                        event.dialog.add(event.promptx[i]);
                                    }
                                }
                                if (Array.isArray(event.selectCard)) {
                                    event.promptbar = event.dialog.add('0/' + get.numStr(event.selectCard[1], 'card'));
                                    event.custom.add.card = function () {
                                        _status.event.promptbar.innerHTML =
                                            ui.selected.cards.length + '/' + get.numStr(_status.event.selectCard[1], 'card');
                                    };
                                }
                            }
                        }
                        else if (event.isOnline()) {
                            event.send();
                        }
                        else {
                            event.result = 'ai';
                        }
                    }
                    "step 1";
                    if (event.result == 'ai') {
                        game.check();
                        if (ai.basic.chooseCard(event.ai) || forced) {
                            ui.click.ok();
                        }
                        else if (event.skill) {
                            var skill = event.skill;
                            ui.click.cancel();
                            event._aiexclude.add(skill);
                            event.redo();
                            game.resume();
                        }
                        else {
                            ui.click.cancel();
                        }
                    }
                    "step 2";
                    event.resume();
                    if (event.glow_result && event.result.cards && !event.directresult) {
                        for (var i = 0; i < event.result.cards.length; i++) {
                            event.result.cards[i].classList.add('glow');
                        }
                    }
                    if (event.dialog)
                        event.dialog.close();
                },
                /**
                 * 选择角色对象
                 * @name content.chooseTarget
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                chooseTarget: function () {
                    "step 0";
                    if (event.isMine()) {
                        if (event.hsskill && !event.forced && _status.prehidden_skills.contains(event.hsskill)) {
                            ui.click.cancel();
                            return;
                        }
                        game.check();
                        game.pause();
                        if (event.createDialog && !event.dialog && Array.isArray(event.createDialog)) {
                            event.dialog = ui.create.dialog.apply(this, event.createDialog);
                        }
                        else if (event.prompt != false) {
                            var str;
                            if (typeof event.prompt == 'string')
                                str = event.prompt;
                            else {
                                str = '请选择';
                                var range = get.select(event.selectTarget);
                                if (range[0] == range[1])
                                    str += get.cnNumber(range[0]);
                                else if (range[1] == Infinity)
                                    str += '至少' + get.cnNumber(range[0]);
                                else
                                    str += get.cnNumber(range[0]) + '至' + get.cnNumber(range[1]);
                                str += '个目标';
                            }
                            event.dialog = ui.create.dialog(str);
                            if (event.prompt2) {
                                event.dialog.addText(event.prompt2, event.prompt2.length <= 20);
                            }
                            if (event.promptbar != 'none') {
                                event.promptbar = event.dialog.add('0/' + get.numStr(get.select(event.selectTarget)[1], 'target'));
                                event.custom.add.target = function () {
                                    _status.event.promptbar.innerHTML =
                                        ui.selected.targets.length + '/' + get.numStr(get.select(event.selectTarget)[1], 'target');
                                };
                            }
                        }
                        else if (get.itemtype(event.dialog) == 'dialog') {
                            event.dialog.open();
                        }
                    }
                    else if (event.isOnline()) {
                        event.send();
                    }
                    else {
                        event.result = 'ai';
                    }
                    "step 1";
                    if (event.result == 'ai') {
                        game.check();
                        if (ai.basic.chooseTarget(event.ai) || forced) {
                            ui.click.ok();
                        }
                        else {
                            ui.click.cancel();
                        }
                    }
                    if (event.result.bool && event.animate !== false) { //play anim
                        for (var i = 0; i < event.result.targets.length; i++) {
                            event.result.targets[i].animate('target');
                        }
                    }
                    if (event.dialog)
                        event.dialog.close();
                    event.resume();
                    "step 2";
                    if (event.onresult) {
                        event.onresult(event.result);
                    }
                    if (event.result.bool && event.autodelay && !event.isMine()) {
                        if (typeof event.autodelay == 'number') {
                            game.delayx(event.autodelay);
                        }
                        else {
                            game.delayx();
                        }
                    }
                },
                /**
                 * 选择卡牌和目标角色
                 * @name content.chooseCardTarget
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                chooseCardTarget: function () {
                    "step 0";
                    if (event.isMine()) {
                        if (event.hsskill && !event.forced && _status.prehidden_skills.contains(event.hsskill)) {
                            ui.click.cancel();
                            return;
                        }
                        game.check();
                        game.pause();
                        if (event.prompt != false) {
                            event.dialog = ui.create.dialog(event.prompt || '请选择卡牌和目标');
                            if (event.prompt2) {
                                event.dialog.addText(event.prompt2, event.prompt2.length <= 20);
                            }
                        }
                    }
                    else if (event.isOnline()) {
                        event.send();
                    }
                    else {
                        event.result = 'ai';
                    }
                    "step 1";
                    if (event.result == 'ai') {
                        game.check();
                        if (ai.basic.chooseCard(event.ai1)) {
                            if (ai.basic.chooseTarget(event.ai2)) {
                                ui.click.ok();
                                _status.event._aiexclude.length = 0;
                            }
                            else {
                                get.card(true).aiexclude();
                                game.uncheck();
                                event.redo();
                                game.resume();
                            }
                        }
                        else {
                            ui.click.cancel();
                        }
                    }
                    "step 2";
                    event.resume();
                    if (event.result.bool && event.animate !== false) {
                        for (var i = 0; i < event.result.targets.length; i++) {
                            event.result.targets[i].animate('target');
                        }
                    }
                    if (event.dialog)
                        event.dialog.close();
                },
                /**
                 * 选择项(列表项)
                 * @name content.chooseControl
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                chooseControl: function () {
                    "step 0";
                    if (event.controls.length == 0) {
                        if (event.sortcard) {
                            var sortnum = 2;
                            if (event.sorttop) {
                                sortnum = 1;
                            }
                            for (var i = 0; i < event.sortcard.length + sortnum; i++) {
                                event.controls.push(get.cnNumber(i, true));
                            }
                        }
                        else if (event.choiceList) {
                            for (var i = 0; i < event.choiceList.length; i++) {
                                event.controls.push('选项' + get.cnNumber(i + 1, true));
                            }
                        }
                        else {
                            event.finish();
                            return;
                        }
                    }
                    else if (event.choiceList && event.controls.length == 1 && event.controls[0] == 'cancel2') {
                        event.controls.shift();
                        for (var i = 0; i < event.choiceList.length; i++) {
                            event.controls.push('选项' + get.cnNumber(i + 1, true));
                        }
                        event.controls.push('cancel2');
                    }
                    if (event.isMine()) {
                        if (event.arrangeSkill) {
                            var hidden = player.hiddenSkills.slice(0);
                            game.expandSkills(hidden);
                            if (hidden.length) {
                                for (var _i = 0, _a = event.controls; _i < _a.length; _i++) {
                                    var i = _a[_i];
                                    if (_status.prehidden_skills.contains(i) && hidden.contains(i)) {
                                        event.result = {
                                            bool: true,
                                            control: i
                                        };
                                        return;
                                    }
                                }
                            }
                        }
                        else if (event.hsskill && _status.prehidden_skills.contains(event.hsskill) && event.controls.contains('cancel2')) {
                            event.result = {
                                bool: true,
                                control: 'cancel2'
                            };
                            return;
                        }
                        if (event.sortcard) {
                            var prompt = event.prompt || '选择一个位置';
                            if (event.tosort) {
                                prompt += '放置' + get.translation(event.tosort);
                            }
                            event.dialog = ui.create.dialog(prompt, 'hidden');
                            if (event.sortcard && event.sortcard.length) {
                                event.dialog.addSmall(event.sortcard);
                            }
                            else {
                                event.dialog.buttons = [];
                                event.dialog.add(ui.create.div('.buttons'));
                            }
                            var buttons = event.dialog.content.lastChild;
                            var sortnum = 2;
                            if (event.sorttop) {
                                sortnum = 1;
                            }
                            for (var i = 0; i < event.dialog.buttons.length + sortnum; i++) {
                                var item = ui.create.div('.button.card.pointerdiv.mebg');
                                item.style.width = '50px';
                                buttons.insertBefore(item, event.dialog.buttons[i]);
                                item.innerHTML = '<div style="font-family: xinwei;font-size: 25px;height: 75px;line-height: 25px;top: 8px;left: 10px;width: 30px;">第' + get.cnNumber(i + 1, true) + '张</div>';
                                if (i == event.dialog.buttons.length + 1) {
                                    item.firstChild.innerHTML = '牌堆底';
                                }
                                item.link = get.cnNumber(i, true);
                                item.listen(ui.click.dialogcontrol);
                            }
                            event.dialog.forcebutton = true;
                            event.dialog.classList.add('forcebutton');
                            event.dialog.open();
                        }
                        else if (event.dialogcontrol) {
                            event.dialog = ui.create.dialog(event.prompt || '选择一项', 'hidden');
                            for (var i = 0; i < event.controls.length; i++) {
                                var item = event.dialog.add('<div class="popup text pointerdiv" style="width:calc(100% - 10px);display:inline-block">' + event.controls[i] + '</div>');
                                item.firstChild.listen(ui.click.dialogcontrol);
                                item.firstChild.link = event.controls[i];
                            }
                            event.dialog.forcebutton = true;
                            event.dialog.classList.add('forcebutton');
                            if (event.addDialog) {
                                for (var i = 0; i < event.addDialog.length; i++) {
                                    if (get.itemtype(event.addDialog[i]) == 'cards') {
                                        event.dialog.addSmall(event.addDialog[i]);
                                    }
                                    else {
                                        event.dialog.add(event.addDialog[i]);
                                    }
                                }
                                event.dialog.add(ui.create.div('.placeholder.slim'));
                            }
                            event.dialog.open();
                        }
                        else {
                            if (event.seperate || lib.config.seperate_control) {
                                event.controlbars = [];
                                for (var i = 0; i < event.controls.length; i++) {
                                    event.controlbars.push(ui.create.control([event.controls[i]]));
                                }
                            }
                            else {
                                event.controlbar = ui.create.control(event.controls);
                            }
                            if (event.dialog) {
                                if (Array.isArray(event.dialog)) {
                                    event.dialog = ui.create.dialog.apply(this, event.dialog);
                                }
                                event.dialog.open();
                            }
                            else if (event.choiceList) {
                                event.dialog = ui.create.dialog(event.prompt || '选择一项', 'hidden');
                                event.dialog.forcebutton = true;
                                event.dialog.open();
                                for (var i = 0; i < event.choiceList.length; i++) {
                                    event.dialog.add('<div class="popup text" style="width:calc(100% - 10px);display:inline-block">选项' +
                                        get.cnNumber(i + 1, true) + '：' + event.choiceList[i] + '</div>');
                                }
                            }
                            else if (event.prompt) {
                                event.dialog = ui.create.dialog(event.prompt);
                                if (event.prompt2) {
                                    event.dialog.addText(event.prompt2, event.prompt2.length <= 20 || event.centerprompt2);
                                }
                            }
                        }
                        game.pause();
                        game.countChoose();
                        event.choosing = true;
                    }
                    else if (event.isOnline()) {
                        event.send();
                    }
                    else {
                        event.result = 'ai';
                    }
                    "step 1";
                    if (event.result == 'ai') {
                        event.result = {};
                        if (event.ai) {
                            var result = event.ai(event.getParent(), player);
                            if (typeof result == 'number')
                                event.result.control = event.controls[result];
                            else
                                event.result.control = result;
                        }
                        else
                            event.result.control = event.controls[event.choice];
                    }
                    event.result.index = event.controls.indexOf(event.result.control);
                    event.choosing = false;
                    _status.imchoosing = false;
                    if (event.dialog && event.dialog.close)
                        event.dialog.close();
                    if (event.controlbar)
                        event.controlbar.close();
                    if (event.controlbars) {
                        for (var i = 0; i < event.controlbars.length; i++) {
                            event.controlbars[i].close();
                        }
                    }
                    event.resume();
                },
                /**
                 * 确认项(确认|取消)
                 * @name content.chooseBool
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                chooseBool: function () {
                    "step 0";
                    if (event.isMine()) {
                        if (event.frequentSkill && !lib.config.autoskilllist.contains(event.frequentSkill)) {
                            ui.click.ok();
                            return;
                        }
                        else if (event.hsskill && _status.prehidden_skills.contains(event.hsskill)) {
                            ui.click.cancel();
                            return;
                        }
                        ui.create.confirm('oc');
                        if (event.createDialog && !event.dialog) {
                            if (Array.isArray(event.createDialog)) {
                                event.dialog = ui.create.dialog.apply(this, event.createDialog);
                                if (event.dialogselectx) {
                                    for (var i = 0; i < event.dialog.buttons.length; i++) {
                                        event.dialog.buttons[i].classList.add('selectedx');
                                    }
                                }
                            }
                        }
                        if (event.dialog) {
                            event.dialog.open();
                        }
                        else if (event.prompt) {
                            event.dialog = ui.create.dialog(event.prompt);
                            if (event.prompt2) {
                                event.dialog.addText(event.prompt2, event.prompt2.length <= 20);
                            }
                        }
                        game.pause();
                        game.countChoose();
                        event.choosing = true;
                    }
                    else if (event.isOnline()) {
                        event.send();
                    }
                    else {
                        event.result = 'ai';
                    }
                    "step 1";
                    if (event.result == 'ai') {
                        if (event.ai) {
                            event.choice = event.ai(event.getParent(), player);
                        }
                        event.result = { bool: event.choice };
                    }
                    _status.imchoosing = false;
                    event.choosing = false;
                    if (event.dialog)
                        event.dialog.close();
                    event.resume();
                },
                /**
                 * 选择(摸牌|回血)
                 * @name content.chooseDrawRecover
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                chooseDrawRecover: function () {
                    'step 0';
                    if (player.isHealthy() && event.forced) {
                        player.draw(event.num1);
                        event.finish();
                        return;
                    }
                    var controls = ['draw_card'];
                    if (player.isDamaged()) {
                        event.num2 = Math.min(event.num2, player.maxHp - player.hp);
                        controls.push('recover_hp');
                    }
                    if (!event.forced) {
                        controls.push('cancel2');
                    }
                    var prompt = event.prompt;
                    if (!prompt) {
                        if (player.isHealthy()) {
                            prompt = '是否摸' + get.cnNumber(event.num1) + '张牌？';
                        }
                        else {
                            prompt = '摸' + get.cnNumber(event.num1) + '张牌或回复' + get.cnNumber(event.num2) + '点' + get.translation('hp');
                        }
                    }
                    var next = player.chooseControl(controls);
                    next.set('prompt', prompt);
                    if (event.hsskill)
                        next.setHiddenSkill(event.hsskill);
                    if (event.ai) {
                        next.set('ai', event.ai);
                    }
                    else {
                        var choice;
                        if (player.isDamaged() && get.recoverEffect(player) > 0 && (player.hp == 1 || player.needsToDiscard() ||
                            player.hasSkillTag('maixie_hp') || event.num2 > event.num1 ||
                            (event.num2 == event.num1 && player.needsToDiscard(1)))) {
                            choice = 'recover_hp';
                        }
                        else {
                            choice = 'draw_card';
                        }
                        next.set('ai', function () {
                            return _status.event.choice;
                        });
                        next.set('choice', choice);
                    }
                    'step 1';
                    if (result.control != 'cancel2') {
                        if (event.logSkill) {
                            if (typeof event.logSkill == 'string') {
                                player.logSkill(event.logSkill);
                            }
                            else if (Array.isArray(event.logSkill)) {
                                player.logSkill.apply(player, event.logSkill);
                            }
                        }
                        if (result.control == 'draw_card') {
                            player.draw(event.num1);
                        }
                        else {
                            player.recover(event.num2);
                        }
                    }
                    event.result = result;
                },
                /**
                 * 从目标角色选择牌
                 * @name content.choosePlayerCard
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                choosePlayerCard: function () {
                    "step 0";
                    if (!event.dialog)
                        event.dialog = ui.create.dialog('hidden');
                    else if (!event.isMine) {
                        event.dialog.style.display = 'none';
                    }
                    if (event.prompt) {
                        event.dialog.add(event.prompt);
                    }
                    else {
                        event.dialog.add('选择' + get.translation(target) + '的一张牌');
                    }
                    if (event.prompt2) {
                        event.dialog.addText(event.prompt2);
                    }
                    var directh = (!lib.config.unauto_choose && !event.complexSelect);
                    directh = game.showPlayerCard(event, target, directh, null);
                    if (event.dialog.buttons.length == 0) {
                        event.finish();
                        return;
                    }
                    var cs = target.getCards(event.position);
                    var select = get.select(event.selectButton);
                    if (event.forced && select[0] >= cs.length) {
                        event.result = {
                            bool: true,
                            buttons: event.dialog.buttons,
                            links: cs
                        };
                    }
                    else if (event.forced && directh && !event.isOnline() && select[0] == select[1]) {
                        event.result = {
                            bool: true,
                            buttons: event.dialog.buttons.randomGets(select[0]),
                            links: []
                        };
                        for (var i = 0; i < event.result.buttons.length; i++) {
                            event.result.links[i] = event.result.buttons[i].link;
                        }
                    }
                    else {
                        if (event.isMine()) {
                            if (event.hsskill && !event.forced && _status.prehidden_skills.contains(event.hsskill)) {
                                ui.click.cancel();
                                return;
                            }
                            event.dialog.open();
                            game.check();
                            game.pause();
                        }
                        else if (event.isOnline()) {
                            event.send();
                        }
                        else {
                            event.result = 'ai';
                        }
                    }
                    "step 1";
                    if (event.result == 'ai') {
                        game.check();
                        if (ai.basic.chooseButton(event.ai) || forced)
                            ui.click.ok();
                        else
                            ui.click.cancel();
                    }
                    event.dialog.close();
                    if (event.result.links) {
                        event.result.cards = event.result.links.slice(0);
                    }
                    event.resume();
                },
                /**
                 * 从目标角色选择牌弃置
                 * @name content.discardPlayerCard
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                discardPlayerCard: function () {
                    "step 0";
                    if (event.directresult) {
                        event.result = {
                            buttons: [],
                            cards: event.directresult.slice(0),
                            links: event.directresult.slice(0),
                            targets: [],
                            confirm: 'ok',
                            bool: true
                        };
                        event.cards = event.directresult.slice(0);
                        event.goto(2);
                        return;
                    }
                    if (!event.dialog)
                        event.dialog = ui.create.dialog('hidden');
                    else if (!event.isMine) {
                        event.dialog.style.display = 'none';
                    }
                    if (event.prompt == undefined) {
                        var str = '弃置' + get.translation(target);
                        var range = get.select(event.selectButton);
                        if (range[0] == range[1])
                            str += get.cnNumber(range[0]);
                        else if (range[1] == Infinity)
                            str += '至少' + get.cnNumber(range[0]);
                        else
                            str += get.cnNumber(range[0]) + '至' + get.cnNumber(range[1]);
                        str += '张';
                        if (event.position == 'h' || event.position == undefined)
                            str += '手';
                        if (event.position == 'e')
                            str += '装备';
                        str += '牌';
                        event.prompt = str;
                    }
                    if (event.prompt) {
                        event.dialog.add(event.prompt);
                    }
                    if (event.prompt2) {
                        event.dialog.addText(event.prompt2);
                    }
                    var directh = (!lib.config.unauto_choose && !event.complexSelect);
                    directh = game.showPlayerCard(event, target, directh, 'canBeDiscarded');
                    if (event.dialog.buttons.length == 0) {
                        event.finish();
                        return;
                    }
                    var cs = target.getCards(event.position);
                    var select = get.select(event.selectButton);
                    if (event.forced && select[0] >= cs.length) {
                        event.result = {
                            bool: true,
                            buttons: event.dialog.buttons,
                            links: cs
                        };
                    }
                    else if (event.forced && directh && !event.isOnline() && select[0] == select[1]) {
                        event.result = {
                            bool: true,
                            buttons: event.dialog.buttons.randomGets(select[0]),
                            links: []
                        };
                        for (var i = 0; i < event.result.buttons.length; i++) {
                            event.result.links[i] = event.result.buttons[i].link;
                        }
                    }
                    else {
                        if (event.isMine()) {
                            event.dialog.open();
                            game.check();
                            game.pause();
                        }
                        else if (event.isOnline()) {
                            event.send();
                        }
                        else {
                            event.result = 'ai';
                        }
                    }
                    "step 1";
                    if (event.result == 'ai') {
                        game.check();
                        if (ai.basic.chooseButton(event.ai) || forced)
                            ui.click.ok();
                        else
                            ui.click.cancel();
                    }
                    event.dialog.close();
                    "step 2";
                    event.resume();
                    if (event.result.bool && event.result.links && !game.online) {
                        if (event.logSkill) {
                            if (typeof event.logSkill == 'string') {
                                player.logSkill(event.logSkill);
                            }
                            else if (Array.isArray(event.logSkill)) {
                                player.logSkill.apply(player, event.logSkill);
                            }
                        }
                        var cards = [];
                        for (var i = 0; i < event.result.links.length; i++) {
                            cards.push(event.result.links[i]);
                        }
                        event.result.cards = event.result.links.slice(0);
                        event.cards = cards;
                        event.trigger("rewriteDiscardResult");
                    }
                    "step 3";
                    if (event.boolline) {
                        player.line(target, 'green');
                    }
                    if (!event.chooseonly) {
                        var next = target.discard(event.cards);
                        if (player != target)
                            next.notBySelf = true;
                        event.done = next;
                        if (event.delay === false) {
                            next.set('delay', false);
                        }
                    }
                },
                /**
                 * 从目标角色选择牌获得
                 * @name content.gainPlayerCard
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                gainPlayerCard: function () {
                    "step 0";
                    if (event.directresult) {
                        event.result = {
                            buttons: [],
                            cards: event.directresult.slice(0),
                            links: event.directresult.slice(0),
                            targets: [],
                            confirm: 'ok',
                            bool: true
                        };
                        event.cards = event.directresult.slice(0);
                        event.goto(2);
                        return;
                    }
                    if (!event.dialog)
                        event.dialog = ui.create.dialog('hidden');
                    else if (!event.isMine) {
                        event.dialog.style.display = 'none';
                    }
                    if (event.prompt == undefined) {
                        var str = '获得' + get.translation(target);
                        var range = get.select(event.selectButton);
                        if (range[0] == range[1])
                            str += get.cnNumber(range[0]);
                        else if (range[1] == Infinity)
                            str += '至少' + get.cnNumber(range[0]);
                        else
                            str += get.cnNumber(range[0]) + '至' + get.cnNumber(range[1]);
                        str += '张';
                        if (event.position == 'h' || event.position == undefined)
                            str += '手';
                        if (event.position == 'e')
                            str += '装备';
                        str += '牌';
                        event.prompt = str;
                    }
                    if (event.prompt) {
                        event.dialog.add(event.prompt);
                    }
                    if (event.prompt2) {
                        event.dialog.addText(event.prompt2);
                    }
                    var directh = (!lib.config.unauto_choose && !event.complexSelect);
                    directh = game.showPlayerCard(event, target, directh, 'canBeGained');
                    if (event.dialog.buttons.length == 0) {
                        event.dialog.close();
                        event.finish();
                        return;
                    }
                    var cs = target.getCards(event.position);
                    var select = get.select(event.selectButton);
                    if (event.forced && select[0] >= cs.length) {
                        event.result = {
                            bool: true,
                            buttons: event.dialog.buttons,
                            links: cs
                        };
                    }
                    else if (event.forced && directh && !event.isOnline() && select[0] == select[1]) {
                        event.result = {
                            bool: true,
                            buttons: event.dialog.buttons.randomGets(select[0]),
                            links: []
                        };
                        for (var i = 0; i < event.result.buttons.length; i++) {
                            event.result.links[i] = event.result.buttons[i].link;
                        }
                    }
                    else {
                        if (event.isMine()) {
                            event.dialog.open();
                            game.check();
                            game.pause();
                        }
                        else if (event.isOnline()) {
                            event.send();
                        }
                        else {
                            event.result = 'ai';
                        }
                    }
                    "step 1";
                    if (event.result == 'ai') {
                        game.check();
                        if (ai.basic.chooseButton(event.ai) || forced)
                            ui.click.ok();
                        else
                            ui.click.cancel();
                    }
                    event.dialog.close();
                    "step 2";
                    event.resume();
                    if (game.online || !event.result.bool) {
                        event.finish();
                    }
                    "step 3";
                    if (event.logSkill && event.result.bool && !game.online) {
                        if (typeof event.logSkill == 'string') {
                            player.logSkill(event.logSkill);
                        }
                        else if (Array.isArray(event.logSkill)) {
                            player.logSkill.apply(player, event.logSkill);
                        }
                    }
                    var cards = [];
                    for (var i = 0; i < event.result.links.length; i++) {
                        cards.push(event.result.links[i]);
                    }
                    event.result.cards = event.result.links.slice(0);
                    event.cards = cards;
                    event.trigger("rewriteGainResult");
                    "step 4";
                    if (event.boolline) {
                        player.line(target, 'green');
                    }
                    if (!event.chooseonly) {
                        if (event.delay !== false) {
                            var next = player.gain(event.cards, target, event.visibleMove ? 'give' : 'giveAuto', 'bySelf');
                            event.done = next;
                        }
                        else {
                            var next = player.gain(event.cards, target, 'bySelf');
                            event.done = next;
                            target[event.visibleMove ? '$give' : '$giveAuto'](cards, player);
                            if (event.visibleMove)
                                next.visible = true;
                        }
                    }
                    else
                        target[event.visibleMove ? '$give' : '$giveAuto'](cards, player);
                },
                /**
                 * 展示角色手牌
                 * @name content.showHandcards
                 * @type {GameCores.Bases.StateMachine}
                 */
                showHandcards: function () {
                    "step 0";
                    if (player.countCards('h') == 0) {
                        event.finish();
                        return;
                    }
                    var cards = player.getCards('h');
                    var str = get.translation(player.name) + '的手牌';
                    if (typeof event.prompt == 'string') {
                        str = event.prompt;
                    }
                    event.dialog = ui.create.dialog(str, cards);
                    event.dialogid = lib.status.videoId++;
                    event.dialog.videoId = event.dialogid;
                    game.broadcast(function (str, cards, id) {
                        ui.create.dialog(str, cards).videoId = id;
                    }, str, cards, event.dialogid);
                    game.log(player, '展示了', cards);
                    game.addVideo('showCards', player, [str, get.cardsInfo(cards)]);
                    game.delayx(2);
                    "step 1";
                    game.broadcast('closeDialog', event.dialogid);
                    event.dialog.close();
                },
                /**
                 * 展示角色的牌
                 * @name content.showHandcards
                 * @type {GameCores.Bases.StateMachine}
                 */
                showCards: function () {
                    "step 0";
                    if (get.itemtype(cards) != 'cards') {
                        event.finish();
                        return;
                    }
                    if (!event.str) {
                        event.str = get.translation(player.name) + '展示的牌';
                    }
                    event.dialog = ui.create.dialog(event.str, cards);
                    event.dialogid = lib.status.videoId++;
                    event.dialog.videoId = event.dialogid;
                    if (event.hiddencards) {
                        for (var i = 0; i < event.dialog.buttons.length; i++) {
                            if (event.hiddencards.contains(event.dialog.buttons[i].link)) {
                                event.dialog.buttons[i].className = 'button card';
                                event.dialog.buttons[i].innerHTML = '';
                            }
                        }
                    }
                    game.broadcast(function (str, cards, cards2, id) {
                        var dialog = ui.create.dialog(str, cards);
                        dialog.forcebutton = true;
                        dialog.videoId = id;
                        if (cards2) {
                            for (var i = 0; i < dialog.buttons.length; i++) {
                                if (cards2.contains(dialog.buttons[i].link)) {
                                    dialog.buttons[i].className = 'button card';
                                    dialog.buttons[i].innerHTML = '';
                                }
                            }
                        }
                    }, event.str, cards, event.hiddencards, event.dialogid);
                    if (event.hiddencards) {
                        var cards2 = cards.slice(0);
                        for (var i = 0; i < event.hiddencards.length; i++) {
                            cards2.remove(event.hiddencards[i]);
                        }
                        game.log(player, '展示了', cards2);
                    }
                    else {
                        game.log(player, '展示了', cards);
                    }
                    game.delayx(2);
                    game.addVideo('showCards', player, [event.str, get.cardsInfo(cards)]);
                    "step 1";
                    game.broadcast('closeDialog', event.dialogid);
                    event.dialog.close();
                },
                /**
                 * 查看牌
                 * @name content.showHandcards
                 * @type {GameCores.Bases.StateMachine}
                 */
                viewCards: function () {
                    "step 0";
                    if (player == game.me) {
                        event.dialog = ui.create.dialog(event.str, event.cards);
                        if (event.isMine()) {
                            game.pause();
                            ui.create.confirm('o');
                            game.countChoose();
                            event.choosing = true;
                        }
                        else {
                            event.finish();
                            event.result = 'viewed';
                            setTimeout(function () {
                                event.dialog.close();
                            }, 2 * lib.config.duration);
                            game.delayx(2);
                        }
                    }
                    else if (event.isOnline()) {
                        event.send();
                    }
                    else {
                        event.finish();
                    }
                    "step 1";
                    event.result = 'viewed';
                    _status.imchoosing = false;
                    event.choosing = false;
                    if (event.dialog)
                        event.dialog.close();
                },
                /**
                 * 移动牌位置
                 * @name content.moveCard
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Object} event.result 返回选择结果给父事件
                 */
                moveCard: function () {
                    'step 0';
                    if (!player.canMoveCard(null, event.nojudge, event.moveHandcard)) {
                        event.finish();
                        return;
                    }
                    var next = player.chooseTarget(2, function (card, player, target) {
                        if (_status.event.sourceFilterTarget && typeof _status.event.sourceFilterTarget == 'function') {
                            if (!_status.event.sourceFilterTarget(card, player, target))
                                return false;
                        }
                        if (ui.selected.targets.length) {
                            var from = ui.selected.targets[0];
                            if (_status.event.moveHandcard && from.countCards('h') > 0)
                                return true;
                            var js = from.getCards('j');
                            for (var i = 0; i < js.length; i++) {
                                if (_status.event.nojudge)
                                    break;
                                if (target.canAddJudge(js[i]))
                                    return true;
                            }
                            if (target.isMin())
                                return false;
                            var es = from.getCards('e');
                            for (var i = 0; i < es.length; i++) {
                                if (target.isEmpty(get.subtype(es[i])))
                                    return true;
                            }
                            return false;
                        }
                        else {
                            var range = 'ej';
                            if (_status.event.nojudge)
                                range = 'e';
                            if (_status.event.moveHandcard)
                                range = 'h' + range;
                            return target.countCards(range) > 0;
                        }
                    });
                    next.set('nojudge', event.nojudge || false);
                    next.set('moveHandcard', event.moveHandcard || false);
                    next.set('sourceFilterTarget', event.sourceFilterTarget || false);
                    next.set('ai', event.ai || function (target) {
                        var player = _status.event.player;
                        var att = get.attitude(player, target);
                        var sgnatt = get.sgn(att);
                        if (ui.selected.targets.length == 0) {
                            if (att > 0) {
                                if (!_status.event.nojudge && target.countCards('j', function (card) {
                                    return game.hasPlayer(function (current) {
                                        return current != target && current.canAddJudge(card) && get.attitude(player, current) < 0;
                                    });
                                }))
                                    return 14;
                                if (target.countCards('e', function (card) {
                                    return get.value(card, target) < 0 && game.hasPlayer(function (current) {
                                        return current != target && get.attitude(player, current) < 0 && current.isEmpty(get.subtype(card)) && get.effect(target, card, player, player) < 0;
                                    });
                                }) > 0)
                                    return 9;
                            }
                            else if (att < 0) {
                                if (game.hasPlayer(function (current) {
                                    if (current != target && get.attitude(player, current) > 0) {
                                        var es = target.getCards('e');
                                        for (var i = 0; i < es.length; i++) {
                                            if (get.value(es[i], target) > 0 && current.isEmpty(get.subtype(es[i])) && get.effect(current, es[i], player, player) > 0)
                                                return true;
                                        }
                                    }
                                })) {
                                    return -att;
                                }
                            }
                            return 0;
                        }
                        var es = ui.selected.targets[0].getCards('e');
                        var i;
                        var att2 = get.sgn(get.attitude(player, ui.selected.targets[0]));
                        for (i = 0; i < es.length; i++) {
                            if (sgnatt != 0 && att2 != 0 && sgnatt != att2 &&
                                get.sgn(get.value(es[i], ui.selected.targets[0])) == -att2 &&
                                get.sgn(get.effect(target, es[i], player, target)) == sgnatt &&
                                target.isEmpty(get.subtype(es[i]))) {
                                return Math.abs(att);
                            }
                        }
                        if (i == es.length && (_status.event.nojudge || !ui.selected.targets[0].countCards('j', function (card) {
                            return target.canAddJudge(card);
                        }) || att2 <= 0)) {
                            return 0;
                        }
                        return -att * att2;
                    });
                    next.set('multitarget', true);
                    next.set('targetprompt', _status.event.targetprompt || ['被移走', '移动目标']);
                    next.set('prompt', event.prompt || '移动场上的一张牌');
                    if (event.prompt2)
                        next.set('prompt2', event.prompt2);
                    if (event.forced)
                        next.set('forced', true);
                    'step 1';
                    event.result = result;
                    if (result.bool) {
                        player.line2(result.targets, 'green');
                        event.targets = result.targets;
                    }
                    else {
                        event.finish();
                    }
                    'step 2';
                    game.delay();
                    'step 3';
                    if (targets.length == 2) {
                        player.choosePlayerCard('hej', true, function (button) {
                            var player = _status.event.player;
                            var targets0 = _status.event.targets0;
                            var targets1 = _status.event.targets1;
                            if (get.attitude(player, targets0) > 0 && get.attitude(player, targets1) < 0) {
                                if (get.position(button.link) == 'j')
                                    return 12;
                                if (get.value(button.link, targets0) < 0 && get.effect(targets1, button.link, player, targets1) > 0)
                                    return 10;
                                return 0;
                            }
                            else {
                                if (get.position(button.link) == 'j')
                                    return -10;
                                return get.value(button.link) * get.effect(targets1, button.link, player, targets1);
                            }
                        }, targets[0]).set('nojudge', event.nojudge || false).set('targets0', targets[0]).set('targets1', targets[1]).set('filterButton', function (button) {
                            var targets1 = _status.event.targets1;
                            if (get.position(button.link) == 'h') {
                                if (!_status.event.moveHandcard)
                                    return false;
                                return true;
                            }
                            if (get.position(button.link) == 'j') {
                                if (_status.event.nojudge)
                                    return false;
                                return targets1.canAddJudge(button.link);
                            }
                            else {
                                return targets1.isEmpty(get.subtype(button.link));
                            }
                        }).set('moveHandcard', event.moveHandcard || false);
                    }
                    else {
                        event.finish();
                    }
                    'step 4';
                    if (result.bool && result.links.length) {
                        var link = result.links[0];
                        if (get.position(link) == 'e') {
                            event.targets[1].equip(link);
                        }
                        else if (get.position(link) == 'h') {
                            event.targets[0].give(link, event.targets[1], 'giveAuto');
                        }
                        else if (link.viewAs) {
                            event.targets[1].addJudge({ name: link.viewAs }, [link]);
                        }
                        else {
                            event.targets[1].addJudge(link);
                        }
                        if (get.position(link) != 'h') {
                            event.targets[0].$give(link, event.targets[1], false);
                            game.log(event.targets[0], '的', link, '被移动给了', event.targets[1]);
                        }
                        event.result.card = link;
                        event.result.position = get.position(link);
                        game.delay();
                    }
                },
                /**
                 * 角色使用牌
                 * @name content.useCard
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {?Object} event.result 返回选择使用结果(如果有)给父事件
                 */
                useCard: function () {
                    "step 0";
                    if (!card) {
                        console.log('err: no card', get.translation(event.player));
                        event.finish();
                        return;
                    }
                    if (!get.info(card, false).noForceDie)
                        event.forceDie = true;
                    var next = player.lose(cards, 'visible', ui.ordering).set('type', 'use');
                    var directDiscard = [];
                    for (var i = 0; i < cards.length; i++) {
                        if (!next.cards.contains(cards[i])) {
                            directDiscard.push(cards[i]);
                        }
                    }
                    if (directDiscard.length)
                        game.cardsGotoOrdering(directDiscard);
                    //player.using=cards;
                    var cardaudio = true;
                    if (event.skill) {
                        if (lib.skill[event.skill].audio) {
                            cardaudio = false;
                        }
                        if (lib.skill[event.skill].log != false) {
                            player.logSkill(event.skill);
                        }
                        if (get.info(event.skill).popname) {
                            player.tryCardAnimate(card, event.card.name, 'metal', true);
                        }
                    }
                    else if (!event.nopopup) {
                        if (lib.translate[event.card.name + '_pop']) {
                            player.tryCardAnimate(card, lib.translate[event.card.name + '_pop'], 'metal');
                        }
                        else {
                            player.tryCardAnimate(card, event.card.name, 'metal');
                        }
                    }
                    if (event.audio === false) {
                        cardaudio = false;
                    }
                    if (cardaudio) {
                        game.broadcastAll(function (player, card) {
                            if (lib.config.background_audio) {
                                if (get.type(card) == 'equip' && !lib.config.equip_audio)
                                    return;
                                var sex = player.sex == 'female' ? 'female' : 'male';
                                var audioinfo = lib.card[card.name].audio;
                                // if(audioinfo||true){
                                if (card.name == 'sha' && (card.nature == 'fire' || card.nature == 'thunder' || card.nature == 'ice' || card.nature == 'ocean')) {
                                    game.playAudio('card', sex, card.name + '_' + card.nature);
                                }
                                else {
                                    if (typeof audioinfo == 'string') {
                                        if (audioinfo.indexOf('ext:') == 0)
                                            game.playAudio('..', 'extension', audioinfo.slice(4), card.name + '_' + sex);
                                        else
                                            game.playAudio('card', sex, audioinfo);
                                    }
                                    else {
                                        game.playAudio('card', sex, card.name);
                                    }
                                }
                                // }
                                // else if(get.type(card)!='equip'){
                                //     game.playAudio('card/default');
                                // }
                            }
                        }, player, card);
                    }
                    if (event.animate != false && event.line != false) {
                        if ((card.name == 'wuxie' || card.name == 'youdishenru') && event.getParent().source) {
                            var lining = event.getParent().sourcex || event.getParent().source2 || event.getParent().source;
                            if (lining == player && event.getParent().sourcex2) {
                                lining = event.getParent().sourcex2;
                            }
                            if (Array.isArray(lining) && event.getTrigger().name == 'jiedao') {
                                player.line(lining[0], 'green');
                            }
                            else {
                                player.line(lining, 'green');
                            }
                        }
                        else {
                            var config = {};
                            if (card.nature == 'fire' ||
                                (card.classList && card.classList.contains('fire'))) {
                                config.color = 'fire';
                            }
                            else if (card.nature == 'thunder' ||
                                (card.classList && card.classList.contains('thunder'))) {
                                config.color = 'thunder';
                            }
                            else if (card.nature == 'ocean' ||
                                (card.classList && card.classList.contains('ocean'))) {
                                config.color = 'ocean';
                            }
                            else if (card.nature == 'yami' ||
                                (card.classList && card.classList.contains('yami'))) {
                                config.color = 'yami';
                            }
                            if (event.addedTarget) {
                                player.line2(targets.concat(event.addedTargets), config);
                            }
                            else if (get.info(card, false).multitarget && targets.length > 1 && !get.info(card, false).multiline) {
                                player.line2(targets, config);
                            }
                            else {
                                player.line(targets, config);
                            }
                        }
                        if (event["throw"] !== false)
                            player.$throw(cards);
                        if (lib.config.sync_speed && cards[0] && cards[0].clone) {
                            var waitingForTransition = get.time();
                            event.waitingForTransition = waitingForTransition;
                            cards[0].clone.listenTransition(function () {
                                if (_status.waitingForTransition == waitingForTransition && _status.paused) {
                                    game.resume();
                                }
                                delete event.waitingForTransition;
                            });
                        }
                    }
                    event.id = get.id();
                    event.excluded = [];
                    event.directHit = [];
                    event.customArgs = { "default": {} };
                    if (typeof event.baseDamage != 'number')
                        event.baseDamage = get.info(card, false).baseDamage || 1;
                    if (event.oncard) {
                        event.oncard(event.card, event.player);
                    }
                    player.actionHistory[player.actionHistory.length - 1].useCard.push(event);
                    if (event.addCount !== false) {
                        if (player.stat[player.stat.length - 1].card[card.name] == undefined) {
                            player.stat[player.stat.length - 1].card[card.name] = 1;
                        }
                        else {
                            player.stat[player.stat.length - 1].card[card.name]++;
                        }
                        if (event.skill) {
                            if (player.stat[player.stat.length - 1].skill[event.skill] == undefined) {
                                player.stat[player.stat.length - 1].skill[event.skill] = 1;
                            }
                            else {
                                player.stat[player.stat.length - 1].skill[event.skill]++;
                            }
                            var sourceSkill = get.info(event.skill).sourceSkill;
                            if (sourceSkill) {
                                if (player.stat[player.stat.length - 1].skill[sourceSkill] == undefined) {
                                    player.stat[player.stat.length - 1].skill[sourceSkill] = 1;
                                }
                                else {
                                    player.stat[player.stat.length - 1].skill[sourceSkill]++;
                                }
                            }
                        }
                    }
                    if (targets.length) {
                        var str = (targets.length == 1 && targets[0] == player) ? '#b自己' : targets;
                        if (cards.length && !card.isCard) {
                            if (event.addedTarget) {
                                game.log(player, '对', str, '使用了', card, '（', cards, '，指向', event.addedTargets, '）');
                            }
                            else {
                                game.log(player, '对', str, '使用了', card, '（', cards, '）');
                            }
                        }
                        else {
                            if (event.addedTarget) {
                                game.log(player, '对', str, '使用了', card, '（指向', event.addedTargets, '）');
                            }
                            else {
                                game.log(player, '对', str, '使用了', card);
                            }
                        }
                    }
                    else {
                        if (cards.length && !card.isCard) {
                            if (event.addedTarget) {
                                game.log(player, '使用了', card, '（', cards, '，指向', event.addedTargets, '）');
                            }
                            else {
                                game.log(player, '使用了', card, '（', cards, '）');
                            }
                        }
                        else {
                            if (event.addedTarget) {
                                game.log(player, '使用了', card, '（指向', event.addedTargets, '）');
                            }
                            else {
                                game.log(player, '使用了', card);
                            }
                        }
                    }
                    if (card.name == 'wuxie') {
                        game.logv(player, [card, cards], [event.getTrigger().card]);
                    }
                    else {
                        game.logv(player, [card, cards], targets);
                    }
                    event.trigger('useCard1');
                    "step 1";
                    event.trigger('useCard2');
                    "step 2";
                    event.trigger('useCard');
                    event._oncancel = function () {
                        game.broadcastAll(function (id) {
                            if (ui.tempnowuxie && ui.tempnowuxie._origin == id) {
                                ui.tempnowuxie.close();
                                delete ui.tempnowuxie;
                            }
                        }, event.id);
                    };
                    "step 3";
                    event.sortTarget = function (animate, sort) {
                        var info = get.info(card, false);
                        if (num == 0 && targets.length > 1) {
                            if (!info.multitarget) {
                                if (!event.fixedSeat && !sort) {
                                    targets.sortBySeat(player);
                                }
                                if (animate)
                                    for (var i = 0; i < targets.length; i++) {
                                        targets[i].animate('target');
                                    }
                            }
                            else if (animate) {
                                for (var i = 0; i < targets.length; i++) {
                                    targets[i].animate('target');
                                }
                            }
                        }
                    };
                    event.sortTarget();
                    event.getTriggerTarget = function (list1, list2) {
                        var listx = list1.slice(0).sortBySeat();
                        for (var i = 0; i < listx.length; i++) {
                            if (list2.numOf(listx[i]) < listx.numOf(listx[i]))
                                return listx[i];
                        }
                        return null;
                    };
                    var info = get.info(card, false);
                    if (!info.nodelay && event.animate != false) {
                        if (event.delayx !== false) {
                            if (event.waitingForTransition) {
                                _status.waitingForTransition = event.waitingForTransition;
                                game.pause();
                            }
                            else {
                                game.delayx();
                            }
                        }
                    }
                    "step 4";
                    if (event.all_excluded)
                        return;
                    if (!event.triggeredTargets1)
                        event.triggeredTargets1 = [];
                    var target = event.getTriggerTarget(targets, event.triggeredTargets1);
                    if (target) {
                        event.triggeredTargets1.push(target);
                        var next = game.createEvent('useCardToPlayer', false);
                        if (event.triggeredTargets1.length == 1)
                            next.isFirstTarget = true;
                        next.setContent('emptyEvent');
                        next.targets = targets;
                        next.target = target;
                        next.card = card;
                        next.cards = cards;
                        next.player = player;
                        next.excluded = event.excluded;
                        next.directHit = event.directHit;
                        next.customArgs = event.customArgs;
                        if (event.forceDie)
                            next.forceDie = true;
                        event.redo();
                    }
                    "step 5";
                    if (event.all_excluded)
                        return;
                    if (!event.triggeredTargets2)
                        event.triggeredTargets2 = [];
                    var target = event.getTriggerTarget(targets, event.triggeredTargets2);
                    if (target) {
                        event.triggeredTargets2.push(target);
                        var next = game.createEvent('useCardToTarget', false);
                        if (event.triggeredTargets2.length == 1)
                            next.isFirstTarget = true;
                        next.setContent('emptyEvent');
                        next.targets = targets;
                        next.target = target;
                        next.card = card;
                        next.cards = cards;
                        next.player = player;
                        next.excluded = event.excluded;
                        next.directHit = event.directHit;
                        next.customArgs = event.customArgs;
                        if (event.forceDie)
                            next.forceDie = true;
                        event.redo();
                    }
                    "step 6";
                    if (event.all_excluded)
                        return;
                    if (!event.triggeredTargets3)
                        event.triggeredTargets3 = [];
                    var target = event.getTriggerTarget(targets, event.triggeredTargets3);
                    if (target) {
                        event.triggeredTargets3.push(target);
                        var next = game.createEvent('useCardToPlayered', false);
                        if (event.triggeredTargets3.length == 1)
                            next.isFirstTarget = true;
                        next.setContent('emptyEvent');
                        next.targets = targets;
                        next.target = target;
                        next.card = card;
                        next.cards = cards;
                        next.player = player;
                        next.excluded = event.excluded;
                        next.directHit = event.directHit;
                        next.customArgs = event.customArgs;
                        if (event.forceDie)
                            next.forceDie = true;
                        event.redo();
                    }
                    "step 7";
                    if (event.all_excluded)
                        return;
                    if (!event.triggeredTargets4)
                        event.triggeredTargets4 = [];
                    var target = event.getTriggerTarget(targets, event.triggeredTargets4);
                    if (target) {
                        event.triggeredTargets4.push(target);
                        var next = game.createEvent('useCardToTargeted', false);
                        if (event.triggeredTargets4.length == 1)
                            next.isFirstTarget = true;
                        next.setContent('emptyEvent');
                        next.targets = targets;
                        next.target = target;
                        next.card = card;
                        next.cards = cards;
                        next.player = player;
                        next.excluded = event.excluded;
                        next.directHit = event.directHit;
                        next.customArgs = event.customArgs;
                        if (event.forceDie)
                            next.forceDie = true;
                        if (targets.length == event.triggeredTargets4.length) {
                            event.sortTarget();
                        }
                        event.redo();
                    }
                    "step 8";
                    var info = get.info(card, false);
                    if (info.contentBefore) {
                        var next = game.createEvent(card.name + 'ContentBefore');
                        next.setContent(info.contentBefore);
                        next.targets = targets;
                        next.card = card;
                        next.cards = cards;
                        next.player = player;
                        next.type = 'precard';
                        if (event.forceDie)
                            next.forceDie = true;
                    }
                    else if (info.reverseOrder && get.is.versus() && targets.length > 1) {
                        var next = game.createEvent(card.name + 'ContentBefore');
                        next.setContent('reverseOrder');
                        next.targets = targets;
                        next.card = card;
                        next.cards = cards;
                        next.player = player;
                        next.type = 'precard';
                        if (event.forceDie)
                            next.forceDie = true;
                    }
                    "step 9";
                    if (event.all_excluded)
                        return;
                    var info = get.info(card, false);
                    if (num == 0 && targets.length > 1) {
                        event.sortTarget(true, true);
                    }
                    if (targets[num] && targets[num].isDead())
                        return;
                    if (targets[num] && targets[num].isOut())
                        return;
                    if (targets[num] && targets[num].removed)
                        return;
                    if (targets[num] && info.ignoreTarget && info.ignoreTarget(card, player, targets[num]))
                        return;
                    if (targets.length == 0 && !info.notarget)
                        return;
                    if (targets[num] && event.excluded.contains(targets[num])) {
                        var next = game.createEvent('useCardToExcluded', false);
                        next.setContent('emptyEvent');
                        next.targets = targets;
                        next.target = targets[num];
                        next.num = num;
                        next.card = card;
                        next.cards = cards;
                        next.player = player;
                        return;
                    }
                    ;
                    var next = game.createEvent(card.name);
                    next.setContent(info.content);
                    next.targets = targets;
                    next.card = card;
                    next.cards = cards;
                    next.player = player;
                    next.num = num;
                    next.type = 'card';
                    next.skill = event.skill;
                    next.multitarget = info.multitarget;
                    next.preResult = event.preResult;
                    next.baseDamage = event.baseDamage;
                    if (event.forceDie)
                        next.forceDie = true;
                    if (event.addedTargets) {
                        next.addedTargets = event.addedTargets;
                        next.addedTarget = event.addedTarget;
                        next._targets = event._targets;
                    }
                    if (info.targetDelay === false) {
                        event.targetDelay = false;
                    }
                    next.target = targets[num];
                    for (var i in event.customArgs["default"])
                        next[i] = event.customArgs["default"][i];
                    if (next.target && event.customArgs[next.target.playerid]) {
                        var customArgs = event.customArgs[next.target.playerid];
                        for (var i in customArgs)
                            next[i] = customArgs[i];
                    }
                    if (next.target && event.directHit.contains(next.target))
                        next.directHit = true;
                    if (next.target && !info.multitarget) {
                        if (num == 0 && targets.length > 1) {
                            // var ttt=next.target;
                            // setTimeout(function(){ttt.animate('target');},0.5*lib.config.duration);
                        }
                        else {
                            next.target.animate('target');
                        }
                    }
                    if (!info.nodelay && num > 0) {
                        if (event.targetDelay !== false) {
                            game.delayx(0.5);
                        }
                    }
                    "step 10";
                    if (event.all_excluded)
                        return;
                    if (!get.info(event.card, false).multitarget && num < targets.length - 1 && !event.cancelled) {
                        event.num++;
                        event.goto(9);
                    }
                    "step 11";
                    if (get.info(card, false).contentAfter) {
                        var next = game.createEvent(card.name + 'ContentAfter');
                        next.setContent(get.info(card, false).contentAfter);
                        next.targets = targets;
                        next.card = card;
                        next.cards = cards;
                        next.player = player;
                        next.preResult = event.preResult;
                        next.type = 'postcard';
                        if (event.forceDie)
                            next.forceDie = true;
                    }
                    "step 12";
                    if (event.postAi) {
                        event.player.logAi(event.targets, event.card);
                    }
                    if (event._result) {
                        event.result = event._result;
                    }
                    //delete player.using;
                    if (document.getElementsByClassName('thrown').length) {
                        if (event.delayx !== false)
                            game.delayx();
                    }
                    else {
                        event.finish();
                    }
                    "step 13";
                    event._oncancel();
                },
                /**
                 * 角色使用技能
                 * @name content.useSkill
                 * @type {GameCores.Bases.StateMachine}
                 */
                useSkill: function () {
                    "step 0";
                    var info = get.info(event.skill);
                    if (!info.noForceDie)
                        event.forceDie = true;
                    event._skill = event.skill;
                    game.trySkillAudio(event.skill, player);
                    var checkShow = player.checkShow(event.skill);
                    if (info.discard != false && info.lose != false && !info.viewAs) {
                        player.discard(cards).delay = false;
                        if (lib.config.low_performance) {
                            event.discardTransition = true;
                        }
                    }
                    else {
                        if (info.lose != false) {
                            if (info.losetrigger == false) {
                                var losecard = player.lose(cards, ui.special)._triggered = null;
                            }
                            else {
                                var losecard = player.lose(cards, ui.special);
                                if (info.visible)
                                    losecard.visible = true;
                                if (info.loseTo)
                                    losecard.position = ui[info.loseTo];
                                if (info.insert)
                                    losecard.insert_card = true;
                                if (losecard.position == ui.special && info.toStorage)
                                    losecard.toStorage = true;
                            }
                        }
                        if (!info.prepare && info.viewAs) {
                            player.$throw(cards);
                            if (losecard)
                                losecard.visible = true;
                            if (lib.config.sync_speed && cards[0] && cards[0].clone) {
                                var waitingForTransition = get.time();
                                event.waitingForTransition = waitingForTransition;
                                cards[0].clone.listenTransition(function () {
                                    if (_status.waitingForTransition == waitingForTransition && _status.paused) {
                                        game.resume();
                                    }
                                    delete event.waitingForTransition;
                                });
                            }
                        }
                    }
                    if (info.line != false && targets.length) {
                        var config = {};
                        if (get.is.object(info.line))
                            config = info.line;
                        else if (info.line == 'fire') {
                            config.color = 'fire';
                        }
                        else if (info.line == 'thunder') {
                            config.color = 'thunder';
                        }
                        else if (info.line == 'ocean') {
                            config.color = 'ocean';
                        }
                        else if (info.line === undefined || info.line == 'green') {
                            config.color = 'green';
                        }
                        if (info.multitarget && !info.multiline && targets.length > 1) {
                            player.line2(targets, config);
                        }
                        else {
                            player.line(targets, config);
                        }
                    }
                    var str = '';
                    if (targets && targets.length && info.log != 'notarget') {
                        str += '对<span class="bluetext">' + (targets[0] == player ? '自己' : get.translation(targets[0]));
                        for (var i = 1; i < targets.length; i++) {
                            str += '、' + (targets[i] == player ? '自己' : get.translation(targets[i]));
                        }
                        str += '</span>';
                    }
                    str += '发动了';
                    if (!info.direct) {
                        game.log(player, str, '#p『' + get.skillTranslation(skill, player) + '』');
                        if (info.logv !== false)
                            game.logv(player, skill, targets);
                        player.trySkillAnimate(skill, skill, checkShow);
                    }
                    if (event.addCount != false) {
                        if (player.stat[player.stat.length - 1].skill[skill] == undefined) {
                            player.stat[player.stat.length - 1].skill[skill] = 1;
                        }
                        else {
                            player.stat[player.stat.length - 1].skill[skill]++;
                        }
                        var sourceSkill = get.info(skill).sourceSkill;
                        if (sourceSkill) {
                            if (player.stat[player.stat.length - 1].skill[sourceSkill] == undefined) {
                                player.stat[player.stat.length - 1].skill[sourceSkill] = 1;
                            }
                            else {
                                player.stat[player.stat.length - 1].skill[sourceSkill]++;
                            }
                        }
                    }
                    if (player.stat[player.stat.length - 1].allSkills == undefined) {
                        player.stat[player.stat.length - 1].allSkills = 1;
                    }
                    else {
                        player.stat[player.stat.length - 1].allSkills++;
                    }
                    if (info.prepare) {
                        switch (info.prepare) {
                            case 'give':
                                if (losecard)
                                    losecard.visible = true;
                                player.$give(cards, targets[0]);
                                break;
                            case 'give2':
                                player.$give(cards.length, targets[0]);
                                break;
                            case 'throw':
                                if (losecard)
                                    losecard.visible = true;
                                player.$throw(cards);
                                break;
                            case 'throw2':
                                player.$throw(cards.length);
                                break;
                            default: info.prepare(cards, player, targets);
                        }
                    }
                    if (info.round) {
                        var roundname = skill + '_roundcount';
                        player.storage[roundname] = game.roundNumber;
                        player.syncStorage(roundname);
                        player.markSkill(roundname);
                    }
                    "step 1";
                    var info = get.info(event.skill);
                    if (info && info.contentBefore) {
                        var next = game.createEvent(event.skill + 'ContentBefore');
                        next.setContent(info.contentBefore);
                        next.targets = targets;
                        next.cards = cards;
                        next.player = player;
                        if (event.forceDie)
                            next.forceDie = true;
                    }
                    "step 2";
                    if (!event.skill) {
                        console.log('error: no skill', get.translation(event.player), event.player.getSkills());
                        if (event._skill) {
                            event.skill = event._skill;
                            console.log(event._skill);
                        }
                        else {
                            event.finish();
                            return;
                        }
                    }
                    var info = get.info(event.skill);
                    if (targets[num] && targets[num].isDead() ||
                        targets[num] && targets[num].isOut() ||
                        targets[num] && targets[num].removed) {
                        if (!info.multitarget && num < targets.length - 1) {
                            event.num++;
                            event.redo();
                        }
                        return;
                    }
                    var next = game.createEvent(event.skill);
                    next.setContent(info.content);
                    next.targets = targets;
                    next.cards = cards;
                    next.player = player;
                    next.num = num;
                    next.multitarget = info.multitarget;
                    if (num == 0 && next.targets.length > 1) {
                        if (!info.multitarget) {
                            lib.tempSortSeat = player;
                            targets.sort(lib.sort.seat);
                            delete lib.tempSortSeat;
                        }
                        for (var i = 0; i < targets.length; i++) {
                            targets[i].animate('target');
                        }
                    }
                    next.target = targets[num];
                    if (event.forceDie)
                        next.forceDie = true;
                    if (next.target && !info.multitarget) {
                        if (num == 0 && targets.length > 1) {
                            // var ttt=next.target;
                            // setTimeout(function(){ttt.animate('target');},0.5*lib.config.duration);
                        }
                        else {
                            next.target.animate('target');
                        }
                    }
                    if (num == 0) {
                        if (typeof info.delay == 'number')
                            game.delay(info.delay);
                        else if (info.delay !== false && info.delay !== 0) {
                            if (event.waitingForTransition) {
                                _status.waitingForTransition = event.waitingForTransition;
                                game.pause();
                            }
                            else {
                                game.delayx();
                            }
                        }
                    }
                    else
                        game.delayx(0.5);
                    if (!info.multitarget && num < targets.length - 1) {
                        event.num++;
                        event.redo();
                    }
                    "step 3";
                    var info = get.info(event.skill);
                    if (info && info.contentAfter) {
                        var next = game.createEvent(event.skill + 'ContentAfter');
                        next.setContent(info.contentAfter);
                        next.targets = targets;
                        next.cards = cards;
                        next.player = player;
                        if (event.forceDie)
                            next.forceDie = true;
                    }
                    "step 4";
                    if (player.getStat().allSkills > 200) {
                        player._noSkill = true;
                        console.log(player.name, event.skill);
                    }
                    if (document.getElementsByClassName('thrown').length) {
                        if (event.skill && get.info(event.skill).delay !== false && get.info(event.skill).delay !== 0)
                            game.delayx();
                    }
                    else {
                        event.finish();
                    }
                    "step 5";
                    ui.clear();
                },
                /**
                 * 从(牌库|牌堆顶|牌堆底)摸牌
                 * @name content.useCard
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 当前事件
                 * @property {!Array<GameCores.GameObjects.Card>} event.result 返回摸到的牌数组
                 */
                draw: function () {
                    // if(lib.config.background_audio){
                    //     game.playAudio('effect','draw');
                    // }
                    // game.broadcast(function(){
                    //     if(lib.config.background_audio){
                    //         game.playAudio('effect','draw');
                    //     }
                    // });
                    if (typeof event.minnum == 'number' && num < event.minnum) {
                        num = event.minnum;
                    }
                    if (event.drawDeck) {
                        if (event.drawDeck > num) {
                            event.drawDeck = num;
                        }
                        num -= event.drawDeck;
                    }
                    if (event.log != false) {
                        if (num > 0) {
                            if (event.bottom)
                                game.log(player, '从牌堆底摸了' + get.cnNumber(num) + '张牌');
                            else
                                game.log(player, '摸了' + get.cnNumber(num) + '张牌');
                        }
                        if (event.drawDeck) {
                            game.log(player, '从牌库中获得了' + get.cnNumber(event.drawDeck) + '张牌');
                        }
                    }
                    var cards;
                    if (num > 0) {
                        if (event.bottom)
                            cards = get.bottomCards(num);
                        else if (player.getTopCards)
                            cards = player.getTopCards(num);
                        else
                            cards = get.cards(num);
                    }
                    else {
                        cards = [];
                    }
                    if (event.drawDeck) {
                        cards = cards.concat(player.getDeckCards(event.drawDeck));
                    }
                    if (event.animate != false) {
                        if (event.visible) {
                            var next = player.gain(cards, 'gain2');
                            if (event.bottom)
                                game.log(player, '从牌堆底摸了' + get.cnNumber(num) + '张牌（', cards, '）');
                            else
                                game.log(player, '摸了' + get.cnNumber(num) + '张牌（', cards, '）');
                        }
                        else {
                            var next = player.gain(cards, 'draw');
                        }
                    }
                    else {
                        var next = player.gain(cards);
                        if (event.$draw) {
                            player.$draw(cards.length);
                        }
                    }
                    if (event.gaintag)
                        next.gaintag.addArray(event.gaintag);
                    event.result = cards;
                },
                /**
                 * 从(手牌区|装备区|武将牌上|判定区)弃置牌
                 * @name content.discard
                 * @type {GameCores.Bases.StateMachine}
                 */
                discard: function () {
                    "step 0";
                    game.log(player, '弃置了', cards);
                    event.done = player.lose(cards, event.position, 'visible').type = 'discard';
                    "step 1";
                    event.trigger('discard');
                },
                /**
                 * 角色打出牌
                 * @name content.respond
                 * @type {GameCores.Bases.StateMachine}
                 */
                respond: function () {
                    'step 0';
                    var cardaudio = true;
                    if (event.skill) {
                        if (lib.skill[event.skill].audio) {
                            cardaudio = false;
                        }
                        player.logSkill(event.skill);
                        player.checkShow(event.skill, true);
                        if (lib.skill[event.skill].onrespond && !game.online) {
                            lib.skill[event.skill].onrespond(event, player);
                        }
                    }
                    else if (!event.nopopup)
                        player.tryCardAnimate(card, card.name, 'wood');
                    if (cardaudio && event.getParent(3).name == 'useCard') {
                        game.broadcastAll(function (player, card) {
                            if (lib.config.background_audio) {
                                var sex = player.sex == 'female' ? 'female' : 'male';
                                var audioinfo = lib.card[card.name].audio;
                                // if(audioinfo||true){
                                if (typeof audioinfo == 'string' && audioinfo.indexOf('ext:') == 0) {
                                    game.playAudio('..', 'extension', audioinfo.slice(4), card.name + '_' + sex);
                                }
                                else {
                                    game.playAudio('card', sex, card.name);
                                }
                                // }
                                // else{
                                //     game.playAudio('card/default');
                                // }
                            }
                        }, player, card);
                    }
                    if (cards.length && (cards.length > 1 || cards[0].name != card.name)) {
                        game.log(player, '打出了', card, '（', cards, '）');
                    }
                    else {
                        game.log(player, '打出了', card);
                    }
                    player.actionHistory[player.actionHistory.length - 1].respond.push(event);
                    var cards2 = cards.slice(0);
                    if (cards2.length) {
                        var next = player.lose(cards2, ui.ordering, 'visible');
                        if (event.noOrdering)
                            next.noOrdering = true;
                        cards2.removeArray(next.cards);
                        if (cards2.length) {
                            var next2 = game.cardsGotoOrdering(cards2);
                            if (event.noOrdering)
                                next2.noOrdering = true;
                        }
                    }
                    if (event.animate != false && event["throw"] !== false) {
                        for (var i = 0; i < cards.length; i++) {
                            player.$throw(cards[i]);
                            if (event.highlight) {
                                cards[i].clone.classList.add('thrownhighlight');
                                game.addVideo('highlightnode', player, get.cardInfo(cards[i]));
                            }
                        }
                        if (event.highlight) {
                            game.broadcast(function (cards) {
                                for (var i = 0; i < cards.length; i++) {
                                    if (cards[i].clone) {
                                        cards[i].clone.classList.add('thrownhighlight');
                                    }
                                }
                            }, cards);
                        }
                    }
                    event.trigger('respond');
                    'step 1';
                    game.delayx(0.5);
                },
                /**
                 * 角色和目标交换(手)牌
                 * @name content.swapHandcards
                 * @type {GameCores.Bases.StateMachine}
                 */
                swapHandcards: function () {
                    'step 0';
                    event.cards1 = event.cards1 || player.getCards('h');
                    event.cards2 = event.cards2 || target.getCards('h');
                    game.loseAsync({
                        player: player,
                        target: target,
                        cards1: event.cards1,
                        cards2: event.cards2
                    }).setContent('swapHandcardsx');
                    'step 1';
                    player.gain(event.cards2);
                    target.gain(event.cards1);
                },
                swapHandcardsx: function () {
                    'step 0';
                    player.$giveAuto(event.cards1, target);
                    target.$giveAuto(event.cards2, player);
                    'step 1';
                    event.cards = event.cards1;
                    var next = player.lose(event.cards, ui.ordering).getlx = false;
                    next.relatedEvent = event.getParent();
                    if (player == game.me) {
                        event.delayed = true;
                    }
                    else {
                        next.delay = false;
                    }
                    'step 2';
                    event.cards = event.cards2;
                    var next = target.lose(event.cards, ui.ordering).getlx = false;
                    next.relatedEvent = event.getParent();
                    if (target == game.me) {
                        event.delayed = true;
                    }
                    else {
                        next.delay = false;
                    }
                    'step 3';
                    if (!event.delayed)
                        game.delay();
                },
                /**
                 * 角色从每个目标获得一张牌
                 * @name content.gainMultiple
                 * @type {GameCores.Bases.StateMachine}
                 */
                gainMultiple: function () {
                    'step 0';
                    event.delayed = false;
                    event.num = 0;
                    event.cards = [];
                    'step 1';
                    player.gainPlayerCard(targets[num], event.position, true).set('boolline', false).set('delay', num == targets.length - 1);
                    'step 2';
                    if (result.bool) {
                        event.cards.addArray(result.cards);
                        if (num == targets.length - 1)
                            event.delayed = true;
                    }
                    event.num++;
                    if (event.num < targets.length) {
                        event.goto(1);
                    }
                    'step 3';
                    if (!event.delayed)
                        game.delay();
                },
                /**
                 * 角色获得牌
                 * @name content.lose
                 * @type {GameCores.Bases.StateMachine}
                 */
                gain: function () {
                    "step 0";
                    if (cards) {
                        var map = {};
                        for (var _i = 0, cards_1 = cards; _i < cards_1.length; _i++) {
                            var i = cards_1[_i];
                            var owner = get.owner(i, 'judge');
                            if (owner && (owner != player || get.position(i) != 'h')) {
                                var id = owner.playerid;
                                if (!map[id])
                                    map[id] = [];
                                map[id].push(i);
                            }
                        }
                        for (var i in map) {
                            var owner = (_status.connectMode ? lib.playerOL : game.playerMap)[i];
                            var next = owner.lose(map[i], ui.special).set('type', 'gain').set('forceDie', true).set('getlx', false);
                            if (event.animate == 'give' || event.visible == true)
                                next.visible = true;
                            event.relatedLose = next;
                        }
                    }
                    else {
                        event.finish();
                    }
                    "step 1";
                    for (var i = 0; i < cards.length; i++) {
                        if (cards[i].destroyed) {
                            if (player.hasSkill(cards[i].destroyed)) {
                                delete cards[i].destroyed;
                            }
                            else {
                                cards.splice(i--, 1);
                            }
                        }
                    }
                    if (cards.length == 0) {
                        event.finish();
                        return;
                    }
                    player.getHistory('gain').push(event);
                    //if(event.source&&event.delay!==false) game.delayx();
                    "step 2";
                    if (player.getStat().gain == undefined) {
                        player.getStat().gain = cards.length;
                    }
                    else {
                        player.getStat().gain += cards.length;
                    }
                    "step 3";
                    var sort;
                    var frag1 = document.createDocumentFragment();
                    var frag2 = document.createDocumentFragment();
                    var hs = player.getCards('hs');
                    for (var i = 0; i < cards.length; i++) {
                        if (hs.contains(cards[i])) {
                            cards.splice(i--, 1);
                        }
                    }
                    for (var num = 0; num < cards.length; num++) {
                        sort = lib.config.sort_card(cards[num]);
                        if (lib.config.reverse_sort)
                            sort = -sort;
                        cards[num].fix();
                        cards[num].style.transform = '';
                        cards[num].addGaintag(event.gaintag);
                        if (_status.discarded) {
                            _status.discarded.remove(cards[num]);
                        }
                        // cards[num].vanishtag.length=0;
                        for (var num2 = 0; num2 < cards[num].vanishtag.length; num2++) {
                            if (cards[num].vanishtag[num2][0] != '_') {
                                cards[num].vanishtag.splice(num2--, 1);
                            }
                        }
                        if (player == game.me) {
                            cards[num].classList.add('drawinghidden');
                        }
                        if (get.is.singleHandcard() || sort > 1)
                            frag1.appendChild(cards[num]);
                        else
                            frag2.appendChild(cards[num]);
                    }
                    var addv = function () {
                        if (player == game.me) {
                            game.addVideo('gain12', player, [get.cardsInfo(frag1.childNodes), get.cardsInfo(frag2.childNodes), event.gaintag]);
                        }
                    };
                    var broadcast = function () {
                        game.broadcast(function (player, cards, num, gaintag) {
                            player.directgain(cards, null, gaintag);
                            _status.cardPileNum = num;
                        }, player, cards, ui.cardPile.childNodes.length, event.gaintag);
                    };
                    if (event.animate == 'draw') {
                        player.$draw(cards.length);
                        game.pause();
                        setTimeout(function () {
                            addv();
                            player.node.handcards1.insertBefore(frag1, player.node.handcards1.firstChild);
                            player.node.handcards2.insertBefore(frag2, player.node.handcards2.firstChild);
                            player.update();
                            if (player == game.me)
                                ui.updatehl();
                            broadcast();
                            game.resume();
                        }, get.delayx(500, 500));
                    }
                    else if (event.animate == 'gain') {
                        player.$gain(cards);
                        game.pause();
                        setTimeout(function () {
                            addv();
                            player.node.handcards1.insertBefore(frag1, player.node.handcards1.firstChild);
                            player.node.handcards2.insertBefore(frag2, player.node.handcards2.firstChild);
                            player.update();
                            if (player == game.me)
                                ui.updatehl();
                            broadcast();
                            game.resume();
                        }, get.delayx(700, 700));
                    }
                    else if (event.animate == 'gain2' || event.animate == 'draw2') {
                        var gain2t = 300;
                        if (player.$gain2(cards) && player == game.me) {
                            gain2t = 500;
                        }
                        game.pause();
                        setTimeout(function () {
                            addv();
                            player.node.handcards1.insertBefore(frag1, player.node.handcards1.firstChild);
                            player.node.handcards2.insertBefore(frag2, player.node.handcards2.firstChild);
                            player.update();
                            if (player == game.me)
                                ui.updatehl();
                            broadcast();
                            game.resume();
                        }, get.delayx(gain2t, gain2t));
                    }
                    else if (event.source && (event.animate == 'give' || event.animate == 'giveAuto')) {
                        if (event.animate == 'give')
                            event.source['$' + event.animate](cards, player);
                        else {
                            var givemap = { hs: [], ots: [] };
                            for (var i = 0; i < cards.length; i++) {
                                givemap[event.relatedLose && event.relatedLose.hs && event.relatedLose.hs.contains(cards[i]) ? 'hs' : 'ots'].push(cards[i]);
                            }
                            if (givemap.hs.length)
                                event.source.$giveAuto(givemap.hs, player);
                            if (givemap.ots.length)
                                event.source.$give(givemap.ots, player);
                        }
                        game.pause();
                        setTimeout(function () {
                            addv();
                            player.node.handcards1.insertBefore(frag1, player.node.handcards1.firstChild);
                            player.node.handcards2.insertBefore(frag2, player.node.handcards2.firstChild);
                            player.update();
                            if (player == game.me)
                                ui.updatehl();
                            broadcast();
                            game.resume();
                        }, get.delayx(500, 500));
                    }
                    else {
                        addv();
                        player.node.handcards1.insertBefore(frag1, player.node.handcards1.firstChild);
                        player.node.handcards2.insertBefore(frag2, player.node.handcards2.firstChild);
                        player.update();
                        if (player == game.me)
                            ui.updatehl();
                        broadcast();
                        event.finish();
                    }
                    if (event.log) {
                        game.log(player, '获得了', cards);
                    }
                    "step 4";
                    game.delayx();
                },
                /**
                 * 失去牌至(弃牌堆|牌堆)，或将牌移动至武将牌上(special arena)
                 * @name content.lose
                 * @type {GameCores.Bases.StateMachine}
                 */
                lose: function () {
                    "step 0";
                    var evt = event.getParent();
                    if (evt.name != 'discard' && event.type != 'discard') {
                        event.delay = false;
                        return;
                    }
                    if (evt.delay === false)
                        event.delay = false;
                    if (evt.animate != false) {
                        evt.discardid = lib.status.videoId++;
                        game.broadcastAll(function (player, cards, id) {
                            player.$throw(cards, null, 'nobroadcast');
                            var cardnodes = [];
                            cardnodes._discardtime = get.time();
                            for (var i = 0; i < cards.length; i++) {
                                if (cards[i].clone) {
                                    cardnodes.push(cards[i].clone);
                                }
                            }
                            ui.todiscard[id] = cardnodes;
                        }, player, cards, evt.discardid);
                        if (lib.config.sync_speed && cards[0] && cards[0].clone) {
                            if (evt.delay != false) {
                                var waitingForTransition = get.time();
                                evt.waitingForTransition = waitingForTransition;
                                cards[0].clone.listenTransition(function () {
                                    if (_status.waitingForTransition == waitingForTransition && _status.paused) {
                                        game.resume();
                                    }
                                    delete evt.waitingForTransition;
                                });
                            }
                            else if (evt.getParent().discardTransition) {
                                delete evt.getParent().discardTransition;
                                var waitingForTransition = get.time();
                                evt.getParent().waitingForTransition = waitingForTransition;
                                cards[0].clone.listenTransition(function () {
                                    if (_status.waitingForTransition == waitingForTransition && _status.paused) {
                                        game.resume();
                                    }
                                    delete evt.getParent().waitingForTransition;
                                });
                            }
                        }
                    }
                    "step 1";
                    event.gaintag_map = {};
                    var hs = [], es = [], js = [], ss = [];
                    if (event.insert_card && event.position == ui.cardPile)
                        event.cards.reverse();
                    var hej = player.getCards('hejs');
                    event.stockcards = cards.slice(0);
                    for (var i = 0; i < cards.length; i++) {
                        if (cards[i].gaintag && cards[i].gaintag.length) {
                            event.gaintag_map[cards[i].cardid] = cards[i].gaintag.slice(0);
                            if (cards[i].hasGaintag('ming_'))
                                event.gaintag_map[cards[i].cardid].push('ming_');
                            if (cards[i].hasGaintag('an_'))
                                event.gaintag_map[cards[i].cardid].push('an_');
                            cards[i].removeGaintag(true);
                        }
                        if (!hej.contains(cards[i])) {
                            cards.splice(i--, 1);
                        }
                        else if (cards[i].parentNode) {
                            if (cards[i].parentNode.classList.contains('equips')) {
                                cards[i].original = 'e';
                                es.push(cards[i]);
                            }
                            else if (cards[i].parentNode.classList.contains('judges')) {
                                cards[i].original = 'j';
                                js.push(cards[i]);
                            }
                            else if (cards[i].parentNode.classList.contains('handcards')) {
                                if (cards[i].classList.contains('glows')) {
                                    cards[i].original = 's';
                                    ss.push(cards[i]);
                                }
                                else {
                                    cards[i].original = 'h';
                                    hs.push(cards[i]);
                                }
                            }
                            else {
                                cards[i].original = null;
                            }
                        }
                        cards[i].style.transform += ' scale(0.2)';
                        cards[i].classList.remove('glow');
                        cards[i].classList.remove('glows');
                        cards[i].recheck();
                        var info = lib.card[cards[i].name];
                        if (info.destroy || cards[i]._destroy) {
                            cards[i]["delete"]();
                            cards[i].destroyed = info.destroy || cards[i]._destroy;
                        }
                        else if (event.position) {
                            if (_status.discarded) {
                                if (event.position == ui.discardPile) {
                                    _status.discarded.add(cards[i]);
                                }
                                else {
                                    _status.discarded.remove(cards[i]);
                                }
                            }
                            if (event.insert_index) {
                                event.position.insertBefore(cards[i], event.insert_index(event, cards[i]));
                                cards[i].fix();
                            }
                            else if (event.insert_card) {
                                event.position.insertBefore(cards[i], event.position.firstChild);
                                cards[i].fix();
                            }
                            else if (event.position == ui.cardPile) {
                                event.position.appendChild(cards[i]);
                                cards[i].fix();
                            }
                            else
                                cards[i].goto(event.position);
                        }
                        else {
                            cards[i].remove();
                        }
                        //if(ss.contains(cards[i])) cards.splice(i--,1);
                    }
                    if (player == game.me)
                        ui.updatehl();
                    ui.updatej(player);
                    game.broadcast(function (player, cards, num) {
                        for (var i = 0; i < cards.length; i++) {
                            cards[i].classList.remove('glow');
                            cards[i].classList.remove('glows');
                            cards[i].fix();
                            cards[i].remove();
                        }
                        if (player == game.me) {
                            ui.updatehl();
                        }
                        ui.updatej(player);
                        _status.cardPileNum = num;
                    }, player, cards, ui.cardPile.childNodes.length);
                    game.addVideo('lose', player, [get.cardsInfo(hs), get.cardsInfo(es), get.cardsInfo(js), get.cardsInfo(ss)]);
                    event.cards2 = hs.concat(es);
                    player.getHistory('lose').push(event);
                    game.getGlobalHistory().cardMove.push(event);
                    player.update();
                    game.addVideo('loseAfter', player);
                    event.num = 0;
                    if (event.position == ui.ordering) {
                        var evt = event.relatedEvent || event.getParent();
                        if (!evt.orderingCards)
                            evt.orderingCards = [];
                        if (!event.noOrdering && !event.cardsOrdered) {
                            event.cardsOrdered = true;
                            var next = game.createEvent('orderingDiscard', false, evt.getParent());
                            next.relatedEvent = evt;
                            next.setContent('orderingDiscard');
                        }
                        if (!event.noOrdering) {
                            evt.orderingCards.addArray(cards);
                            evt.orderingCards.addArray(ss);
                        }
                    }
                    else if (event.position == ui.cardPile) {
                        game.updateRoundNumber();
                    }
                    event.hs = hs;
                    event.es = es;
                    event.js = js;
                    event.ss = ss;
                    "step 2";
                    if (num < cards.length) {
                        var evt_1 = event.getParent();
                        if (event.es.contains(cards[num])) {
                            event.moveEquip = false;
                            if ((evt_1.name == 'equip' && evt_1.cards.contains(cards[num]))
                                || (event.getParent() && event.getParent().name != 'swapEquip'))
                                event.moveEquip = true;
                            event.loseEquip = true;
                            player.removeEquipTrigger(cards[num], event.moveEquip);
                            var info = get.info(cards[num]);
                            if (info.onLose && (!info.filterLose || info.filterLose(cards[num], player))) {
                                event.goto(3);
                                return;
                            }
                        }
                        event.num++;
                        event.redo();
                    }
                    else {
                        if (event.loseEquip) {
                            player.addEquipTrigger();
                        }
                        event.goto(4);
                    }
                    "step 3";
                    var info = get.info(cards[num]);
                    if (info.loseDelay != false && (player.isAlive() || info.forceDie)) {
                        player.popup(cards[num].name);
                        game.delayx();
                    }
                    if (Array.isArray(info.onLose)) {
                        for (var i = 0; i < info.onLose.length; i++) {
                            var next = game.createEvent('lose_' + cards[num].name);
                            next.setContent(info.onLose[i]);
                            if (info.forceDie)
                                next.forceDie = true;
                            next.player = player;
                            next.card = cards[num];
                        }
                    }
                    else {
                        var next = game.createEvent('lose_' + cards[num].name);
                        next.setContent(info.onLose);
                        next.player = player;
                        if (info.forceDie)
                            next.forceDie = true;
                        next.card = cards[num];
                    }
                    event.num++;
                    event.goto(2);
                    "step 4";
                    var evt = event.getParent();
                    if (evt.name != 'discard' && event.type != 'discard')
                        return;
                    if (evt.delay != false) {
                        if (evt.waitingForTransition) {
                            _status.waitingForTransition = evt.waitingForTransition;
                            game.pause();
                        }
                        else {
                            game.delayx();
                        }
                    }
                },
                /**
                 * 令角色受到伤害
                 * @name content.damage
                 * @type {GameCores.Bases.StateMachine}
                 */
                damage: function () {
                    "step 0";
                    event.forceDie = true;
                    event.trigger('damageBegin1');
                    "step 1";
                    event.trigger('damageBegin2');
                    "step 2";
                    event.trigger('damageBegin3');
                    "step 3";
                    event.trigger('damageBegin4');
                    "step 4";
                    if (num > 0 && player.hujia && !player.hasSkillTag('nohujia') && !(source && source.hasSkillTag('overHujia', true, {
                        name: event.card ? event.card.name : null,
                        target: player,
                        card: event.card
                    }))) {
                        if (num >= player.hujia) {
                            event.hujia = player.hujia;
                            num -= player.hujia;
                        }
                        else {
                            event.hujia = num;
                            num = 0;
                        }
                        player.changeHujia(-event.hujia).type = 'damage';
                    }
                    event.num = num;
                    if (num <= 0) {
                        event.trigger('damageZero');
                        delete event.filterStop;
                        event.finish();
                        event._triggered = null;
                    }
                    if (num > 0) {
                        event.trigger('damageHit');
                    }
                    "step 5";
                    if (lib.config.background_audio) {
                        game.playAudio('effect', 'damage' + (num > 1 ? '2' : ''));
                    }
                    game.broadcast(function (num) {
                        if (lib.config.background_audio) {
                            game.playAudio('effect', 'damage' + (num > 1 ? '2' : ''));
                        }
                    }, num);
                    var str = '受到了';
                    if (source)
                        str += '来自<span class="bluetext">' + (source == player ? '自己' : get.translation(source)) + '</span>的';
                    str += get.cnNumber(num) + '点';
                    if (event.nature)
                        str += get.translation(event.nature) + '属性';
                    str += '伤害';
                    game.log(player, str);
                    if (player.stat[player.stat.length - 1].damaged == undefined) {
                        player.stat[player.stat.length - 1].damaged = num;
                    }
                    else {
                        player.stat[player.stat.length - 1].damaged += num;
                    }
                    if (source) {
                        source.getHistory('sourceDamage').push(event);
                        if (source.stat[source.stat.length - 1].damage == undefined) {
                            source.stat[source.stat.length - 1].damage = num;
                        }
                        else {
                            source.stat[source.stat.length - 1].damage += num;
                        }
                    }
                    player.getHistory('damage').push(event);
                    if (event.notrigger) {
                        player.changeHp(-num, false)._triggered = null;
                    }
                    else {
                        player.changeHp(-num, false);
                    }
                    if (event.animate !== false) {
                        player.$damage(source);
                        game.broadcastAll(function (nature, player) {
                            if (lib.config.animation && !lib.config.low_performance) {
                                if (nature == 'fire') {
                                    player.$fire();
                                }
                                else if (nature == 'thunder') {
                                    player.$thunder();
                                }
                            }
                        }, event.nature, player);
                        player.$damagepop(-num, event.nature);
                    }
                    if (!event.notrigger) {
                        if (num == 0) {
                            event.trigger('damageZero');
                            event._triggered = null;
                        }
                        else {
                            event.trigger('damage');
                        }
                    }
                    "step 6";
                    if (player.hp <= 0 && player.isAlive()) {
                        game.delayx();
                        player.dying(event);
                    }
                    if (source && lib.config.border_style == 'auto') {
                        var dnum = 0;
                        for (var j = 0; j < source.stat.length; j++) {
                            if (source.stat[j].damage != undefined)
                                dnum += source.stat[j].damage;
                        }
                        if (dnum >= 2) {
                            if (lib.config.autoborder_start == 'silver') {
                                dnum += 4;
                            }
                            else if (lib.config.autoborder_start == 'gold') {
                                dnum += 8;
                            }
                        }
                        if (lib.config.autoborder_count == 'damage') {
                            source.node.framebg.dataset.decoration = '';
                            if (dnum >= 10) {
                                source.node.framebg.dataset.auto = 'gold';
                                if (dnum >= 12)
                                    source.node.framebg.dataset.decoration = 'gold';
                            }
                            else if (dnum >= 6) {
                                source.node.framebg.dataset.auto = 'silver';
                                if (dnum >= 8)
                                    source.node.framebg.dataset.decoration = 'silver';
                            }
                            else if (dnum >= 2) {
                                source.node.framebg.dataset.auto = 'bronze';
                                if (dnum >= 4)
                                    source.node.framebg.dataset.decoration = 'bronze';
                            }
                            if (dnum >= 2) {
                                source.classList.add('topcount');
                            }
                        }
                        else if (lib.config.autoborder_count == 'mix') {
                            source.node.framebg.dataset.decoration = '';
                            switch (source.node.framebg.dataset.auto) {
                                case 'bronze':
                                    if (dnum >= 4)
                                        source.node.framebg.dataset.decoration = 'bronze';
                                    break;
                                case 'silver':
                                    if (dnum >= 8)
                                        source.node.framebg.dataset.decoration = 'silver';
                                    break;
                                case 'gold':
                                    if (dnum >= 12)
                                        source.node.framebg.dataset.decoration = 'gold';
                                    break;
                            }
                        }
                    }
                    "step 7";
                    if (!event.notrigger)
                        event.trigger('damageSource');
                },
                /**
                 * 角色回复血量
                 * @name content.recover
                 * @type {GameCores.Bases.StateMachine}
                 */
                recover: function () {
                    if (lib.config.background_audio) {
                        game.playAudio('effect', 'recover');
                    }
                    game.broadcast(function () {
                        if (lib.config.background_audio) {
                            game.playAudio('effect', 'recover');
                        }
                    });
                    if (num > player.maxHp - player.hp) {
                        num = player.maxHp - player.hp;
                        event.num = num;
                    }
                    if (num > 0) {
                        player.changeHp(num, false);
                        game.broadcastAll(function (player) {
                            if (lib.config.animation && !lib.config.low_performance) {
                                player.$recover();
                            }
                        }, player);
                        player.$damagepop(num, 'wood');
                        game.log(player, '回复了' + get.cnNumber(num) + '点' + get.translation('hp'));
                        event.result = num;
                    }
                },
                /**
                 * 令角色失去血量
                 * @name content.loseHp
                 * @type {GameCores.Bases.StateMachine}
                 */
                loseHp: function () {
                    "step 0";
                    if (lib.config.background_audio) {
                        game.playAudio('effect', 'loseHp');
                    }
                    game.broadcast(function () {
                        if (lib.config.background_audio) {
                            game.playAudio('effect', 'loseHp');
                        }
                    });
                    game.log(player, '失去了' + get.cnNumber(num) + '点' + get.translation('hp'));
                    player.changeHp(-num);
                    "step 1";
                    if (player.hp <= 0) {
                        game.delayx();
                        player.dying(event);
                    }
                },
                /**
                 * 双将模式下，如果“双将体力设置”选择为“平均值”，因此向下取整体力的角色可以摸一张牌
                 * @name content.doubleDraw
                 * @type {GameCores.Bases.StateMachine}
                 */
                doubleDraw: function () {
                    "step 0";
                    player.chooseBool('你的主副将体力上限之和是奇数，是否摸一张牌？');
                    "step 1";
                    if (result.bool) {
                        player.draw();
                    }
                },
                /**
                 * 令角色减少血量上限
                 * @name content.loseMaxHp
                 * @type {GameCores.Bases.StateMachine}
                 */
                loseMaxHp: function () {
                    "step 0";
                    game.log(player, '减少了' + get.cnNumber(num) + '点' + get.translation('hp') + '上限');
                    player.maxHp -= num;
                    event.loseHp = Math.max(0, player.hp - player.maxHp);
                    player.update();
                    "step 1";
                    if (player.maxHp <= 0) {
                        player.die(event);
                    }
                },
                /**
                 * 令角色增加血量上限
                 * @name content.gainMaxHp
                 * @type {GameCores.Bases.StateMachine}
                 */
                gainMaxHp: function () {
                    "step 0";
                    game.log(player, '增加了' + get.cnNumber(num) + '点' + get.translation('hp') + '上限');
                    player.maxHp += num;
                    player.update();
                },
                /**
                 * 令角色改变血量(不能超过上限)
                 * @name content.changeHp
                 * @type {GameCores.Bases.StateMachine}
                 */
                changeHp: function () {
                    //柚子：这里加了一个改变体力前时机
                    'step 0';
                    event.trigger('changeHpBegin');
                    'step 1';
                    player.hp += num;
                    if (isNaN(player.hp))
                        player.hp = 0;
                    if (player.hp > player.maxHp)
                        player.hp = player.maxHp;
                    player.update();
                    if (event.popup !== false) {
                        player.$damagepop(num, 'water');
                    }
                    //改变体力后立即刷新濒死列表
                    if (_status.dying.contains(player) && player.hp > 0) {
                        _status.dying.remove(player);
                        game.broadcast(function (list) {
                            _status.dying = list;
                        }, _status.dying);
                        var evt = event.getParent('_save');
                        if (evt && evt.finish)
                            evt.finish();
                        evt = event.getParent('dying');
                        if (evt && evt.finish)
                            evt.finish();
                    }
                    event.trigger('changeHp');
                },
                /**
                 * 令角色获得/失去护甲
                 * @name content.changeHujia
                 * @type {GameCores.Bases.StateMachine}
                 */
                changeHujia: function () {
                    if (lib.config.background_audio) {
                        game.playAudio('effect', 'hujia');
                    }
                    game.broadcast(function () {
                        if (lib.config.background_audio) {
                            game.playAudio('effect', 'hujia');
                        }
                    });
                    player.hujia += num;
                    player.$damagepop((num > 0 ? '+' + num : num), 'gray');
                    if (num > 0) {
                        game.log(player, '获得了' + get.cnNumber(num) + '点护甲');
                    }
                    else if (num < 0) {
                        if (event.type == 'damage')
                            game.log(player, '的护甲抵挡了' + get.cnNumber(-num) + '点伤害');
                        //else if(event.type=='lose')	game.log(player,'失去了'+get.cnNumber(-num)+'点护甲');
                        else
                            game.log(player, '失去了' + get.cnNumber(-num) + '点护甲');
                    }
                    if (player.hujia < 0) {
                        player.hujia = 0;
                    }
                    player.getHistory('changeHujia').push(event);
                    player.update();
                },
                /**
                 * 角色濒死事件
                 * @name content.dying
                 * @type {GameCores.Bases.StateMachine}
                 */
                dying: function () {
                    "step 0";
                    event.forceDie = true;
                    if (player.isDying() || player.hp > 0) {
                        event.finish();
                        return;
                    }
                    _status.dying.unshift(player);
                    game.broadcast(function (list) {
                        _status.dying = list;
                    }, _status.dying);
                    event.trigger('dying');
                    game.log(player, '濒死');
                    "step 1";
                    delete event.filterStop;
                    if (player.hp > 0) {
                        _status.dying.remove(player);
                        game.broadcast(function (list) {
                            _status.dying = list;
                        }, _status.dying);
                        event.finish();
                    }
                    else if (!event.skipTao) {
                        var next = game.createEvent('_save');
                        var start = false;
                        var starts = [_status.currentPhase, event.source, event.player, game.me, game.players[0]];
                        for (var i = 0; i < starts.length; i++) {
                            if (get.itemtype(starts[i]) == 'player') {
                                start = starts[i];
                                break;
                            }
                        }
                        next.player = start;
                        next._trigger = event;
                        next.triggername = '_save';
                        next.forceDie = true;
                        next.setContent(lib.skill._save.content);
                    }
                    "step 2";
                    _status.dying.remove(player);
                    game.broadcast(function (list) {
                        _status.dying = list;
                    }, _status.dying);
                    if (player.hp <= 0 && !player.nodying)
                        player.die(event.reason);
                },
                /**
                 * 角色死亡事件
                 * @name content.die
                 * @type {GameCores.Bases.StateMachine}
                 */
                die: function () {
                    "step 0";
                    event.forceDie = true;
                    if (_status.roundStart == player) {
                        _status.roundStart = player.next || player.getNext() || game.players[0];
                    }
                    if (ui.land && ui.land.player == player) {
                        game.addVideo('destroyLand');
                        ui.land.destroy();
                    }
                    var unseen = false;
                    if (player.classList.contains('unseen')) {
                        player.classList.remove('unseen');
                        unseen = true;
                    }
                    var logvid = game.logv(player, 'die', source);
                    event.logvid = logvid;
                    if (unseen) {
                        player.classList.add('unseen');
                    }
                    if (source) {
                        game.log(player, '被', source, '杀害');
                        if (source.stat[source.stat.length - 1].kill == undefined) {
                            source.stat[source.stat.length - 1].kill = 1;
                        }
                        else {
                            source.stat[source.stat.length - 1].kill++;
                        }
                    }
                    else {
                        game.log(player, '阵亡');
                    }
                    // player.removeEquipTrigger();
                    // for(var i in lib.skill.globalmap){
                    //     if(lib.skill.globalmap[i].contains(player)){
                    //                  lib.skill.globalmap[i].remove(player);
                    //                  if(lib.skill.globalmap[i].length==0&&!lib.skill[i].globalFixed){
                    //                               game.removeGlobalSkill(i);
                    //                  }
                    //     }
                    // }
                    game.broadcastAll(function (player) {
                        player.classList.add('dead');
                        player.removeLink();
                        player.classList.remove('turnedover');
                        player.classList.remove('out');
                        player.node.count.innerHTML = '0';
                        player.node.hp.hide();
                        player.node.equips.hide();
                        player.node.count.hide();
                        player.previous.next = player.next;
                        player.next.previous = player.previous;
                        game.players.remove(player);
                        game.dead.push(player);
                        _status.dying.remove(player);
                        if (lib.config.background_speak) {
                            if (lib.character[player.name] && lib.character[player.name][4].contains('die_audio')) {
                                game.playAudio('die', player.name);
                            }
                            // else if(true){
                            else {
                                game.playAudio('die', player.name, function () {
                                    game.playAudio('die', player.name.slice(player.name.indexOf('_') + 1));
                                });
                            }
                        }
                    }, player);
                    game.addVideo('diex', player);
                    if (event.animate !== false) {
                        player.$die(source);
                    }
                    if (player.hp != 0) {
                        player.changeHp(0 - player.hp, false).forceDie = true;
                    }
                    "step 1";
                    if (player.dieAfter)
                        player.dieAfter(source);
                    "step 2";
                    event.trigger('die');
                    "step 3";
                    if (player.isDead()) {
                        if (!game.reserveDead) {
                            for (var mark in player.marks) {
                                player.unmarkSkill(mark);
                            }
                            while (player.node.marks.childNodes.length > 1) {
                                player.node.marks.lastChild.remove();
                            }
                            game.broadcast(function (player) {
                                while (player.node.marks.childNodes.length > 1) {
                                    player.node.marks.lastChild.remove();
                                }
                            }, player);
                        }
                        for (var i in player.tempSkills) {
                            player.removeSkill(i);
                        }
                        var skills = player.getSkills();
                        for (var i = 0; i < skills.length; i++) {
                            if (lib.skill[skills[i]].temp) {
                                player.removeSkill(skills[i]);
                            }
                        }
                        if (_status.characterlist) {
                            if (lib.character[player.name])
                                _status.characterlist.add(player.name);
                            if (lib.character[player.name1])
                                _status.characterlist.add(player.name1);
                            if (lib.character[player.name2])
                                _status.characterlist.add(player.name2);
                        }
                        event.cards = player.getCards('hejs');
                        if (event.cards.length) {
                            player.discard(event.cards).forceDie = true;
                            //player.$throw(event.cards,1000);
                        }
                    }
                    "step 4";
                    if (player.dieAfter2)
                        player.dieAfter2(source);
                    "step 5";
                    game.broadcastAll(function (player) {
                        if (game.online && player == game.me && !_status.over && !game.controlOver && !ui.exit) {
                            if (lib.mode[lib.configOL.mode].config.dierestart) {
                                ui.create.exit();
                            }
                        }
                    }, player);
                    if (!_status.connectMode && player == game.me && !_status.over && !game.controlOver) {
                        ui.control.show();
                        if (get.config('revive') && lib.mode[lib.config.mode].config.revive && !ui.revive) {
                            ui.revive = ui.create.control('revive', ui.click.dierevive);
                        }
                        if (get.config('continue_game') && !ui.continue_game && lib.mode[lib.config.mode].config.continue_game && !_status.brawl && !game.no_continue_game) {
                            ui.continue_game = ui.create.control('再战', game.reloadCurrent);
                        }
                        if (get.config('dierestart') && lib.mode[lib.config.mode].config.dierestart && !ui.restart) {
                            ui.restart = ui.create.control('restart', game.reload);
                        }
                    }
                    if (!_status.connectMode && player == game.me && !game.modeSwapPlayer) {
                        // _status.auto=false;
                        if (ui.auto) {
                            // ui.auto.classList.remove('glow');
                            ui.auto.hide();
                        }
                        if (ui.wuxie)
                            ui.wuxie.hide();
                    }
                    if (typeof _status.coin == 'number' && source && !_status.auto) {
                        if (source == game.me || source.isUnderControl()) {
                            _status.coin += 10;
                        }
                    }
                    if (source && lib.config.border_style == 'auto' && (lib.config.autoborder_count == 'kill' || lib.config.autoborder_count == 'mix')) {
                        switch (source.node.framebg.dataset.auto) {
                            case 'gold':
                            case 'silver':
                                source.node.framebg.dataset.auto = 'gold';
                                break;
                            case 'bronze':
                                source.node.framebg.dataset.auto = 'silver';
                                break;
                            default: source.node.framebg.dataset.auto = lib.config.autoborder_start || 'bronze';
                        }
                        if (lib.config.autoborder_count == 'kill') {
                            source.node.framebg.dataset.decoration = source.node.framebg.dataset.auto;
                        }
                        else {
                            var dnum = 0;
                            for (var j = 0; j < source.stat.length; j++) {
                                if (source.stat[j].damage != undefined)
                                    dnum += source.stat[j].damage;
                            }
                            source.node.framebg.dataset.decoration = '';
                            switch (source.node.framebg.dataset.auto) {
                                case 'bronze':
                                    if (dnum >= 4)
                                        source.node.framebg.dataset.decoration = 'bronze';
                                    break;
                                case 'silver':
                                    if (dnum >= 8)
                                        source.node.framebg.dataset.decoration = 'silver';
                                    break;
                                case 'gold':
                                    if (dnum >= 12)
                                        source.node.framebg.dataset.decoration = 'gold';
                                    break;
                            }
                        }
                        source.classList.add('topcount');
                    }
                },
                /**
                 * 角色使用装备牌
                 * @name content.equip
                 * @type {GameCores.Bases.StateMachine}
                 */
                equip: function () {
                    "step 0";
                    console.log(card, cards);
                    if (cards) {
                        var owner = get.owner(cards[0]);
                        if (owner)
                            owner.lose(card, ui.special, 'visible').set('type', 'equip').set('getlx', false);
                    }
                    "step 1";
                    if (event.cancelled) {
                        event.finish();
                        return;
                    }
                    if (cards[0].destroyed) {
                        if (player.hasSkill(cards[0].destroyed)) {
                            delete cards[0].destroyed;
                        }
                        else {
                            event.finish();
                            return;
                        }
                    }
                    if (event.draw) {
                        game.delay(0, 300);
                        player.$draw(cards);
                    }
                    var viewAs = typeof card == 'string' ? card : card.name;
                    event.viewAs = viewAs;
                    if (!lib.card[viewAs]) {
                        cards[0].fix();
                        cards[0].style.transform = '';
                        cards[0].classList.remove('drawinghidden');
                        delete cards[0]._transform;
                        game.cardsDiscard(cards[0]);
                        event.finish();
                    }
                    "step 2";
                    game.broadcast(function (player, card, viewAs) {
                        if (card.clone && (card.clone.parentNode == player.parentNode || card.clone.parentNode == ui.arena)) {
                            card.clone.moveDelete(player);
                            game.addVideo('gain2', player, get.cardsInfo([card]));
                        }
                    }, player, cards[0], event.viewAs);
                    if (cards[0].clone && (cards[0].clone.parentNode == player.parentNode || cards[0].clone.parentNode == ui.arena)) {
                        cards[0].clone.moveDelete(player);
                        game.addVideo('gain2', player, get.cardsInfo(cards));
                    }
                    player.equiping = true;
                    "step 3";
                    var info = get.info(card, false);
                    var current = player.getCards('e', function (card) {
                        if (info.customSwap)
                            return info.customSwap(card);
                        return get.subtype(card, false) == info.subtype;
                    });
                    if (current.length) {
                        player.lose(current, false, 'visible').set('type', 'equip').set('getlx', false);
                        if (info.loseThrow) {
                            player.$throw(current);
                        }
                        event.swapped = true;
                        event.redo();
                    }
                    if (get.itemtype(card) != 'card') {
                        if (typeof card == 'string')
                            cards[0].viewAs = card;
                        else
                            cards[0].viewAs = card.name;
                    }
                    else {
                        delete cards[0].viewAs;
                    }
                    "step 4";
                    if (player.isMin() || player.countCards('e', { subtype: get.subtype(event.viewAs) })) {
                        event.finish();
                        game.cardsDiscard(cards[0]);
                        delete player.equiping;
                        return;
                    }
                    if (lib.config.background_audio) {
                        game.playAudio('effect', get.subtype(event.viewAs));
                    }
                    game.broadcast(function (type) {
                        if (lib.config.background_audio) {
                            game.playAudio('effect', type);
                        }
                    }, get.subtype(cards[0].viewAs));
                    if (cards[0].viewAs && cards[0].viewAs != cards[0].name) {
                        player.$equip(cards[0], cards[0].viewAs);
                        game.addVideo('equip', player, get.cardInfo(cards[0].viewAs));
                        game.log(player, '装备了<span class="yellowtext">' + get.translation(cards[0].viewAs) + '</span>（', cards[0], '）');
                    }
                    else if (cards[0].originalName && cards[0].originalName != cards[0].name) {
                        player.$equip(cards[0]);
                        game.addVideo('equip', player, get.cardInfo(cards[0]));
                        game.log(player, '装备了', cards[0], '（【' + get.translation(cards[0].originalName) + '】）');
                    }
                    else {
                        player.$equip(cards[0]);
                        game.addVideo('equip', player, get.cardInfo(card));
                        game.log(player, '装备了', card);
                    }
                    "step 5";
                    var info = get.info(card, false);
                    if (info.onEquip && (!info.filterEquip || info.filterEquip(card, player))) {
                        if (Array.isArray(info.onEquip)) {
                            for (var i = 0; i < info.onEquip.length; i++) {
                                var next = game.createEvent('equip_' + card.name);
                                next.setContent(info.onEquip[i]);
                                next.player = player;
                                next.card = card;
                            }
                        }
                        else {
                            var next = game.createEvent('equip_' + card.name);
                            next.setContent(info.onEquip);
                            next.player = player;
                            next.card = card;
                        }
                        if (info.equipDelay != 'false')
                            game.delayx();
                    }
                    delete player.equiping;
                    if (event.delay) {
                        game.delayx();
                    }
                },
                /**
                 * 角色添加判定牌
                 * @name content.addJudge
                 * @type {GameCores.Bases.StateMachine}
                 */
                addJudge: function () {
                    "step 0";
                    if (cards) {
                        var owner = get.owner(cards[0]);
                        if (owner) {
                            event.relatedLose = owner.lose(cards, 'visible').set('getlx', false);
                        }
                    }
                    "step 1";
                    if (cards[0].destroyed) {
                        if (player.hasSkill(cards[0].destroyed)) {
                            delete cards[0].destroyed;
                        }
                        else {
                            event.finish();
                            return;
                        }
                    }
                    cards[0].fix();
                    cards[0].style.transform = '';
                    cards[0].classList.remove('drawinghidden');
                    delete cards[0]._transform;
                    var viewAs = typeof card == 'string' ? card : card.name;
                    if (!lib.card[viewAs] || !lib.card[viewAs].effect) {
                        game.cardsDiscard(cards[0]);
                    }
                    else {
                        cards[0].style.transform = '';
                        cards[0].classList.add('drawinghidden');
                        player.node.judges.insertBefore(cards[0], player.node.judges.firstChild);
                        if (_status.discarded) {
                            _status.discarded.remove(cards[0]);
                        }
                        ui.updatej(player);
                        game.broadcast(function (player, card, viewAs) {
                            card.fix();
                            card.style.transform = '';
                            card.classList.add('drawinghidden');
                            card.viewAs = viewAs;
                            if (viewAs && viewAs != card.name && (card.classList.contains('fullskin') || card.classList.contains('fullborder'))) {
                                card.classList.add('fakejudge');
                                card.node.background.innerHTML = lib.translate[viewAs + '_bg'] || get.translation(viewAs)[0];
                            }
                            else {
                                card.classList.remove('fakejudge');
                            }
                            player.node.judges.insertBefore(card, player.node.judges.firstChild);
                            ui.updatej(player);
                            if (card.clone && (card.clone.parentNode == player.parentNode || card.clone.parentNode == ui.arena)) {
                                card.clone.moveDelete(player);
                                game.addVideo('gain2', player, get.cardsInfo([card]));
                            }
                        }, player, cards[0], viewAs);
                        if (cards[0].clone && (cards[0].clone.parentNode == player.parentNode || cards[0].clone.parentNode == ui.arena)) {
                            cards[0].clone.moveDelete(player);
                            game.addVideo('gain2', player, get.cardsInfo(cards));
                        }
                        // player.$gain2(cards);
                        if (get.itemtype(card) != 'card') {
                            if (typeof card == 'string')
                                cards[0].viewAs = card;
                            else
                                cards[0].viewAs = card.name;
                        }
                        else {
                            delete cards[0].viewAs;
                        }
                        if (cards[0].viewAs && cards[0].viewAs != cards[0].name) {
                            if (cards[0].classList.contains('fullskin') || cards[0].classList.contains('fullborder')) {
                                cards[0].classList.add('fakejudge');
                                cards[0].node.background.innerHTML = lib.translate[cards[0].viewAs + '_bg'] || get.translation(cards[0].viewAs)[0];
                            }
                            //姑且改成了取单牌的形式，以后需要叠多张牌的时候再改回来
                            game.log(player, '被贴上了<span class="yellowtext">' + get.translation(cards[0].viewAs) + '</span>（', cards[0], '）');
                        }
                        else {
                            cards[0].classList.remove('fakejudge');
                            game.log(player, '被贴上了', cards);
                        }
                        game.addVideo('addJudge', player, [get.cardInfo(cards[0]), cards[0].viewAs]);
                    }
                },
                /**
                 * 角色进行判定
                 * @name content.judge
                 * @type {GameCores.Bases.StateMachine}
                 * @property {!Object} event 本事件
                 * @property {!Object} event.result 将判定牌信息返回给父事件
                 */
                judge: function () {
                    "step 0";
                    var judgestr = get.translation(player) + '的' + event.judgestr + '判定';
                    event.videoId = lib.status.videoId++;
                    var cardj = event.directresult;
                    if (!cardj) {
                        if (player.getTopCards)
                            cardj = player.getTopCards()[0];
                        else
                            cardj = get.cards()[0];
                    }
                    var nextj = game.cardsGotoOrdering(cardj);
                    if (event.position != ui.discardPile)
                        nextj.noOrdering = true;
                    player.judging.unshift(cardj);
                    game.addVideo('judge1', player, [get.cardInfo(player.judging[0]), judgestr, event.videoId]);
                    game.broadcastAll(function (player, card, str, id, cardid) {
                        var event;
                        if (game.online) {
                            event = {};
                        }
                        else {
                            event = _status.event;
                        }
                        if (game.chess) {
                            event.node = card.copy('thrown', 'center', ui.arena).animate('start');
                        }
                        else {
                            event.node = player.$throwordered(card.copy(), true);
                        }
                        if (lib.cardOL)
                            lib.cardOL[cardid] = event.node;
                        event.node.cardid = cardid;
                        event.node.classList.add('thrownhighlight');
                        ui.arena.classList.add('thrownhighlight');
                        event.dialog = ui.create.dialog(str);
                        event.dialog.classList.add('center');
                        event.dialog.videoId = id;
                    }, player, player.judging[0], judgestr, event.videoId, get.id());
                    game.log(player, '进行' + event.judgestr + '判定，亮出的判定牌为', player.judging[0]);
                    game.delay(2);
                    if (!event.noJudgeTrigger)
                        event.trigger('judge');
                    "step 1";
                    event.result = {
                        card: player.judging[0],
                        name: player.judging[0].name,
                        number: get.number(player.judging[0]),
                        suit: get.suit(player.judging[0]),
                        color: get.color(player.judging[0]),
                        node: event.node
                    };
                    if (event.fixedResult) {
                        for (var i in event.fixedResult) {
                            event.result[i] = event.fixedResult[i];
                        }
                    }
                    event.result.judge = event.judge(event.result);
                    if (event.result.judge > 0)
                        event.result.bool = true;
                    else if (event.result.judge < 0)
                        event.result.bool = false;
                    else
                        event.result.bool = null;
                    player.judging.shift();
                    game.checkMod(player, event.result, 'judge', player);
                    if (event.result.bool == true) {
                        player.popup('洗具');
                    }
                    else if (event.result.bool == false) {
                        player.popup('杯具');
                    }
                    if (event.clearArena != false) {
                        game.broadcastAll(ui.clear);
                    }
                    game.broadcast(function (id) {
                        var dialog = get.idDialog(id);
                        if (dialog) {
                            dialog.close();
                        }
                        ui.arena.classList.remove('thrownhighlight');
                    }, event.videoId);
                    event.dialog.close();
                    game.addVideo('judge2', null, event.videoId);
                    ui.arena.classList.remove('thrownhighlight');
                    game.log(player, '的判定结果为', event.result.card);
                    if (event.callback) {
                        var next = game.createEvent('judgeCallback', false);
                        next.player = player;
                        next.card = event.result.card;
                        next.judgeResult = get.copy(event.result);
                        next.setContent(event.callback);
                    }
                    else {
                        if (!get.owner(event.result.card)) {
                            if (event.position != ui.discardPile)
                                event.position.appendChild(event.result.card);
                        }
                    }
                },
                /**
                 * 角色武将牌翻面
                 * @name content.turnOver
                 * @type {GameCores.Bases.StateMachine}
                 */
                turnOver: function () {
                    game.log(player, '翻面');
                    player.classList.toggle('turnedover');
                    game.broadcast(function (player) {
                        player.classList.toggle('turnedover');
                    }, player);
                    game.addVideo('turnOver', player, player.classList.contains('turnedover'));
                },
                /**
                 * 角色连环/解除连环
                 * @name content.link
                 * @type {GameCores.Bases.StateMachine}
                 */
                link: function () {
                    if (player.isLinked()) {
                        game.log(player, '解除连环');
                    }
                    else {
                        game.log(player, '被连环');
                    }
                    if (lib.config.background_audio) {
                        game.playAudio('effect', 'link');
                    }
                    game.broadcast(function () {
                        if (lib.config.background_audio) {
                            game.playAudio('effect', 'link');
                        }
                    });
                    player.classList.remove('target');
                    if (get.is.linked2(player)) {
                        player.classList.toggle('linked2');
                    }
                    else {
                        player.classList.toggle('linked');
                    }
                    ui.updatej(player);
                    ui.updatem(player);
                    game.broadcast(function (player, linked) {
                        player.classList.remove('target');
                        if (get.is.linked2(player)) {
                            if (linked) {
                                player.classList.add('linked2');
                            }
                            else {
                                player.classList.remove('linked2');
                            }
                        }
                        else {
                            if (linked) {
                                player.classList.add('linked');
                            }
                            else {
                                player.classList.remove('linked');
                            }
                        }
                        ui.updatej(player);
                        ui.updatem(player);
                    }, player, player.isLinked());
                    game.addVideo('link', player, player.isLinked());
                },
                chooseToGuanxing: function () {
                    "step 0";
                    if (player.isUnderControl()) {
                        game.swapPlayerAuto(player);
                    }
                    var cards = get.cards(num);
                    event.cards = cards;
                    var switchToAuto = (event.ai || function () {
                        _status.imchoosing = false;
                        if (event.dialog)
                            event.dialog.close();
                        if (event.control)
                            event.control.close();
                        var top = [];
                        var bottom;
                        cards.sort(function (a, b) {
                            return get.value(b, player) - get.value(a, player);
                        });
                        while (cards.length) {
                            if (get.value(cards[0], player) <= 5)
                                break;
                            top.unshift(cards.shift());
                        }
                        bottom = cards;
                        for (var i = 0; i < top.length; i++) {
                            ui.cardPile.insertBefore(top[i], ui.cardPile.firstChild);
                        }
                        for (i = 0; i < bottom.length; i++) {
                            ui.cardPile.appendChild(bottom[i]);
                        }
                        player.popup(get.cnNumber(top.length) + '上' + get.cnNumber(bottom.length) + '下');
                        game.log(player, '将' + get.cnNumber(top.length) + '张牌置于牌堆顶');
                        game.delay(2);
                    });
                    var chooseButton = function (player, cards) {
                        var event = _status.event;
                        player = player || event.player;
                        cards = cards || event.cards;
                        event.top = [];
                        event.bottom = [];
                        event.status = true;
                        event.dialog = ui.create.dialog('按顺序选择置于牌堆顶的牌（先选择的在上）', cards);
                        for (var i = 0; i < event.dialog.buttons.length; i++) {
                            event.dialog.buttons[i].classList.add('pointerdiv');
                        }
                        event.switchToAuto = function () {
                            event._result = 'ai';
                            event.dialog.close();
                            event.control.close();
                            _status.imchoosing = false;
                        },
                            event.control = ui.create.control('ok', 'pileTop', 'pileBottom', function (link) {
                                var event = _status.event;
                                if (link == 'ok') {
                                    event._result = {
                                        top: [],
                                        bottom: []
                                    };
                                    for (var i = 0; i < event.top.length; i++) {
                                        event._result.top.push(event.top[i].link);
                                    }
                                    for (var i = 0; i < event.bottom.length; i++) {
                                        event._result.bottom.push(event.bottom[i].link);
                                    }
                                    event.dialog.close();
                                    event.control.close();
                                    game.resume();
                                    _status.imchoosing = false;
                                }
                                else if (link == 'pileTop') {
                                    event.status = true;
                                    event.dialog.content.childNodes[0].innerHTML = '按顺序选择置于牌堆顶的牌';
                                }
                                else {
                                    event.status = false;
                                    event.dialog.content.childNodes[0].innerHTML = '按顺序选择置于牌堆底的牌';
                                }
                            });
                        for (var i = 0; i < event.dialog.buttons.length; i++) {
                            event.dialog.buttons[i].classList.add('selectable');
                        }
                        event.custom.replace.button = function (link) {
                            var event = _status.event;
                            if (link.classList.contains('target')) {
                                link.classList.remove('target');
                                event.top.remove(link);
                            }
                            else if (link.classList.contains('glow')) {
                                link.classList.remove('glow');
                                event.bottom.remove(link);
                            }
                            else if (event.status) {
                                link.classList.add('target');
                                event.top.unshift(link);
                            }
                            else {
                                link.classList.add('glow');
                                event.bottom.push(link);
                            }
                        };
                        event.custom.replace.window = function () {
                            for (var i = 0; i < _status.event.dialog.buttons.length; i++) {
                                _status.event.dialog.buttons[i].classList.remove('target');
                                _status.event.dialog.buttons[i].classList.remove('glow');
                                _status.event.top.length = 0;
                                _status.event.bottom.length = 0;
                            }
                        };
                        game.pause();
                        game.countChoose();
                    };
                    event.switchToAuto = switchToAuto;
                    if (event.isMine()) {
                        chooseButton();
                    }
                    else if (event.isOnline()) {
                        event.player.send(chooseButton, event.player, event.cards);
                        event.player.wait();
                        game.pause();
                    }
                    else {
                        event.switchToAuto();
                        event.finish();
                    }
                    "step 1";
                    var result = event.result || result;
                    if (!result || result == 'ai') {
                        event.switchToAuto();
                    }
                    else {
                        var top = result.top || [];
                        var bottom = result.bottom || [];
                        for (var i = 0; i < top.length; i++) {
                            ui.cardPile.insertBefore(top[i], ui.cardPile.firstChild);
                        }
                        for (i = 0; i < event.cards.length; i++) {
                            if (!top.contains(event.cards[i]) && !bottom.contains(event.cards[i])) {
                                ui.cardPile.appendChild(event.cards[i]);
                            }
                        }
                        for (i = 0; i < bottom.length; i++) {
                            ui.cardPile.appendChild(bottom[i]);
                        }
                        player.popup(get.cnNumber(top.length) + '上' + get.cnNumber(event.cards.length - top.length) + '下');
                        game.log(player, '将' + get.cnNumber(top.length) + '张牌置于牌堆顶');
                        game.updateRoundNumber();
                        game.delay(2);
                    }
                }
            },
            /**
             * 玩家方法，.player节点共用的方法（比如展示牌【showCard】）
             * 角色
             * @namespace
             * @mixin
             */
            player: {
                /**
                 * 检测本角色武将牌周围是否有牌
                 */
                hasCardAround: function () {
                    var cards = [];
                    var skills = this.getSkills(true, false, false);
                    game.expandSkills(skills);
                    for (var _i = 0, skills_1 = skills; _i < skills_1.length; _i++) {
                        var i = skills_1[_i];
                        if (lib.skill[i] && lib.skill[i].cardAround) {
                            var key = [];
                            var storage = this.getStorage(i);
                            var method = lib.skill[i].cardAround;
                            if (Array.isArray(method)) {
                                for (var _a = 0, method_1 = method; _a < method_1.length; _a++) {
                                    var j = method_1[_a];
                                    key = key.concat(storage[j]);
                                }
                            }
                            else if (typeof method == 'function') {
                                key = key.concat(method(this));
                            }
                            else if (Array.isArray(storage))
                                key = key.concat(storage);
                            else
                                key.push(storage);
                            console.log(key);
                            cards.addArray(key);
                        }
                    }
                    if (cards.length)
                        return cards;
                    return false;
                },
                isYingV: function () {
                    var info = lib.character[this.name || this.name1];
                    if (info && info[4]) {
                        if (info[4].contains('yingV'))
                            return true;
                    }
                },
                isGuoV: function () {
                    var info = lib.character[this.name || this.name1];
                    if (info && info[4]) {
                        if (info[4].contains('guoV'))
                            return true;
                    }
                },
                /**
                 * 将一张牌置入本角色的判定区
                 */
                addToJudge: function (card, source) {
                    var cards = (get.itemtype(card) == 'card') ? [card] : card;
                    if (source)
                        source.$give(cards, this, false);
                    if (get.type(cards[0]) == 'delay')
                        this.addJudge(cards[0]);
                    else if (get.color(cards[0]) == 'red' && this.canAddJudge('lebu'))
                        this.addJudge({ name: 'lebu' }, cards);
                    else if (get.color(cards[0]) == 'black' && this.canAddJudge('bingliang'))
                        this.addJudge({ name: 'bingliang' }, cards);
                },
                /**
                 * 判断一张牌能否本角色的判定区
                 */
                canAddToJudge: function (card) {
                    if (get.type(card) == 'delay')
                        return this.canAddJudge(card);
                    if (this.canAddJudge('lebu') && get.color(card) == 'red')
                        return true;
                    if (this.canAddJudge('bingliang') && get.color(card) == 'black')
                        return true;
                    return false;
                },
                //自创函数(升阶相关)
                chooseShengjie: function () {
                    var next = game.createEvent('chooseShengjie');
                    next.player = this;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'cards')
                            next.materials = arguments[i];
                        else if (typeof arguments[i] == 'boolean')
                            next.forced = arguments[i];
                        else if (typeof arguments[i] == 'string')
                            next.prompt = arguments[i];
                        else if (get.itemtype(arguments[i]) == 'select' || typeof arguments[i] == 'number')
                            next.select = arguments[i];
                        else if (typeof arguments[i] == 'function')
                            next.filterProduct = arguments[i];
                        else if (typeof arguments[i] == 'function')
                            next.filterMaterial = arguments[i];
                    }
                    if (!this.canShengjie.apply(this, arguments))
                        return;
                    if (next.prompt == undefined)
                        next.prompt = '请选择升阶获得的卡牌';
                    if (next.select == undefined)
                        next.select = [1, Infinity];
                    next.setContent('chooseShengjie');
                    return next;
                },
                canShengjie: function () {
                    if (lib.configOL.protect_beginner)
                        return false;
                    var list = [];
                    if (!lib.cardPack.mode_derivation || !lib.cardPack.mode_derivation.length)
                        return false;
                    for (var i = 0; i < lib.cardPack.mode_derivation.length; i++) {
                        var info = lib.card[lib.cardPack.mode_derivation[i]];
                        if (info && info.materials && (typeof info.materials == 'function' || Array.isArray(info.materials)))
                            list.push(lib.cardPack.mode_derivation[i]);
                    }
                    var materials, select, filterProduct, bool = false;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'cards')
                            materials = arguments[i];
                        else if (get.itemtype(arguments[i]) == 'select' || typeof arguments[i] == 'number')
                            select = arguments[i];
                        else if (typeof arguments[i] == 'function')
                            filterProduct = arguments[i];
                    }
                    if (filterProduct)
                        list = list.filter(filterProduct);
                    if (!materials || !list.length)
                        return false;
                    if (select == undefined)
                        select = [1, Infinity];
                    var materialList = [];
                    var cards = materials.slice(0);
                    var l = cards.length;
                    var all = Math.pow(l, 2);
                    for (var i = 1; i < all; i++) {
                        var array = [];
                        for (var j = 0; j < l; j++) {
                            if (Math.floor((i % Math.pow(2, j + 1)) / Math.pow(2, j)) > 0)
                                array.push(cards[j]);
                        }
                        if ((get.itemtype(select) == 'select' && array.length >= select[0] && array.length <= select[1])
                            || (typeof select == 'number' && array.length == select))
                            materialList.push(array);
                    }
                    for (var _i = 0, materialList_1 = materialList; _i < materialList_1.length; _i++) {
                        var j = materialList_1[_i];
                        for (var _a = 0, list_1 = list; _a < list_1.length; _a++) {
                            var k = list_1[_a];
                            var filter = get.info({ name: k }).materials;
                            if (Array.isArray(filter) && filter.length == j.length) {
                                var mate = filter.slice(0);
                                for (var l = 0; l < mate.length; l++) {
                                    for (var _b = 0, j_1 = j; _b < j_1.length; _b++) {
                                        var card = j_1[_b];
                                        if (get.is.filterCardBy(card, mate[l])) {
                                            mate.splice(l--, 1);
                                        }
                                    }
                                }
                                if (mate.length == 0) {
                                    bool = true;
                                }
                            }
                            if (typeof filter == 'function') {
                                bool = filter(j);
                            }
                        }
                    }
                    return bool;
                },
                //新函数
                /**
                 * 将技能移入本角色的封锁列表
                 */
                addSkillBlocker: function (skill) {
                    if (!this.storage.skill_blocker)
                        this.storage.skill_blocker = [];
                    this.storage.skill_blocker.push(skill);
                },
                /**
                 * 将技能移出本角色的封锁列表
                 */
                removeSkillBlocker: function (skill) {
                    if (this.storage.skill_blocker) {
                        this.storage.skill_blocker.remove(skill);
                        if (!this.storage.skill_blocker.length)
                            delete this.storage.skill_blocker;
                    }
                },
                /**
                 * 将本角色的卡牌移入(目标角色)特殊区
                 */
                loseToSpecial: function (cards, tag, target) {
                    var next = game.loseAsync({
                        player: this,
                        cards: cards,
                        tag: tag,
                        toStorage: true,
                        target: target || this
                    });
                    next.setContent(function () {
                        "step 0";
                        player.lose(cards, ui.special).set('getlx', false);
                        "step 1";
                        target.directgains(cards, null, event.tag);
                    });
                    return next;
                },
                /**
                 * 为本角色的手牌添加标签
                 */
                addGaintag: function (cards, tag) {
                    if (get.itemtype(cards) == 'card')
                        cards = [cards];
                    game.addVideo('addGaintag', this, [get.cardsInfo(cards), tag]);
                    game.broadcastAll(function (player, cards, tag) {
                        var hs = player.getCards('h');
                        for (var _i = 0, cards_2 = cards; _i < cards_2.length; _i++) {
                            var i = cards_2[_i];
                            if (hs.contains(i))
                                i.addGaintag(tag);
                        }
                    }, this, cards, tag);
                },
                /**
                 * 为本角色手牌移除标签
                 */
                removeGaintag: function (tag, cards) {
                    game.addVideo('removeGaintag', this, tag);
                    game.broadcastAll(function (player, tag, cards) {
                        cards = cards || player.getCards('h');
                        for (var _i = 0, cards_3 = cards; _i < cards_3.length; _i++) {
                            var i = cards_3[_i];
                            i.removeGaintag(tag);
                        }
                    }, this, tag, cards);
                },
                /**
                 * 判断本角色能否在濒死求桃事件中救治目标角色
                 * @param {string} target 目标角色
                 * @returns {!boolean} 可以救治返回`true`，不可以返回`false`
                 */
                canSave: function (target) {
                    var player = this;
                    if (player.hasSkillTag('save', true, target, true))
                        return true;
                    var name = {}, hs = player.getCards('hs');
                    for (var _i = 0, hs_1 = hs; _i < hs_1.length; _i++) {
                        var i = hs_1[_i];
                        name[get.name(i)] = true;
                    }
                    for (var i in lib.card) {
                        if (lib.card[i].savable && (lib.inpile.contains(i) || name[i])) {
                            if (lib.filter.cardSavable({ name: i }, player, target) && (_status.connectMode || player.hasUsableCard(i)))
                                return true;
                        }
                    }
                    return false;
                },
                /**
                 * 展示本角色
                 * @param {(0|1|2)} num 0:展示主将; 1: 展示副将; 2: 全部展示
                 * @param {?boolean} [log] 如果为true或未指定，输出日志；如果为false，不输出日志
                 * @returns {GameCores.Bases.Event}
                 */
                showCharacter: function (num, log) {
                    var toShow = [];
                    if ((num == 0 || num == 2) && this.isUnseen(0))
                        toShow.add(this.name1);
                    if ((num == 1 || num == 2) && this.isUnseen(1))
                        toShow.add(this.name2);
                    if (!toShow.length)
                        return;
                    lib.element.player.$showCharacter.apply(this, arguments);
                    var next = game.createEvent('showCharacter', false);
                    next.player = this;
                    next.num = num;
                    next.toShow = toShow;
                    next._args = arguments;
                    next.setContent('showCharacter');
                    return next;
                },
                /**
                 * 展示本角色(无事件)
                 * @param {(0|1|2)} num 0:展示主将; 1: 展示副将; 2: 全部展示
                 * @param {?boolean} [log] 如果为true或未指定，输出日志；如果为false，不输出日志
                 */
                $showCharacter: function (num, log) {
                    if (num == 0 && !this.isUnseen(0)) {
                        return;
                    }
                    if (num == 1 && (!this.name2 || !this.isUnseen(1))) {
                        return;
                    }
                    if (!this.isUnseen(2)) {
                        return;
                    }
                    game.addVideo('showCharacter', this, num);
                    var skills;
                    switch (num) {
                        case 0:
                            if (log !== false)
                                game.log(this, '展示了主将', '#b' + this.name1);
                            this.name = this.name1;
                            skills = lib.character[this.name][3] || [];
                            this.sex = lib.character[this.name][0];
                            if (this.group == 'unknown')
                                this.group = lib.character[this.name][1];
                            this.classList.remove('unseen');
                            break;
                        case 1:
                            if (log !== false)
                                game.log(this, '展示了副将', '#b' + this.name2);
                            skills = lib.character[this.name2][3] || [];
                            if (this.sex == 'unknown')
                                this.sex = lib.character[this.name2][0];
                            if (this.name.indexOf('unknown') == 0)
                                this.name = this.name2;
                            this.classList.remove('unseen2');
                            break;
                        case 2:
                            if (log !== false) {
                                if (this.name2)
                                    game.log(this, '展示了主将', '#b' + this.name1, '、副将', '#b' + this.name2);
                                else
                                    game.log(this, '展示了主将', '#b' + this.name1);
                            }
                            this.name = this.name1;
                            var skills = (lib.character[this.name][3] || []);
                            if (this.name2)
                                skills = skills.concat(lib.character[this.name2][3] || []);
                            this.sex = lib.character[this.name][0];
                            if (this.group == 'unknown')
                                this.group = lib.character[this.name][1];
                            this.classList.remove('unseen');
                            this.classList.remove('unseen2');
                            break;
                    }
                    if (!this.isUnseen(2)) {
                        delete this.storage.nohp;
                        this.hp = this.storage.rawHp + this.maxHp - 1;
                        this.maxHp = this.storage.rawMaxHp + this.maxHp - 1;
                        this.node.hp.show();
                        this.update();
                    }
                    game.broadcast(function (player, name, sex, num, group) {
                        player.group = group;
                        player.name = name;
                        player.sex = sex;
                        switch (num) {
                            case 0:
                                player.classList.remove('unseen');
                                break;
                            case 1:
                                player.classList.remove('unseen2');
                                break;
                            case 2:
                                player.classList.remove('unseen');
                                player.classList.remove('unseen2');
                                break;
                        }
                        if (!player.isUnseen(2)) {
                            delete player.storage.nohp;
                            player.node.hp.show();
                            player.update();
                        }
                    }, this, this.name, this.sex, num, this.group);
                    for (var i = 0; i < skills.length; i++) {
                        if (this.hiddenSkills.contains(skills[i])) {
                            this.hiddenSkills.remove(skills[i]);
                            this.addSkill(skills[i]);
                        }
                    }
                    this.checkConflict();
                },
                /**
                 * 观星
                 * 本角色观看牌堆顶的`num`张牌并将其以任意顺序置于牌堆顶或牌堆底
                 * @param {number} num
                 * @returns {GameCores.Bases.Event}
                 */
                chooseToGuanxing: function (num) {
                    var next = game.createEvent('chooseToGuanxing');
                    next.num = num || 1;
                    next.player = this;
                    next.setContent('chooseToGuanxing');
                    return next;
                },
                /**
                 * 向其他角色发送互动表情(本机)
                 * @param {!GameCores.GameObjects.Player} 互动的对象
                 * @param {!string} emotion 表情
                 */
                $throwEmotion: function (target, name) {
                    game.addVideo('throwEmotion', this, [target.dataset.position, name]);
                    var getLeft = function (player) {
                        if (player == game.me && !ui.fakeme && !ui.chess)
                            return player.getLeft() + player.node.avatar.offsetWidth / 2;
                        return player.getLeft() + player.offsetWidth / 2;
                    };
                    var player = this;
                    var emotion = ui.create.div('', '<div style="text-align:center"> <img src="' + lib.assetURL + 'image/emotion/throw_emotion/' + name + '1.png"> </div>', game.chess ? ui.chess : ui.window);
                    emotion.style.width = '60px';
                    emotion.style.height = '60px';
                    var width = emotion.offsetWidth / 2;
                    var height = emotion.offsetHeight / 2;
                    if (game.chess)
                        width += 60;
                    var left = getLeft(player) - width;
                    var top = player.getTop() + player.offsetHeight / 3 - height;
                    emotion.style.left = left + 'px';
                    emotion.style.top = top + 'px';
                    var left2 = getLeft(target) - width;
                    var top2 = target.getTop() + target.offsetHeight / 3 - height;
                    emotion.style['z-index'] = 10;
                    emotion.style.transform = 'translateY(' + (top2 - top) + 'px) translateX(' + (left2 - left) + 'px)';
                    if (lib.config.background_audio)
                        game.playAudio('effect', 'throw_' + name + get.rand(1, 2));
                    setTimeout(function () {
                        emotion.innerHTML = ('<div style="text-align:center"> <img src="' + lib.assetURL + 'image/emotion/throw_emotion/' + name + '2.png"> </div>');
                        setTimeout(function () {
                            emotion["delete"]();
                        }, 1200);
                    }, 600);
                },
                /**
                 * 本角色尝试播放一个技能动画[support online]
                 * @param {string} name 技能名
                 * @param {string} popname 弹出的名称，如果`popname`等于`name`，使用`get.skillTranslation(name, this)`作为弹出的名称
                 * @param {?boolean} [checkShow]
                 */
                trySkillAnimate: function (name, popname, checkShow) {
                    if (!game.online && lib.config.skill_animation_type != 'off' && lib.skill[name] && lib.skill[name].skillAnimation) {
                        if (lib.config.skill_animation_type == 'default') {
                            checkShow = checkShow || 'main';
                        }
                        else {
                            checkShow = false;
                        }
                        if (lib.skill[name].textAnimation) {
                            checkShow = false;
                        }
                        this.$skill(lib.skill[name].animationStr || lib.translate[name], lib.skill[name].skillAnimation, lib.skill[name].animationColor, checkShow);
                        return;
                    }
                    var player = this;
                    game.broadcast(function (player, name, popname) {
                        player.trySkillAnimate(name, popname);
                    }, player, name, popname);
                    if (lib.animate.skill[name])
                        lib.animate.skill[name].apply(this, arguments);
                    else {
                        if (popname != name)
                            this.popup(popname, 'water', false);
                        else
                            this.popup(get.skillTranslation(name, this), 'water', false);
                    }
                },
                /**
                 * 本角色尝试播放一个游戏牌动画[support online]
                 * @param {!GameCores.GameObjects.Card} card
                 * @param {string} name 游戏牌名
                 * @param {string} nature 属性
                 * @param {?string} [popname] 弹出的名称，如果未指定，使用`name`作为弹出的名称
                 */
                tryCardAnimate: function (card, name, nature, popname) {
                    var player = this;
                    game.broadcast(function (player, card, name, nature, popname) {
                        player.tryCardAnimate(card, name, nature, popname);
                    }, player, card, name, nature, popname);
                    if (lib.animate.card[card.name])
                        lib.animate.card[card.name].apply(this, arguments);
                    else {
                        if (!lib.config.show_card_prompt)
                            return;
                        if (get.type(card) == 'equip' && lib.config.hide_card_prompt_equip)
                            return;
                        if (get.type(card) == 'basic' && lib.config.hide_card_prompt_basic)
                            return;
                        if (popname)
                            player.popup({ name: card.name, nature: card.nature }, nature, false);
                        else
                            player.popup(name, nature, false);
                    }
                },
                hasUsableCard: function (name) {
                    var player = this;
                    if (player.countCards('hs', name))
                        return true;
                    var skills = player.getSkills(true).concat(lib.skill.global);
                    game.expandSkills(skills);
                    for (var i = 0; i < skills.length; i++) {
                        var ifo = get.info(skills[i]);
                        if (ifo.viewAs && typeof ifo.viewAs != 'function' && ifo.viewAs.name == name) {
                            if (!ifo.viewAsFilter || ifo.viewAsFilter(player)) {
                                return true;
                            }
                        }
                        else {
                            var hiddenCard = get.info(skills[i]).hiddenCard;
                            if (typeof hiddenCard == 'function' && hiddenCard(player, name)) {
                                return true;
                            }
                        }
                    }
                },
                /**
                 * 判断目标角色是否在本角色的攻击范围内
                 * @param {string} to 目标角色
                 * @returns {!boolean} 在范围内返回`true`，在范围外返回`false`
                 */
                inRange: function (to) {
                    var from = this;
                    if (from == to || from.hasSkill('undist') || to.hasSkill('undist'))
                        return false;
                    if (!game.players.contains(from) && !game.dead.contains(from))
                        return false;
                    if (!game.players.contains(to) && !game.dead.contains(to))
                        return false;
                    var mod1 = game.checkMod(from, to, 'unchanged', 'inRange', from);
                    if (mod1 != 'unchanged')
                        return mod1;
                    var mod2 = game.checkMod(from, to, 'unchanged', 'inRangeOf', to);
                    if (mod2 != 'unchanged')
                        return mod2;
                    if (from.getAttackRange() < 1)
                        return false;
                    var player = from, m, n = 1, i;
                    var fxy, txy;
                    if (game.chess) {
                        fxy = from.getXY();
                        txy = to.getXY();
                        n = Math.abs(fxy[0] - txy[0]) + Math.abs(fxy[1] - txy[1]);
                    }
                    else if (to.isMin(true) || from.isMin(true)) { }
                    else {
                        var length = game.players.length;
                        var totalPopulation = game.players.length + game.dead.length + 1;
                        for (var iwhile = 0; iwhile < totalPopulation; iwhile++) {
                            if (player.nextSeat != to) {
                                player = player.nextSeat;
                                if (player.isAlive() && !player.isOut() && !player.hasSkill('undist') && !player.isMin(true))
                                    n++;
                            }
                            else {
                                break;
                            }
                        }
                        for (i = 0; i < game.players.length; i++) {
                            if (game.players[i].isOut() || game.players[i].hasSkill('undist') || game.players[i].isMin(true))
                                length--;
                        }
                        if (from.isDead())
                            length++;
                        if (to.isDead())
                            length++;
                        var left = from.hasSkillTag('left_hand');
                        var right = from.hasSkillTag('right_hand');
                        if (left === right)
                            n = Math.min(n, length - n);
                        else if (left == true)
                            n = length - n;
                    }
                    n = game.checkMod(from, to, n, 'globalFrom', from);
                    n = game.checkMod(from, to, n, 'globalTo', to);
                    m = n;
                    m = game.checkMod(from, to, m, 'attackFrom', from);
                    m = game.checkMod(from, to, m, 'attackTo', to);
                    var equips1 = from.getCards('e', function (card) {
                        return !ui.selected.cards || !ui.selected.cards.contains(card);
                    }), equips2 = to.getCards('e', function (card) {
                        return !ui.selected.cards || !ui.selected.cards.contains(card);
                    });
                    for (i = 0; i < equips1.length; i++) {
                        var info = get.info(equips1[i]).distance;
                        if (!info)
                            continue;
                        if (info.globalFrom) {
                            m += info.globalFrom;
                            n += info.globalFrom;
                        }
                        if (info.attackFrom) {
                            m += info.attackFrom;
                        }
                    }
                    for (i = 0; i < equips2.length; i++) {
                        var info = get.info(equips2[i]).distance;
                        if (!info)
                            continue;
                        if (info.globalTo) {
                            m += info.globalTo;
                            n += info.globalTo;
                        }
                        if (info.attaclTo) {
                            m += info.attaclTo;
                        }
                    }
                    return m <= 1;
                },
                /**
                 * 判断本角色是否在目标角色的攻击范围内
                 * @param {string} source 目标角色
                 * @returns {!boolean} 在范围内返回`true`，在范围外返回`false`
                 */
                inRangeOf: function (source) {
                    return source.inRange(this);
                },
                /**
                 * 获得本角色已损失的体力值
                 * @returns {!number} this.maxHp - Math.max(0, this.hp)
                 */
                getDamagedHp: function () {
                    return this.maxHp - Math.max(0, this.hp);
                },
                changeGroup: function (group, log, broadcast) {
                    var player = this;
                    if (broadcast !== false) {
                        game.broadcast(function (player, group) {
                            player.group = group;
                            player.node.name.dataset.nature = get.groupnature(group);
                        }, player, group);
                    }
                    player.group = group;
                    player.node.name.dataset.nature = get.groupnature(group);
                    if (log !== false)
                        game.log(this, '将势力变为了', '#y' + get.translation(group + 2));
                },
                chooseToDuiben: function (target) {
                    var next = game.createEvent('chooseToDuiben');
                    next.player = this;
                    next.target = target;
                    next.setContent('chooseToDuiben');
                    return next;
                },
                chooseToPSS: function (target) {
                    var next = game.createEvent('chooseToPSS');
                    next.player = this;
                    next.target = target;
                    next.setContent('chooseToPSS');
                    return next;
                },
                chooseToEnable: function () {
                    var next = game.createEvent('chooseToEnable');
                    next.player = this;
                    next.setContent('chooseToEnable');
                    return next;
                },
                chooseToDisable: function (horse) {
                    var next = game.createEvent('chooseToDisable');
                    next.player = this;
                    if (horse)
                        next.horse = true;
                    next.setContent('chooseToDisable');
                    return next;
                },
                countDisabled: function () {
                    if (!this.storage.disableEquip)
                        return 0;
                    return this.storage.disableEquip.length;
                },
                isPhaseUsing: function (notmeisok) {
                    if (!notmeisok && _status.currentPhase != this)
                        return false;
                    return _status.event.name == 'phaseUse' || _status.event.getParent('phaseUse').name == 'phaseUse';
                },
                swapEquip: function (target, subtype) {
                    var next = game.createEvent('swapEquip');
                    next.player = this;
                    next.target = target;
                    next.subtype = subtype;
                    next.setContent('swapEquip');
                    return next;
                },
                canCompare: function (target) {
                    if (this == target)
                        return false;
                    if (!this.countCards('h') || !target.countCards('h'))
                        return false;
                    if (this.hasSkillTag('noCompareSource') || target.hasSkillTag('noCompareTarget'))
                        return false;
                    return true;
                },
                disableEquip: function (pos) {
                    if (typeof pos == 'number')
                        pos = 'equip' + pos;
                    var next = game.createEvent('disableEquip');
                    next.player = this;
                    next.pos = pos;
                    next.source = _status.event.player;
                    next.setContent('disableEquip');
                    return next;
                },
                $disableEquip: function (skill) {
                    game.broadcast(function (player, skill) {
                        player.$disableEquip(skill);
                    }, this, skill);
                    var player = this;
                    if (!player.storage.disableEquip)
                        player.storage.disableEquip = [];
                    player.storage.disableEquip.add(skill);
                    player.storage.disableEquip.sort();
                    var pos = { equip1: '武器栏', equip2: '防具栏', equip3: '+1马栏', equip4: '-1马栏', equip5: '宝物栏' }[skill];
                    if (!pos)
                        return;
                    var card = game.createCard('feichu_' + skill, pos, '');
                    card.fix();
                    card.style.transform = '';
                    card.classList.remove('drawinghidden');
                    card.classList.add('feichu');
                    delete card._transform;
                    var equipNum = get.equipNum(card);
                    var equipped = false;
                    for (var i = 0; i < player.node.equips.childNodes.length; i++) {
                        if (get.equipNum(player.node.equips.childNodes[i]) >= equipNum) {
                            player.node.equips.insertBefore(card, player.node.equips.childNodes[i]);
                            equipped = true;
                            break;
                        }
                    }
                    if (!equipped) {
                        player.node.equips.appendChild(card);
                        if (_status.discarded) {
                            _status.discarded.remove(card);
                        }
                    }
                    return player;
                },
                enableEquip: function (pos) {
                    if (typeof pos == 'number')
                        pos = 'equip' + pos;
                    var next = game.createEvent('enableEquip');
                    next.player = this;
                    next.pos = pos;
                    next.source = _status.event.player;
                    next.setContent('enableEquip');
                    return next;
                },
                $enableEquip: function (skill) {
                    game.broadcast(function (player, skill) {
                        player.$enableEquip(skill);
                    }, this, skill);
                    var player = this;
                    if (player.storage.disableEquip)
                        player.storage.disableEquip.remove(skill);
                    for (var i = 0; i < player.node.equips.childNodes.length; i++) {
                        if (player.node.equips.childNodes[i].name == 'feichu_' + skill) {
                            player.node.equips.removeChild(player.node.equips.childNodes[i]);
                            break;
                        }
                    }
                    return player;
                },
                isDisabled: function (arg) {
                    if (typeof arg == 'number')
                        arg = 'equip' + arg;
                    if (arg == 'equip6' && this.storage.disableEquip && (this.storage.disableEquip.contains('equip3') || this.storage.disableEquip.contains('equip4')))
                        return true;
                    if (this.storage.disableEquip && this.storage.disableEquip.contains(arg))
                        return true;
                    return false;
                },
                isEmpty: function (num) {
                    if (num == 6 || num == 'equip6') {
                        if (!this.isEmpty(3) || !this.isEmpty(4))
                            return false;
                    }
                    else if ([3, 4, 'equip3', 'equip4'].contains(num)) {
                        if (this.getEquip(6))
                            return false;
                    }
                    return !this.isDisabled(num) && !this.getEquip(num);
                },
                $disableJudge: function () {
                    var player = this;
                    var card = game.createCard('disable_judge', '', '');
                    player.storage._disableJudge = true;
                    card.fix();
                    card.classList.add('feichu');
                    card.style.transform = '';
                    card.classList.add('drawinghidden');
                    player.node.judges.insertBefore(card, player.node.judges.firstChild);
                    ui.updatej(player);
                },
                $enableJudge: function () {
                    var player = this;
                    player.storage._disableJudge = false;
                    for (var i = 0; i < player.node.judges.childNodes.length; i++) {
                        if (player.node.judges.childNodes[i].name == 'disable_judge') {
                            player.node.judges.removeChild(player.node.judges.childNodes[i]);
                            break;
                        }
                    }
                },
                disableJudge: function () {
                    var next = game.createEvent('disableJudge');
                    next.player = this;
                    next.source = _status.event.player;
                    next.setContent('disableJudge');
                    return next;
                },
                enableJudge: function () {
                    var next = game.createEvent('enableJudge');
                    next.player = this;
                    next.source = _status.event.player;
                    next.setContent('enableJudge');
                    return next;
                },
                //原有函数
                /**
                 * 角色初始化
                 * @param {?string} character 角色名，如果未指定，函数直接返回undefined
                 * @param {(string|false)} character2 如果为角色名，创建双将角色；如果为false，创建单将
                 * @param {!boolean} skill 如果为true，添加技能；如果为false，不添加角色技能；该参数在`character2`参数为false时无效
                 * @returns {GameCores.GameObjects.Card} 角色对象
                 */
                init: function (character, character2, skill) {
                    if (typeof character == 'string' && !lib.character[character]) {
                        lib.character[character] = get.character(character);
                    }
                    if (typeof character2 == 'string' && !lib.character[character2]) {
                        lib.character[character2] = get.character(character2);
                    }
                    if (!lib.character[character])
                        return;
                    if (get.is.jun(character2)) {
                        var tmp = character;
                        character = character2;
                        character2 = tmp;
                    }
                    if (character2 == false) {
                        skill = false;
                        character2 = null;
                    }
                    var info = lib.character[character];
                    if (!info) {
                        info = ['', '', 1, [], []];
                    }
                    if (!info[4]) {
                        info[4] = [];
                    }
                    var skills = info[3].slice(0);
                    this.clearSkills(true);
                    this.classList.add('fullskin');
                    if (!game.minskin && get.is.newLayout() && !info[4].contains('minskin')) {
                        this.classList.remove('minskin');
                        this.node.avatar.setBackground(character, 'character');
                    }
                    else {
                        this.node.avatar.setBackground(character, 'character');
                        if (info[4].contains('minskin')) {
                            this.classList.add('minskin');
                        }
                        else if (game.minskin) {
                            this.classList.add('minskin');
                        }
                        else {
                            this.classList.remove('minskin');
                        }
                    }
                    var hp1 = get.infoHp(info[2]);
                    var maxHp1 = get.infoMaxHp(info[2]);
                    this.node.avatar.show();
                    this.node.count.show();
                    this.node.equips.show();
                    this.name = character;
                    this.name1 = character;
                    this.sex = info[0];
                    this.group = info[1];
                    this.hp = hp1;
                    this.maxHp = maxHp1;
                    this.hujia = 0;
                    this.node.intro.innerHTML = lib.config.intro;
                    this.node.name.dataset.nature = get.groupnature(this.group);
                    lib.setIntro(this);
                    this.node.name.innerHTML = get[get.slimName2 ? 'slimName2' : 'slimName'](character);
                    if (this.classList.contains('minskin') && this.node.name.querySelectorAll('br').length >= 4) {
                        this.node.name.classList.add('long');
                    }
                    if (info[4].contains('hiddenSkill') && !this.noclick) {
                        if (!this.hiddenSkills)
                            this.hiddenSkills = [];
                        this.hiddenSkills.addArray(skills);
                        skills = [];
                        this.classList.add(_status.video ? 'unseen_v' : 'unseen');
                        this.name = 'unknown';
                        if (!this.node.name_seat && !_status.video) {
                            this.node.name_seat = ui.create.div('.name.name_seat', get.verticalStr(get.translation(this.name)), this);
                            this.node.name_seat.dataset.nature = get.groupnature(this.group);
                        }
                        this.sex = 'male';
                        //this.group='unknown';
                        this.storage.nohp = true;
                        skills.add('g_hidden_ai');
                    }
                    if (character2 && lib.character[character2]) {
                        var info2 = lib.character[character2];
                        if (!info2) {
                            info2 = ['', '', 1, [], []];
                        }
                        if (!info2[4]) {
                            info2[4] = [];
                        }
                        this.classList.add('fullskin2');
                        this.node.avatar2.setBackground(character2, 'character');
                        this.node.avatar2.show();
                        this.name2 = character2;
                        var hp2 = get.infoHp(info2[2]);
                        var maxHp2 = get.infoMaxHp(info2[2]);
                        var double_hp;
                        if (_status.connectMode || get.mode() == 'single') {
                            double_hp = 'pingjun';
                        }
                        else {
                            double_hp = get.config('double_hp');
                        }
                        switch (double_hp) {
                            case 'pingjun': {
                                this.maxHp = Math.floor((maxHp1 + maxHp2) / 2);
                                this.hp = Math.floor((hp1 + hp2) / 2);
                                this.singleHp = ((maxHp1 + maxHp2) % 2 === 1);
                                break;
                            }
                            case 'zuidazhi': {
                                this.maxHp = Math.max(maxHp1, maxHp2);
                                this.hp = Math.max(hp1, hp2);
                                break;
                            }
                            case 'zuixiaozhi': {
                                this.maxHp = Math.min(maxHp1, maxHp2);
                                this.hp = Math.min(hp1, hp2);
                                break;
                            }
                            case 'zonghe': {
                                this.maxHp = maxHp1 + maxHp2;
                                this.hp = hp1 + hp2;
                                break;
                            }
                            default:
                                {
                                    this.maxHp = maxHp1 + maxHp2 - 3;
                                    this.hp = hp1 + hp2 - 3;
                                }
                                ;
                        }
                        this.node.count.classList.add('p2');
                        if (info2[4].contains('hiddenSkill') && !this.noclick) {
                            if (!this.hiddenSkills)
                                this.hiddenSkills = [];
                            this.hiddenSkills.addArray(info2[3]);
                            this.classList.add(_status.video ? 'unseen2_v' : 'unseen2');
                            this.storage.nohp = true;
                            skills.add('g_hidden_ai');
                        }
                        else
                            skills = skills.concat(info2[3]);
                        this.node.name2.innerHTML = get.slimName(character2);
                    }
                    if (this.storage.nohp) {
                        this.storage.rawHp = this.hp;
                        this.storage.rawMaxHp = this.maxHp;
                        this.hp = 1;
                        this.maxHp = 1;
                        this.node.hp.hide();
                    }
                    if (skill != false) {
                        for (var i = 0; i < skills.length; i++) {
                            this.addSkill(skills[i]);
                        }
                        this.checkConflict();
                    }
                    lib.group.add(this.group);
                    if (this.inits) {
                        for (var i = 0; i < lib.element.player.inits.length; i++) {
                            lib.element.player.inits[i](this);
                        }
                    }
                    if (this._inits) {
                        for (var i = 0; i < this._inits.length; i++) {
                            this._inits[i](this);
                        }
                    }
                    this.update();
                    return this;
                },
                /**
                 * 角色初始化[support online]
                 * @param {string} name 玩家名
                 * @param {string} character 角色名
                 */
                initOL: function (name, character) {
                    this.node.avatar.setBackground(character, 'character');
                    this.node.avatar.show();
                    this.node.name.innerHTML = get.verticalStr(name);
                    this.nickname = name;
                    this.avatar = character;
                    this.node.nameol.innerHTML = '';
                    if (lib.character[character])
                        this.sex = lib.character[character][0];
                },
                /**
                 * 在角色销毁时调用[support online]
                 */
                uninitOL: function () {
                    this.node.avatar.hide();
                    this.node.name.innerHTML = '';
                    this.node.identity.firstChild.innerHTML = '';
                    delete this.nickname;
                    delete this.avatar;
                    delete this.sex;
                },
                /**
                 * 初始化房间
                 * @returns {GameCores.GameObjects.Player} this self
                 * @param {Array} info 房间信息
                 */
                initRoom: function (info, info2) {
                    var str = '';
                    this.serving = false;
                    if (!info || info == 'server') {
                        this.roomempty = true;
                        str = '空房间';
                        this.roomfull = false;
                        this.roomgaming = false;
                        this.version = null;
                        if (info == 'server') {
                            this.serving = true;
                        }
                    }
                    else {
                        var config = info[2];
                        this.key = info[4];
                        this.roomempty = false;
                        str += get.modetrans(config);
                        str += ' 模式　';
                        for (var i = str.length; i < 11; i++)
                            str += '　';
                        this.version = config.version;
                        if (config.gameStarted) {
                            str += '<span class="firetext">游戏中</span>　';
                            if (config.observe && config.observeReady && this.version == lib.versionOL) {
                                this.classList.remove('exclude');
                            }
                            else {
                                this.classList.add('exclude');
                            }
                        }
                        else {
                            str += '<span class="greentext">等待中</span>　';
                            if (this.version != lib.versionOL) {
                                this.classList.add('exclude');
                            }
                            else {
                                this.classList.remove('exclude');
                            }
                        }
                        this.maxHp = parseInt(config.number);
                        this.hp = Math.min(this.maxHp, info[3]);
                        if (this.hp < this.maxHp || config.gameStarted)
                            str += ('人数：' + this.hp + '/' + this.maxHp);
                        else
                            str += ('人数：<span class="firetext">' + this.hp + '/' + this.maxHp + '</span>');
                        str += ('　(' + info[0].slice(0, 12) + ' 的房间)');
                        this.config = config;
                        if (this.hp == this.maxHp && !config.gameStarted) {
                            this.roomfull = true;
                        }
                        else {
                            this.roomfull = false;
                        }
                        if (config.gameStarted && (!config.observe || !config.observeReady)) {
                            this.roomgaming = true;
                        }
                        else {
                            this.roomgaming = false;
                        }
                    }
                    this.firstChild.innerHTML = str;
                    return this;
                },
                /**
                 * TODO - 重新初始化
                 * @param {*} from
                 * @param {*} to
                 * @param {*} maxHp
                 * @param {*} online
                 * @returns {(undefined|GameCores.GameObjects.Player)}
                 */
                reinit: function (from, to, maxHp, online) {
                    var info1 = lib.character[from];
                    var info2 = lib.character[to];
                    var smooth = true;
                    if (maxHp == 'nosmooth') {
                        smooth = false;
                        maxHp = null;
                    }
                    if (this.name2 == from) {
                        this.name2 = to;
                        if (this.isUnseen(0) && !this.isUnseen(1)) {
                            this.sex = info2[0];
                            this.name = to;
                        }
                        if (smooth)
                            this.smoothAvatar(true);
                        this.node.avatar2.setBackground(to, 'character');
                        this.node.name2.innerHTML = get.slimName(to);
                    }
                    else if (this.name == from || this.name1 == from) {
                        if (this.name1 == from) {
                            this.name1 = to;
                        }
                        if (!this.classList.contains('unseen2')) {
                            this.name = to;
                            this.sex = info2[0];
                        }
                        if (smooth)
                            this.smoothAvatar(false);
                        this.node.avatar.setBackground(to, 'character');
                        this.node.name.innerHTML = get.slimName(to);
                        if (this == game.me && ui.fakeme) {
                            ui.fakeme.style.backgroundImage = this.node.avatar.style.backgroundImage;
                        }
                    }
                    else {
                        return this;
                    }
                    if (online) {
                        return;
                    }
                    for (var i = 0; i < info1[3].length; i++) {
                        this.removeSkill(info1[3][i]);
                    }
                    for (var i = 0; i < info2[3].length; i++) {
                        this.addSkill(info2[3][i]);
                    }
                    if (Array.isArray(maxHp)) {
                        this.maxHp = maxHp[1];
                        this.hp = maxHp[0];
                    }
                    else {
                        var num;
                        if (maxHp === false) {
                            num = 0;
                        }
                        else {
                            if (typeof maxHp != 'number') {
                                maxHp = get.infoMaxHp(info2[2]);
                            }
                            num = maxHp - get.infoMaxHp(info1[2]);
                        }
                        if (typeof this.singleHp == 'boolean') {
                            if (num % 2 != 0) {
                                if (this.singleHp) {
                                    this.maxHp += (num + 1) / 2;
                                    this.singleHp = false;
                                }
                                else {
                                    this.maxHp += (num - 1) / 2;
                                    this.singleHp = true;
                                    if (!game.online) {
                                        this.doubleDraw();
                                    }
                                }
                            }
                            else {
                                this.maxHp += num / 2;
                            }
                        }
                        else {
                            this.maxHp += num;
                        }
                    }
                    game.broadcast(function (player, from, to, skills) {
                        player.reinit(from, to, null, true);
                        player.applySkills(skills);
                    }, this, from, to, get.skillState(this));
                    game.addVideo('reinit3', this, {
                        from: from,
                        to: to,
                        hp: this.maxHp,
                        avatar2: this.name2 == to
                    });
                    this.update();
                },
                /**
                 * 在角色销毁时调用
                 * @returns {!GameCores.GameObjects.Player} this self
                 */
                uninit: function () {
                    for (var i = 1; i < 6; i++) {
                        if (this.isDisabled(i))
                            this.$enableEquip('equip' + i);
                    }
                    if (this.storage._disableJudge) {
                        game.broadcastAll(function (player) {
                            player.storage._disableJudge = false;
                            for (var i = 0; i < player.node.judges.childNodes.length; i++) {
                                if (player.node.judges.childNodes[i].name == 'disable_judge') {
                                    player.node.judges.removeChild(player.node.judges.childNodes[i]);
                                    break;
                                }
                            }
                        }, this);
                    }
                    this.node.avatar.hide();
                    this.node.count.hide();
                    if (this.node.wuxing) {
                        this.node.wuxing.hide();
                    }
                    if (this.node.name_seat) {
                        this.node.name_seat.remove();
                        delete this.node.name_seat;
                    }
                    if (this.storage.nohp)
                        this.node.hp.show();
                    this.classList.remove('unseen');
                    this.classList.remove('unseen2');
                    delete this.name;
                    delete this.name1;
                    delete this.sex;
                    delete this.group;
                    delete this.hp;
                    delete this.maxHp;
                    delete this.hujia;
                    this.clearSkills(true);
                    this.node.identity.style.backgroundColor = '';
                    this.node.intro.innerHTML = '';
                    this.node.name.innerHTML = '';
                    this.node.hp.innerHTML = '';
                    this.node.count.innerHTML = '0';
                    if (this.name2) {
                        delete this.singleHp;
                        this.node.avatar2.hide();
                        this.node.name2.innerHTML = '';
                        this.classList.remove('fullskin2');
                        delete this.name2;
                        this.node.count.classList.remove('p2');
                    }
                    for (var mark in this.marks) {
                        this.marks[mark].remove();
                    }
                    ui.updatem(this);
                    this.skipList = [];
                    this.skills = this.skills.contains('cangji_yozuru') ? ['cangji_yozuru'] : [];
                    this.initedSkills = [];
                    this.additionalSkills = {};
                    this.disabledSkills = {};
                    this.hiddenSkills = [];
                    this.awakenedSkills = [];
                    this.forbiddenSkills = {};
                    this.phaseNumber = 0;
                    this.stat = [{ card: {}, skill: {} }];
                    this.tempSkills = {};
                    this.storage = {};
                    this.marks = {};
                    this.ai = { friend: [], enemy: [], neutral: [] };
                    return this;
                },
                /**
                 * 返回`this.offsetLeft`
                 * @returns {!number}
                 */
                getLeft: function () {
                    return this.offsetLeft;
                },
                /**
                 * 返回`this.offsetTop`
                 * @returns {!number}
                 */
                getTop: function () {
                    return this.offsetTop;
                },
                /**
                 * @param {?boolean} [vice] 是否使用副将头像，如果为true则使用副将头像；如果为false或未指定，使用(主将)头像
                 * @param {?boolean} [video] 如果为true或未指定，添加动画；如果为false，不添加动画
                 */
                smoothAvatar: function (vice, video) {
                    var div = ui.create.div('.fullsize');
                    if (vice) {
                        div.style.background = getComputedStyle(this.node.avatar2).background;
                        this.node.avatar2.appendChild(div);
                    }
                    else {
                        div.style.background = getComputedStyle(this.node.avatar).background;
                        this.node.avatar.appendChild(div);
                    }
                    ui.refresh(div);
                    div.style.transition = 'all 1s';
                    setTimeout(function () {
                        div.classList.add('removing');
                        setTimeout(function () {
                            div.remove();
                        }, 2000);
                    }, 100);
                    if (video != false) {
                        game.addVideo('smoothAvatar', this, vice);
                    }
                },
                /**
                 * 强制改变本角色座次，即使目标座次已经有角色存在
                 * @param {number} position
                 * @param {boolean} [video] 如果为true或未指定，添加动画；如果为false，不添加动画
                 */
                changeSeat: function (position, video) {
                    var player = this;
                    if (video !== false)
                        game.addVideo('changeSeat', player, position);
                    var rect1 = player.getBoundingClientRect();
                    player.style.transition = 'all 0s';
                    ui.refresh(player);
                    player.dataset.position = position;
                    var rect2 = player.getBoundingClientRect();
                    var dx = rect1.left - rect2.left;
                    var dy = rect1.top - rect2.top;
                    if ((game.chess || (player.dataset.position != 0 && position != 0)) && player.classList.contains('linked')) {
                        player.style.transform = 'rotate(-90deg) translate(' + (-dy) + 'px,' + (dx) + 'px)';
                    }
                    else {
                        player.style.transform = 'translate(' + (dx) + 'px,' + (dy) + 'px)';
                    }
                    setTimeout(function () {
                        player.style.transition = '';
                        ui.refresh(player);
                        player.style.transform = '';
                    }, 100);
                },
                /**
                 * 将数据(参数)传输至服务器
                 * @returns {!GameCores.GameObjects.Player} this self
                 */
                send: function () {
                    if (!this.ws || this.ws.closed)
                        return this;
                    this.ws.send.apply(this.ws, arguments);
                    return this;
                },
                /**
                 * 为本角色生成并注册ID，如果本角色的ID已经存在就重新生成；如果是在(联机|播放录播)的情况下，该函数不做操作
                 * @returns {!GameCores.GameObjects.Player} this self
                 */
                getId: function () {
                    if (_status.video || _status.connectMode)
                        return this;
                    if (this.playerid) {
                        delete game.playerMap[this.playerid];
                    }
                    this.playerid = get.id();
                    game.playerMap[this.playerid] = this;
                    return this;
                },
                /**
                 * 向其他角色发送互动表情[support online]
                 * @param {!GameCores.GameObjects.Player} 互动的对象
                 * @param {!string} emotion 表情
                 */
                throwEmotion: function (target, emotion) {
                    game.broadcastAll(function (player, target, emotion) {
                        player.$throwEmotion(target, emotion);
                    }, this, target, emotion);
                },
                /**
                 * 本角色发送聊天表情
                 * @param {string} emotionPack 表情包
                 * @param {number} emotionID 表情ID
                 */
                emotion: function (pack, id) {
                    var str = '<img src="##assetURL##image/emotion/' + pack + '/' + id + '.gif" width="50" height="50">';
                    lib.element.player.say.call(this, str);
                    game.broadcast(function (id, str) {
                        if (lib.playerOL[id]) {
                            lib.playerOL[id].say(str);
                        }
                        else if (game.connectPlayers) {
                            for (var i = 0; i < game.connectPlayers.length; i++) {
                                if (game.connectPlayers[i].playerid == id) {
                                    lib.element.player.say.call(game.connectPlayers[i], str);
                                    return;
                                }
                            }
                        }
                    }, this.playerid, str);
                },
                /**
                 * 本角色发送聊天消息[support online]
                 * @param {!string} str 聊天消息
                 */
                chat: function (str) {
                    if (get.is.banWords(str))
                        return;
                    lib.element.player.say.call(this, str);
                    game.broadcast(function (id, str) {
                        if (lib.playerOL[id]) {
                            lib.playerOL[id].say(str);
                        }
                        else if (game.connectPlayers) {
                            for (var i = 0; i < game.connectPlayers.length; i++) {
                                if (game.connectPlayers[i].playerid == id) {
                                    lib.element.player.say.call(game.connectPlayers[i], str);
                                    return;
                                }
                            }
                        }
                    }, this.playerid, str);
                },
                /**
                 * 本角色发送聊天消息(单机)
                 * @param {!string} str 聊天消息
                 */
                say: function (str) {
                    str = str.replace(/##assetURL##/g, lib.assetURL);
                    var dialog = ui.create.dialog('hidden');
                    dialog.classList.add('static');
                    dialog.add('<div class="text" style="word-break:break-all;display:inline">' + str + '</div>');
                    dialog.classList.add('popped');
                    ui.window.appendChild(dialog);
                    var width = dialog.content.firstChild.firstChild.offsetWidth;
                    if (width < 190) {
                        dialog._mod_height = -16;
                    }
                    else {
                        dialog.content.firstChild.style.textAlign = 'left';
                    }
                    dialog.style.width = (width + 16) + 'px';
                    var refnode;
                    if (this.node && this.node.avatar && this.parentNode == ui.arena) {
                        refnode = this.node.avatar;
                    }
                    if (refnode) {
                        lib.placePoppedDialog(dialog, {
                            clientX: (ui.arena.offsetLeft + this.getLeft() + refnode.offsetLeft + refnode.offsetWidth / 2) * game.documentZoom,
                            clientY: (ui.arena.offsetTop + this.getTop() + refnode.offsetTop + refnode.offsetHeight / 4) * game.documentZoom
                        });
                    }
                    else {
                        lib.placePoppedDialog(dialog, {
                            clientX: (this.getLeft() + this.offsetWidth / 2) * game.documentZoom,
                            clientY: (this.getTop() + this.offsetHeight / 4) * game.documentZoom
                        });
                    }
                    if (dialog._mod_height) {
                        dialog.content.firstChild.style.padding = 0;
                    }
                    setTimeout(function () {
                        dialog["delete"]();
                    }, lib.quickVoice.indexOf(str) != -1 ? 3800 : 2000);
                    var name = get.translation(this.name);
                    var info = [name ? (name + '[' + this.nickname + ']') : this.nickname, str];
                    lib.chatHistory.push(info);
                    if (_status.addChatEntry) {
                        if (_status.addChatEntry._origin.parentNode) {
                            _status.addChatEntry(info, false);
                        }
                        else {
                            delete _status.addChatEntry;
                        }
                    }
                    if (lib.config.background_speak && lib.quickVoice.indexOf(str) != -1) {
                        game.playAudio('voice', (this.sex == 'female' ? 'female' : 'male'), lib.quickVoice.indexOf(str));
                    }
                },
                /**
                 * 显示投降按钮
                 */
                showGiveup: function () {
                    this._giveUp = true;
                    if (this == game.me) {
                        ui.create.giveup();
                    }
                    else if (this.isOnline2()) {
                        this.send(ui.create.giveup);
                    }
                },
                /**
                 * 同步技能信息[support online]
                 * @param {Object} skills 要同步的技能信息
                 * @param {?Array<string>} skills.global 全局技能的信息
                 * @param {?Object} skills.skillinfo 技能模板信息
                 * @param {?Object} skills.stat 本角色的技能状态信息
                 * @param {?Object} skills."['playerid']" 角色的技能信息
                 */
                applySkills: function (skills) {
                    for (var i in skills) {
                        if (i == 'global') {
                            lib.skill.global = skills[i];
                        }
                        else if (i == 'skillinfo') {
                            for (var j in skills[i]) {
                                if (!lib.skill[j]) {
                                    lib.skill[j] = {};
                                }
                                lib.skill[j].chooseButton = skills[i][j];
                            }
                        }
                        else if (i == 'stat') {
                            this.stat = [skills.stat];
                        }
                        else if (lib.playerOL[i]) {
                            for (var j in skills[i]) {
                                lib.playerOL[i][j] = skills[i][j];
                            }
                        }
                    }
                },
                /**
                 * 返回本角色状态信息
                 * @returns {GameCores.GameObjects.Player~State}
                 */
                getState: function () {
                    /**
                     * @name GameCores.GameObjects.Player~State
                     * @property {number} hp 当前血量
                     * @property {number} maxHp 最大血量
                     * @property {string} nickname 玩家昵称
                     * @property {string} sex 角色性别
                     * @property {string} group 角色势力
                     * @property {string} name 角色姓名
                     * @property {string} name1 角色(主将)姓名
                     * @property {string} name2 角色(副将)姓名
                     * @property {Array<GameCores.GameObjects.Card>} handcards 角色手牌
                     * @property {Array<string>} gaintag gaintag标签数组
                     * @property {Array<GameCores.GameObjects.Card>} equips 角色装备区的牌
                     * @property {Array<GameCores.GameObjects.Card>} judges 角色判定区的牌
                     * @property {Array<GameCores.GameObjects.Card>} specials 角色武将牌上的牌
                     * @property {Array<string>} disableJudge 对角色无效的判定数组
                     * @property {Array<(string|number)>} disableEquip 角色废除的装备(类型)数组
                     * @property {Array<(string|undefined)>} views 角色判定区牌的视为名数组，即使判定牌的视为名为空也会添加到该数组中，`views`与`judges`一一对应
                     * @property {number} position 角色位置(座次)
                     * @property {number} hujia 角色护甲
                     * @property {(boolean|undefined)} side 角色所属的一侧，如果`p1.side == p2.side`则认为p1与p2为同侧(友方)，否则为异侧(敌方)；该值仅在部分模式(vs等)中使用，在其他模式中默认为undefined
                     * @property {boolean} identityShown 是否显示身份
                     * @property {Array} identityNode [this.node.identity.innerHTML, this.node.identity.dataset.color]
                     * @property {string} identity 角色身份
                     * @property {boolean} dead 角色是否已死亡
                     * @property {boolean} linked 角色是否被链接
                     * @property {boolean} turnedover 角色是否翻面
                     * @property {number} phaseNumber 此时的回合计数
                     * @property {boolean} unseen
                     * @property {boolean} unseen2
                     * @property {string} mode 当前的模式
                     */
                    var state = {
                        hp: this.hp,
                        maxHp: this.maxHp,
                        nickname: this.nickname,
                        sex: this.sex,
                        group: this.group,
                        name: this.name,
                        name1: this.name1,
                        name2: this.name2,
                        handcards: this.getCards('hs'),
                        gaintag: [],
                        equips: this.getCards('e'),
                        judges: this.getCards('j'),
                        specials: this.getCards('s'),
                        disableJudge: this.storage._disableJudge,
                        disableEquip: this.storage.disableEquip,
                        views: [],
                        position: parseInt(this.dataset.position),
                        hujia: this.hujia,
                        side: this.side,
                        identityShown: this.identityShown,
                        identityNode: [this.node.identity.innerHTML, this.node.identity.dataset.color],
                        identity: this.identity,
                        dead: this.isDead(),
                        linked: this.isLinked(),
                        turnedover: this.isTurnedOver(),
                        phaseNumber: this.phaseNumber,
                        unseen: this.isUnseen(0),
                        unseen2: this.isUnseen(1)
                    };
                    for (var i = 0; i < state.judges.length; i++) {
                        state.views[i] = state.judges[i].viewAs;
                    }
                    for (var i = 0; i < state.handcards.length; i++) {
                        state.gaintag[i] = state.handcards[i].gaintag;
                    }
                    if (this.getModeState) {
                        state.mode = this.getModeState();
                    }
                    return state;
                },
                /**
                 * 设置玩家昵称
                 * @param {string} [str] 玩家昵称，如果未指定或为空字符串，使用`this.nickname`。如果`this.nickname`的值也未指定，使用空字符串
                 * @returns {GameCores.GameObjects.Player} this self
                 */
                setNickname: function (str) {
                    this.node.nameol.innerHTML = (str || this.nickname || '').slice(0, 12);
                    return this;
                },
                /**
                 * 设置头像[support online]
                 * @param {!string} name 武将名，如果是角色副将，则设置副将的头像；如果是主将，则设置主将的头像
                 * @param {!string} name2 新图片名(角色名)，用于设置背景；{@link HTMLDivElement#setBackground}
                 * @param {?boolean} [video] 如果为true或未指定，添加动画；如果为false，不添加动画
                 * @param {?boolean} [fakeme] 如果为true或未指定，设置{@link ui.fakeme}的背景图为头像图；如果为false，不设置
                 */
                setAvatar: function (name, name2, video, fakeme) {
                    var node;
                    if (this.name2 == name) {
                        node = this.node.avatar2;
                        this.smoothAvatar(true, video);
                    }
                    else if (this.name == name) {
                        node = this.node.avatar;
                        this.smoothAvatar(false, video);
                    }
                    if (node) {
                        node.setBackground(name2, 'character');
                        if (this == game.me && ui.fakeme && fakeme !== false) {
                            ui.fakeme.style.backgroundImage = node.style.backgroundImage;
                        }
                        if (video != false) {
                            game.addVideo('setAvatar', this, [name, name2]);
                        }
                    }
                    game.broadcast(function (player, name, name2) {
                        player.setAvatar(name, name2, false);
                    }, this, name, name2);
                },
                /**
                 * 设置头像更新数组，每张头像更新后停留1s，全部更新完成后，还原头像
                 * @param {!string} name 武将名，如果是角色副将，则设置副将的头像；如果是主将，则设置主将的头像
                 * @param {Array<string>} list 头像名(角色名)数组
                 * @see {@link lib.element.player.setAvatar}
                 */
                setAvatarQueue: function (name, list) {
                    var node;
                    var player = this;
                    if (player.name2 == name) {
                        node = player.node.avatar2;
                    }
                    else {
                        node = player.node.avatar;
                    }
                    if (node._avatarqueue) {
                        for (var i = 0; i < list.length; i++) {
                            node._avatarqueue.push(list[i]);
                        }
                    }
                    else {
                        var func = function () {
                            if (node._avatarqueue.length) {
                                player.setAvatar(name, node._avatarqueue.shift(), false, false);
                            }
                            else {
                                clearInterval(node._avatarqueueinterval);
                                delete node._avatarqueue;
                                delete node._avatarqueueinterval;
                                player.setAvatar(name, name, false, false);
                            }
                        };
                        node._avatarqueue = list.slice(0);
                        node._avatarqueueinterval = setInterval(func, 1000);
                        func();
                    }
                    game.addVideo('setAvatarQueue', this, [name, list]);
                },
                /**
                 * 本角色闪烁头像
                 * @param {!string} skill 技能名，如果技能属于角色副将，则设置副将的头像，否则设置主将的头像
                 * @param {!string} name (角色|技能)名，如果是角色名，闪烁此角色的头像；如果是技能名，使用此技能所属角色的角色名
                 */
                flashAvatar: function (skill, name) {
                    if (lib.skill[name] && !lib.character[name]) {
                        var stop = false;
                        var list = lib.config.all.characters.slice(0);
                        for (var i in lib.characterPack) {
                            list.add(i);
                        }
                        for (var i = 0; i < list.length; i++) {
                            for (var j in lib.characterPack[list[i]]) {
                                if (lib.characterPack[list[i]][j][3].contains(name)) {
                                    name = j;
                                    stop = true;
                                    break;
                                }
                            }
                            if (stop) {
                                break;
                            }
                        }
                    }
                    if (lib.character[this.name2] && lib.character[this.name2][3].contains(skill)) {
                        this.setAvatarQueue(this.name2, [name]);
                    }
                    else {
                        this.setAvatarQueue(this.name, [name]);
                    }
                },
                /**
                 * 本角色头像下绘制图像
                 * @param {!string} buff 技能名，如果技能属于角色副将，则设置副将的头像，否则设置主将的头像
                 * @param {!string} skill 技能名，如果技能属于角色副将，则设置副将的头像，否则设置主将的头像
                 * @param {!string} name (角色|技能)名，如果是角色名，闪烁此角色的头像；如果是技能名，使用此技能所属角色的角色名
                 */
                buffAvatar: function (buff, skill, name) {
                    if (lib.skill[name] && !lib.character[name]) {
                        var stop = false;
                        var list = lib.config.all.characters.slice(0);
                        for (var i in lib.characterPack) {
                            list.add(i);
                        }
                        for (var i = 0; i < list.length; i++) {
                            for (var j in lib.characterPack[list[i]]) {
                                if (lib.characterPack[list[i]][j][3].contains(name)) {
                                    name = j;
                                    stop = true;
                                    break;
                                }
                            }
                            if (stop) {
                                break;
                            }
                        }
                    }
                    if (lib.character[this.name2] && lib.character[this.name2][3].contains(skill)) {
                        this.setAvatarQueue(this.name2, [name]);
                    }
                    else {
                        this.setAvatarQueue(this.name, [name]);
                    }
                },
                /**
                 * 同步本角色数据(联网)
                 * @returns {?GameCores.GameObjects.Player} this self；如果是回放模式且该函数被无参调用，返回空值(undefined)
                 */
                update: function () {
                    if (_status.video && arguments.length == 0)
                        return;
                    if (this.hp >= this.maxHp)
                        this.hp = this.maxHp;
                    var hp = this.node.hp;
                    hp.style.transition = 'none';
                    game.broadcast(function (player, hp, maxHp, hujia) {
                        player.hp = hp;
                        player.maxHp = maxHp;
                        player.hujia = hujia;
                        player.update();
                    }, this, this.hp, this.maxHp, this.hujia);
                    if (!_status.video) {
                        if (this.hujia) {
                            this.markSkill('ghujia');
                        }
                        else {
                            this.unmarkSkill('ghujia');
                        }
                    }
                    if (!this.storage.nohp) {
                        var libHp = lib.character[(this.name && this.name.indexOf('unknown') == 0) ? this.name1 : this.name];
                        if (this.maxHp == Infinity) {
                            hp.innerHTML = '∞';
                        }
                        else if (libHp && libHp[2] && get.infoHp(libHp[2]) < 0) {
                            hp.innerHTML = this.hp + '/' + this.maxHp;
                            hp.classList.add('text');
                        }
                        else if (game.layout == 'default' && this.maxHp > 14) {
                            hp.innerHTML = this.hp + '/' + this.maxHp;
                            hp.classList.add('text');
                        }
                        else if (get.is.newLayout() &&
                            (this.maxHp > 9 ||
                                (this.maxHp > 5 && this.classList.contains('minskin')) ||
                                ((game.layout == 'mobile' || game.layout == 'long') && this.dataset.position == 0 && this.maxHp > 7))) {
                            hp.innerHTML = this.hp + '<br>/<br>' + this.maxHp + '<div></div>';
                            if (this.hp == 0) {
                                hp.lastChild.classList.add('lost');
                            }
                            hp.classList.add('textstyle');
                            // hp.classList.remove('long');
                        }
                        else {
                            hp.innerHTML = '';
                            hp.classList.remove('text');
                            hp.classList.remove('textstyle');
                            while (this.maxHp > hp.childNodes.length) {
                                ui.create.div(hp);
                            }
                            while (Math.max(0, this.maxHp) < hp.childNodes.length) {
                                hp.removeChild(hp.lastChild);
                            }
                            for (var i = 0; i < this.maxHp; i++) {
                                var index = i;
                                if (get.is.newLayout()) {
                                    index = this.maxHp - i - 1;
                                }
                                if (i < this.hp) {
                                    hp.childNodes[index].classList.remove('lost');
                                }
                                else {
                                    hp.childNodes[index].classList.add('lost');
                                }
                            }
                            // if(this.maxHp==9){
                            //     hp.classList.add('long');
                            // }
                            // else{
                            //     hp.classList.remove('long');
                            // }
                        }
                        if (hp.classList.contains('room')) {
                            hp.dataset.condition = 'high';
                        }
                        else if (this.hp == 0) {
                            hp.dataset.condition = '';
                        }
                        else if (this.hp > Math.round(this.maxHp / 2) || this.hp === this.maxHp) {
                            hp.dataset.condition = 'high';
                        }
                        else if (this.hp > Math.floor(this.maxHp / 3)) {
                            hp.dataset.condition = 'mid';
                        }
                        else {
                            hp.dataset.condition = 'low';
                        }
                        setTimeout(function () {
                            hp.style.transition = '';
                        });
                    }
                    var numh = this.countCards('h');
                    if (_status.video) {
                        numh = arguments[0];
                    }
                    if (numh >= 10) {
                        numh = numh.toString();
                        this.node.count.dataset.condition = 'low';
                        this.node.count.innerHTML = numh[0] + '<br>' + numh[1];
                    }
                    else {
                        if (numh > 5) {
                            this.node.count.dataset.condition = 'higher';
                        }
                        else if (numh > 2) {
                            this.node.count.dataset.condition = 'high';
                        }
                        else if (numh > 0) {
                            this.node.count.dataset.condition = 'mid';
                        }
                        else {
                            this.node.count.dataset.condition = 'none';
                        }
                        this.node.count.innerHTML = numh;
                    }
                    if (this.updates) {
                        for (var i = 0; i < lib.element.player.updates.length; i++) {
                            lib.element.player.updates[i](this);
                        }
                    }
                    if (!_status.video) {
                        game.addVideo('update', this, [this.countCards('h'), this.hp, this.maxHp, this.hujia]);
                    }
                    this.updateMarks();
                    return this;
                },
                /**
                 * 本角色的一个技能标记移除指定数量，如果这个技能当前(没有标记|标记数为0)，返回`undefined`；
                 * 此函数仅支持数值类型的标记，如果是非数值类型的标记，不做任何移除操作，返回`undefined`；
                 * 数值类型仅支持整数
                 * @param {!string} i 技能名，此函数会调用`this.storage[i]`获取该技能的标记数量
                 * @param {?number} [num] 正整数，标记要移除的数量；如果值为0或未指定，则使用数量 **1** 作为要移除的数量
                 * @param {?boolean} [log] 是否输出日志，如果为true或未指定，输出日志；如果为false，不输出日志
                 */
                removeMark: function (i, num, log) {
                    if (typeof num != 'number' || !num)
                        num = 1;
                    if (typeof this.storage[i] != 'number' || !this.storage[i])
                        return;
                    if (num > this.storage[i])
                        num = this.storage[i];
                    this.storage[i] -= num;
                    if (log !== false) {
                        var str = false;
                        var info = get.info(i);
                        if (info && info.intro && (info.intro.name || info.intro.name2))
                            str = info.intro.name2 || info.intro.name;
                        else
                            str = lib.translate[i];
                        if (str)
                            game.log(this, '移去了', get.cnNumber(num), '个', '#g【' + str + '】');
                    }
                    this.syncStorage(i);
                    this[this.storage[i] ? 'markSkill' : 'unmarkSkill'](i);
                },
                /**
                 * 本角色的一个技能标记添加指定数量；
                 * 此函数支持任意类型的标记，但不建议使用非数值类型的标记，因为对非数值类型的标记，会首先使用 0 值覆盖原值；
                 * 数值类型不支持浮点数
                 * @param {!string} i 技能名，此函数会调用`this.storage[i]`获取该技能的标记数量
                 * @param {?number} [num] 正整数，标记要添加的数量；如果值为0或未指定，则使用数量 **1** 作为要添加的数量
                 * @param {?boolean} [log] 是否输出日志，如果为true或未指定，输出日志；如果为false，不输出日志
                 */
                addMark: function (i, num, log) {
                    if (typeof num != 'number' || !num)
                        num = 1;
                    if (typeof this.storage[i] != 'number')
                        this.storage[i] = 0;
                    this.storage[i] += num;
                    if (log !== false) {
                        var str = false;
                        var info = get.info(i);
                        if (info && info.intro && (info.intro.name || info.intro.name2))
                            str = info.intro.name2 || info.intro.name;
                        else
                            str = lib.translate[i];
                        if (str)
                            game.log(this, '获得了', get.cnNumber(num), '个', '#g【' + str + '】');
                    }
                    this.syncStorage(i);
                    this.markSkill(i);
                },
                /**
                 * 返回本角色一个技能的标记数
                 * @param {?string} [i] 技能名，如果是数值型标记，返回此技能的标记数；如果是数组型标记，返回数组的长度值；否则，返回0值
                 * @returns {!number}
                 */
                countMark: function (i) {
                    if (this.storage[i] == undefined)
                        return 0;
                    if (typeof this.storage[i] == 'number')
                        return this.storage[i];
                    if (Array.isArray(this.storage[i]))
                        return this.storage[i].length;
                    return 0;
                },
                /**
                 * 返回此角色是否有一个技能的标记
                 * 此函数仅支持数值型标记，对于非数值型标记，此函数总返回false
                 * @param {!string} i 技能名，此函数会调用`this.storage[i]`获取该技能的标记数量
                 * @returns {!boolean}
                 */
                hasMark: function (i) {
                    return this.countMark(i) > 0;
                },
                /**
                 * 同步本角色一个技能标记的显示数值，如果是非数值类型的标记，不做同步操作，返回`this`
                 * @param {!string} i 技能名
                 * @param {?boolean} [storage] 是否同步标记数据，如果为true，同步标记(联网)；如果为false或未指定，不同步
                 */
                updateMark: function (i, storage) {
                    if (!this.marks[i]) {
                        if (lib.skill[i] && lib.skill[i].intro && (this.storage[i] || lib.skill[i].intro.markcount)) {
                            this.markSkill(i);
                            if (!this.marks[i])
                                return this;
                        }
                        else {
                            return this;
                        }
                    }
                    if (storage && this.storage[i]) {
                        this.syncStorage(i);
                    }
                    if (i == 'ghujia' || ((!this.marks[i].querySelector('.image') || this.storage[i + '_markcount']) &&
                        lib.skill[i] && lib.skill[i].intro && !lib.skill[i].intro.nocount &&
                        (this.storage[i] || lib.skill[i].intro.markcount))) {
                        this.marks[i].classList.add('overflowmark');
                        var num = 0;
                        if (typeof lib.skill[i].intro.markcount == 'function') {
                            num = lib.skill[i].intro.markcount(this.storage[i], this);
                        }
                        else if (typeof this.storage[i + '_markcount'] == 'number') {
                            num = this.storage[i + '_markcount'];
                        }
                        else if (i == 'ghujia') {
                            num = this.hujia;
                        }
                        else if (typeof this.storage[i] == 'number') {
                            num = this.storage[i];
                        }
                        else if (Array.isArray(this.storage[i])) {
                            num = this.storage[i].length;
                        }
                        if (num) {
                            if (!this.marks[i].markcount) {
                                this.marks[i].markcount = ui.create.div('.markcount.menubutton', this.marks[i]);
                            }
                            this.marks[i].markcount.innerHTML = num;
                        }
                        else if (this.marks[i].markcount) {
                            this.marks[i].markcount["delete"]();
                            delete this.marks[i].markcount;
                        }
                    }
                    else {
                        if (this.marks[i].markcount) {
                            this.marks[i].markcount["delete"]();
                            delete this.marks[i].markcount;
                        }
                        if (lib.skill[i].mark == 'auto') {
                            this.unmarkSkill(i);
                        }
                    }
                    return this;
                },
                /**
                 * 更新本角色全部数值型技能标记信息，不处理非数值标记
                 * @param {?string} [skillname] 技能名，同步本角色的一个技能标记数据然后同步更新(联网)；如果未指定，则不进行同步，仅在本机更新
                 */
                updateMarks: function (connect) {
                    if (typeof connect == 'string' && _status.connectMode && !game.online) {
                        game.broadcast(function (player, storage, skill) {
                            player.storage[skill] = storage;
                            player.updateMarks();
                        }, this, this.storage[connect], connect);
                    }
                    for (var i in this.marks) {
                        this.updateMark(i);
                    }
                },
                num: function (arg1, arg2, arg3) {
                    if (get.itemtype(arg1) == 'position') {
                        return this.get(arg1, arg2, arg3).length;
                    }
                    else if (arg1 == 's') {
                        if (typeof arg2 == 'boolean') {
                            return game.expandSkills(this.getSkills(arg2).concat(lib.skill.global)).contains(arg3);
                        }
                        else {
                            return game.expandSkills(this.getSkills().concat(lib.skill.global)).contains(arg2);
                        }
                    }
                },
                line: function (target, config) {
                    if (get.itemtype(target) == 'players') {
                        for (var i = 0; i < target.length; i++) {
                            this.line(target[i], config);
                        }
                    }
                    else if (get.itemtype(target) == 'player') {
                        if (target == this)
                            return;
                        game.broadcast(function (player, target, config) {
                            player.line(target, config);
                        }, this, target, config);
                        game.addVideo('line', this, [target.dataset.position, config]);
                        game.linexy([
                            this.getLeft() + this.offsetWidth / 2,
                            this.getTop() + this.offsetHeight / 2,
                            target.getLeft() + target.offsetWidth / 2,
                            target.getTop() + target.offsetHeight / 2
                        ], config, true);
                    }
                },
                line2: function (targets, config) {
                    this.line(targets[0], config);
                    targets = targets.slice(0);
                    for (var i = 1; i < targets.length; i++) {
                        (function (j) {
                            setTimeout(function () {
                                targets[j - 1].line(targets[j], config);
                            }, lib.config.duration * i);
                        }(i));
                    }
                },
                getNext: function () {
                    if (this.hasSkill('undist'))
                        return null;
                    var target = this;
                    for (var i = 0; i < game.players.length - 1; i++) {
                        target = target.next;
                        if (!target.hasSkill('undist')) {
                            return target;
                        }
                    }
                    return null;
                },
                getPrevious: function () {
                    if (this.hasSkill('undist'))
                        return null;
                    var target = this;
                    for (var i = 0; i < game.players.length - 1; i++) {
                        target = target.previous;
                        if (!target.hasSkill('undist')) {
                            return target;
                        }
                    }
                    return null;
                },
                countUsed: function (card, type) {
                    if (type === true) {
                        var num = 0;
                        var history = this.getHistory('useCard');
                        for (var i = 0; i < history.length; i++) {
                            if (!card)
                                num++;
                            else if (typeof card == 'string' && history[i].card && card == history[i].card.name)
                                num++;
                            else if (typeof card == 'object' && history[i].card && card.name == history[i].card.name)
                                num++;
                        }
                        return num;
                    }
                    var num;
                    var stat = this.getStat('card');
                    if (!card) {
                        num = 0;
                        for (var i in stat) {
                            if (typeof stat[i] == 'number') {
                                console.log(i, stat[i]);
                                num += stat[i];
                            }
                        }
                        return num;
                    }
                    if (typeof card == 'object') {
                        card = card.name;
                    }
                    num = stat[card];
                    if (typeof num != 'number')
                        return 0;
                    return num;
                },
                countSkill: function (skill) {
                    var num = this.getStat('skill')[skill];
                    if (num == undefined)
                        return 0;
                    return num;
                },
                getStockSkills: function (unowned, unique, hidden) {
                    var list = [];
                    if (lib.character[this.name] && (hidden || !this.isUnseen(0))) {
                        list.addArray(lib.character[this.name][3]);
                    }
                    if (lib.character[this.name1] && (hidden || !this.isUnseen(0))) {
                        list.addArray(lib.character[this.name1][3]);
                    }
                    if (lib.character[this.name2] && (hidden || !this.isUnseen(1))) {
                        list.addArray(lib.character[this.name2][3]);
                    }
                    if (!unowned) {
                        for (var i = 0; i < list.length; i++) {
                            if (!this.hasSkill(list[i])) {
                                list.splice(i--, 1);
                            }
                        }
                    }
                    if (!unique) {
                        for (var i = 0; i < list.length; i++) {
                            var info = lib.skill[list[i]];
                            if (!info || info.unique || info.temp || info.sub || info.charlotte) {
                                list.splice(i--, 1);
                            }
                        }
                    }
                    return list;
                },
                /**
                 * 返回本角色(手牌|装备区|判定区|武将牌上)或任意位置组合的游戏牌
                 * @function lib.element.player.getCards
                 * @param {string} [position='h'] 游戏牌位置组合: [hesj]+
                 * @returns {!Array<GameCores.GameObjects.Card>}
                 */
                /**
                 * 返回本角色所有牌中等于指定名称或手牌轴被视为指定名称的游戏牌
                 * @function lib.element.player.getCards
                 * @variation 2
                 * @param {string} [position='h'] 游戏牌位置: [hesj]+
                 * @param {!string} [name] 游戏牌名，返回所有名称等于该牌名，或者手牌中被视为此牌名的牌
                 * @returns {!Array<GameCores.GameObjects.Card>}
                 */
                /**
                 * 返回本角色所有牌中满足特定条件的游戏牌
                 * @function lib.element.player.getCards
                 * @variation 3
                 * @param {string} [position='h'] 游戏牌位置: [hesj]+
                 * @param {?Object} [cond] 条件对象，每个属性对应一个匹配条件(游戏牌对象必须有该属性，否则该条件会被跳过，不会生效)，只要有一次匹配失败就将牌从结果数组中移除；如果未指定则跳过匹配过程
                 * @param {...(Array<(Object|string)>|string)} cond.'[keyname]' 匹配条件，如果`cond[keyname] == card[keyname] || cond[keyname].contains(card[keyname])`成立，则匹配成功
                 * @returns {!Array<GameCores.GameObjects.Card>}
                 */
                /**
                 * getCards筛选函数
                 * @callback lib.element.player.getCards~filterCard
                 * @param {!GameCores.GameObjects.Card} card 游戏牌对象
                 * @returns {?boolean} true表示保留此游戏牌，false或未指定表示不保留
                 * @see {@link lib.element.player.getCards(4)}
                 */
                /**
                 * 返回本角色所有牌中通过筛选函数的游戏牌
                 * @function lib.element.player.getCards
                 * @variation 4
                 * @param {string} [position='h'] 游戏牌位置: [hesj]+
                 * @param {?lib.element.player.getCards~filterCard} [filter] 筛选函数，如果未指定则跳过筛选过程
                 * @returns {!Array<GameCores.GameObjects.Card>}
                 */
                getCards: function (arg1, arg2) {
                    if (typeof arg1 != 'string') {
                        arg1 = 'h';
                    }
                    var cards = [], cards1 = [];
                    var i, j;
                    for (i = 0; i < arg1.length; i++) {
                        if (arg1[i] == 'h') {
                            for (j = 0; j < this.node.handcards1.childElementCount; j++) {
                                if (!this.node.handcards1.childNodes[j].classList.contains('removing') && !this.node.handcards1.childNodes[j].classList.contains('glows')) {
                                    cards.push(this.node.handcards1.childNodes[j]);
                                }
                            }
                            for (j = 0; j < this.node.handcards2.childElementCount; j++) {
                                if (!this.node.handcards2.childNodes[j].classList.contains('removing') && !this.node.handcards2.childNodes[j].classList.contains('glows')) {
                                    cards.push(this.node.handcards2.childNodes[j]);
                                }
                            }
                        }
                        else if (arg1[i] == 's') {
                            for (j = 0; j < this.node.handcards1.childElementCount; j++) {
                                if (!this.node.handcards1.childNodes[j].classList.contains('removing') && this.node.handcards1.childNodes[j].classList.contains('glows')) {
                                    cards.push(this.node.handcards1.childNodes[j]);
                                }
                            }
                            for (j = 0; j < this.node.handcards2.childElementCount; j++) {
                                if (!this.node.handcards2.childNodes[j].classList.contains('removing') && this.node.handcards2.childNodes[j].classList.contains('glows')) {
                                    cards.push(this.node.handcards2.childNodes[j]);
                                }
                            }
                        }
                        else if (arg1[i] == 'e') {
                            for (j = 0; j < this.node.equips.childElementCount; j++) {
                                if (!this.node.equips.childNodes[j].classList.contains('removing') && !this.node.equips.childNodes[j].classList.contains('feichu')) {
                                    cards.push(this.node.equips.childNodes[j]);
                                }
                            }
                        }
                        else if (arg1[i] == 'j') {
                            for (j = 0; j < this.node.judges.childElementCount; j++) {
                                if (!this.node.judges.childNodes[j].classList.contains('removing') && !this.node.judges.childNodes[j].classList.contains('feichu')) {
                                    cards.push(this.node.judges.childNodes[j]);
                                    if (this.node.judges.childNodes[j].viewAs && arguments.length > 1) {
                                        this.node.judges.childNodes[j].tempJudge = this.node.judges.childNodes[j].name;
                                        this.node.judges.childNodes[j].name = this.node.judges.childNodes[j].viewAs;
                                        cards1.push(this.node.judges.childNodes[j]);
                                    }
                                }
                            }
                        }
                    }
                    if (arguments.length == 1) {
                        return cards;
                    }
                    if (arg2) {
                        for (i = 0; i < cards.length; i++) {
                            if (!get.is.filterCardBy(cards[i], arg2)) {
                                cards.splice(i--, 1);
                            }
                        }
                    }
                    for (i = 0; i < cards1.length; i++) {
                        if (cards1[i].tempJudge) {
                            cards1[i].name = cards1[i].tempJudge;
                            delete cards1[i].tempJudge;
                        }
                    }
                    return cards;
                },
                getDiscardableCards: function (player, arg1, arg2) {
                    var cards = this.getCards(arg1, arg2);
                    for (var i = 0; i < cards.length; i++) {
                        if (!lib.filter.canBeDiscarded(cards[i], player, this)) {
                            cards.splice(i--, 1);
                        }
                    }
                    return cards;
                },
                getGainableCards: function (player, arg1, arg2) {
                    var cards = this.getCards(arg1, arg2);
                    for (var i = 0; i < cards.length; i++) {
                        if (!lib.filter.canBeGained(cards[i], player, this)) {
                            cards.splice(i--, 1);
                        }
                    }
                    return cards;
                },
                getGainableSkills: function (func) {
                    var list = [];
                    var names = [this.name, this.name1, this.name2];
                    for (var i = 0; i < names.length; i++) {
                        list.addArray(get.gainableSkillsName(names[i], func));
                    }
                    return list;
                },
                countCards: function (arg1, arg2) {
                    return this.getCards(arg1, arg2).length;
                },
                countDiscardableCards: function (player, arg1, arg2) {
                    return this.getDiscardableCards(player, arg1, arg2).length;
                },
                countGainableCards: function (player, arg1, arg2) {
                    return this.getGainableCards(player, arg1, arg2).length;
                },
                getOriginalSkills: function () {
                    var skills = [];
                    if (lib.character[this.name] && !this.isUnseen(0)) {
                        skills.addArray(lib.character[this.name][3]);
                    }
                    if (this.name2 && lib.character[this.name2] && !this.isUnseen(1)) {
                        skills.addArray(lib.character[this.name2][3]);
                    }
                    return skills;
                },
                /**
                 * 返回本角色的技能组；
                 * 该技能组不包括子技能；
                 * @param {!string} skill 技能名
                 * @param {*} arg2 为真时表示计入隐藏的技能、为'e'时表示仅返回装备技能
                 * @param {*} arg3 为false时表示不计入装备技能
                 * @param {*} arg4 为false时表示计入失效的技能
                 * @returns {!Array<string>}
                 */
                getSkills: function (arg2, arg3, arg4) {
                    var skills = this.skills.slice(0);
                    var es = [];
                    var i, j;
                    if (arg3 !== false) {
                        for (i = 0; i < this.node.equips.childElementCount; i++) {
                            if (!this.node.equips.childNodes[i].classList.contains('removing')) {
                                var equipskills = get.info(this.node.equips.childNodes[i], false).skills;
                                if (equipskills) {
                                    es.addArray(equipskills);
                                }
                            }
                        }
                        if (arg2 == 'e') {
                            return es;
                        }
                    }
                    for (var i in this.additionalSkills) {
                        if (Array.isArray(this.additionalSkills[i]) && (arg2 || i.indexOf('hidden:') !== 0)) {
                            for (j = 0; j < this.additionalSkills[i].length; j++) {
                                if (this.additionalSkills[i][j]) {
                                    skills.add(this.additionalSkills[i][j]);
                                }
                            }
                        }
                        else if (this.additionalSkills[i] && typeof this.additionalSkills[i] == 'string') {
                            skills.add(this.additionalSkills[i]);
                        }
                    }
                    for (var i in this.tempSkills) {
                        skills.add(i);
                    }
                    if (arg2)
                        skills.addArray(this.hiddenSkills);
                    if (arg3 !== false)
                        skills.addArray(es);
                    for (var i in this.forbiddenSkills) {
                        skills.remove(i);
                    }
                    if (arg4 !== false) {
                        skills = game.filterSkills(skills, this, es);
                    }
                    return skills;
                },
                /**
                 * 角色的游戏牌区域(手牌|装备区|判定区)组合
                 * Regex: [hej]|he|hj|ej|hej
                 * @typedef {string} GameCores.PlayerCardPosition
                 * @see {@link GameCores.CardPosition}
                 */
                /**
                 * 返回本角色(武将牌上|手牌|装备区|判定区)的游戏牌 TODO
                 * @param {('s'|GameCores.PlayerCardPosition)} position 角色的游戏牌区域或者角色的武将牌上区域
                 * @param {*} arg2
                 * @param {*} arg3
                 * @param {*} arg4
                 * @returns {Array<GameCores.GameObjects.Card>}
                 * @see {@link GameCores.PlayerCardPosition}
                 * @example
                 * let cards = player.get('he')//手牌和装备区所有未被移除、废除、的牌
                 *
                 *
                 */
                get: function (arg1, arg2, arg3, arg4) {
                    var i, j;
                    if (arg1 == 's') {
                        var skills = this.skills.slice(0);
                        var es = [];
                        if (arg3 !== false) {
                            for (i = 0; i < this.node.equips.childElementCount; i++) {
                                if (!this.node.equips.childNodes[i].classList.contains('removing') && !this.node.equips.childNodes[i].classList.contains('feichu')) {
                                    var equipskills = get.info(this.node.equips.childNodes[i]).skills;
                                    if (equipskills) {
                                        es.addArray(equipskills);
                                    }
                                }
                            }
                            if (arg2 == 'e') {
                                return es;
                            }
                        }
                        for (var i in this.additionalSkills) {
                            if (Array.isArray(this.additionalSkills[i])) {
                                for (j = 0; j < this.additionalSkills[i].length; j++) {
                                    if (this.additionalSkills[i][j]) {
                                        skills.add(this.additionalSkills[i][j]);
                                    }
                                }
                            }
                            else if (this.additionalSkills[i] && typeof this.additionalSkills[i] == 'string') {
                                skills.add(this.additionalSkills[i]);
                            }
                        }
                        for (var i in this.tempSkills) {
                            skills.add(i);
                        }
                        if (arg2)
                            skills.addArray(this.hiddenSkills);
                        if (arg3 !== false)
                            skills.addArray(es);
                        for (var i in this.forbiddenSkills) {
                            skills.remove(i);
                        }
                        if (arg4 !== false) {
                            skills = game.filterSkills(skills, this, es);
                        }
                        return skills;
                    }
                    else if (get.is.pos(arg1)) {
                        var cards = [], cards1 = [];
                        for (i = 0; i < arg1.length; i++) {
                            if (arg1[i] == 'h') {
                                for (j = 0; j < this.node.handcards1.childElementCount; j++) {
                                    if (!this.node.handcards1.childNodes[j].classList.contains('removing') && !this.node.handcards1.childNodes[j].classList.contains('feichu') && !this.node.handcards1.childNodes[j].classList.contains('glows')) {
                                        cards.push(this.node.handcards1.childNodes[j]);
                                    }
                                }
                                for (j = 0; j < this.node.handcards2.childElementCount; j++) {
                                    if (!this.node.handcards2.childNodes[j].classList.contains('removing') && !this.node.handcards2.childNodes[j].classList.contains('feichu') && !this.node.handcards2.childNodes[j].classList.contains('glows')) {
                                        cards.push(this.node.handcards2.childNodes[j]);
                                    }
                                }
                            }
                            else if (arg1[i] == 'e') {
                                for (j = 0; j < this.node.equips.childElementCount; j++) {
                                    if (!this.node.equips.childNodes[j].classList.contains('removing') && !this.node.equips.childNodes[j].classList.contains('feichu')) {
                                        cards.push(this.node.equips.childNodes[j]);
                                    }
                                }
                                if (arguments.length == 2 && typeof arg2 == 'string' && /1|2|3|4|5/.test(arg2)) {
                                    for (j = 0; j < cards.length; j++) {
                                        if (get.subtype(cards[j]) == 'equip' + arg2)
                                            return cards[j];
                                    }
                                    return;
                                }
                            }
                            else if (arg1[i] == 'j') {
                                for (j = 0; j < this.node.judges.childElementCount; j++) {
                                    if (!this.node.judges.childNodes[j].classList.contains('removing') && !this.node.judges.childNodes[j].classList.contains('feichu')) {
                                        cards.push(this.node.judges.childNodes[j]);
                                        if (this.node.judges.childNodes[j].viewAs && arguments.length > 1) {
                                            this.node.judges.childNodes[j].tempJudge = this.node.judges.childNodes[j].name;
                                            this.node.judges.childNodes[j].name = this.node.judges.childNodes[j].viewAs;
                                            cards1.push(this.node.judges.childNodes[j]);
                                        }
                                    }
                                }
                            }
                        }
                        if (arguments.length == 1) {
                            return cards;
                        }
                        if (arg2 != undefined) {
                            if (typeof arg3 == 'function') {
                                var cards2 = cards.slice(0);
                                cards.sort(function (a, b) {
                                    return arg3(b, cards2) - arg3(a, cards2);
                                });
                            }
                            if (typeof arg2 == 'string') {
                                for (i = 0; i < cards.length; i++) {
                                    if (cards[i].name != arg2) {
                                        cards.splice(i, 1);
                                        i--;
                                    }
                                }
                            }
                            else if (typeof arg2 == 'object') {
                                for (i = 0; i < cards.length; i++) {
                                    for (j in arg2) {
                                        if (j == 'type') {
                                            if (typeof arg2[j] == 'object') {
                                                if (arg2[j].contains(get.type(cards[i])) == false) {
                                                    cards.splice(i, 1);
                                                    i--;
                                                    break;
                                                }
                                            }
                                            else if (typeof arg2[j] == 'string') {
                                                if (get.type(cards[i]) != arg2[j]) {
                                                    cards.splice(i, 1);
                                                    i--;
                                                    break;
                                                }
                                            }
                                        }
                                        else if (j == 'subtype') {
                                            if (typeof arg2[j] == 'object') {
                                                if (arg2[j].contains(get.subtype(cards[i])) == false) {
                                                    cards.splice(i, 1);
                                                    i--;
                                                    break;
                                                }
                                            }
                                            else if (typeof arg2[j] == 'string') {
                                                if (get.subtype(cards[i]) != arg2[j]) {
                                                    cards.splice(i, 1);
                                                    i--;
                                                    break;
                                                }
                                            }
                                        }
                                        else if (j == 'color') {
                                            if (typeof arg2[j] == 'object') {
                                                if (arg2[j].contains(get.color(cards[i])) == false) {
                                                    cards.splice(i, 1);
                                                    i--;
                                                    break;
                                                }
                                            }
                                            else if (typeof arg2[j] == 'string') {
                                                if (get.color(cards[i]) != arg2[j]) {
                                                    cards.splice(i, 1);
                                                    i--;
                                                    break;
                                                }
                                            }
                                        }
                                        else if (j == 'suit') {
                                            if (typeof arg2[j] == 'object') {
                                                if (arg2[j].contains(get.suit(cards[i])) == false) {
                                                    cards.splice(i, 1);
                                                    i--;
                                                    break;
                                                }
                                            }
                                            else if (typeof arg2[j] == 'string') {
                                                if (get.suit(cards[i]) != arg2[j]) {
                                                    cards.splice(i, 1);
                                                    i--;
                                                    break;
                                                }
                                            }
                                        }
                                        else if (j == 'number') {
                                            if (typeof arg2[j] == 'object') {
                                                if (arg2[j].contains(get.number(cards[i])) == false) {
                                                    cards.splice(i, 1);
                                                    i--;
                                                    break;
                                                }
                                            }
                                            else if (typeof arg2[j] == 'string') {
                                                if (get.number(cards[i]) != arg2[j]) {
                                                    cards.splice(i, 1);
                                                    i--;
                                                    break;
                                                }
                                            }
                                        }
                                        else if (typeof arg2[j] == 'object') {
                                            if (arg2[j].contains(cards[i][j]) == false) {
                                                cards.splice(i, 1);
                                                i--;
                                                break;
                                            }
                                        }
                                        else if (typeof arg2[j] == 'string') {
                                            if (cards[i][j] != arg2[j]) {
                                                cards.splice(i, 1);
                                                i--;
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            else if (typeof arg2 == 'number' && arg2 > 0) {
                                cards.splice(arg2);
                            }
                            else if (typeof arg2 == 'function') {
                                for (i = 0; i < cards.length; i++) {
                                    if (!arg2(cards[i])) {
                                        cards.splice(i, 1);
                                        i--;
                                    }
                                }
                            }
                        }
                        for (i = 0; i < cards1.length; i++) {
                            if (cards1[i].tempJudge) {
                                cards1[i].name = cards1[i].tempJudge;
                                delete cards1[i].tempJudge;
                            }
                        }
                        if (arg2 === 0)
                            return cards[0];
                        if (typeof arg3 == 'number') {
                            if (arg3 == 0)
                                return cards[0];
                            cards.splice(arg3);
                        }
                        if (typeof arg4 == 'number') {
                            if (arg4 == 0)
                                return cards[0];
                            cards.splice(arg4);
                        }
                        return cards;
                    }
                },
                /**
                 * 记录本角色的一个技能当前标记数(回放记录)，并更新全部标记信息({@link lib.element.player.updateMarks})
                 * @param {!string} skill 技能名
                 */
                syncStorage: function (skill) {
                    switch (get.itemtype(this.storage[skill])) {
                        case 'cards':
                            game.addVideo('storage', this, [skill, get.cardsInfo(this.storage[skill]), 'cards']);
                            break;
                        case 'card':
                            game.addVideo('storage', this, [skill, get.cardInfo(this.storage[skill]), 'card']);
                            break;
                        default:
                            try {
                                game.addVideo('storage', this, [skill, JSON.parse(JSON.stringify(this.storage[skill]))]);
                            }
                            catch (e) {
                                console.log(this.storage[skill]);
                            }
                    }
                },
                syncSkills: function () {
                    game.broadcast(function (player, skills) {
                        player.applySkills(skills);
                    }, this, get.skillState(this));
                },
                playerfocus: function (time) {
                    time = time || 1000;
                    this.classList.add('playerfocus');
                    ui.arena.classList.add('playerfocus');
                    var that = this;
                    setTimeout(function () {
                        that.classList.remove('playerfocus');
                        ui.arena.classList.remove('playerfocus');
                    }, time);
                    game.addVideo('playerfocus', this, time);
                    game.broadcast(function (player, time) {
                        player.playerfocus(time);
                    }, this, time);
                    return this;
                },
                /**
                 * 记录本角色的一个技能当前标记数(回放记录)，并更新全部标记信息({@link lib.element.player.updateMarks})
                 * @param {!string} skill 技能名
                 */
                setIdentity: function (identity) {
                    if (!identity)
                        identity = this.identity;
                    if (get.is.jun(this)) {
                        this.node.identity.firstChild.innerHTML = '君';
                    }
                    else {
                        this.node.identity.firstChild.innerHTML = get.translation(identity);
                    }
                    this.node.identity.dataset.color = identity;
                    return this;
                },
                insertPhase: function (skill, insert) {
                    var evt = _status.event.getParent('phase');
                    var next;
                    if (evt && evt.parent && evt.parent.next) {
                        evt = evt.parent;
                        next = game.createEvent('phase', null, evt);
                    }
                    else if (_status.event.parent && _status.event.parent.next) {
                        evt = _status.event.parent;
                        next = game.createEvent('phase', null, evt);
                    }
                    else {
                        evt = null;
                        next = game.createEvent('phase');
                    }
                    if (evt && insert && evt.next.contains(next)) {
                        evt.next.remove(next);
                        evt.next.unshift(next);
                    }
                    next.player = this;
                    next.skill = skill || _status.event.name;
                    next.setContent('phase');
                    return next;
                },
                insertEvent: function (name, content, arg) {
                    var evt = _status.event.getParent('phase');
                    var next;
                    if (evt && evt.parent && evt.parent.next) {
                        next = game.createEvent(name, null, evt.parent);
                    }
                    else {
                        next = game.createEvent(name);
                    }
                    for (var i in arg) {
                        next[i] = arg[i];
                    }
                    next.player = this;
                    next.setContent(content);
                    return next;
                },
                phase: function (skill, stageList) {
                    var next = game.createEvent('phase');
                    next.player = this;
                    next.setContent('phase');
                    if (!_status.roundStart) {
                        _status.roundStart = this;
                    }
                    if (skill) {
                        next.skill = skill;
                    }
                    if (stageList) {
                        next.stageList = stageList;
                    }
                    return next;
                },
                phaseZhunbei: function () {
                    var next = game.createEvent('phaseZhunbei');
                    next.player = this;
                    next.setContent('emptyEvent');
                    return next;
                },
                phaseJudge: function () {
                    var next = game.createEvent('phaseJudge');
                    next.player = this;
                    next.setContent('phaseJudge');
                    return next;
                },
                phaseDraw: function () {
                    var next = game.createEvent('phaseDraw');
                    next.player = this;
                    next.num = 2;
                    if ((get.config('first_less') || _status.connectMode || _status.first_less_forced) && game.phaseNumber == 1 && _status.first_less) {
                        next.num--;
                    }
                    next.setContent('phaseDraw');
                    return next;
                },
                phaseUse: function () {
                    var next = game.createEvent('phaseUse');
                    next.player = this;
                    next.setContent('phaseUse');
                    return next;
                },
                phaseDiscard: function () {
                    var next = game.createEvent('phaseDiscard');
                    next.player = this;
                    next.setContent('phaseDiscard');
                    return next;
                },
                phaseJieshu: function () {
                    var next = game.createEvent('phaseJieshu');
                    next.player = this;
                    next.setContent('emptyEvent');
                    return next;
                },
                chooseToUse: function (use) {
                    var next = game.createEvent('chooseToUse');
                    next.player = this;
                    if (arguments.length == 1 && get.objtype(arguments[0]) == 'object') {
                        for (var i in use) {
                            next[i] = use[i];
                        }
                    }
                    else {
                        for (var i = 0; i < arguments.length; i++) {
                            if (typeof arguments[i] == 'number' || get.itemtype(arguments[i]) == 'select') {
                                next.selectTarget = arguments[i];
                            }
                            else if ((typeof arguments[i] == 'object' && arguments[i]) || typeof arguments[i] == 'function') {
                                if (get.itemtype(arguments[i]) == 'player' || next.filterCard) {
                                    next.filterTarget = arguments[i];
                                }
                                else
                                    next.filterCard = arguments[i];
                            }
                            else if (typeof arguments[i] == 'boolean') {
                                next.forced = arguments[i];
                            }
                            else if (typeof arguments[i] == 'string') {
                                next.prompt = arguments[i];
                            }
                        }
                    }
                    if (typeof next.filterCard == 'object') {
                        next.filterCard = get.filter(next.filterCard);
                    }
                    if (typeof next.filterTarget == 'object') {
                        next.filterTarget = get.filter(next.filterTarget, 2);
                    }
                    if (next.filterCard == undefined) {
                        next.filterCard = lib.filter.filterCard;
                    }
                    if (next.selectCard == undefined) {
                        next.selectCard = [1, 1];
                    }
                    if (next.filterTarget == undefined) {
                        next.filterTarget = lib.filter.filterTarget;
                    }
                    if (next.selectTarget == undefined) {
                        next.selectTarget = lib.filter.selectTarget;
                    }
                    next.position = 'hs';
                    if (next.ai1 == undefined)
                        next.ai1 = get.order;
                    if (next.ai2 == undefined)
                        next.ai2 = get.effect_use;
                    next.setContent('chooseToUse');
                    next._args = Array.from(arguments);
                    return next;
                },
                chooseToRespond: function () {
                    var next = game.createEvent('chooseToRespond');
                    next.player = this;
                    var filter;
                    for (var i = 0; i < arguments.length; i++) {
                        if (typeof arguments[i] == 'number') {
                            next.selectCard = [arguments[i], arguments[i]];
                        }
                        else if (get.itemtype(arguments[i]) == 'select') {
                            next.selectCard = arguments[i];
                        }
                        else if (typeof arguments[i] == 'boolean') {
                            next.forced = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'position') {
                            next.position = arguments[i];
                        }
                        else if (typeof arguments[i] == 'function') {
                            if (next.filterCard)
                                next.ai = arguments[i];
                            else
                                next.filterCard = arguments[i];
                        }
                        else if (typeof arguments[i] == 'object' && arguments[i]) {
                            next.filterCard = get.filter(arguments[i]);
                            filter = arguments[i];
                        }
                        else if (arguments[i] == 'nosource') {
                            next.nosource = true;
                        }
                        else if (typeof arguments[i] == 'string') {
                            next.prompt = arguments[i];
                        }
                    }
                    if (next.filterCard == undefined)
                        next.filterCard = lib.filter.all;
                    if (next.selectCard == undefined)
                        next.selectCard = [1, 1];
                    if (next.source == undefined && !next.nosource)
                        next.source = _status.event.player;
                    if (next.ai == undefined)
                        next.ai = get.unuseful2;
                    if (next.prompt != false) {
                        if (typeof next.prompt == 'string') {
                            //next.dialog=next.prompt;
                        }
                        else {
                            var str = '请打出' + get.cnNumber(next.selectCard[0]) + '张';
                            if (filter) {
                                if (filter.name) {
                                    str += get.translation(filter.name);
                                }
                                else {
                                    str += '牌';
                                }
                            }
                            else {
                                str += '牌';
                            }
                            if (_status.event.getParent().name == 'useCard') {
                                var cardname = _status.event.name;
                                if (lib.card[cardname] && lib.translate[cardname]) {
                                    str += '响应' + lib.translate[cardname];
                                }
                            }
                            next.prompt = str;
                        }
                    }
                    next.position = 'hs';
                    next.setContent('chooseToRespond');
                    next._args = Array.from(arguments);
                    return next;
                },
                chooseToDiscard: function () {
                    var next = game.createEvent('chooseToDiscard');
                    next.player = this;
                    for (var i = 0; i < arguments.length; i++) {
                        if (typeof arguments[i] == 'number') {
                            next.selectCard = [arguments[i], arguments[i]];
                        }
                        else if (get.itemtype(arguments[i]) == 'select') {
                            next.selectCard = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'dialog') {
                            next.dialog = arguments[i];
                            next.prompt = false;
                        }
                        else if (typeof arguments[i] == 'boolean') {
                            next.forced = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'position') {
                            next.position = arguments[i];
                        }
                        else if (typeof arguments[i] == 'function') {
                            if (next.filterCard)
                                next.ai = arguments[i];
                            else
                                next.filterCard = arguments[i];
                        }
                        else if (typeof arguments[i] == 'object' && arguments[i]) {
                            next.filterCard = get.filter(arguments[i]);
                        }
                        else if (typeof arguments[i] == 'string') {
                            get.evtprompt(next, arguments[i]);
                        }
                        if (arguments[i] === null) {
                            for (var i = 0; i < arguments.length; i++) {
                                console.log(arguments[i]);
                            }
                        }
                    }
                    if (next.isMine() == false && next.dialog)
                        next.dialog.style.display = 'none';
                    if (next.filterCard == undefined)
                        next.filterCard = lib.filter.all;
                    if (next.selectCard == undefined)
                        next.selectCard = [1, 1];
                    if (next.ai == undefined)
                        next.ai = get.unuseful;
                    next.autochoose = function () {
                        if (!this.forced)
                            return false;
                        if (typeof this.selectCard == 'function')
                            return false;
                        var cards = this.player.getCards(this.position);
                        var num = cards.length;
                        for (var i = 0; i < cards.length; i++) {
                            if (!lib.filter.cardDiscardable(cards[i], this.player, this))
                                num--;
                        }
                        return get.select(this.selectCard)[0] >= num;
                    };
                    next.setContent('chooseToDiscard');
                    next._args = Array.from(arguments);
                    return next;
                },
                chooseToCompare: function (target, check) {
                    var next = game.createEvent('chooseToCompare');
                    next.player = this;
                    if (Array.isArray(target)) {
                        next.targets = target;
                        if (check)
                            next.ai = check;
                        else
                            next.ai = function (card) {
                                if (typeof card == 'string' && lib.skill[card]) {
                                    var ais = lib.skill[card].check || function () { return 0; };
                                    return ais();
                                }
                                var addi = (get.value(card) >= 8 && get.type(card) != 'equip') ? -10 : 0;
                                if (card.name == 'du')
                                    addi += 5;
                                var source = _status.event.source;
                                var player = _status.event.player;
                                var getn = function (card) {
                                    if (player.hasSkill('tianbian') && get.suit(card) == 'heart')
                                        return 13;
                                    return get.number(card);
                                };
                                if (source && source != player && get.attitude(player, source) > 1) {
                                    return -getn(card) - get.value(card) / 2 + addi;
                                }
                                return getn(card) - get.value(card) / 2 + addi;
                            };
                        next.setContent('chooseToCompareMultiple');
                    }
                    else {
                        next.target = target;
                        if (check)
                            next.ai = check;
                        else
                            next.ai = function (card) {
                                if (typeof card == 'string' && lib.skill[card]) {
                                    var ais = lib.skill[card].check || function () { return 0; };
                                    return ais();
                                }
                                var player = get.owner(card);
                                var getn = function (card) {
                                    if (player.hasSkill('tianbian') && get.suit(card) == 'heart')
                                        return 13;
                                    return get.number(card);
                                };
                                var event = _status.event.getParent();
                                var to = (player == event.player ? event.target : event.player);
                                var addi = (get.value(card) >= 8 && get.type(card) != 'equip') ? -10 : 0;
                                if (card.name == 'du')
                                    addi += 5;
                                if (player == event.player) {
                                    if (get.attitude(player, to) > 0 && event.small) {
                                        return -getn(card) - get.value(card) / 2 + addi;
                                    }
                                    return getn(card) - get.value(card) / 2 + addi;
                                }
                                else {
                                    if (get.attitude(player, to) > 0 && !event.small) {
                                        return -getn(card) - get.value(card) / 2 + addi;
                                    }
                                    return getn(card) - get.value(card) / 2 + addi;
                                }
                            };
                        next.setContent('chooseToCompare');
                    }
                    next._args = Array.from(arguments);
                    return next;
                },
                discoverSkill: function (list) {
                    var next = game.createEvent('discoverSkill');
                    next.player = this;
                    next.setContent('discoverSkill');
                    next.list = list;
                    for (var i = 1; i < arguments.length; i++) {
                        if (typeof arguments[i] == 'boolean') {
                            next.forced = arguments[i];
                        }
                        else if (typeof arguments[i] == 'number') {
                            next.num = arguments[i];
                        }
                        else if (typeof arguments[i] == 'string') {
                            next.prompt = arguments[i];
                        }
                        else if (typeof arguments[i] === 'function') {
                            next.ai = arguments[i];
                        }
                    }
                },
                chooseSkill: function (target) {
                    var next = game.createEvent('chooseSkill');
                    next.player = this;
                    next.setContent('chooseSkill');
                    next.target = target;
                    for (var i = 1; i < arguments.length; i++) {
                        if (typeof arguments[i] == 'string') {
                            next.prompt = arguments[i];
                        }
                        else if (typeof arguments[i] == 'function') {
                            next.func = arguments[i];
                        }
                    }
                },
                discoverCard: function (list) {
                    var next = game.createEvent('discoverCard');
                    next.player = this;
                    next.setContent('discoverCard');
                    next.list = list || lib.inpile.slice(0);
                    next.forced = true;
                    for (var i = 1; i < arguments.length; i++) {
                        if (typeof arguments[i] == 'boolean') {
                            next.forced = arguments[i];
                        }
                        else if (typeof arguments[i] == 'string') {
                            switch (arguments[i]) {
                                case 'use':
                                    next.use = true;
                                    break;
                                case 'nogain':
                                    next.nogain = true;
                                    break;
                                default: next.prompt = arguments[i];
                            }
                        }
                        else if (typeof arguments[i] == 'number') {
                            next.num = arguments[i];
                        }
                        else if (typeof arguments[i] === 'function') {
                            next.ai = arguments[i];
                        }
                    }
                    return next;
                },
                chooseCardButton: function () {
                    var cards, prompt, forced, select;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'cards')
                            cards = arguments[i];
                        else if (typeof arguments[i] == 'boolean')
                            forced = arguments[i];
                        else if (typeof arguments[i] == 'string')
                            prompt = arguments[i];
                        else if (get.itemtype(arguments[i]) == 'select' || typeof arguments[i] == 'number')
                            select = arguments[i];
                    }
                    if (prompt == undefined)
                        prompt = '请选择卡牌';
                    return this.chooseButton(forced, select, 'hidden', [prompt, cards, 'hidden']);
                },
                chooseVCardButton: function () {
                    var list, prompt, forced, select, notype = false;
                    for (var i = 0; i < arguments.length; i++) {
                        if (Array.isArray(arguments[i])) {
                            list = arguments[i];
                        }
                        else if (arguments[i] == 'notype') {
                            notype = true;
                        }
                        else if (typeof arguments[i] == 'boolean')
                            forced = arguments[i];
                        else if (typeof arguments[i] == 'string')
                            prompt = arguments[i];
                        else if (get.itemtype(arguments[i]) == 'select' || typeof arguments[i] == 'number')
                            select = arguments[i];
                    }
                    for (var i = 0; i < list.length; i++) {
                        list[i] = [notype ? '' : (get.subtype(list[i]) || get.type(list[i])), '', list[i]];
                    }
                    if (prompt == undefined)
                        prompt = '请选择卡牌';
                    return this.chooseButton(forced, select, 'hidden', [prompt, [list, 'vcard'], 'hidden']);
                },
                chooseButton: function () {
                    var next = game.createEvent('chooseButton');
                    for (var i = 0; i < arguments.length; i++) {
                        if (typeof arguments[i] == 'boolean') {
                            next.forced = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'dialog') {
                            next.dialog = arguments[i];
                            next.closeDialog = true;
                        }
                        else if (get.itemtype(arguments[i]) == 'select') {
                            next.selectButton = arguments[i];
                        }
                        else if (typeof arguments[i] == 'number') {
                            next.selectButton = [arguments[i], arguments[i]];
                        }
                        else if (typeof arguments[i] == 'function') {
                            if (next.ai)
                                next.filterButton = arguments[i];
                            else
                                next.ai = arguments[i];
                        }
                        else if (Array.isArray(arguments[i])) {
                            next.createDialog = arguments[i];
                        }
                    }
                    next.player = this;
                    if (typeof next.forced != 'boolean')
                        next.forced = false;
                    if (next.isMine() == false && next.dialog)
                        next.dialog.style.display = 'none';
                    if (next.filterButton == undefined)
                        next.filterButton = lib.filter.filterButton;
                    if (next.selectButton == undefined)
                        next.selectButton = [1, 1];
                    if (next.ai == undefined)
                        next.ai = function () { return 1; };
                    next.setContent('chooseButton');
                    next._args = Array.from(arguments);
                    next.forceDie = true;
                    return next;
                },
                chooseButtonOL: function (list, callback, ai) {
                    var next = game.createEvent('chooseButtonOL');
                    next.list = list;
                    next.setContent('chooseButtonOL');
                    next.ai = ai;
                    next.callback = callback;
                    next._args = Array.from(arguments);
                    return next;
                },
                chooseCardOL: function () {
                    var next = game.createEvent('chooseCardOL');
                    next._args = [];
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'players') {
                            next.list = arguments[i].slice(0);
                        }
                        else {
                            next._args.push(arguments[i]);
                        }
                    }
                    next.setContent('chooseCardOL');
                    next._args.add('glow_result');
                    return next;
                },
                chooseCard: function (choose) {
                    var next = game.createEvent('chooseCard');
                    next.player = this;
                    if (arguments.length == 1 && get.is.object(choose)) {
                        for (var i in choose) {
                            next[i] = choose[i];
                        }
                    }
                    else {
                        for (var i = 0; i < arguments.length; i++) {
                            if (typeof arguments[i] == 'number') {
                                next.selectCard = [arguments[i], arguments[i]];
                            }
                            else if (get.itemtype(arguments[i]) == 'select') {
                                next.selectCard = arguments[i];
                            }
                            else if (typeof arguments[i] == 'boolean') {
                                next.forced = arguments[i];
                            }
                            else if (get.itemtype(arguments[i]) == 'position') {
                                next.position = arguments[i];
                            }
                            else if (typeof arguments[i] == 'function') {
                                if (next.filterCard)
                                    next.ai = arguments[i];
                                else
                                    next.filterCard = arguments[i];
                            }
                            else if (typeof arguments[i] == 'object' && arguments[i]) {
                                next.filterCard = get.filter(arguments[i]);
                            }
                            else if (arguments[i] == 'glow_result') {
                                next.glow_result = true;
                            }
                            else if (typeof arguments[i] == 'string') {
                                get.evtprompt(next, arguments[i]);
                            }
                        }
                    }
                    if (next.filterCard == undefined)
                        next.filterCard = lib.filter.all;
                    if (next.selectCard == undefined)
                        next.selectCard = [1, 1];
                    if (next.ai == undefined)
                        next.ai = get.unuseful3;
                    next.setContent('chooseCard');
                    next._args = Array.from(arguments);
                    return next;
                },
                chooseUseTarget: function () {
                    var next = game.createEvent('chooseUseTarget');
                    next.player = this;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'cards') {
                            next.cards = arguments[i].slice(0);
                        }
                        else if (get.itemtype(arguments[i]) == 'card') {
                            next.card = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'players') {
                            next.targets = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'player') {
                            next.targets = [arguments[i]];
                        }
                        else if (get.is.object(arguments[i]) && arguments[i].name) {
                            next.card = arguments[i];
                        }
                        else if (typeof arguments[i] == 'string') {
                            if (arguments[i] == 'nopopup') {
                                next.nopopup = true;
                            }
                            else if (arguments[i] == 'noanimate') {
                                next.animate = false;
                            }
                            else if (arguments[i] == 'nothrow') {
                                next["throw"] = false;
                            }
                            else if (arguments[i] == 'nodistance') {
                                next.nodistance = true;
                            }
                            else if (arguments[i] == 'noTargetDelay') {
                                next.noTargetDelay = true;
                            }
                            else if (arguments[i] == 'nodelayx') {
                                next.nodelayx = true;
                            }
                            else if (lib.card[arguments[i]] && !next.card) {
                                next.card = { name: arguments[i], isCard: true };
                            }
                            else
                                get.evtprompt(next, arguments[i]);
                        }
                        else if (arguments[i] === true) {
                            next.forced = true;
                        }
                        else if (arguments[i] === false) {
                            next.addCount = false;
                        }
                    }
                    if (!next.targets)
                        next.targets = game.players.slice(0);
                    if (next.cards == undefined) {
                        if (get.itemtype(next.card) == 'card') {
                            next.cards = [next.card];
                        }
                        else
                            next.cards = [];
                    }
                    else if (next.card == undefined) {
                        if (next.cards) {
                            next.card = next.cards[0];
                        }
                    }
                    next.setContent('chooseUseTarget');
                    next._args = Array.from(arguments);
                    return next;
                    // Fully Online-Ready! Enjoy It!
                },
                chooseTarget: function () {
                    var next = game.createEvent('chooseTarget');
                    next.player = this;
                    for (var i = 0; i < arguments.length; i++) {
                        if (typeof arguments[i] == 'number') {
                            next.selectTarget = [arguments[i], arguments[i]];
                        }
                        else if (get.itemtype(arguments[i]) == 'select') {
                            next.selectTarget = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'dialog') {
                            next.dialog = arguments[i];
                            next.prompt = false;
                        }
                        else if (typeof arguments[i] == 'boolean') {
                            next.forced = arguments[i];
                        }
                        else if (typeof arguments[i] == 'function') {
                            if (next.filterTarget)
                                next.ai = arguments[i];
                            else
                                next.filterTarget = arguments[i];
                        }
                        else if (typeof arguments[i] == 'string') {
                            get.evtprompt(next, arguments[i]);
                        }
                    }
                    if (next.filterTarget == undefined)
                        next.filterTarget = lib.filter.all;
                    if (next.selectTarget == undefined)
                        next.selectTarget = [1, 1];
                    if (next.ai == undefined)
                        next.ai = get.attitude2;
                    next.setContent('chooseTarget');
                    next._args = Array.from(arguments);
                    next.forceDie = true;
                    return next;
                },
                chooseCardTarget: function (choose) {
                    var next = game.createEvent('chooseCardTarget');
                    next.player = this;
                    if (arguments.length == 1) {
                        for (var i in choose) {
                            next[i] = choose[i];
                        }
                    }
                    if (typeof next.filterCard == 'object') {
                        next.filterCard = get.filter(next.filterCard);
                    }
                    if (typeof next.filterTarget == 'object') {
                        next.filterTarget = get.filter(next.filterTarget, 2);
                    }
                    if (next.filterCard == undefined || next.filterCard === true) {
                        next.filterCard = lib.filter.all;
                    }
                    if (next.selectCard == undefined) {
                        next.selectCard = 1;
                    }
                    if (next.filterTarget == undefined || next.filterTarget === true) {
                        next.filterTarget = lib.filter.all;
                    }
                    if (next.selectTarget == undefined) {
                        next.selectTarget = 1;
                    }
                    if (next.ai1 == undefined)
                        next.ai1 = get.unuseful2;
                    if (next.ai2 == undefined)
                        next.ai2 = get.attitude2;
                    next.setContent('chooseCardTarget');
                    next._args = Array.from(arguments);
                    return next;
                },
                chooseControlList: function () {
                    var list = [];
                    var prompt = null;
                    var forced = 'cancel2';
                    var func = null;
                    for (var i = 0; i < arguments.length; i++) {
                        if (typeof arguments[i] == 'string') {
                            if (!prompt) {
                                prompt = arguments[i];
                            }
                            else {
                                list.push(arguments[i]);
                            }
                        }
                        else if (Array.isArray(arguments[i])) {
                            list = arguments[i];
                        }
                        else if (arguments[i] === true) {
                            forced = null;
                        }
                        else if (typeof arguments[i] == 'function') {
                            func = arguments[i];
                        }
                    }
                    return this.chooseControl(forced, func).set('choiceList', list).set('prompt', prompt);
                },
                chooseControl: function () {
                    var next = game.createEvent('chooseControl');
                    next.controls = [];
                    for (var i = 0; i < arguments.length; i++) {
                        if (typeof arguments[i] == 'string') {
                            if (arguments[i] == 'dialogcontrol') {
                                next.dialogcontrol = true;
                            }
                            else if (arguments[i] == 'seperate') {
                                next.seperate = true;
                            }
                            else {
                                next.controls.push(arguments[i]);
                            }
                        }
                        else if (Array.isArray(arguments[i])) {
                            next.controls = next.controls.concat(arguments[i]);
                        }
                        else if (typeof arguments[i] == 'function') {
                            next.ai = arguments[i];
                        }
                        else if (typeof arguments[i] == 'number') {
                            next.choice = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'dialog') {
                            next.dialog = arguments[i];
                        }
                    }
                    next.player = this;
                    if (next.choice == undefined)
                        next.choice = 0;
                    next.setContent('chooseControl');
                    next._args = Array.from(arguments);
                    next.forceDie = true;
                    return next;
                },
                chooseBool: function () {
                    var next = game.createEvent('chooseBool');
                    for (var i = 0; i < arguments.length; i++) {
                        if (typeof arguments[i] == 'boolean') {
                            next.choice = arguments[i];
                        }
                        else if (typeof arguments[i] == 'function') {
                            next.ai = arguments[i];
                        }
                        else if (typeof arguments[i] == 'string') {
                            get.evtprompt(next, arguments[i]);
                        }
                        else if (get.itemtype(arguments[i]) == 'dialog') {
                            next.dialog = arguments[i];
                        }
                        if (next.choice == undefined)
                            next.choice = true;
                    }
                    next.player = this;
                    next.setContent('chooseBool');
                    next._args = Array.from(arguments);
                    next.forceDie = true;
                    return next;
                },
                chooseDrawRecover: function () {
                    var next = game.createEvent('chooseDrawRecover', false);
                    next.player = this;
                    for (var i = 0; i < arguments.length; i++) {
                        if (typeof arguments[i] == 'number') {
                            if (typeof next.num1 == 'number') {
                                next.num2 = arguments[i];
                            }
                            else {
                                next.num1 = arguments[i];
                            }
                        }
                        else if (typeof arguments[i] == 'boolean') {
                            next.forced = arguments[i];
                        }
                        else if (typeof arguments[i] == 'string') {
                            next.prompt = arguments[i];
                        }
                        else if (typeof arguments[i] == 'function') {
                            next.ai = arguments[i];
                        }
                    }
                    if (typeof next.num1 != 'number') {
                        next.num1 = 1;
                    }
                    if (typeof next.num2 != 'number') {
                        next.num2 = 1;
                    }
                    next.setContent('chooseDrawRecover');
                    return next;
                },
                choosePlayerCard: function () {
                    var next = game.createEvent('choosePlayerCard');
                    next.player = this;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'player') {
                            next.target = arguments[i];
                        }
                        else if (typeof arguments[i] == 'number') {
                            next.selectButton = [arguments[i], arguments[i]];
                        }
                        else if (get.itemtype(arguments[i]) == 'select') {
                            next.selectButton = arguments[i];
                        }
                        else if (typeof arguments[i] == 'boolean') {
                            next.forced = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'position') {
                            next.position = arguments[i];
                        }
                        else if (arguments[i] == 'visible') {
                            next.visible = true;
                        }
                        else if (typeof arguments[i] == 'function') {
                            if (next.ai)
                                next.filterButton = arguments[i];
                            else
                                next.ai = arguments[i];
                        }
                        else if (typeof arguments[i] == 'object' && arguments[i]) {
                            next.filterButton = get.filter(arguments[i]);
                        }
                        else if (typeof arguments[i] == 'string') {
                            next.prompt = arguments[i];
                        }
                    }
                    if (next.filterButton == undefined)
                        next.filterButton = lib.filter.all;
                    if (next.position == undefined)
                        next.position = 'he';
                    if (next.selectButton == undefined)
                        next.selectButton = [1, 1];
                    if (next.ai == undefined)
                        next.ai = function (button) {
                            var val = get.buttonValue(button);
                            if (get.attitude(_status.event.player, get.owner(button.link)) > 0)
                                return -val;
                            return val;
                        };
                    next.setContent('choosePlayerCard');
                    next._args = Array.from(arguments);
                    return next;
                },
                discardPlayerCard: function () {
                    var next = game.createEvent('discardPlayerCard');
                    next.player = this;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'player') {
                            next.target = arguments[i];
                        }
                        else if (typeof arguments[i] == 'number') {
                            next.selectButton = [arguments[i], arguments[i]];
                        }
                        else if (get.itemtype(arguments[i]) == 'select') {
                            next.selectButton = arguments[i];
                        }
                        else if (typeof arguments[i] == 'boolean') {
                            next.forced = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'position') {
                            next.position = arguments[i];
                        }
                        else if (arguments[i] == 'visible') {
                            next.visible = true;
                        }
                        else if (typeof arguments[i] == 'function') {
                            if (next.ai)
                                next.filterButton = arguments[i];
                            else
                                next.ai = arguments[i];
                        }
                        else if (typeof arguments[i] == 'object' && arguments[i]) {
                            next.filterButton = get.filter(arguments[i]);
                        }
                        else if (typeof arguments[i] == 'string') {
                            next.prompt = arguments[i];
                        }
                    }
                    if (next.filterButton == undefined)
                        next.filterButton = lib.filter.all;
                    if (next.position == undefined)
                        next.position = 'he';
                    if (next.selectButton == undefined)
                        next.selectButton = [1, 1];
                    if (next.ai == undefined)
                        next.ai = function (button) {
                            var val = get.buttonValue(button);
                            if (get.attitude(_status.event.player, get.owner(button.link)) > 0)
                                return -val;
                            return val;
                        };
                    next.setContent('discardPlayerCard');
                    next._args = Array.from(arguments);
                    return next;
                },
                gainPlayerCard: function () {
                    var next = game.createEvent('gainPlayerCard');
                    next.player = this;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'player') {
                            next.target = arguments[i];
                        }
                        else if (typeof arguments[i] == 'number') {
                            next.selectButton = [arguments[i], arguments[i]];
                        }
                        else if (get.itemtype(arguments[i]) == 'select') {
                            next.selectButton = arguments[i];
                        }
                        else if (typeof arguments[i] == 'boolean') {
                            next.forced = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'position') {
                            next.position = arguments[i];
                        }
                        else if (arguments[i] == 'visible') {
                            next.visible = true;
                        }
                        else if (arguments[i] == 'visibleMove') {
                            next.visibleMove = true;
                        }
                        else if (typeof arguments[i] == 'function') {
                            if (next.ai)
                                next.filterButton = arguments[i];
                            else
                                next.ai = arguments[i];
                        }
                        else if (typeof arguments[i] == 'object' && arguments[i]) {
                            next.filterButton = get.filter(arguments[i]);
                        }
                        else if (typeof arguments[i] == 'string') {
                            next.prompt = arguments[i];
                        }
                    }
                    if (next.filterButton == undefined)
                        next.filterButton = lib.filter.all;
                    if (next.position == undefined)
                        next.position = 'he';
                    if (next.selectButton == undefined)
                        next.selectButton = [1, 1];
                    if (next.ai == undefined)
                        next.ai = function (button) {
                            var val = get.buttonValue(button);
                            if (get.attitude(_status.event.player, get.owner(button.link)) > 0)
                                return -val;
                            return val;
                        };
                    next.setContent('gainPlayerCard');
                    next._args = Array.from(arguments);
                    return next;
                },
                showHandcards: function (str) {
                    var next = game.createEvent('showHandcards');
                    next.player = this;
                    if (typeof str == 'string') {
                        next.prompt = str;
                    }
                    next.setContent('showHandcards');
                    next._args = Array.from(arguments);
                    return next;
                },
                showCards: function (cards, str) {
                    var next = game.createEvent('showCards');
                    next.player = this;
                    next.str = str;
                    if (typeof cards == 'string') {
                        str = cards;
                        cards = next.str;
                        next.str = str;
                    }
                    if (get.itemtype(cards) == 'card')
                        next.cards = [cards];
                    else if (get.itemtype(cards) == 'cards')
                        next.cards = cards.slice(0);
                    else
                        _status.event.next.remove(next);
                    next.setContent('showCards');
                    next._args = Array.from(arguments);
                    return next;
                },
                viewCards: function (str, cards) {
                    var next = game.createEvent('viewCards');
                    next.player = this;
                    next.str = str;
                    next.cards = cards.slice(0);
                    next.setContent('viewCards');
                    next._args = Array.from(arguments);
                    return next;
                },
                viewHandcards: function (target) {
                    var cards = target.getCards('h');
                    if (cards.length) {
                        return this.viewCards(get.translation(target) + '的手牌', cards);
                    }
                    else {
                        return false;
                    }
                },
                canMoveCard: function (withatt, nojudge, moveHandcard) {
                    var player = this;
                    return game.hasPlayer(function (current) {
                        var att = get.sgn(get.attitude(player, current));
                        if (!withatt || att != 0) {
                            var es = current.getCards('e');
                            for (var i = 0; i < es.length; i++) {
                                if (game.hasPlayer(function (current2) {
                                    if (withatt) {
                                        if (get.sgn(get.value(es[i], current)) != -att)
                                            return false;
                                        var att2 = get.sgn(get.attitude(player, current2));
                                        if (att == att2 || att2 != get.sgn(get.effect(current2, es[i], player, current2)))
                                            return false;
                                    }
                                    return current != current2 && !current2.isMin() && current2.isEmpty(get.subtype(es[i]));
                                })) {
                                    return true;
                                }
                            }
                        }
                        if (!nojudge && (!withatt || att > 0)) {
                            var js = current.getCards('j');
                            for (var i = 0; i < js.length; i++) {
                                if (game.hasPlayer(function (current2) {
                                    if (withatt) {
                                        var att2 = get.attitude(player, current2);
                                        if (att2 >= 0)
                                            return false;
                                    }
                                    return current != current2 && current2.canAddJudge(js[i]);
                                })) {
                                    return true;
                                }
                            }
                        }
                        if (moveHandcard == true) {
                            if (current.countCards('h') > 0)
                                return true;
                        }
                    });
                },
                moveCard: function () {
                    var next = game.createEvent('moveCard');
                    next.player = this;
                    for (var i = 0; i < arguments.length; i++) {
                        if (typeof arguments[i] == 'boolean') {
                            next.forced = arguments[i];
                        }
                        else if (typeof arguments[i] == 'string') {
                            get.evtprompt(next, arguments[i]);
                        }
                        else if (typeof arguments[i] == 'function') {
                            if (next.sourceFilterTarget)
                                next.ai = arguments[i];
                            else
                                next.sourceFilterTarget = arguments[i];
                        }
                        else if (Array.isArray(arguments[i])) {
                            for (var j = 0; j < arguments[i].length; j++) {
                                if (typeof arguments[i][j] != 'string')
                                    break;
                            }
                            if (j == arguments[i].length) {
                                next.targetprompt = arguments[i];
                            }
                        }
                    }
                    next.setContent('moveCard');
                    next._args = Array.from(arguments);
                    return next;
                },
                /**
                 * 本角色使用牌或技能；`chooseToUse`时调用
                 * @function
                 * @param {*} result `chooseToUse`的结果
                 * @param {?GameCores.Bases.Event} [event] 父事件，如果不指定，使用当前事件作为父事件
                 */
                useResult: function (result, event) {
                    event = event || _status.event;
                    if (result._sendskill) {
                        lib.skill[result._sendskill[0]] = result._sendskill[1];
                    }
                    if (event.onresult) {
                        event.onresult(result);
                    }
                    if (result.skill) {
                        var info = get.info(result.skill);
                        if (info.onuse) {
                            info.onuse(result, this);
                        }
                        if (info.direct && !info.clearTime) {
                            _status.noclearcountdown = true;
                        }
                    }
                    if (event.logSkill) {
                        if (typeof event.logSkill == 'string') {
                            this.logSkill(event.logSkill);
                        }
                        else if (Array.isArray(event.logSkill)) {
                            this.logSkill.apply(this, event.logSkill);
                        }
                    }
                    if (result.card || !result.skill) {
                        result.used = result.card || result.cards[0];
                        var next = this.useCard(result.card, result.cards, result.targets, result.skill);
                        next.oncard = event.oncard;
                        next.respondTo = event.respondTo;
                        if (event.addCount === false) {
                            next.addCount = false;
                        }
                        return next;
                    }
                    else if (result.skill) {
                        result.used = result.skill;
                        return this.useSkill(result.skill, result.cards, result.targets);
                    }
                },
                useCard: function () {
                    var next = game.createEvent('useCard');
                    next.player = this;
                    next.num = 0;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'cards') {
                            next.cards = arguments[i].slice(0);
                        }
                        else if (get.itemtype(arguments[i]) == 'players') {
                            next.targets = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'player') {
                            next.targets = [arguments[i]];
                        }
                        else if (get.itemtype(arguments[i]) == 'card') {
                            next.card = arguments[i];
                        }
                        else if (typeof arguments[i] == 'object' && arguments[i] && arguments[i].name) {
                            next.card = arguments[i];
                        }
                        else if (typeof arguments[i] == 'string') {
                            if (arguments[i] == 'noai') {
                                next.noai = true;
                            }
                            else if (arguments[i] == 'nowuxie') {
                                next.nowuxie = true;
                            }
                            else {
                                next.skill = arguments[i];
                            }
                        }
                        else if (typeof arguments[i] == 'boolean') {
                            next.addCount = arguments[i];
                        }
                    }
                    if (next.cards == undefined) {
                        if (get.itemtype(next.card) == 'card') {
                            next.cards = [next.card];
                        }
                        else
                            next.cards = [];
                    }
                    else if (next.card == undefined) {
                        if (next.cards) {
                            next.card = next.cards[0];
                        }
                    }
                    if (!next.targets) {
                        next.targets = [];
                    }
                    if (next.card) {
                        next.card = get.autoViewAs(next.card, false, next.player);
                        var info = get.info(next.card);
                        if (info.changeTarget) {
                            info.changeTarget(next.player, next.targets);
                        }
                        if (info.singleCard) {
                            next._targets = next.targets.slice(0);
                            next.target = next.targets[0];
                            next.addedTargets = next.targets.splice(1);
                            if (next.addedTargets.length) {
                                next.addedTarget = next.addedTargets[0];
                            }
                        }
                        if (!next.card.isCard && next.cards.length) {
                            next.card.cards = next.cards.slice(0);
                        }
                    }
                    for (var i = 0; i < next.targets.length; i++) {
                        if (get.attitude(this, next.targets[i]) >= -1 && get.attitude(this, next.targets[i]) < 0) {
                            if (!this.ai.tempIgnore)
                                this.ai.tempIgnore = [];
                            this.ai.tempIgnore.add(next.targets[i]);
                        }
                    }
                    if (typeof this.logAi == 'function' && !next.noai && !get.info(next.card).noai) {
                        var postAi = get.info(next.card).postAi;
                        if (postAi && postAi(next.targets)) {
                            next.postAi = true;
                        }
                        else {
                            this.logAi(next.targets, next.card);
                        }
                    }
                    next.stocktargets = next.targets.slice(0);
                    next.setContent('useCard');
                    return next;
                },
                useSkill: function () {
                    var next = game.createEvent('useSkill');
                    next.player = this;
                    next.num = 0;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'cards') {
                            next.cards = arguments[i].slice(0);
                        }
                        else if (get.itemtype(arguments[i]) == 'players') {
                            next.targets = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'card') {
                            next.card = arguments[i];
                        }
                        else if (typeof arguments[i] == 'string') {
                            next.skill = arguments[i];
                        }
                        else if (typeof arguments[i] == 'boolean') {
                            next.addCount = arguments[i];
                        }
                    }
                    if (next.cards == undefined) {
                        next.cards = [];
                    }
                    if (next.skill && get.info(next.skill) && get.info(next.skill).changeTarget) {
                        get.info(next.skill).changeTarget(next.player, next.targets);
                    }
                    if (next.targets) {
                        for (var i = 0; i < next.targets.length; i++) {
                            if (get.attitude(this, next.targets[i]) >= -1 && get.attitude(this, next.targets[i]) < 0) {
                                if (!this.ai.tempIgnore)
                                    this.ai.tempIgnore = [];
                                this.ai.tempIgnore.add(next.targets[i]);
                            }
                        }
                        if (typeof this.logAi == 'function') {
                            this.logAi(next.targets, next.skill);
                        }
                    }
                    else {
                        next.targets = [];
                    }
                    next.setContent('useSkill');
                    return next;
                },
                drawTo: function (num, args) {
                    var num2 = num - this.countCards('h');
                    if (!num2)
                        return;
                    var next = this.draw(num2);
                    if (Array.isArray(args)) {
                        for (var i = 0; i < args.length; i++) {
                            if (get.itemtype(args[i]) == 'player') {
                                next.source = args[i];
                            }
                            else if (typeof args[i] == 'boolean') {
                                next.animate = args[i];
                            }
                            else if (args[i] == 'nodelay') {
                                next.animate = false;
                                next.$draw = true;
                            }
                            else if (args[i] == 'visible') {
                                next.visible = true;
                            }
                            else if (args[i] == 'bottom') {
                                next.bottom = true;
                            }
                            else if (typeof args[i] == 'object' && args[i] && args[i].drawDeck != undefined) {
                                next.drawDeck = args[i].drawDeck;
                            }
                        }
                    }
                    return next;
                },
                draw: function () {
                    var next = game.createEvent('draw');
                    next.player = this;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'player') {
                            next.source = arguments[i];
                        }
                        else if (typeof arguments[i] == 'number') {
                            next.num = arguments[i];
                        }
                        else if (typeof arguments[i] == 'boolean') {
                            next.animate = arguments[i];
                        }
                        else if (arguments[i] == 'nodelay') {
                            next.animate = false;
                            next.$draw = true;
                        }
                        else if (arguments[i] == 'visible') {
                            next.visible = true;
                        }
                        else if (arguments[i] == 'bottom') {
                            next.bottom = true;
                        }
                        else if (typeof arguments[i] == 'object' && arguments[i] && arguments[i].drawDeck != undefined) {
                            next.drawDeck = arguments[i].drawDeck;
                        }
                    }
                    if (next.num == undefined)
                        next.num = 1;
                    if (next.num <= 0)
                        _status.event.next.remove(next);
                    next.setContent('draw');
                    if (lib.config.mode == 'stone' && _status.mode == 'deck' &&
                        next.drawDeck == undefined && !next.player.isMin() && next.num > 1) {
                        next.drawDeck = 1;
                    }
                    return next;
                },
                randomDiscard: function () {
                    var position = 'he', num = 1, delay = null;
                    for (var i = 0; i < arguments.length; i++) {
                        if (typeof arguments[i] == 'number') {
                            num = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'position') {
                            position = arguments[i];
                        }
                        else if (typeof arguments[i] == 'boolean') {
                            delay = arguments[i];
                        }
                    }
                    var cards = this.getCards(position).randomGets(num);
                    if (cards.length) {
                        var next = this.discard(cards, 'notBySelf');
                        if (typeof delay == 'boolean') {
                            next.delay = delay;
                        }
                    }
                    return cards;
                },
                randomGain: function () {
                    var position = 'he', num = 1, target = null, line = false;
                    for (var i = 0; i < arguments.length; i++) {
                        if (typeof arguments[i] == 'number') {
                            num = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'position') {
                            position = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'player') {
                            target = arguments[i];
                        }
                        else if (typeof arguments[i] == 'boolean') {
                            line = arguments[i];
                        }
                    }
                    if (target) {
                        var cards = target.getCards(position).randomGets(num);
                        if (cards.length) {
                            if (line) {
                                this.line(target, 'green');
                            }
                            this.gain(cards, target, 'log', 'bySelf');
                            target.$giveAuto(cards, this);
                        }
                        return cards;
                    }
                    return [];
                },
                discard: function () {
                    var next = game.createEvent('discard');
                    next.player = this;
                    next.num = 0;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'player') {
                            next.source = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'cards') {
                            next.cards = arguments[i].slice(0);
                        }
                        else if (get.itemtype(arguments[i]) == 'card') {
                            next.cards = [arguments[i]];
                        }
                        else if (typeof arguments[i] == 'boolean') {
                            next.animate = arguments[i];
                        }
                        else if (get.objtype(arguments[i]) == 'div') {
                            next.position = arguments[i];
                        }
                        else if (arguments[i] == 'notBySelf') {
                            next.notBySelf = true;
                        }
                    }
                    if (next.cards == undefined)
                        _status.event.next.remove(next);
                    next.setContent('discard');
                    return next;
                },
                respond: function () {
                    var next = game.createEvent('respond');
                    next.player = this;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'cards') {
                            next.cards = arguments[i].slice(0);
                        }
                        else if (get.itemtype(arguments[i]) == 'card') {
                            next.card = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'player') {
                            next.source = arguments[i];
                        }
                        else if (typeof arguments[i] == 'object' && arguments[i] && arguments[i].name) {
                            next.card = arguments[i];
                        }
                        else if (typeof arguments[i] == 'boolean')
                            next.animate = arguments[i];
                        else if (arguments[i] == 'highlight')
                            next.highlight = true;
                        else if (arguments[i] == 'noOrdering')
                            next.noOrdering = true;
                        else if (typeof arguments[i] == 'string')
                            next.skill = arguments[i];
                    }
                    if (next.cards == undefined) {
                        if (get.itemtype(next.card) == 'card') {
                            next.cards = [next.card];
                        }
                        else {
                            next.cards = [];
                        }
                    }
                    else if (next.card == undefined) {
                        if (next.cards) {
                            next.card = next.cards[0];
                            if (!next.skill) {
                                next.card = get.autoViewAs(next.card, null, next.player);
                            }
                        }
                    }
                    next.setContent('respond');
                    return next;
                },
                swapHandcards: function (target, cards1, cards2) {
                    var next = game.createEvent('swapHandcards', false);
                    next.player = this;
                    next.target = target;
                    if (cards1)
                        next.cards1 = cards1;
                    if (cards2)
                        next.cards2 = cards2;
                    next.setContent('swapHandcards');
                    return next;
                },
                directequip: function (cards) {
                    for (var i = 0; i < cards.length; i++) {
                        this.$equip(cards[i]);
                    }
                    if (!_status.video) {
                        game.addVideo('directequip', this, get.cardsInfo(cards));
                    }
                },
                directgain: function (cards, broadcast, gaintag) {
                    var hs = this.getCards('hs');
                    for (var i = 0; i < cards.length; i++) {
                        if (hs.contains(cards[i])) {
                            cards.splice(i--, 1);
                        }
                    }
                    for (var i = 0; i < cards.length; i++) {
                        cards[i].fix();
                        if (gaintag)
                            cards[i].addGaintag(gaintag);
                        var sort = lib.config.sort_card(cards[i]);
                        if (this == game.me) {
                            cards[i].classList.add('drawinghidden');
                        }
                        if (get.is.singleHandcard() || sort > 0) {
                            this.node.handcards1.insertBefore(cards[i], this.node.handcards1.firstChild);
                        }
                        else {
                            this.node.handcards2.insertBefore(cards[i], this.node.handcards2.firstChild);
                        }
                    }
                    if (this == game.me || _status.video)
                        ui.updatehl();
                    if (!_status.video) {
                        game.addVideo('directgain', this, get.cardsInfo(cards));
                        this.update();
                    }
                    if (broadcast !== false)
                        game.broadcast(function (player, cards) {
                            player.directgain(cards);
                        }, this, cards);
                    return this;
                },
                /**
                 * 本角色获取游戏牌到武将牌上，从除本角色武将牌上、手牌外的区域
                 * @param {Array<GameCores.GameObjects.Card>} cards 要获取的游戏牌数组，如果一张游戏牌在本角色(手牌|武将牌上)，就从数组中移除它
                 * @param {?boolean} [broadcast] 如果为trueh或未指定，通过{@link game.broadcast}同步获取游戏牌；如果为false，本机更新
                 * @param {string} [gaintag] 为此次通过此函数移动到武将牌上的每张游戏牌设置`card.gaintag=`
                 */
                directgains: function (cards, broadcast, gaintag) {
                    var hs = this.getCards('hs');
                    for (var i = 0; i < cards.length; i++) {
                        if (hs.contains(cards[i])) {
                            cards.splice(i--, 1);
                        }
                    }
                    var addLast = function (card, node) {
                        if (gaintag) {
                            for (var i = 0; i < node.childNodes.length; i++) {
                                var add = node.childNodes[node.childNodes.length - i - 1];
                                if (!add.classList.contains('glows'))
                                    break;
                                if (add.hasGaintag(gaintag)) {
                                    node.insertBefore(card, add.nextSibling);
                                    return;
                                }
                            }
                        }
                        node.appendChild(card);
                    };
                    for (var i = 0; i < cards.length; i++) {
                        cards[i].fix();
                        cards[i].remove();
                        if (gaintag)
                            cards[i].addGaintag(gaintag);
                        cards[i].classList.add('glows');
                        if (this == game.me) {
                            cards[i].classList.add('drawinghidden');
                        }
                        if (get.is.singleHandcard()) {
                            addLast(cards[i], this.node.handcards1);
                        }
                        else {
                            addLast(cards[i], this.node.handcards2);
                        }
                    }
                    if (this == game.me || _status.video)
                        ui.updatehl();
                    if (!_status.video) {
                        game.addVideo('directgains', this, get.cardsInfo(cards));
                        this.update();
                    }
                    if (broadcast !== false)
                        game.broadcast(function (player, cards, gaintag) {
                            player.directgains(cards, null, gaintag); //[recommend] use false instead of null
                        }, this, cards, gaintag);
                    return this;
                },
                gainMultiple: function (targets, position) {
                    var next = game.createEvent('gainMultiple', false);
                    next.setContent('gainMultiple');
                    next.player = this;
                    next.targets = targets;
                    next.position = position || 'h';
                    return next;
                },
                gain: function () {
                    var next = game.createEvent('gain');
                    next.player = this;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'player') {
                            next.source = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'cards') {
                            next.cards = arguments[i].slice(0);
                        }
                        else if (get.itemtype(arguments[i]) == 'card') {
                            next.cards = [arguments[i]];
                        }
                        else if (arguments[i] === 'log') {
                            next.log = true;
                        }
                        else if (arguments[i] == 'fromStorage') {
                            next.fromStorage = true;
                        }
                        else if (arguments[i] == 'bySelf') {
                            next.bySelf = true;
                        }
                        else if (typeof arguments[i] == 'string') {
                            next.animate = arguments[i];
                        }
                        else if (typeof arguments[i] == 'boolean') {
                            next.delay = arguments[i];
                        }
                    }
                    if (next.animate == 'gain2' || next.animate == 'draw2') {
                        if (!next.hasOwnProperty('log')) {
                            next.log = true;
                        }
                    }
                    next.setContent('gain');
                    next.getl = function (player) {
                        var that = this;
                        var map = {
                            player: player,
                            hs: [],
                            es: [],
                            js: [],
                            ss: [],
                            cards: [],
                            cards2: []
                        };
                        player.getHistory('lose', function (evt) {
                            if (evt.parent == that) {
                                map.hs.addArray(evt.hs);
                                map.es.addArray(evt.es);
                                map.js.addArray(evt.js);
                                map.ss.addArray(evt.ss);
                                map.cards.addArray(evt.cards);
                                map.cards2.addArray(evt.cards2);
                            }
                        });
                        if (map.cards.length > 0 || map.ss.length > 0)
                            return map;
                    };
                    next.gaintag = [];
                    return next;
                },
                give: function (cards, target, visible) {
                    var next = target.gain(cards, this);
                    next.animate = visible ? 'give' : 'giveAuto';
                },
                lose: function () {
                    var next = game.createEvent('lose');
                    next.player = this;
                    next.forceDie = true;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'player') {
                            next.source = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'cards') {
                            next.cards = arguments[i].slice(0);
                        }
                        else if (get.itemtype(arguments[i]) == 'card') {
                            next.cards = [arguments[i]];
                        }
                        else if (get.objtype(arguments[i]) == 'div') {
                            next.position = arguments[i];
                        }
                        else if (arguments[i] == 'toStorage') {
                            next.toStorage = true;
                        }
                        else if (arguments[i] == 'visible') {
                            next.visible = true;
                        }
                        else if (arguments[i] == 'insert') {
                            next.insert_card = true;
                        }
                    }
                    if (next.cards) {
                        var hej = this.getCards('hejs');
                        for (var i = 0; i < next.cards.length; i++) {
                            if (!hej.contains(next.cards[i])) {
                                next.cards.splice(i--, 1);
                            }
                        }
                    }
                    if (!next.cards || !next.cards.length) {
                        _status.event.next.remove(next);
                    }
                    else {
                        if (next.position == undefined)
                            next.position = ui.discardPile;
                        next.cards = next.cards.slice(0);
                    }
                    next.setContent('lose');
                    next.getl = function (player) {
                        if (this.getlx !== false && this.player == player)
                            return this;
                    };
                    return next;
                },
                damage: function () {
                    var next = game.createEvent('damage');
                    //next.forceDie=true;
                    next.player = this;
                    var nocard, nosource;
                    var event = _status.event;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'cards') {
                            next.cards = arguments[i].slice(0);
                        }
                        else if (get.itemtype(arguments[i]) == 'card') {
                            next.card = arguments[i];
                        }
                        else if (typeof arguments[i] == 'number') {
                            next.num = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'player') {
                            next.source = arguments[i];
                        }
                        else if (typeof arguments[i] == 'object' && arguments[i] && arguments[i].name) {
                            next.card = arguments[i];
                        }
                        else if (arguments[i] == 'nocard') {
                            nocard = true;
                        }
                        else if (arguments[i] == 'nosource') {
                            nosource = true;
                        }
                        else if (arguments[i] == 'notrigger') {
                            next._triggered = null;
                            next.notrigger = true;
                        }
                        else if (get.itemtype(arguments[i]) == 'nature') {
                            next.nature = arguments[i];
                        }
                    }
                    if (next.card == undefined && !nocard)
                        next.card = event.card;
                    if (next.cards == undefined && !nocard)
                        next.cards = event.cards;
                    if (next.source == undefined && !nosource)
                        next.source = event.player;
                    if (next.source && next.source.isDead())
                        delete next.source;
                    if (next.num == undefined)
                        next.num = 1;
                    if (next.nature == 'poison')
                        delete next._triggered;
                    next.setContent('damage');
                    next.filterStop = function () {
                        if (this.source && this.source.isDead())
                            delete this.source;
                        if (this.num <= 0) {
                            delete this.filterStop;
                            this.trigger('damageZero');
                            this.finish();
                            this._triggered = null;
                            return true;
                        }
                    };
                    return next;
                },
                recover: function () {
                    var next = game.createEvent('recover');
                    next.player = this;
                    var nocard, nosource;
                    var event = _status.event;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'cards') {
                            next.cards = arguments[i].slice(0);
                        }
                        else if (get.itemtype(arguments[i]) == 'card') {
                            next.card = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'player') {
                            next.source = arguments[i];
                        }
                        else if (typeof arguments[i] == 'object' && arguments[i] && arguments[i].name) {
                            next.card = arguments[i];
                        }
                        else if (typeof arguments[i] == 'number') {
                            next.num = arguments[i];
                        }
                        else if (arguments[i] == 'nocard') {
                            nocard = true;
                        }
                        else if (arguments[i] == 'nosource') {
                            nosource = true;
                        }
                    }
                    if (next.card == undefined && !nocard)
                        next.card = event.card;
                    if (next.cards == undefined && !nocard)
                        next.cards = event.cards;
                    if (next.source == undefined && !nosource)
                        next.source = event.player;
                    if (next.num == undefined)
                        next.num = 1;
                    if (next.num <= 0)
                        _status.event.next.remove(next);
                    next.setContent('recover');
                    return next;
                },
                doubleDraw: function () {
                    if (get.is.changban())
                        return;
                    var next = game.createEvent('doubleDraw');
                    next.player = this;
                    next.setContent('doubleDraw');
                    return next;
                },
                loseHp: function (num) {
                    var next = game.createEvent('loseHp');
                    next.num = num;
                    next.player = this;
                    if (next.num == undefined)
                        next.num = 1;
                    next.setContent('loseHp');
                    return next;
                },
                loseMaxHp: function () {
                    var next = game.createEvent('loseMaxHp');
                    next.player = this;
                    var nosource;
                    var event = _status.event;
                    next.num = 1;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'player') {
                            next.source = arguments[i];
                        }
                        else if (typeof arguments[i] === 'number') {
                            next.num = arguments[i];
                        }
                        else if (typeof arguments[i] === 'boolean') {
                            next.forced = arguments[i];
                        }
                        else if (arguments[i] == 'nosource') {
                            nosource = true;
                        }
                    }
                    if (next.source == undefined && !nosource)
                        next.source = event.player;
                    next.setContent('loseMaxHp');
                    return next;
                },
                gainMaxHp: function () {
                    var next = game.createEvent('gainMaxHp');
                    next.player = this;
                    var nosource;
                    var event = _status.event;
                    next.num = 1;
                    for (var i = 0; i < arguments.length; i++) {
                        if (typeof arguments[i] === 'number') {
                            next.num = arguments[i];
                        }
                        else if (get.itemtype(arguments[i]) == 'player') {
                            next.source = arguments[i];
                        }
                        else if (typeof arguments[i] === 'boolean') {
                            next.forced = arguments[i];
                        }
                        else if (arguments[i] == 'nosource') {
                            nosource = true;
                        }
                    }
                    if (next.source == undefined && !nosource)
                        next.source = event.player;
                    next.setContent('gainMaxHp');
                    return next;
                },
                changeHp: function (num, popup) {
                    var next = game.createEvent('changeHp', false);
                    next.num = num;
                    if (popup != undefined)
                        next.popup = popup;
                    next.player = this;
                    next.setContent('changeHp');
                    return next;
                },
                changeHujia: function (num, type) {
                    var next = game.createEvent('changeHujia');
                    if (typeof num != 'number') {
                        num = 1;
                    }
                    next.num = num;
                    next.player = this;
                    if (type)
                        next.type = type;
                    next.setContent('changeHujia');
                    return next;
                },
                getBuff: function () {
                    var list = [1, 2, 3, 4, 5, 6];
                    var nodelay = false;
                    for (var i = 0; i < arguments.length; i++) {
                        if (typeof arguments[i] == 'number') {
                            list.remove(arguments[i]);
                        }
                        else if (arguments[i] === false) {
                            nodelay = true;
                        }
                    }
                    if (this.isHealthy()) {
                        list.remove(2);
                    }
                    if (!this.countCards('j')) {
                        list.remove(5);
                    }
                    if (!this.isLinked() && !this.isTurnedOver()) {
                        list.remove(6);
                    }
                    if (this.hasSkill('qianxing')) {
                        list.remove(4);
                    }
                    switch (list.randomGet()) {
                        case 1:
                            this.draw(nodelay ? 'nodelay' : 1);
                            break;
                        case 2:
                            this.recover();
                            break;
                        case 3:
                            this.changeHujia();
                            break;
                        case 4: this.tempHide();
                        case 5:
                            this.discard(this.getCards('j')).delay = (!nodelay);
                            break;
                        case 6: {
                            if (this.isLinked())
                                this.link();
                            if (this.isTurnedOver())
                                this.turnOver();
                            break;
                        }
                    }
                    return this;
                },
                getDebuff: function () {
                    var list = [1, 2, 3, 4, 5, 6];
                    var nodelay = false;
                    for (var i = 0; i < arguments.length; i++) {
                        if (typeof arguments[i] == 'number') {
                            list.remove(arguments[i]);
                        }
                        else if (arguments[i] === false) {
                            nodelay = true;
                        }
                    }
                    if (this.countCards('he') == 0) {
                        list.remove(1);
                    }
                    if (this.isLinked()) {
                        list.remove(4);
                    }
                    if (this.hasSkill('fengyin')) {
                        list.remove(5);
                    }
                    if (this.hp == 1) {
                        list.remove(3);
                        if (list.length > 1)
                            list.remove(2);
                    }
                    if (!list.length)
                        return this;
                    var num = list.randomGet();
                    switch (list.randomGet()) {
                        case 1:
                            this.randomDiscard(nodelay ? false : 'he');
                            break;
                        case 2:
                            this.loseHp();
                            break;
                        case 3:
                            this.damage();
                            break;
                        case 4:
                            if (!this.isLinked())
                                this.link();
                            break;
                        case 5:
                            this.addTempSkill('fengyin', { player: 'phaseAfter' });
                            break;
                        case 6: {
                            var list = [];
                            for (var i = 0; i < lib.inpile.length; i++) {
                                var info = lib.card[lib.inpile[i]];
                                if (info.type == 'delay' && !info.cancel && !this.hasJudge(lib.inpile[i])) {
                                    list.push(lib.inpile[i]);
                                }
                            }
                            if (list.length) {
                                var card = game.createCard(list.randomGet());
                                this.addJudge(card);
                                this.$draw(card);
                                if (!nodelay)
                                    game.delay();
                            }
                            else {
                                this.getDebuff(6);
                            }
                            break;
                        }
                    }
                    return this;
                },
                dying: function (reason) {
                    if (this.nodying || this.hp > 0 || this.isDying())
                        return;
                    var next = game.createEvent('dying');
                    next.player = this;
                    next.reason = reason;
                    if (reason && reason.source)
                        next.source = reason.source;
                    next.setContent('dying');
                    next.filterStop = function () {
                        if (this.player.hp > 0) {
                            delete this.filterStop;
                            return true;
                        }
                    };
                    return next;
                },
                die: function (reason) {
                    var next = game.createEvent('die');
                    next.player = this;
                    next.reason = reason;
                    if (reason)
                        next.source = reason.source;
                    next.setContent('die');
                    return next;
                },
                revive: function (hp, log) {
                    if (log !== false)
                        game.log(this, '复活');
                    if (this.maxHp < 1)
                        this.maxHp = 1;
                    if (hp)
                        this.hp = hp;
                    else {
                        this.hp = 1;
                    }
                    game.addVideo('revive', this);
                    this.classList.remove('dead');
                    this.removeAttribute('style');
                    this.node.avatar.style.transform = '';
                    this.node.avatar2.style.transform = '';
                    this.node.hp.show();
                    this.node.equips.show();
                    this.node.count.show();
                    this.update();
                    var player;
                    player = this.previousSeat;
                    while (player.isDead())
                        player = player.previousSeat;
                    player.next = this;
                    this.previous = player;
                    player = this.nextSeat;
                    while (player.isDead())
                        player = player.nextSeat;
                    player.previous = this;
                    this.next = player;
                    game.players.add(this);
                    game.dead.remove(this);
                    if (this == game.me) {
                        if (ui.auto)
                            ui.auto.show();
                        if (ui.wuxie)
                            ui.wuxie.show();
                        if (ui.revive) {
                            ui.revive.close();
                            delete ui.revive;
                        }
                        if (ui.exit) {
                            ui.exit.close();
                            delete ui.exit;
                        }
                        if (ui.swap) {
                            ui.swap.close();
                            delete ui.swap;
                        }
                        if (ui.restart) {
                            ui.restart.close();
                            delete ui.restart;
                        }
                        if (ui.continue_game) {
                            ui.continue_game.close();
                            delete ui.continue_game;
                        }
                    }
                },
                /**
                 * 返回本角色是否处于混乱状态
                 * @returns {!boolean}
                 */
                isMad: function () {
                    return this.hasSkill('mad');
                },
                /**
                 * 令本角色进入混乱状态；
                 * 此函数会输出日志
                 * @param {(string|Object)} [end] 结束时点，下一次触发该时点时结束本角色结束混乱状态；如果未指定，默认为'phaseAfter'
                 */
                goMad: function (end) {
                    if (end) {
                        this.addTempSkill('mad', end);
                    }
                    else {
                        this.addSkill('mad');
                    }
                    game.log(this, '进入混乱状态');
                },
                /**
                 * 令本角色移除混乱状态
                 */
                unMad: function () {
                    this.removeSkill('mad');
                },
                tempHide: function () {
                    this.addTempSkill('qianxing', { player: 'phaseBegin' });
                },
                addExpose: function (num) {
                    if (typeof this.ai.shown == 'number' && !this.identityShown && this.ai.shown < 1) {
                        this.ai.shown += num;
                        if (this.ai.shown > 0.95) {
                            this.ai.shown = 0.95;
                        }
                    }
                    return this;
                },
                equip: function (card, arg2) {
                    if (get.type(card) != 'equip')
                        return;
                    var next = game.createEvent('equip');
                    next.card = card;
                    if (get.is.object(next.card) && get.itemtype(next.card.cards) == 'cards' && get.name(next.card.cards[0]) == next.card.name && next.card.cards.length == 1)
                        next.card = next.card.cards[0];
                    next.player = this;
                    if (arg2) {
                        if (arg2 === true) {
                            next.draw = true;
                        }
                        else {
                            next.cards = arg2;
                        }
                    }
                    if (!next.cards)
                        next.cards = [next.card];
                    if (get.itemtype(next.cards) == 'card')
                        next.cards = [next.cards];
                    next.setContent(lib.element.content.equip);
                    next.getl = function (player) {
                        var that = this;
                        var map = {
                            player: player,
                            hs: [],
                            es: [],
                            js: [],
                            ss: [],
                            cards: [],
                            cards2: []
                        };
                        player.getHistory('lose', function (evt) {
                            if (evt.parent == that) {
                                map.hs.addArray(evt.hs);
                                map.es.addArray(evt.es);
                                map.js.addArray(evt.js);
                                map.ss.addArray(evt.ss);
                                map.cards.addArray(evt.cards);
                                map.cards2.addArray(evt.cards2);
                            }
                        });
                        if (map.cards.length > 0 || map.ss.length > 0)
                            return map;
                    };
                    return next;
                },
                addJudge: function (card, cards) {
                    var next = game.createEvent('addJudge');
                    next.card = card;
                    next.cards = cards;
                    if (next.cards == undefined)
                        next.cards = [card];
                    if (get.itemtype(next.cards) == 'card')
                        next.cards = [next.cards];
                    next.player = this;
                    next.setContent('addJudge');
                    next.getl = function (player) {
                        var that = this;
                        var map = {
                            player: player,
                            hs: [],
                            es: [],
                            js: [],
                            ss: [],
                            cards: [],
                            cards2: []
                        };
                        player.getHistory('lose', function (evt) {
                            if (evt.parent == that) {
                                map.hs.addArray(evt.hs);
                                map.es.addArray(evt.es);
                                map.js.addArray(evt.js);
                                map.ss.addArray(evt.ss);
                                map.cards.addArray(evt.cards);
                                map.cards2.addArray(evt.cards2);
                            }
                        });
                        if (map.cards.length > 0 || map.ss.length > 0)
                            return map;
                    };
                    return next;
                },
                canAddJudge: function (card) {
                    if (this.storage._disableJudge)
                        return false;
                    var name;
                    if (typeof card == 'string') {
                        name = card;
                    }
                    else {
                        name = card.viewAs || card.name;
                    }
                    if (!name)
                        return false;
                    if (this.hasJudge(name))
                        return false;
                    var mod = game.checkMod(card, this, this, 'unchanged', 'targetEnabled', this);
                    if (mod != 'unchanged')
                        return mod;
                    return true;
                },
                addJudgeNext: function (card) {
                    if (!card.expired) {
                        var target = this.next;
                        var name = card.viewAs || card.name;
                        var bool = false;
                        for (var iwhile = 0; iwhile < 20; iwhile++) {
                            if (target.canAddJudge(card)) {
                                bool = true;
                                break;
                            }
                            target = target.next;
                        }
                        if (!bool) {
                            game.log(card, '进入了弃牌堆');
                            game.cardsDiscard(card);
                        }
                        else {
                            if (card.name != name) {
                                target.addJudge(name, card);
                            }
                            else {
                                target.addJudge(card);
                            }
                        }
                    }
                    else {
                        card.expired = false;
                    }
                },
                /**
                 * 判定事件
                 * @returns {!boolean}
                 */
                judge: function () {
                    var next = game.createEvent('judge');
                    next.player = this;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'card') {
                            next.card = arguments[i];
                        }
                        else if (typeof arguments[i] == 'string') {
                            next.skill = arguments[i];
                        }
                        else if (typeof arguments[i] == 'function') {
                            next.judge = arguments[i];
                        }
                        else if (typeof arguments[i] == 'boolean') {
                            next.clearArena = arguments[i];
                        }
                        else if (get.objtype(arguments[i]) == 'div') {
                            next.position = arguments[i];
                        }
                    }
                    if (next.card && next.judge == undefined) {
                        next.judge = get.judge(next.card);
                    }
                    if (next.judge == undefined)
                        next.judge = function () { return 0; };
                    if (next.position == undefined)
                        next.position = ui.discardPile;
                    if (next.card)
                        next.cardname = next.card.viewAs || next.card.name;
                    var str = '';
                    if (next.card)
                        str = get.translation(next.card.viewAs || next.card.name);
                    else if (next.skill)
                        str = get.translation(next.skill);
                    else
                        str = get.translation(_status.event.name);
                    next.judgestr = str;
                    next.setContent('judge');
                    return next;
                },
                /**
                 * 翻面事件
                 * @returns {!boolean}
                 */
                turnOver: function (bool) {
                    if (typeof bool == 'boolean') {
                        if (bool) {
                            if (this.isTurnedOver())
                                return;
                        }
                        else {
                            if (!this.isTurnedOver())
                                return;
                        }
                    }
                    var next = game.createEvent('turnOver');
                    next.player = this;
                    var nosource;
                    var event = _status.event;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'player') {
                            next.source = arguments[i];
                        }
                        else if (arguments[i] == 'nosource') {
                            nosource = true;
                        }
                    }
                    if (next.source == undefined && !nosource)
                        next.source = event.player;
                    next.setContent('turnOver');
                    return next;
                },
                out: function (skill) {
                    if (typeof skill == 'number') {
                        this.outCount += skill;
                    }
                    else if (typeof skill == 'string') {
                        if (!this.outSkills) {
                            this.outSkills = [];
                        }
                        this.outSkills.add(skill);
                    }
                    else {
                        this.outCount++;
                    }
                    if (!this.classList.contains('out')) {
                        this.classList.add('out');
                        game.log(this, '离开游戏');
                    }
                    if (!game.countPlayer()) {
                        game.over();
                    }
                },
                "in": function (skill) {
                    if (this.isOut()) {
                        if (typeof skill == 'string') {
                            if (this.outSkills) {
                                this.outSkills.remove(skill);
                                if (!this.outSkills.length) {
                                    delete this.outSkills;
                                }
                            }
                        }
                        else if (typeof skill == 'number') {
                            this.outCount -= skill;
                        }
                        else {
                            if (skill === true) {
                                delete this.outSkills;
                            }
                            this.outCount = 0;
                        }
                        if (this.outCount <= 0 && !this.outSkills) {
                            this.outCount = 0;
                            this.classList.remove('out');
                            game.log(this, '进入游戏');
                        }
                    }
                },
                /**
                 * 横置事件
                 * @returns {!boolean}
                 */
                link: function (bool) {
                    if (typeof bool == 'boolean') {
                        if (bool) {
                            if (this.isLinked())
                                return;
                        }
                        else {
                            if (!this.isLinked())
                                return;
                        }
                    }
                    var next = game.createEvent('link');
                    next.player = this;
                    var nosource;
                    var event = _status.event;
                    for (var i = 0; i < arguments.length; i++) {
                        if (get.itemtype(arguments[i]) == 'player') {
                            next.source = arguments[i];
                        }
                        else if (arguments[i] == 'nosource') {
                            nosource = true;
                        }
                    }
                    if (next.source == undefined && !nosource)
                        next.source = event.player;
                    next.setContent('link');
                    return next;
                },
                skip: function (name) {
                    this.skipList.add(name);
                },
                wait: function (callback) {
                    if (lib.node) {
                        if (typeof callback == 'function') {
                            callback._noname_waiting = true;
                            lib.node.torespond[this.playerid] = callback;
                        }
                        else {
                            lib.node.torespond[this.playerid] = '_noname_waiting';
                        }
                        clearTimeout(lib.node.torespondtimeout[this.playerid]);
                        if (this.ws && !this.ws.closed) {
                            var player = this;
                            var time = parseInt(lib.configOL.choose_timeout) * 1000;
                            if (ui.arena && ui.arena.classList.contains('choose-character') && lib.configOL.chooseCharacter_timeout) {
                                time *= 5;
                            }
                            if (_status.event.getParent().skillHidden) {
                                for (var i = 0; i < game.players.length; i++) {
                                    game.players[i].showTimer(time);
                                }
                                player._hide_all_timer = true;
                            }
                            else if (!_status.event._global_waiting) {
                                player.showTimer(time);
                            }
                            lib.node.torespondtimeout[this.playerid] = setTimeout(function () {
                                player.unwait('ai');
                                player.ws.ws.close();
                            }, time + 5000);
                        }
                    }
                },
                unwait: function (result) {
                    if (this._hide_all_timer) {
                        delete this._hide_all_timer;
                        for (var i = 0; i < game.players.length; i++) {
                            game.players[i].hideTimer();
                        }
                    }
                    else if (!_status.event._global_waiting) {
                        this.hideTimer();
                    }
                    clearTimeout(lib.node.torespondtimeout[this.playerid]);
                    delete lib.node.torespondtimeout[this.playerid];
                    if (!lib.node.torespond.hasOwnProperty(this.playerid)) {
                        return;
                    }
                    var noresume = false;
                    var proceed = null;
                    if (typeof lib.node.torespond[this.playerid] == 'function' && lib.node.torespond[this.playerid]._noname_waiting) {
                        proceed = lib.node.torespond[this.playerid](result, this);
                        if (proceed === false) {
                            noresume = true;
                        }
                    }
                    lib.node.torespond[this.playerid] = result;
                    for (var i in lib.node.torespond) {
                        if (lib.node.torespond[i] == '_noname_waiting') {
                            return;
                        }
                        else if (lib.node.torespond[i] && lib.node.torespond[i]._noname_waiting) {
                            return;
                        }
                    }
                    _status.event.result = result;
                    _status.event.resultOL = lib.node.torespond;
                    lib.node.torespond = {};
                    if (typeof proceed == 'function')
                        proceed();
                    else if (_status.paused && !noresume)
                        game.resume();
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                logSkill: function (name, targets, nature, logv, audio) {
                    if (get.itemtype(targets) == 'player')
                        targets = [targets];
                    var nopop = false;
                    var popname = name;
                    if (Array.isArray(name)) {
                        popname = name[1];
                        name = name[0];
                    }
                    var checkShow = this.checkShow(name);
                    if (lib.translate[name]) {
                        this.trySkillAnimate(name, popname, checkShow);
                        if (typeof targets == 'object' && targets.length) {
                            var str;
                            if (targets[0] == this) {
                                str = '#b自己';
                                if (targets.length > 1) {
                                    str += '、';
                                    str += get.translation(targets.slice(1));
                                }
                            }
                            else
                                str = targets;
                            game.log(this, '对', str, '发动了', '#p『' + get.skillTranslation(name, this) + '』');
                        }
                        else {
                            game.log(this, '发动了', '#p『' + get.skillTranslation(name, this) + '』');
                        }
                    }
                    if (nature != false) {
                        if (nature === undefined) {
                            nature = 'green';
                        }
                        this.line(targets, nature);
                    }
                    var info = lib.skill[name];
                    if (info && info.ai && info.ai.expose != undefined &&
                        this.logAi && (!targets || targets.length != 1 || targets[0] != this)) {
                        this.logAi(lib.skill[name].ai.expose);
                    }
                    if (info && info.round) {
                        var roundname = name + '_roundcount';
                        this.storage[roundname] = game.roundNumber;
                        this.syncStorage(roundname);
                        this.markSkill(roundname);
                    }
                    if (audio !== false) {
                        game.trySkillAudio(name, this, true);
                    }
                    if (game.chess) {
                        this.chessFocus();
                    }
                    if (logv === true) {
                        game.logv(this, name, targets, null, true);
                    }
                    else if (info && info.logv !== false) {
                        game.logv(this, name, targets);
                    }
                    if (this._hookTrigger) {
                        for (var i = 0; i < this._hookTrigger.length; i++) {
                            var info = lib.skill[this._hookTrigger[i]].hookTrigger;
                            if (info && info.log) {
                                info.log(this, name, targets);
                            }
                        }
                    }
                },
                unprompt: function () {
                    if (this.node.prompt) {
                        this.node.prompt["delete"]();
                        delete this.node.prompt;
                    }
                },
                prompt: function (str, nature) {
                    var node;
                    if (this.node.prompt) {
                        node = this.node.prompt;
                        node.innerHTML = '';
                        node.className = 'damage normal-font damageadded';
                    }
                    else {
                        node = ui.create.div('.damage.normal-font', this);
                        this.node.prompt = node;
                        ui.refresh(node);
                        node.classList.add('damageadded');
                    }
                    node.innerHTML = str;
                    node.dataset.nature = nature || 'soil';
                },
                prompt_old: function (name2, className) {
                    var node;
                    if (this.node.prompt) {
                        node = this.node.prompt;
                        node.innerHTML = '';
                        node.className = 'popup';
                    }
                    else {
                        node = ui.create.div('.popup', this.parentNode);
                        this.node.prompt = node;
                    }
                    node.dataset.position = this.dataset.position;
                    if (this.dataset.position == 0 || parseInt(this.dataset.position) == parseInt(ui.arena.dataset.number) / 2 ||
                        typeof name2 == 'number' || this.classList.contains('minskin')) {
                        node.innerHTML = name2;
                    }
                    else {
                        for (var i = 0; i < name2.length; i++) {
                            node.innerHTML += name2[i] + '<br/>';
                        }
                    }
                    if (className) {
                        node.classList.add(className);
                    }
                },
                /**
                 * 文字弹出动画效果
                 * [recommend] 令人迷惑的是，此函数实质调用了{@link lib.element.player.$damagepop}，而不是{@link lib.element.player.$damagepop}调用此函数
                 * @param {!string} name (技能|角色|游戏牌)名或其他任意非空字符串
                 * @param {string} [classname='water'] 效果色
                 * @param {?boolean} [nobroadcast] 如果为true，则
                 */
                popup: function (name, className, nobroadcast) {
                    var name2 = get.translation(name);
                    if (!name2)
                        return;
                    this.$damagepop(name2, className || 'water', true, nobroadcast);
                },
                popup_old: function (name, className) {
                    var name2 = get.translation(name);
                    var node = ui.create.div('.popup', this.parentNode);
                    if (!name2) {
                        node.remove();
                        return node;
                    }
                    game.addVideo('popup', this, [name, className]);
                    node.dataset.position = this.dataset.position;
                    if (this.dataset.position == 0 || parseInt(this.dataset.position) == parseInt(ui.arena.dataset.number) / 2 ||
                        typeof name2 == 'number' || this.classList.contains('minskin')) {
                        node.innerHTML = name2;
                    }
                    else {
                        for (var i = 0; i < name2.length; i++) {
                            node.innerHTML += name2[i] + '<br/>';
                        }
                    }
                    if (className) {
                        node.classList.add(className);
                    }
                    this.popups.push(node);
                    if (this.popups.length > 1) {
                        node.hide();
                    }
                    else {
                        var that = this;
                        setTimeout(function () { that._popup(); }, 1000);
                    }
                    return node;
                },
                _popup: function () {
                    if (this.popups.length) {
                        this.popups.shift()["delete"]();
                        if (this.popups.length) {
                            this.popups[0].show();
                            var that = this;
                            setTimeout(function () { that._popup(); }, 1000);
                        }
                    }
                },
                showTimer: function (time) {
                    if (!time && lib.configOL) {
                        time = parseInt(lib.configOL.choose_timeout) * 1000;
                    }
                    // if(ui.arena&&ui.arena.classList.contains('choose-character')&&lib.configOL.chooseCharacter_timeout){
                    // 	time *= 5;
                    // }
                    if (_status.connectMode && !game.online) {
                        game.broadcast(function (player, time) {
                            player.showTimer(time);
                        }, this, time);
                    }
                    if (this == game.me) {
                        return;
                    }
                    if (this.node.timer) {
                        this.node.timer.remove();
                    }
                    var timer = ui.create.div('.timerbar', this);
                    this.node.timer = timer;
                    ui.create.div(this.node.timer);
                    var bar = ui.create.div(this.node.timer);
                    ui.refresh(bar);
                    bar.style.transitionDuration = (time / 1000) + 's';
                    bar.style.width = 0;
                },
                hideTimer: function () {
                    if (_status.connectMode && !game.online && this.playerid) {
                        game.broadcast(function (player) {
                            player.hideTimer();
                        }, this);
                    }
                    if (this.node.timer) {
                        this.node.timer["delete"]();
                        delete this.node.timer;
                    }
                },
                markAuto: function (name, info) {
                    if (Array.isArray(info)) {
                        if (!Array.isArray(this.storage[name]))
                            this.storage[name] = [];
                        this.storage[name].addArray(info);
                        this.markSkill(name);
                    }
                    else {
                        var storage = this.storage[name];
                        if (Array.isArray(storage)) {
                            this[storage.length > 0 ? 'markSkill' : 'unmarkSkill'](name);
                        }
                        else if (typeof storage == 'number') {
                            this[storage.length > 0 ? 'markSkill' : 'unmarkSkill'](name);
                        }
                    }
                },
                unmarkAuto: function (name, info) {
                    var storage = this.storage[name];
                    if (Array.isArray(info) && Array.isArray(storage)) {
                        storage.removeArray(info.slice(0));
                        this.markAuto(name);
                    }
                },
                getStorage: function (name) {
                    return this.storage[name] || [];
                },
                markSkill: function (name, info, card) {
                    if (info === true) {
                        this.syncStorage(name);
                        info = null;
                    }
                    if (get.itemtype(card) == 'card') {
                        game.addVideo('markSkill', this, [name, get.cardInfo(card)]);
                    }
                    else {
                        game.addVideo('markSkill', this, [name]);
                    }
                    game.broadcastAll(function (storage, player, name, info, card) {
                        if (storage != undefined) {
                            player.storage[name] = storage;
                        }
                        if (!info) {
                            if (player.marks[name]) {
                                player.updateMarks();
                                return;
                            }
                            if (lib.skill[name]) {
                                info = lib.skill[name].intro;
                            }
                            if (!info) {
                                return;
                            }
                        }
                        if (player.marks[name]) {
                            player.marks[name].info = info;
                        }
                        else {
                            if (card) {
                                player.marks[name] = player.mark(card, info, name);
                            }
                            else {
                                player.marks[name] = player.mark(name, info);
                            }
                        }
                        player.updateMarks();
                    }, this.storage[name], this, name, info, card);
                    return this;
                },
                unmarkSkill: function (name) {
                    game.addVideo('unmarkSkill', this, name);
                    game.broadcast(function (player, name) {
                        if (player.marks[name]) {
                            player.marks[name]["delete"]();
                            player.marks[name].style.transform += ' scale(0.2)';
                            delete player.marks[name];
                            ui.updatem(player);
                        }
                    }, this, name);
                    if (this.marks[name]) {
                        this.marks[name]["delete"]();
                        this.marks[name].style.transform += ' scale(0.2)';
                        delete this.marks[name];
                        ui.updatem(this);
                        var info = lib.skill[name];
                        if (info && info.intro && info.intro.onunmark) {
                            if (info.intro.onunmark == 'throw') {
                                if (get.itemtype(this.storage[name]) == 'cards') {
                                    this.$throw(this.storage[name], 1000);
                                    game.cardsDiscard(this.storage[name]);
                                    game.log(this.storage[name], '进入了弃牌堆');
                                    this.storage[name].length = 0;
                                }
                            }
                            else if (typeof info.intro.onunmark == 'function') {
                                info.intro.onunmark(this.storage[name], this);
                            }
                        }
                    }
                    return this;
                },
                markSkillCharacter: function (id, target, name, content) {
                    if (typeof target == 'object') {
                        target = target.name;
                    }
                    game.broadcastAll(function (player, target, name, content, id) {
                        if (player.marks[id]) {
                            player.marks[id].name = name + '_charactermark';
                            player.marks[id]._name = target;
                            player.marks[id].info = {
                                name: name,
                                content: content,
                                id: id
                            };
                            player.marks[id].setBackground(target, 'character');
                            game.addVideo('changeMarkCharacter', player, {
                                id: id,
                                name: name,
                                content: content,
                                target: target
                            });
                        }
                        else {
                            player.marks[id] = player.markCharacter(target, {
                                name: name,
                                content: content,
                                id: id
                            });
                            player.marks[id]._name = target;
                            game.addVideo('markCharacter', player, {
                                name: name,
                                content: content,
                                id: id,
                                target: target
                            });
                        }
                    }, this, target, name, content, id);
                    return this;
                },
                markCharacter: function (name, info, learn, learn2) {
                    if (typeof name == 'object') {
                        name = name.name;
                    }
                    var node;
                    if (name.indexOf('unknown') == 0) {
                        node = ui.create.div('.card.mark.drawinghidden');
                        ui.create.div('.background.skillmark', node).innerHTML = get.translation(name)[0];
                    }
                    else {
                        if (!lib.character[name])
                            return;
                        node = ui.create.div('.card.mark.drawinghidden').setBackground(name, 'character');
                    }
                    this.node.marks.insertBefore(node, this.node.marks.childNodes[1]);
                    node.name = name + '_charactermark';
                    if (!info) {
                        info = {};
                    }
                    if (!info.name) {
                        info.name = get.translation(name);
                    }
                    if (!info.content) {
                        info.content = get.skillintro(name, learn, learn2);
                    }
                    node.info = info;
                    node.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.card);
                    if (!lib.config.touchscreen) {
                        if (lib.config.hover_all) {
                            lib.setHover(node, ui.click.hoverplayer);
                        }
                        if (lib.config.right_info) {
                            node.oncontextmenu = ui.click.rightplayer;
                        }
                    }
                    ui.updatem(this);
                    return node;
                },
                /**
                 * 标记
                 * @function
                 * @param {(Array<Card>|Card|string)} name
                 * @param {*} info mark info
                 * @param {*} skill
                 * @returns {*}
                 */
                mark: function (name, info, skill) {
                    if (get.itemtype(name) == 'cards') {
                        var marks = [];
                        for (var i = 0; i < name.length; i++) {
                            marks.push(this.mark(name[i], info));
                        }
                        return marks;
                    }
                    else {
                        var node;
                        if (get.itemtype(name) == 'card') {
                            node = name.copy('mark');
                            node.classList.add('drawinghidden');
                            this.node.marks.insertBefore(node, this.node.marks.childNodes[1]);
                            node.suit = name.suit;
                            node.number = name.number;
                            // if(name.name&&lib.card[name.name]&&lib.card[name.name].markimage){
                            //     node.node.image.style.left=lib.card[name.name].markimage;
                            // }
                            if (name.classList.contains('fullborder')) {
                                node.classList.add('fakejudge');
                                node.classList.add('fakemark');
                                (node.querySelector('.background') || ui.create.div('.background', node)).innerHTML = lib.translate[name.name + '_bg'] || get.translation(name.name)[0];
                            }
                            name = name.name;
                        }
                        else {
                            node = ui.create.div('.card.mark.drawinghidden');
                            this.node.marks.insertBefore(node, this.node.marks.childNodes[1]);
                            var str = lib.translate[name + '_bg'];
                            if (!str || str[0] == '+' || str[0] == '-') {
                                str = get.translation(name)[0];
                            }
                            ui.create.div('.background.skillmark', node).innerHTML = str;
                            // node.style.fontFamily=lib.config.card_font;
                        }
                        node.name = name;
                        node.skill = skill || name;
                        if (typeof info == 'object') {
                            node.info = info;
                        }
                        else if (typeof info == 'string') {
                            node.markidentifer = info;
                        }
                        node.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.card);
                        if (!lib.config.touchscreen) {
                            if (lib.config.hover_all) {
                                lib.setHover(node, ui.click.hoverplayer);
                            }
                            if (lib.config.right_info) {
                                node.oncontextmenu = ui.click.rightplayer;
                            }
                        }
                        this.updateMarks();
                        ui.updatem(this);
                        return node;
                    }
                },
                /**
                 * 取消标记
                 * @function
                 * @param {*} name
                 * @param {*} info
                 */
                unmark: function (name, info) {
                    game.addVideo('unmarkname', this, name);
                    if (get.itemtype(name) == 'card') {
                        this.unmark(name.name, info);
                    }
                    else if (get.itemtype(name) == 'cards') {
                        for (var i = 0; i < name.length; i++) {
                            this.unmark(name[i].name, info);
                        }
                    }
                    else {
                        for (var i = 0; i < this.node.marks.childNodes.length; i++) {
                            if (this.node.marks.childNodes[i].name == name &&
                                (!info || this.node.marks.childNodes[i].markidentifer == info)) {
                                this.node.marks.childNodes[i]["delete"]();
                                this.node.marks.childNodes[i].style.transform += ' scale(0.2)';
                                ui.updatem(this);
                                return;
                            }
                        }
                    }
                },
                addLink: function () {
                    if (get.is.linked2(this)) {
                        this.classList.add('linked2');
                    }
                    else {
                        this.classList.add('linked');
                    }
                },
                removeLink: function () {
                    if (get.is.linked2(this)) {
                        this.classList.remove('linked2');
                    }
                    else {
                        this.classList.remove('linked');
                    }
                },
                /**
                 * 返回一张牌当前本角色是否可以(对目标角色)使用
                 * @returns {!boolean}
                 */
                canUse: function (card, target, distance, includecard) {
                    if (typeof card == 'string')
                        card = { name: card, isCard: true };
                    var info = get.info(card);
                    if (info.multicheck && !info.multicheck(card, this))
                        return false;
                    if (!lib.filter.cardEnabled(card, this))
                        return false;
                    if (distance !== false && !lib.filter.targetInRange(card, this, target))
                        return false;
                    return lib.filter[includecard ? 'targetEnabledx' : 'targetEnabled'](card, this, target);
                },
                /**
                 * 返回一张牌当前本角色是否可以使用
                 * @returns {!boolean}
                 */
                hasUseTarget: function (card, distance, includecard) {
                    var player = this;
                    return game.hasPlayer(function (current) {
                        return player.canUse(card, current, distance, includecard);
                    });
                },
                /**
                 * 返回一张牌当前本角色使用的收益为正收益，当前可以使用，且有使用对象
                 * @returns {!boolean}
                 */
                hasValueTarget: function () {
                    return this.getUseValue.apply(this, arguments) > 0;
                },
                /**
                 * 返回一张牌当前本角色使用的收益
                 * @returns {!boolean}
                 */
                getUseValue: function (card, distance, includecard) {
                    if (typeof (card) == 'string') {
                        card = { name: card, isCard: true };
                    }
                    var player = this;
                    var targets = game.filterPlayer();
                    var value = [];
                    var min = 0;
                    var info = get.info(card);
                    if (!info || info.notarget)
                        return 0;
                    var range;
                    var select = get.copy(info.selectTarget);
                    if (select == undefined) {
                        if (info.filterTarget == undefined)
                            return true;
                        range = [1, 1];
                    }
                    else if (typeof select == 'number')
                        range = [select, select];
                    else if (get.itemtype(select) == 'select')
                        range = select;
                    else if (typeof select == 'function')
                        range = select(card, player);
                    if (info.singleCard)
                        range = [1, 1];
                    game.checkMod(card, player, range, 'selectTarget', player);
                    if (!range)
                        return 0;
                    for (var i = 0; i < targets.length; i++) {
                        if (player.canUse(card, targets[i], distance, includecard)) {
                            var eff = get.effect(targets[i], card, player, player);
                            value.push(eff);
                        }
                    }
                    value.sort(function (a, b) {
                        return b - a;
                    });
                    for (var i = 0; i < value.length; i++) {
                        if (i == range[1] || range[1] != -1 && value[i] <= 0)
                            break;
                        min += value[i];
                    }
                    return min;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                addSubPlayer: function (cfg) {
                    var skill = 'subplayer_' + cfg.name + '_' + get.id();
                    game.log(this, '获得了随从', '#g' + get.translation(cfg.name));
                    cfg.hs = cfg.hs || [];
                    cfg.es = cfg.es || [];
                    cfg.skills = cfg.skills || [];
                    cfg.hp = cfg.hp || 1;
                    cfg.maxHp = cfg.maxHp || 1;
                    cfg.sex = cfg.sex || 'male';
                    cfg.group = cfg.group || 'qun';
                    cfg.skill = cfg.skill || _status.event.name;
                    if (!cfg.source) {
                        if (this.hasSkill(_status.event.name) && this.name2 && lib.character[this.name2] &&
                            lib.character[this.name2][3].contains(_status.event.name)) {
                            cfg.source = this.name2;
                        }
                        else {
                            cfg.source = this.name;
                        }
                    }
                    game.broadcastAll(function (player, skill, cfg) {
                        lib.skill[skill] = {
                            intro: {
                                content: cfg.intro || ''
                            },
                            mark: 'character',
                            subplayer: cfg.skill,
                            ai: {
                                subplayer: true
                            }
                        };
                        lib.character[skill] = [cfg.sex, cfg.group, cfg.maxHp, cfg.skills, ['character:' + cfg.name]];
                        lib.translate[skill] = cfg.caption || get.rawName(cfg.name);
                        player.storage[skill] = cfg;
                    }, this, skill, cfg);
                    game.addVideo('addSubPlayer', this, [skill, lib.skill[skill], lib.character[skill], lib.translate[skill], { name: cfg.name }]);
                    this.addSkill(skill);
                    return skill;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                removeSubPlayer: function (name) {
                    if (this.hasSkill('subplayer') && this.name == name) {
                        this.exitSubPlayer(true);
                    }
                    else {
                        if (player.storage[name].onremove) {
                            player.storage[name].onremove(player);
                        }
                        this.removeSkill(name);
                        delete this.storage[name];
                        game.log(player, '牺牲了随从', '#g' + name);
                        _status.event.trigger('removeSubPlayer');
                    }
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                callSubPlayer: function () {
                    if (this.hasSkill('subplayer'))
                        return;
                    var next = game.createEvent('callSubPlayer');
                    next.player = this;
                    for (var i = 0; i < arguments.length; i++) {
                        if (typeof arguments[i] == 'string') {
                            next.directresult = arguments[i];
                        }
                    }
                    next.setContent('callSubPlayer');
                    return next;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                toggleSubPlayer: function () {
                    if (!this.hasSkill('subplayer'))
                        return;
                    var next = game.createEvent('toggleSubPlayer');
                    next.player = this;
                    for (var i = 0; i < arguments.length; i++) {
                        if (typeof arguments[i] == 'string') {
                            next.directresult = arguments[i];
                        }
                    }
                    next.setContent('toggleSubPlayer');
                    return next;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                exitSubPlayer: function (remove) {
                    if (!this.hasSkill('subplayer'))
                        return;
                    var next = game.createEvent('exitSubPlayer');
                    next.player = this;
                    next.remove = remove;
                    next.setContent('exitSubPlayer');
                    return next;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                getSubPlayers: function (tag) {
                    var skills = this.getSkills();
                    var list = [];
                    for (var i = 0; i < skills.length; i++) {
                        var name = skills[i];
                        var info = lib.skill[name];
                        if (tag && info.subplayer != tag)
                            continue;
                        if (info.ai && info.ai.subplayer && this.storage[name] && this.storage[name].name) {
                            list.push(name);
                        }
                    }
                    return list;
                },
                /**
                 * 同时将info.global内的技能添加到{@link lib.skill.global}
                 * @returns {!boolean}
                 */
                addSkillTrigger: function (skill, hidden, triggeronly) {
                    var info = lib.skill[skill];
                    if (!info)
                        return;
                    if (typeof info.group == 'string') {
                        this.addSkillTrigger(info.group, hidden);
                    }
                    else if (Array.isArray(info.group)) {
                        for (var i = 0; i < info.group.length; i++) {
                            this.addSkillTrigger(info.group[i], hidden);
                        }
                    }
                    if (!triggeronly) {
                        if (info.global && (!hidden || info.globalSilent)) {
                            if (typeof info.global == 'string') {
                                game.addGlobalSkill(info.global, this);
                            }
                            else {
                                for (var j = 0; j < info.global.length; j++) {
                                    game.addGlobalSkill(info.global[j], this);
                                }
                            }
                        }
                        if (this.initedSkills.contains(skill))
                            return this;
                        this.initedSkills.push(skill);
                        if (info.init && !_status.video) {
                            info.init(this, skill);
                        }
                    }
                    if (info.trigger && this.playerid) {
                        var playerid = this.playerid;
                        var setTrigger = function (i, evt) {
                            if (i == 'global') {
                                if (!lib.hook.globaltrigger[evt]) {
                                    lib.hook.globaltrigger[evt] = {};
                                }
                                if (!lib.hook.globaltrigger[evt][playerid]) {
                                    lib.hook.globaltrigger[evt][playerid] = [];
                                }
                                lib.hook.globaltrigger[evt][playerid].add(skill);
                            }
                            else {
                                var name = playerid + '_' + i + '_' + evt;
                                if (!lib.hook[name]) {
                                    lib.hook[name] = [];
                                }
                                lib.hook[name].add(skill);
                            }
                            lib.hookmap[evt] = true;
                        };
                        for (var i in info.trigger) {
                            if (typeof info.trigger[i] == 'string') {
                                setTrigger(i, info.trigger[i]);
                            }
                            else if (Array.isArray(info.trigger[i])) {
                                for (var j = 0; j < info.trigger[i].length; j++) {
                                    setTrigger(i, info.trigger[i][j]);
                                }
                            }
                        }
                    }
                    if (info.hookTrigger) {
                        if (!this._hookTrigger) {
                            this._hookTrigger = [];
                        }
                        this._hookTrigger.add(skill);
                    }
                    if (_status.event && _status.event.addTrigger)
                        _status.event.addTrigger(skill, this);
                    return this;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                addSkillLog: function (skill) {
                    this.addSkill(skill);
                    this.popup(skill);
                    game.log(this, '获得了技能', '#g『' + get.translation(skill) + '』');
                },
                /**
                 * 添加一组技能
                 * @name lib.element.player.addSkill
                 * @function
                 * @param {Array<string>} skills 技能名数组
                 * @param {?boolean} [checkConflict] 是否检测冲突，如果为true，添加技能完成后检测；如果为false或未指定，不检测
                 * @param {?boolean} [nobroadcast] 如果为true，直接添加技能；如果为false或未指定，调用{@link game.broadcast}为本角色添加技能
                 * @returns {string} 如果添加技能成功，返回技能名`skill`；如果失败，返回undefined
                 * @see {@link lib.element.player.addSkill(2)}
                 */
                /**
                 * 本角色添加技能
                 * @name lib.element.player.addSkill
                 * @function
                 * @variation 2
                 * @param {!string} skill 技能名
                 * @param {?boolean} [checkConflict] 是否检测冲突，如果为true，添加技能完成后检测；如果为false或未指定，不检测
                 * @param {?boolean} [nobroadcast] 如果为true，直接添加技能；如果为false或未指定，调用{@link game.broadcast}为本角色添加技能
                 * @returns {string} 如果添加技能成功，返回技能名`skill`；如果失败，返回undefined
                 */
                addSkill: function (skill, checkConflict, nobroadcast) {
                    if (Array.isArray(skill)) {
                        for (var i = 0; i < skill.length; i++) {
                            this.addSkill(skill[i]);
                        }
                    }
                    else {
                        if (this.skills.contains(skill))
                            return;
                        var info = lib.skill[skill];
                        if (!info)
                            return;
                        if (!nobroadcast) {
                            game.broadcast(function (player, skill) {
                                player.skills.add(skill);
                            }, this, skill);
                        }
                        this.skills.add(skill);
                        this.addSkillTrigger(skill);
                        if (this.awakenedSkills.contains(skill)) {
                            this.awakenSkill(skill);
                            return;
                        }
                        if (info.init2 && !_status.video) {
                            info.init2(this, skill);
                        }
                        if (info.mark) {
                            if (info.mark == 'card' &&
                                get.itemtype(this.storage[skill]) == 'card') {
                                this.markSkill(skill, null, this.storage[skill]);
                            }
                            else if (info.mark == 'card' &&
                                get.itemtype(this.storage[skill]) == 'cards') {
                                this.markSkill(skill, null, this.storage[skill][0]);
                            }
                            else if (info.mark == 'image') {
                                this.markSkill(skill, null, ui.create.card(null, 'noclick').init([null, null, skill]));
                            }
                            else if (info.mark == 'character') {
                                var intro = info.intro.content;
                                if (typeof intro == 'function') {
                                    intro = intro(this.storage[skill], this);
                                }
                                else if (typeof intro == 'string') {
                                    intro = intro.replace(/#/g, this.storage[skill]);
                                    intro = intro.replace(/&/g, get.cnNumber(this.storage[skill]));
                                    intro = intro.replace(/\$/g, get.translation(this.storage[skill]));
                                }
                                var caption;
                                if (typeof info.intro.name == 'function') {
                                    caption = info.intro.name(this.storage[skill], this);
                                }
                                else if (typeof info.intro.name == 'string') {
                                    caption = info.name;
                                }
                                else {
                                    caption = get.translation(skill);
                                }
                                this.markSkillCharacter(skill, this.storage[skill], caption, intro);
                            }
                            else {
                                this.markSkill(skill);
                            }
                        }
                    }
                    if (checkConflict)
                        this.checkConflict();
                    return skill;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                addAdditionalSkill: function (skill, skills, keep) {
                    if (this.additionalSkills[skill]) {
                        if (keep) {
                            if (typeof this.additionalSkills[skill] == 'string') {
                                this.additionalSkills[skill] = [this.additionalSkills[skill]];
                            }
                        }
                        else {
                            this.removeAdditionalSkill(skill);
                            this.additionalSkills[skill] = [];
                        }
                    }
                    else {
                        this.additionalSkills[skill] = [];
                    }
                    if (typeof skills == 'string') {
                        skills = [skills];
                    }
                    for (var i = 0; i < skills.length; i++) {
                        this.addSkill(skills[i], null, true);
                        this.skills.remove(skills[i]);
                        this.additionalSkills[skill].push(skills[i]);
                    }
                    this.checkConflict();
                    return this;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                removeAdditionalSkill: function (skill, target) {
                    if (this.additionalSkills[skill]) {
                        var additionalSkills = this.additionalSkills[skill];
                        if (Array.isArray(additionalSkills) && typeof target == 'string') {
                            if (additionalSkills.contains(target)) {
                                additionalSkills.remove(target);
                                this.removeSkill(target);
                            }
                        }
                        else {
                            delete this.additionalSkills[skill];
                            if (typeof additionalSkills == 'string') {
                                this.removeSkill(additionalSkills);
                            }
                            else if (Array.isArray(additionalSkills)) {
                                for (var i = 0; i < additionalSkills.length; i++) {
                                    this.removeSkill(additionalSkills[i]);
                                }
                            }
                        }
                    }
                    return this;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                awakenSkill: function (skill, nounmark) {
                    if (!nounmark)
                        this.unmarkSkill(skill);
                    this.disableSkill(skill + '_awake', skill);
                    this.awakenedSkills.add(skill);
                    if (this.storage[skill] === false)
                        this.storage[skill] = true;
                    return this;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                restoreSkill: function (skill, nomark) {
                    if (this.storage[skill] === true)
                        this.storage[skill] = false;
                    this.awakenedSkills.remove(skill);
                    this.enableSkill(skill + '_awake', skill);
                    if (!nomark)
                        this.markSkill(skill);
                    return this;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                disableSkill: function (skill, skills) {
                    if (typeof skills == 'string') {
                        if (!this.disabledSkills[skills]) {
                            this.disabledSkills[skills] = [];
                            var info = get.info(skills);
                            if (info.ondisable && info.onremove) {
                                info.onremove(this);
                            }
                        }
                        this.disabledSkills[skills].add(skill);
                        var group = lib.skill[skills].group;
                        if (typeof group == 'string' || Array.isArray(group)) {
                            this.disableSkill(skill, group);
                        }
                    }
                    else if (Array.isArray(skills)) {
                        for (var i = 0; i < skills.length; i++) {
                            this.disableSkill(skill, skills[i]);
                        }
                    }
                    return this;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                enableSkill: function (skill) {
                    for (var i in this.disabledSkills) {
                        this.disabledSkills[i].remove(skill);
                        if (this.disabledSkills[i].length == 0) {
                            delete this.disabledSkills[i];
                        }
                    }
                    return this;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                checkMarks: function () {
                    var skills = this.getSkills();
                    game.expandSkills(skills);
                    for (var i in this.marks) {
                        if (!skills.contains(i) && !this.marks[i].info.fixed) {
                            this.unmarkSkill(i);
                        }
                    }
                    return this;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                addEquipTrigger: function (card) {
                    if (card) {
                        var info = get.info(card);
                        if (info.skills) {
                            for (var j = 0; j < info.skills.length; j++) {
                                this.addSkillTrigger(info.skills[j]);
                            }
                        }
                    }
                    else {
                        var es = this.getCards('e');
                        for (var i = 0; i < es.length; i++) {
                            this.addEquipTrigger(es[i]);
                        }
                    }
                    return this;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                removeEquipTrigger: function (card, move) {
                    if (card) {
                        var info = get.info(card);
                        if (move === false) {
                            if (card.originalName) {
                                card.classList.remove('fakejudge');
                                if (get.type(card.originalName) == 'equip') {
                                    card.classList.remove(get.subtype(card.viewAs));
                                    card.classList.add(get.subtype(card.originalName));
                                }
                                else {
                                    card.classList.remove(get.subtype(card.viewAs));
                                }
                                card.name = card.originalName;
                                delete card.viewAs;
                                delete card.originalName;
                            }
                        }
                        else {
                            //	if(card.viewAs&&card.originalName&&card.originalName){
                            //		card.name = card.originalName
                            //	}
                        }
                        var skills = this.getSkills(null, false);
                        if (info.skills) {
                            for (var j = 0; j < info.skills.length; j++) {
                                if (skills.contains(info.skills[j]))
                                    continue;
                                this.removeSkillTrigger(info.skills[j]);
                            }
                        }
                        if (info.clearLose && typeof info.onLose == 'function') {
                            var next = game.createEvent('lose_' + card.name);
                            next.setContent(info.onLose);
                            next.player = this;
                            next.card = card;
                        }
                    }
                    else {
                        var es = this.getCards('e');
                        for (var i = 0; i < es.length; i++) {
                            this.removeEquipTrigger(es[i]);
                        }
                    }
                    return this;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                removeSkillTrigger: function (skill, triggeronly) {
                    var info = lib.skill[skill];
                    if (!info)
                        return;
                    if (typeof info.group == 'string') {
                        this.removeSkillTrigger(info.group);
                    }
                    else if (Array.isArray(info.group)) {
                        for (var i = 0; i < info.group.length; i++) {
                            this.removeSkillTrigger(info.group[i]);
                        }
                    }
                    if (!triggeronly)
                        this.initedSkills.remove(skill);
                    if (info.trigger) {
                        var playerid = this.playerid;
                        var removeTrigger = function (i, evt) {
                            if (i == 'global') {
                                for (var j in lib.hook.globaltrigger) {
                                    if (lib.hook.globaltrigger[j][playerid]) {
                                        lib.hook.globaltrigger[j][playerid].remove(skill);
                                        if (lib.hook.globaltrigger[j][playerid].length == 0) {
                                            delete lib.hook.globaltrigger[j][playerid];
                                        }
                                        if (get.is.empty(lib.hook.globaltrigger[j])) {
                                            delete lib.hook.globaltrigger[j];
                                        }
                                    }
                                }
                            }
                            else {
                                var name = playerid + '_' + i + '_' + evt;
                                if (lib.hook[name]) {
                                    lib.hook[name].remove(skill);
                                    if (lib.hook[name].length == 0) {
                                        delete lib.hook[name];
                                    }
                                }
                            }
                        };
                        for (var i in info.trigger) {
                            if (typeof info.trigger[i] == 'string') {
                                removeTrigger(i, info.trigger[i]);
                            }
                            else if (Array.isArray(info.trigger[i])) {
                                for (var j = 0; j < info.trigger[i].length; j++) {
                                    removeTrigger(i, info.trigger[i][j]);
                                }
                            }
                        }
                    }
                    if (info.hookTrigger) {
                        if (this._hookTrigger) {
                            this._hookTrigger.remove(skill);
                            if (!this._hookTrigger.length) {
                                delete this._hookTrigger;
                            }
                        }
                    }
                    return this;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                removeSkill: function (skill) {
                    if (!skill)
                        return;
                    if (Array.isArray(skill)) {
                        for (var i = 0; i < skill.length; i++) {
                            this.removeSkill(skill[i]);
                        }
                    }
                    else {
                        var info = lib.skill[skill];
                        if (info && info.fixed && arguments[1] !== true)
                            return skill;
                        this.unmarkSkill(skill);
                        game.broadcastAll(function (player, skill) {
                            player.skills.remove(skill);
                            player.hiddenSkills.remove(skill);
                        }, this, skill);
                        this.checkConflict(skill);
                        delete this.tempSkills[skill];
                        if (info) {
                            if (info.onremove) {
                                if (typeof info.onremove == 'function') {
                                    info.onremove(this, skill);
                                }
                                else if (typeof info.onremove == 'string') {
                                    if (info.onremove == 'storage') {
                                        delete this.storage[skill];
                                    }
                                    else {
                                        var cards = this.storage[skill];
                                        if (get.itemtype(cards) == 'card') {
                                            cards = [cards];
                                        }
                                        if (get.itemtype(cards) == 'cards') {
                                            if (this.onremove == 'discard') {
                                                this.$throw(cards);
                                            }
                                            if (this.onremove == 'discard' || this.onremove == 'lose') {
                                                game.cardsDiscard(cards);
                                                delete this.storage[skill];
                                            }
                                        }
                                    }
                                }
                                else if (Array.isArray(info.onremove)) {
                                    for (var i = 0; i < info.onremove.length; i++) {
                                        delete this.storage[info.onremove[i]];
                                    }
                                }
                                else if (info.onremove === true) {
                                    delete this.storage[skill];
                                }
                            }
                            this.removeSkillTrigger(skill);
                            if (!info.keepSkill) {
                                this.removeAdditionalSkill(skill);
                            }
                        }
                        this.enableSkill(skill + '_awake');
                    }
                    return skill;
                },
                /**
                 * 本角色添加一个临时技能
                 * @param {!string} skill 技能名
                 * @param {(string|Object|undefined)} [expire='phaseAfter'] 过期时间，`expire`实际上对应一个触发器，本角色在下一次触发器被触发的时候移除此技能；如果未指定，使用'phaseAfter'
                 * @param {?boolean} [checkConflict] 如果为true，添加技能完成后检测冲突；如果为false或未指定，不检测
                 * @returns {string} 如果添加成功，返回技能名`skill`；否则，返回undefined
                 */
                addTempSkill: function (skill, expire, checkConflict) {
                    if (this.hasSkill(skill) && this.tempSkills[skill] == undefined)
                        return;
                    var noremove = this.skills.contains(skill);
                    this.addSkill(skill, checkConflict, true);
                    if (!noremove)
                        this.skills.remove(skill);
                    if (!expire) {
                        expire = 'phaseAfter';
                    }
                    this.tempSkills[skill] = expire;
                    if (typeof expire == 'string') {
                        lib.hookmap[expire] = true;
                    }
                    else if (Array.isArray(expire)) {
                        for (var i = 0; i < expire.length; i++) {
                            lib.hookmap[expire[i]] = true;
                        }
                    }
                    else if (get.objtype(expire) == 'object') {
                        var roles = ['player', 'source', 'target'];
                        for (var i = 0; i < roles.length; i++) {
                            if (typeof expire[roles[i]] == 'string') {
                                lib.hookmap[expire[roles[i]]] = true;
                            }
                            else if (Array.isArray(expire[roles[i]])) {
                                for (var j = 0; j < expire[roles[i]].length; j++) {
                                    lib.hookmap[expire[roles[i]][j]] = true;
                                }
                            }
                        }
                        if (expire.global) {
                            if (typeof expire.global == 'string') {
                                lib.hookmap[expire.global] = true;
                            }
                            else if (Array.isArray(expire.global)) {
                                for (var i = 0; i < expire.global.length; i++) {
                                    lib.hookmap[expire.global[i]] = true;
                                }
                            }
                        }
                    }
                    for (var i in expire) {
                        if (typeof expire[i] == 'string') {
                            lib.hookmap[expire[i]] = true;
                        }
                        else if (Array.isArray(expire[i])) {
                            for (var j = 0; j < expire.length; j++) {
                                lib.hookmap[expire[i][j]] = true;
                            }
                        }
                    }
                    return skill;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                attitudeTo: function (target) {
                    if (typeof get.attitude == 'function')
                        return get.attitude(this, target);
                    return 0;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                clearSkills: function (all) {
                    var list = [];
                    var exclude = [];
                    for (var i = 0; i < arguments.length; i++) {
                        exclude.push(arguments[i]);
                    }
                    for (i = 0; i < this.skills.length; i++) {
                        if (lib.skill[this.skills[i]].superCharlotte)
                            continue;
                        if (!all && (lib.skill[this.skills[i]].temp || lib.skill[this.skills[i]].charlotte))
                            continue;
                        if (!exclude.contains(this.skills[i])) {
                            list.push(this.skills[i]);
                        }
                    }
                    if (all) {
                        for (var i in this.additionalSkills) {
                            this.removeAdditionalSkill(i);
                        }
                    }
                    this.removeSkill(list);
                    this.checkConflict();
                    this.checkMarks();
                    return list;
                },
                /**
                 *
                 * @returns {!boolean}
                 */
                checkConflict: function (skill) {
                    if (skill) {
                        if (this.forbiddenSkills[skill]) {
                            delete this.forbiddenSkills[skill];
                        }
                        else {
                            for (var i in this.forbiddenSkills) {
                                if (this.forbiddenSkills[i].remove(skill)) {
                                    if (!this.forbiddenSkills[i].length) {
                                        delete this.forbiddenSkills[i];
                                    }
                                }
                            }
                        }
                    }
                    else {
                        this.forbiddenSkills = {};
                        var forbid = [];
                        var getName = function (arr) {
                            var str = '';
                            for (var i = 0; i < arr.length; i++) {
                                str += arr[i] + '+';
                            }
                            return str.slice(0, str.length - 1);
                        };
                        var forbidlist = lib.config.forbid.concat(lib.config.customforbid);
                        var skills = this.getSkills();
                        for (var i = 0; i < forbidlist.length; i++) {
                            if (lib.config.customforbid.contains(forbidlist[i]) ||
                                !lib.config.forbidlist.contains(getName(forbidlist[i]))) {
                                for (var j = 0; j < forbidlist[i].length; j++) {
                                    if (!skills.contains(forbidlist[i][j]))
                                        break;
                                }
                                if (j == forbidlist[i].length) {
                                    forbid.push(forbidlist[i]);
                                }
                            }
                        }
                        for (var i = 0; i < forbid.length; i++) {
                            if (forbid[i][1] || this.name2) {
                                this.forbiddenSkills[forbid[i][0]] = this.forbiddenSkills[forbid[i][0]] || [];
                                if (forbid[i][1]) {
                                    this.forbiddenSkills[forbid[i][0]].add(forbid[i][1]);
                                }
                            }
                        }
                    }
                },
                /**
                 * 返回本角色的一个记录数据
                 * @returns {!boolean}
                 */
                getHistory: function (key, filter, last) {
                    if (!key)
                        return this.actionHistory[this.actionHistory.length - 1];
                    if (!filter)
                        return this.actionHistory[this.actionHistory.length - 1][key];
                    else {
                        var history = this.getHistory(key).slice(0);
                        if (last)
                            history = history.slice(0, history.indexOf(last) + 1);
                        for (var i = 0; i < history.length; i++) {
                            if (!filter(history[i]))
                                history.splice(i--, 1);
                        }
                        return history;
                    }
                },
                hasHistory: function (key, filter, last) {
                    var history = this.getHistory(key).slice(0);
                    if (last)
                        history = history.slice(0, history.indexOf(last) + 1);
                    for (var i = 0; i < history.length; i++) {
                        if (filter(history[i]))
                            return true;
                    }
                    return false;
                },
                /**
                 * 返回本角色最近(当前)的记录数据
                 * @returns {Array}
                 */
                getLastHistory: function (key, filter, last) {
                    var history = false;
                    for (var i = this.actionHistory.length - 1; i >= 0; i--) {
                        if (this.actionHistory[i].isMe) {
                            history = this.actionHistory[i];
                            break;
                        }
                    }
                    if (!history)
                        return null;
                    if (!key)
                        return history;
                    if (!filter)
                        return history[key];
                    else {
                        history = history.slice(0);
                        if (last)
                            history = history.slice(0, history.indexOf(last) + 1);
                        for (var i = 0; i < history.length; i++) {
                            if (!filter(history[i]))
                                history.splice(i--, 1);
                        }
                        return history;
                    }
                },
                /**
                 * 返回本角色的记录数据 TODO
                 * @returns {Array}
                 */
                getAllHistory: function (key, filter, last) {
                    var list = [];
                    var all = this.actionHistory;
                    for (var j = 0; j < all.length; j++) {
                        if (!key || !all[j][key]) {
                            list.push(all[j]);
                        }
                        else {
                            if (!filter)
                                list.addArray(all[j][key]);
                            else {
                                var history = all[j][key].slice(0);
                                if (last)
                                    history = history.slice(0, history.indexOf(last) + 1);
                                for (var i = 0; i < history.length; i++) {
                                    if (filter(history[i]))
                                        list.push(history[i]);
                                }
                            }
                        }
                    }
                    return list;
                },
                hasAllHistory: function (key, filter, last) {
                    var list = [];
                    var all = this.actionHistory;
                    for (var j = 0; j < all.length; j++) {
                        var history = all[j][key].slice(0);
                        if (last)
                            history = history.slice(0, history.indexOf(last) + 1);
                        for (var i = 0; i < history.length; i++) {
                            if (filter(history[i]))
                                return true;
                        }
                    }
                    return false;
                },
                /**
                 * 返回一张本角色使用过的牌
                 * @param {number} [idx=0] 索引，从最近到最远，为0表示最近使用的牌，如果未索引到(e.g. `idx >= length`)，返回null
                 * @returns {(GameCores.GameObjects.Card|null)}
                 */
                getLastUsed: function (num) {
                    if (typeof num != 'number')
                        num = 0;
                    var history = this.getHistory('useCard');
                    if (history.length <= num)
                        return null;
                    return history[history.length - num - 1];
                },
                /**
                 * 返回最后的`stat`的指定键名的值
                 * @param {string} [key] 键名；如果未指定或者为空字符串，返回最后`stat`
                 * @returns {?Object}
                 */
                getStat: function (key) {
                    if (!key)
                        return this.stat[this.stat.length - 1];
                    return this.stat[this.stat.length - 1][key];
                },
                /**
                 * 返回最后的`stat`的指定键名的值 TODO
                 * @param {string} [key] 键名；如果未指定或者为空字符串，返回最后`stat`
                 * @returns {?Object}
                 */
                getLastStat: function (key) {
                    var stat = false;
                    for (var i = this.stat.length - 1; i >= 0; i--) {
                        if (this.stat[i].isMe) {
                            stat = this.stat[i];
                            break;
                        }
                    }
                    if (!stat)
                        return null;
                    if (!key)
                        return stat;
                    return stat[key];
                },
                /**
                 * 设置本角色的Timeout队列，Timeout延迟一定时长，然后重置角色位置
                 * @param {(number|false)} [time=500] 等待时长(ms)；如果为false，表示终止最近添加的Timeout并重置本角色Timeout队列计数
                 */
                queue: function (time) {
                    if (time == false) {
                        clearTimeout(this.queueTimeout);
                        this.queueCount = 0;
                        return;
                    }
                    if (time == undefined)
                        time = 500;
                    var player = this;
                    player.queueCount++;
                    this.queueTimeout = setTimeout(function () {
                        player.queueCount--;
                        if (player.queueCount == 0) {
                            player.style.transform = '';
                            player.node.avatar.style.transform = '';
                            player.node.avatar2.style.transform = '';
                            if (game.chess) {
                                ui.placeChess(player, player.dataset.position);
                            }
                            if (player == game.me)
                                ui.me.removeAttribute('style');
                        }
                    }, time);
                },
                /**
                 * 返回一张游戏牌可以被本角色使用的次数，如果本角色有被动技**cardUsable**改变游戏牌的使用次数，采用改变后的值
                 * @param {!string} cardname 牌名
                 * @param {boolean} [ignoreUsed] 是否忽略使用过的次数，如果为true，忽略使用过的次数；如果为false或者未指定，结果会减去使用过的次数
                 * @returns {!number}
                 */
                getCardUsable: function (card, pure) {
                    var player = this;
                    if (typeof card == 'string') {
                        card = { name: card };
                    }
                    card = get.autoViewAs(card, null, player);
                    var num = get.info(card).usable;
                    if (typeof num == 'function')
                        num = num(card, player);
                    num = game.checkMod(card, player, num, 'cardUsable', player);
                    if (typeof num != 'number')
                        return Infinity;
                    if (!pure && _status.currentPhase == player) {
                        return num - player.countUsed(card);
                    }
                    return num;
                },
                /**
                 * 返回攻击范围
                 * @returns {!number}
                 */
                getAttackRange: function (raw) {
                    var player = this;
                    var range = 0;
                    if (raw)
                        range = game.checkMod(player, player, range, 'globalFrom', player);
                    range = game.checkMod(player, player, range, 'attackFrom', player);
                    var equips = player.getCards('e', function (card) {
                        return !ui.selected.cards || !ui.selected.cards.contains(card);
                    });
                    for (var i = 0; i < equips.length; i++) {
                        var info = get.info(equips[i]).distance;
                        if (!info)
                            continue;
                        if (raw && info.globalFrom) {
                            range += info.globalFrom;
                        }
                        if (info.attackFrom) {
                            range += info.attackFrom;
                        }
                    }
                    return (1 - range);
                },
                /**
                 * TODO
                 * @returns {!boolean}
                 */
                getGlobalFrom: function () {
                    var player = this;
                    var range = 0;
                    range = game.checkMod(player, player, range, 'globalFrom', player);
                    var equips = player.getCards('e', function (card) {
                        return !ui.selected.cards || !ui.selected.cards.contains(card);
                    });
                    for (var i = 0; i < equips.length; i++) {
                        var info = get.info(equips[i]).distance;
                        if (!info)
                            continue;
                        if (info.globalFrom) {
                            range += info.globalFrom;
                        }
                    }
                    return (-range);
                },
                /**
                 * TODO
                 * @returns {!boolean}
                 */
                getGlobalTo: function () {
                    var player = this;
                    var range = 0;
                    range = game.checkMod(player, player, range, 'globalTo', player);
                    var equips = player.getCards('e', function (card) {
                        return !ui.selected.cards || !ui.selected.cards.contains(card);
                    });
                    for (var i = 0; i < equips.length; i++) {
                        var info = get.info(equips[i]).distance;
                        if (!info)
                            continue;
                        if (info.globalTo) {
                            range += info.globalTo;
                        }
                    }
                    return (range);
                },
                /**
                 * 返回本角色的最大手牌数**num**；如果本角色有被动技**maxHandcardBase maxHandcard maxHandcardFinal**，依次改变**num**，返回改变后的**num**；**num**不会小于0
                 * @returns {!number} 非负整数
                 */
                getHandcardLimit: function () {
                    var num = Math.max(this.hp, 0);
                    num = game.checkMod(this, num, 'maxHandcardBase', this);
                    num = game.checkMod(this, num, 'maxHandcard', this);
                    num = game.checkMod(this, num, 'maxHandcardFinal', this);
                    return Math.max(0, num);
                },
                /**
                 * @callback lib.element.player~playerFilterPredicate
                 * @param {!GameCores.GameObjects.Player} player
                 * @returns {!boolean}
                 */
                /**
                 * 返回本角色的敌方角色
                 * @name lib.element.player.getEnemies
                 * @function
                 * @param {lib.element.player~playerFilterPredicate} [predicate] 筛选函数
                 * @returns {!GameCores.GameObjects.Player[]} 如果没有找到角色，返回空数组
                 */
                getEnemies: function (func) {
                    var player = this;
                    var targets;
                    var mode = get.mode();
                    if (mode == 'identity') {
                        if (_status.mode == 'purple') {
                            switch (player.identity) {
                                case 'bZhu':
                                case 'bZhong':
                                case 'rNei':
                                    targets = game.filterPlayer(function (target) {
                                        if (func && !func(target))
                                            return false;
                                        return ['rZhu', 'rZhong', 'bNei'].contains(target.identity);
                                    });
                                    break;
                                case 'rZhu':
                                case 'rZhong':
                                case 'bNei':
                                    targets = game.filterPlayer(function (target) {
                                        if (func && !func(target))
                                            return false;
                                        return ['bZhu', 'bZhong', 'rNei'].contains(target.identity);
                                    });
                                    break;
                                case 'rYe':
                                case 'bYe':
                                    targets = game.filterPlayer(function (target) {
                                        if (func && !func(target))
                                            return false;
                                        return !['rYe', 'bYe'].contains(target.identity);
                                    });
                                    break;
                            }
                        }
                        else {
                            var num = get.population('fan');
                            switch (player.identity) {
                                case 'zhu':
                                case 'zhong':
                                case 'mingzhong':
                                    targets = game.filterPlayer(function (target) {
                                        if (func && !func(target))
                                            return false;
                                        if (num >= 3)
                                            return target.identity == 'fan';
                                        return target.identity == 'nei' || target.identity == 'fan';
                                    });
                                    break;
                                case 'nei':
                                    targets = game.filterPlayer(function (target) {
                                        if (func && !func(target))
                                            return false;
                                        if (num >= 3)
                                            return target.identity == 'fan';
                                        if (game.players.length == 2)
                                            return target != player;
                                        return target.identity == 'zhong' || target.identity == 'mingzhong' || target.identity == 'fan';
                                    });
                                    break;
                                case 'fan':
                                    targets = game.filterPlayer(function (target) {
                                        if (func && !func(target))
                                            return false;
                                        return target.identity != 'fan';
                                    });
                                    break;
                            }
                        }
                    }
                    else if (mode == 'guozhan') {
                        if (player.identity == 'ye') {
                            targets = game.filterPlayer(function (target) {
                                if (func && !func(target))
                                    return false;
                                return true;
                            });
                        }
                        else {
                            var group = lib.character[player.name1][1];
                            targets = game.filterPlayer(function (target) {
                                if (func && !func(target))
                                    return false;
                                return target.identity == 'ye' || lib.character[target.name1][1] != group;
                            });
                        }
                    }
                    else if (mode == 'doudizhu' || mode == 'longlaoguan') {
                        targets = game.filterPlayer(function (target) {
                            if (func && !func(target))
                                return false;
                            return target.identity != player.identity;
                        });
                    }
                    else {
                        targets = game.filterPlayer(function (target) {
                            if (func && !func(target))
                                return false;
                            return target.side != player.side;
                        });
                    }
                    targets.remove(player);
                    return targets;
                },
                /**
                 * 返回本角色的友方角色
                 * @name lib.element.player.getFriends
                 * @function
                 * @param {lib.element.player~playerFilterPredicate} predicate 筛选函数
                 * @returns {!GameCores.GameObjects.Player[]} 如果没有找到角色，返回空数组
                 */
                /**
                 * 返回本角色的友方角色
                 * @name lib.element.player.getFriends
                 * @function
                 * @param {?boolean} hasSelf 结果是否包含本角色，如果为true，则包括；如果为false或未指定，则不包括
                 * @returns {!GameCores.GameObjects.Player[]} 如果没有找到角色，返回空数组
                 */
                getFriends: function (func) {
                    var player = this;
                    var targets;
                    var mode = get.mode();
                    var self = false;
                    if (func === true) {
                        func = null;
                        self = true;
                    }
                    if (mode == 'identity') {
                        if (_status.mode == 'purple') {
                            switch (player.identity) {
                                case 'rZhu':
                                case 'rZhong':
                                case 'bNei':
                                    targets = game.filterPlayer(function (target) {
                                        if (func && !func(target))
                                            return false;
                                        return ['rZhu', 'rZhong', 'bNei'].contains(target.identity);
                                    });
                                    break;
                                case 'bZhu':
                                case 'bZhong':
                                case 'rNei':
                                    targets = game.filterPlayer(function (target) {
                                        if (func && !func(target))
                                            return false;
                                        return ['bZhu', 'bZhong', 'rNei'].contains(target.identity);
                                    });
                                    break;
                                case 'rYe':
                                case 'bYe':
                                    targets = game.filterPlayer(function (target) {
                                        if (func && !func(target))
                                            return false;
                                        return ['rYe', 'bYe'].contains(target.identity);
                                    });
                                    break;
                            }
                        }
                        else {
                            switch (player.identity) {
                                case 'zhu':
                                case 'zhong':
                                case 'mingzhong':
                                    targets = game.filterPlayer(function (target) {
                                        if (func && !func(target))
                                            return false;
                                        return ['zhu', 'zhong', 'mingzhong'].contains(target.identity);
                                    });
                                    break;
                                case 'nei':
                                    targets = [];
                                    break;
                                case 'fan':
                                    targets = game.filterPlayer(function (target) {
                                        if (func && !func(target))
                                            return false;
                                        return target.identity == 'fan';
                                    });
                                    break;
                            }
                        }
                    }
                    else if (mode == 'guozhan') {
                        if (player.identity == 'ye') {
                            targets = [];
                        }
                        else {
                            var group = lib.character[player.name1][1];
                            targets = game.filterPlayer(function (target) {
                                if (func && !func(target))
                                    return false;
                                return target.identity != 'ye' && lib.character[target.name1][1] == group;
                            });
                        }
                    }
                    else if (mode == 'doudizhu' || mode == 'longlaoguan') {
                        targets = game.filterPlayer(function (target) {
                            if (func && !func(target))
                                return false;
                            return target.identity == player.identity;
                        });
                    }
                    else {
                        targets = game.filterPlayer(function (target) {
                            if (func && !func(target))
                                return false;
                            return target.side == player.side;
                        });
                    }
                    if (self) {
                        targets.add(player);
                    }
                    else {
                        targets.remove(player);
                    }
                    return targets;
                },
                /**
                 * 返回本角色是否是目标的敌方
                 * @param {!GameCores.GameObjects.Player} player 目标角色
                 * @returns {!boolean}
                 */
                isEnemyOf: function () {
                    return !this.isFriendOf.apply(this, arguments);
                },
                /**
                 * 返回本角色是否是目标的友方
                 * @param {!GameCores.GameObjects.Player} player 目标角色
                 * @returns {!boolean}
                 */
                isFriendOf: function (player) {
                    if (get.mode() == 'guozhan') {
                        if (this == player)
                            return true;
                        if (this.storage.yexinjia_friend == player || player.storage.yexinjia_friend == this)
                            return true;
                        if (this.identity == 'unknown' || this.identity == 'ye')
                            return false;
                        if (player.identity == 'unknown' || player.identity == 'ye')
                            return false;
                        return this.identity == player.identity;
                    }
                    if (get.mode() == 'doudizhu' || get.mode() == 'longlaoguan') {
                        return this.identity == player.identity;
                    }
                    if (this.side != undefined && typeof player.side == 'boolean') {
                        return this.side == player.side;
                    }
                    return this == player;
                },
                /**
                 * 返回本角色是否是目标的友方
                 * @param {!GameCores.GameObjects.Player} player 目标角色
                 * @returns {!boolean}
                 */
                isFriendsOf: function (player) {
                    return player.getFriends(true).contains(this);
                },
                /**
                 * 返回本角色是否是目标的敌方
                 * @param {!GameCores.GameObjects.Player} player 目标角色
                 * @returns {!boolean}
                 */
                isEnemiesOf: function (player) {
                    return player.getEnemies().contains(this);
                },
                /**
                 * 返回本角色是否未死亡
                 * @returns {!boolean} true表示未死亡，false表示已死亡
                 */
                isAlive: function () {
                    return this.classList.contains('dead') == false;
                },
                /**
                 * 返回本角色是否死亡
                 * @returns {!boolean}
                 */
                isDead: function () {
                    return this.classList.contains('dead');
                },
                /**
                 * 返回本角色是否处于濒死状态
                 * @returns {!boolean}
                 */
                isDying: function () {
                    return _status.dying.contains(this) && this.hp <= 0 && this.isAlive();
                },
                /**
                 * 返回本角色是否当前血量小于最大血量，如果本角色处于**无HP状态**，返回false
                 * @returns {!boolean}
                 */
                isDamaged: function () {
                    return this.hp < this.maxHp && !this.storage.nohp;
                },
                /**
                 * 返回本角色是否当前血量等于最大血量，如果本角色处于**无HP状态**，返回true
                 * @returns {!boolean}
                 */
                isHealthy: function () {
                    return this.hp == this.maxHp || this.storage.nohp;
                },
                /**
                 * 返回本角色的血量是否是局中最多
                 * @param {boolean} [isUnique] 如果为true，只在血量最多且唯一时返回true；如果为false或未指定，只要血量最多就返回true
                 * @returns {!boolean}
                 */
                isMaxHp: function (equal) {
                    for (var i = 0; i < game.players.length; i++) {
                        if (game.players[i].isOut() || game.players[i] == this)
                            continue;
                        if (equal) {
                            if (game.players[i].hp >= this.hp)
                                return false;
                        }
                        else {
                            if (game.players[i].hp > this.hp)
                                return false;
                        }
                    }
                    return true;
                },
                /**
                 * 返回本角色的血量是否是局中最少
                 * @param {boolean} [isUnique] 如果为true，只在血量最少且唯一时返回true；如果为false或未指定，只要血量最少就返回true
                 * @returns {!boolean}
                 */
                isMinHp: function (equal) {
                    for (var i = 0; i < game.players.length; i++) {
                        if (game.players[i].isOut() || game.players[i] == this)
                            continue;
                        if (equal) {
                            if (game.players[i].hp <= this.hp)
                                return false;
                        }
                        else {
                            if (game.players[i].hp < this.hp)
                                return false;
                        }
                    }
                    return true;
                },
                /**
                 * 返回本角色的手牌和装备总数是否是局中最多
                 * @param {boolean} [isUnique] 如果为true，只在数量最多且唯一时返回true；如果为false或未指定，只要数量是最多就返回true
                 * @returns {!boolean}
                 */
                isMaxCard: function (equal) {
                    var nh = this.countCards('he');
                    for (var i = 0; i < game.players.length; i++) {
                        if (game.players[i].isOut() || game.players[i] == this)
                            continue;
                        if (equal) {
                            if (game.players[i].countCards('he') >= nh)
                                return false;
                        }
                        else {
                            if (game.players[i].countCards('he') > nh)
                                return false;
                        }
                    }
                    return true;
                },
                /**
                 * 返回本角色的手牌和装备总数是否是局中最少
                 * @param {boolean} [isUnique] 如果为true，只在数量最少且唯一时返回true；如果为false或未指定，只要数量是最少就返回true
                 * @returns {!boolean}
                 */
                isMinCard: function (equal) {
                    var nh = this.countCards('he');
                    for (var i = 0; i < game.players.length; i++) {
                        if (game.players[i].isOut() || game.players[i] == this)
                            continue;
                        if (equal) {
                            if (game.players[i].countCards('he') <= nh)
                                return false;
                        }
                        else {
                            if (game.players[i].countCards('he') < nh)
                                return false;
                        }
                    }
                    return true;
                },
                /**
                 * 返回本角色的手牌数量是否是局中最多
                 * @param {boolean} [isUnique] 如果为true，只在手牌数量最多且唯一时返回true；如果为false或未指定，只要装备数量是最多就返回true
                 * @returns {!boolean}
                 */
                isMaxHandcard: function (equal) {
                    var nh = this.countCards('h');
                    for (var i = 0; i < game.players.length; i++) {
                        if (game.players[i].isOut() || game.players[i] == this)
                            continue;
                        if (equal) {
                            if (game.players[i].countCards('h') >= nh)
                                return false;
                        }
                        else {
                            if (game.players[i].countCards('h') > nh)
                                return false;
                        }
                    }
                    return true;
                },
                /**
                 * 返回本角色的手牌数量是否是局中最少
                 * @param {boolean} [isUnique] 如果为true，只在手牌数量最少且唯一时返回true；如果为false或未指定，只要手牌数量是最少就返回true
                 * @returns {!boolean}
                 */
                isMinHandcard: function (equal) {
                    var nh = this.countCards('h');
                    for (var i = 0; i < game.players.length; i++) {
                        if (game.players[i].isOut() || game.players[i] == this)
                            continue;
                        if (equal) {
                            if (game.players[i].countCards('h') <= nh)
                                return false;
                        }
                        else {
                            if (game.players[i].countCards('h') < nh)
                                return false;
                        }
                    }
                    return true;
                },
                /**
                 * 返回本角色的装备数量是否是局中最多
                 * @param {boolean} [isUnique] 如果为true，只在装备数量最多且唯一时返回true；如果为false或未指定，只要装备数量是最多就返回true
                 * @returns {!boolean}
                 */
                isMaxEquip: function (equal) {
                    var nh = this.countCards('e');
                    for (var i = 0; i < game.players.length; i++) {
                        if (game.players[i].isOut() || game.players[i] == this)
                            continue;
                        if (equal) {
                            if (game.players[i].countCards('e') >= nh)
                                return false;
                        }
                        else {
                            if (game.players[i].countCards('e') > nh)
                                return false;
                        }
                    }
                    return true;
                },
                /**
                 * 返回本角色的装备数量是否是局中最少
                 * @param {boolean} [isUnique] 如果为true，只在装备数量最少且唯一时返回true；如果为false或未指定，只要装备数量是最少就返回true
                 * @returns {!boolean}
                 */
                isMinEquip: function (equal) {
                    var nh = this.countCards('e');
                    for (var i = 0; i < game.players.length; i++) {
                        if (game.players[i].isOut() || game.players[i] == this)
                            continue;
                        if (equal) {
                            if (game.players[i].countCards('e') <= nh)
                                return false;
                        }
                        else {
                            if (game.players[i].countCards('e') < nh)
                                return false;
                        }
                    }
                    return true;
                },
                /**
                 * 返回本角色是否被链接
                 * @returns {!boolean} true表示被链接，false表示未被链接
                 */
                isLinked: function () {
                    if (get.is.linked2(this)) {
                        return this.classList.contains('linked2');
                    }
                    return this.classList.contains('linked');
                },
                /**
                 * 返回本角色是否翻面
                 * @returns {!boolean} true表示翻面，false表示未翻面
                 */
                isTurnedOver: function () {
                    return this.classList.contains('turnedover');
                },
                /**
                 * 返回本角色的玩家是否离开
                 * @returns {!boolean} true表示离开，false表示未离开
                 */
                isOut: function () {
                    return this.classList.contains('out');
                },
                /**
                 * 本角色是否不计入距离的计算
                 * @param {?boolean} [distance]
                 * @returns {!boolean}
                 */
                //TODO
                isMin: function (distance) {
                    if (distance && lib.config.mode != 'stone')
                        return false;
                    if (this.forcemin)
                        return true;
                    return this.classList.contains('minskin') && !game.chess;
                },
                /**
                 * 表示本角色是否在局中(未死亡&未离开&未移出房间)
                 * @returns {!boolean} true表示在局中，false表示不在局中
                 */
                isIn: function () {
                    return this.classList.contains('dead') == false && this.classList.contains('out') == false && !this.removed;
                },
                /**
                 * 返回本角色是否可见，如果可见返回true
                 * @param {number} num **0**: unseen; **1**: unseen2; **2**: unseen && unseen2; **default**: unseen && !unseen2
                 * @returns {!boolean}
                 */
                isUnseen: function (num) {
                    switch (num) {
                        case 0: return this.classList.contains('unseen');
                        case 1: return this.classList.contains('unseen2');
                        case 2: return this.classList.contains('unseen') || this.classList.contains('unseen2');
                        default: return this.classList.contains('unseen') && (!this.name2 || this.classList.contains('unseen2'));
                    }
                },
                /**
                 * 判断本角色是否可以被某角色的玩家控制
                 * @param {?boolean} self 如果为true，当是两个角色是同一个角色时返回true；如果为false或未指定，返回false
                 * @param {GameCores.GameObjects.Player} [me] 某角色，用于判断本角色是否被`me`的玩家控制，如果未指定，默认使用`game.me`
                 * @returns {!boolean}
                 */
                isUnderControl: function (self, me) {
                    me = (me || game.me);
                    var that = this._trueMe || this;
                    if (that.isMad() || game.notMe)
                        return false;
                    if (this === me) {
                        if (self)
                            return true;
                        return false;
                    }
                    if (that === me || this == me._trueMe)
                        return true;
                    if (_status.connectMode)
                        return false;
                    if (lib.config.mode == 'versus') {
                        if (_status.mode == 'three')
                            return this.side == me.side;
                        if (_status.mode == 'standard')
                            return lib.storage.single_control && this.side == me.side;
                        if (_status.mode == 'four')
                            return get.config('four_phaseswap') && this.side == me.side;
                        if (_status.mode == 'two')
                            return get.config('two_phaseswap') && this.side == me.side;
                        return false;
                    }
                    else if (lib.config.mode == 'boss') {
                        if (me.side)
                            return false;
                        return this.side == me.side && get.config('single_control');
                    }
                    else if (game.chess) {
                        if (lib.config.mode == 'chess') {
                            if (_status.mode == 'combat' && !get.config('single_control'))
                                return false;
                        }
                        return this.side == me.side;
                    }
                    return false;
                },
                /**
                 * 角色是否处于联机状态
                 * 注意，该函数如果角色处于托管状态，返回false
                 * @returns {!boolean}
                 */
                isOnline: function () {
                    if (this.ws && lib.node && !this.ws.closed && this.ws.inited && !this.isAuto) {
                        return true;
                    }
                    return false;
                },
                /**
                 * 角色是否处于联机状态
                 * @returns {!boolean}
                 */
                isOnline2: function () {
                    if (this.ws && lib.node && !this.ws.closed) {
                        return true;
                    }
                    return false;
                },
                /**
                 * 角色是否处于脱机状态
                 * @returns {!boolean}
                 */
                isOffline: function () {
                    if (this.ws && lib.node && this.ws.closed) {
                        return true;
                    }
                    return false;
                },
                checkShow: function (skill, showonly) {
                    var sourceSkill = get.info(skill);
                    var noshow = false;
                    if (sourceSkill && sourceSkill.sourceSkill) {
                        skill = sourceSkill.sourceSkill;
                    }
                    if (lib.skill.global.contains(skill))
                        return false;
                    if (get.mode() != 'guozhan' || game.expandSkills(this.getSkills()).contains(skill)) {
                        if (showonly) {
                            return false;
                        }
                        else {
                            noshow = true;
                        }
                    }
                    var unseen0 = this.isUnseen(0);
                    var name1 = this.name1 || this.name;
                    if (lib.character[name1] && (!showonly || unseen0)) {
                        var skills = game.expandSkills(lib.character[name1][3].slice(0));
                        if (skills.contains(skill)) {
                            if (!noshow && this.isUnseen(0))
                                this.showCharacter(0);
                            return 'main';
                        }
                    }
                    var unseen1 = this.isUnseen(1);
                    var name2 = this.name2;
                    if (lib.character[name2] && (!showonly || unseen1)) {
                        var skills = game.expandSkills(lib.character[name2][3].slice(0));
                        if (skills.contains(skill)) {
                            if (!noshow && this.isUnseen(1))
                                this.showCharacter(1);
                            return 'vice';
                        }
                    }
                    return false;
                },
                /**
                 * 返回本角色当前超出手牌上限多少张牌，如果没有超出上限，返回0；
                 * 如果角色有被动技**ignoredHandcard**，令被动技返回`true`的牌不计入手牌上限
                 * @param {?number} [num]
                 * @returns {!number} 非负整数
                 */
                needsToDiscard: function (num) {
                    if (typeof num != 'number')
                        num = 0;
                    var hs = this.getCards('h');
                    num += hs.length;
                    for (var i = 0; i < hs.length; i++) {
                        if (game.checkMod(hs[i], this, false, 'ignoredHandcard', this) == true) {
                            num--;
                        }
                    }
                    return Math.max(0, num - this.getHandcardLimit());
                },
                distanceTo: function (target, method) {
                    return get.distance(this, target, method);
                },
                distanceFrom: function (target, method) {
                    return get.distance(target, this, method);
                },
                /**
                 * 返回本角色是否拥有一个技能；
                 * 此技能会在角色拥有(技能|子技能)中查找技能名；
                 * 实际调用了{@link lib.element.player.getSkills this.getSkills(arg2, arg3, arg4)}，并用{@link game.expandSkills}展开
                 * @param {!string} skill 技能名
                 * @param {*} arg2 为真时表示计入隐藏的技能、为'e'时表示仅返回装备技能
                 * @param {*} arg3 为false时表示不计入装备技能
                 * @param {*} arg4 为false时表示计入失效的技能
                 * @returns {!boolean}
                 */
                hasSkill: function (skill, arg2, arg3, arg4) {
                    return game.expandSkills(this.getSkills(arg2, arg3, arg4)).contains(skill);
                },
                hasStockSkill: function (skill, arg1, arg2, arg3) {
                    return game.expandSkills(this.getStockSkills(arg1, arg2, arg3)).contains(skill);
                },
                hasZhuSkill: function (skill, player) {
                    if (!this.hasSkill(skill))
                        return false;
                    var mode = get.mode();
                    if (mode == 'identity' || (mode == 'versus' && (_status.mode == 'four' || _status.mode == 'guandu'))) {
                        if (mode != 'identity') {
                            if (player && this.side != player.side)
                                return false;
                        }
                        if (_status.mode == 'purple') {
                            if (player && this.identity.slice(0, 1) != player.identity.slice(0, 1))
                                return false;
                        }
                        if (this.isZhu == true)
                            return true;
                        for (var i in this.storage) {
                            if (i.indexOf('zhuSkill_') == 0 && this.storage[i].contains(skill))
                                return true;
                        }
                    }
                    return false;
                },
                hasGlobalTag: function (tag, arg) {
                    var skills = lib.skill.global.slice(0);
                    game.expandSkills(skills);
                    for (var i = 0; i < skills.length; i++) {
                        var info = lib.skill[skills[i]];
                        if (info && info.ai) {
                            if (info.ai.skillTagFilter && info.ai[tag] &&
                                info.ai.skillTagFilter(this, tag, arg) === false)
                                continue;
                            if (typeof info.ai[tag] == 'string') {
                                if (info.ai[tag] == arg)
                                    return true;
                            }
                            else if (info.ai[tag]) {
                                return true;
                            }
                        }
                    }
                    return false;
                },
                hasSkillTag: function (tag, hidden, arg, globalskill) {
                    var skills = this.getSkills(hidden);
                    if (globalskill) {
                        skills.addArray(lib.skill.global);
                    }
                    game.expandSkills(skills);
                    for (var i = 0; i < skills.length; i++) {
                        var info = lib.skill[skills[i]];
                        if (info && info.ai) {
                            if (info.ai.skillTagFilter && info.ai[tag] &&
                                info.ai.skillTagFilter(this, tag, arg) === false)
                                continue;
                            if (typeof info.ai[tag] == 'string') {
                                if (info.ai[tag] == arg)
                                    return true;
                            }
                            else if (info.ai[tag]) {
                                return true;
                            }
                        }
                    }
                    return false;
                },
                hasJudge: function (name) {
                    if (name && typeof name == 'object') {
                        name = name.viewAs || name.name;
                    }
                    var judges = this.node.judges.childNodes;
                    for (var i = 0; i < judges.length; i++) {
                        if (judges[i].classList.contains('removing'))
                            continue;
                        if ((judges[i].viewAs || judges[i].name) == name) {
                            return true;
                        }
                    }
                    return false;
                },
                hasFriend: function () {
                    for (var i = 0; i < game.players.length; i++) {
                        if (game.players[i].isOut())
                            continue;
                        if (game.players[i] != this && get.attitude(game.players[i], this) > 0) {
                            return true;
                        }
                    }
                    return false;
                },
                hasUnknown: function (num) {
                    var mode = get.mode();
                    if (typeof num != 'number') {
                        num = 0;
                    }
                    if (mode == 'identity' || mode == 'guozhan') {
                        for (var i = 0; i < game.players.length; i++) {
                            if (game.players[i].ai.shown == 0 && game.players[i] != this) {
                                num--;
                                if (num <= 0) {
                                    return true;
                                }
                            }
                        }
                    }
                    return false;
                },
                isUnknown: function (player) {
                    var mode = get.mode();
                    if (mode == 'identity' || mode == 'guozhan') {
                        if (this.ai.shown == 0 && this != player) {
                            return true;
                        }
                    }
                    return false;
                },
                //暗属性
                hasYami: function () {
                    if (this.countCards('h', { nature: 'yami' }))
                        return true;
                    var skills = this.getSkills(true).concat(lib.skill.global);
                    game.expandSkills(skills);
                    for (var i = 0; i < skills.length; i++) {
                        var ifo = get.info(skills[i]);
                        if (ifo.viewAs && typeof ifo.viewAs != 'function' && ifo.viewAs.nature == 'yami') {
                            if (!ifo.viewAsFilter || ifo.viewAsFilter(this)) {
                                return true;
                            }
                        }
                        else {
                            var hiddenYami = get.info(skills[i]).hiddenYami;
                            if (typeof hiddenYami == 'function' && hiddenYami(this, false)) {
                                return true;
                            }
                        }
                    }
                    return false;
                },
                hasWuxie: function () {
                    if (this.countCards('hs', 'wuxie'))
                        return true;
                    var skills = this.getSkills(true).concat(lib.skill.global);
                    game.expandSkills(skills);
                    for (var i = 0; i < skills.length; i++) {
                        var ifo = get.info(skills[i]);
                        if (ifo.viewAs && typeof ifo.viewAs != 'function' && ifo.viewAs.name == 'wuxie') {
                            if (!ifo.viewAsFilter || ifo.viewAsFilter(this)) {
                                return true;
                            }
                        }
                        else {
                            var hiddenCard = get.info(skills[i]).hiddenCard;
                            if (typeof hiddenCard == 'function' && hiddenCard(this, 'wuxie')) {
                                return true;
                            }
                        }
                    }
                    return false;
                },
                hasSha: function (respond, noauto) {
                    if (this.countCards('hs', 'sha'))
                        return true;
                    if (this.countCards('hs', 'hufu'))
                        return true;
                    if (!noauto && this.countCards('hs', 'yuchanqian'))
                        return true;
                    if (this.hasSkillTag('respondSha', true, respond ? 'respond' : 'use', true))
                        return true;
                    return false;
                },
                hasShan: function () {
                    if (this.countCards('hs', 'shan'))
                        return true;
                    if (this.countCards('hs', 'hufu'))
                        return true;
                    if (this.hasSkillTag('respondShan', true, null, true))
                        return true;
                    return false;
                },
                mayHaveShan: function () {
                    return this.hasShan();
                    // modify: After AngelBeats! -2nd Beat-
                },
                hasCard: function (name, position) {
                    if (typeof name == 'function') {
                        var hs = this.getCards(position);
                        for (var i = 0; i < hs.length; i++) {
                            if (name(hs[i]))
                                return true;
                        }
                    }
                    else {
                        if (this.countCards(position, name))
                            return true;
                    }
                    return false;
                },
                canEquip: function (name, replace) {
                    if (get.type(name) == 'card') {
                        name = get.equiptype(name);
                    }
                    var range = get.subtype(name);
                    if (this.isDisabled(range))
                        return false;
                    if (['equip3', 'equip4'].contains(range) && this.getEquip(6))
                        return false;
                    if (!replace && !this.isEmpty(range))
                        return false;
                    return true;
                },
                /**
                 * 装备类型
                 * |string|number|equip|
                 * |:----:|:----:|:---:|
                 * |equip1|1|武器|
                 * |equip2|2|防具|
                 * |equip3|3|防御载具|
                 * |equip4|4|攻击载具|
                 * |equip5|5|宝物|
                 * |equip6|6|坐骑|
                 *
                 * @typedef {('equip[1-6]'|number)} GameCores.EquipType
                 */
                /**
                 * 返回角色装备区的一张牌
                 * @param {(GameCores.GameObjects.Card|'equip[0-9]'|number)} name 如果为游戏牌对象，使用其装备类型(如果有)；如果不是可装备类型或者`name`未指定，此函数返回null；可以取值为数值[0-9]或字符串'equip[0-9]'，但是通常只在[1-6]范围内({@link GameCores.EquipType})
                 * @returns {(null|GameCores.GameObjects.Card)}
                 */
                getEquip: function (name) {
                    var es = this.getCards('e');
                    if (typeof name == 'object' && get.info(name)) {
                        name = get.info(name).subtype;
                        if (name) {
                            name = parseInt(name[5]);
                        }
                    }
                    else if (typeof name == 'string' && name.indexOf('equip') == 0 && name.length == 6) {
                        name = parseInt(name[5]);
                    }
                    if (!name) {
                        return null;
                    }
                    for (var i = 0; i < es.length; i++) {
                        if (typeof name === 'number') {
                            if (get.info(es[i]).subtype === 'equip' + name) {
                                return es[i];
                            }
                        }
                        else {
                            if (es[i].name === name)
                                return es[i];
                            var source = get.info(es[i]).source;
                            if (Array.isArray(source) && source.contains(name)) {
                                return es[i];
                            }
                        }
                    }
                    return null;
                },
                /**
                 * 返回角色判定区一张(指定牌|视为指定牌)
                 * @function
                 * @param {?string} name 指定牌的牌名
                 * @returns {(GameCores.GameObjects.Card|null)} 如果没找到，返回null
                 */
                getJudge: function (name) {
                    var judges = this.node.judges.childNodes;
                    for (var i = 0; i < judges.length; i++) {
                        if (judges[i].classList.contains('removing'))
                            continue;
                        if ((judges[i].viewAs || judges[i].name) == name) {
                            return judges[i];
                        }
                    }
                    return null;
                },
                $drawAuto: function (cards, target) {
                    if (this.isUnderControl(true, target)) {
                        this.$draw(cards);
                    }
                    else {
                        this.$draw(cards.length);
                    }
                },
                $draw: function (num, init, config) {
                    if (init !== false && init !== 'nobroadcast') {
                        game.broadcast(function (player, num, init, config) {
                            player.$draw(num, init, config);
                        }, this, num, init, config);
                    }
                    var cards, node;
                    if (get.itemtype(num) == 'cards') {
                        cards = num;
                        num = cards.length;
                    }
                    else if (get.itemtype(num) == 'card') {
                        cards = [num];
                        num = 1;
                    }
                    if (init !== false) {
                        if (cards) {
                            game.addVideo('drawCard', this, get.cardsInfo(cards));
                        }
                        else {
                            game.addVideo('draw', this, num);
                        }
                    }
                    if (cards) {
                        cards = cards.slice(0);
                        node = cards.shift().copy('thrown', 'drawingcard');
                    }
                    else {
                        node = ui.create.div('.card.thrown.drawingcard');
                    }
                    node.fixed = true;
                    node.hide();
                    var dx, dy;
                    if (game.chess) {
                        var rect = this.getBoundingClientRect();
                        if (rect.left <= 80) {
                            dx = -10;
                            if (rect.top <= 80) {
                                dy = -10;
                            }
                            else if (rect.top + rect.height + 80 >= ui.chessContainer.offsetHeight) {
                                dy = 10;
                            }
                            else {
                                dy = 0;
                            }
                        }
                        else if (rect.left + rect.width + 80 >= ui.chessContainer.offsetWidth) {
                            dx = 10;
                            if (rect.top <= 80) {
                                dy = -10;
                            }
                            else if (rect.top + rect.height + 80 >= ui.chessContainer.offsetHeight) {
                                dy = 10;
                            }
                            else {
                                dy = 0;
                            }
                        }
                        else if (rect.top <= 80) {
                            dx = 0;
                            dy = -10;
                        }
                        else if (rect.top + rect.height + 80 >= ui.chessContainer.offsetHeight) {
                            dx = 0;
                            dy = 10;
                        }
                        else {
                            dx = rect.left + this.offsetWidth / 2 - ui.arena.offsetWidth / 2;
                            dy = rect.top + this.offsetHeight / 2 - ui.arena.offsetHeight / 2;
                        }
                        var coeff = 240 / Math.sqrt(dx * dx + dy * dy);
                        dx *= coeff;
                        dy *= coeff;
                        node.style.left = (this.getLeft() + this.offsetWidth / 2 - 52 - dx) + 'px';
                        node.style.top = (this.getTop() + this.offsetHeight / 2 - 52 - dy) + 'px';
                        this.parentNode.appendChild(node);
                    }
                    else {
                        this.parentNode.appendChild(node);
                        node.style.left = 'calc(50% - 52px)';
                        node.style.top = 'calc(50% - 52px)';
                        dx = this.getLeft() + this.offsetWidth / 2 - 52 - node.offsetLeft;
                        dy = this.getTop() + this.offsetHeight / 2 - 52 - node.offsetTop;
                        if (get.is.mobileMe(this)) {
                            dx += get.cardOffset();
                            if (ui.arena.classList.contains('oblongcard')) {
                                dy -= 16;
                            }
                        }
                    }
                    node.style.transitionDuration = '0.8s';
                    ui.refresh(node);
                    if (typeof num == 'number' && init !== false) {
                        config = {
                            total: num,
                            current: 1
                        };
                    }
                    if (config && config.total > 1) {
                        var total = config.total, current = config.current;
                        var dxtotal;
                        if (total <= 5) {
                            dxtotal = Math.min(80, (total - 1) * 20);
                            dx += -dxtotal + 2 * dxtotal * (current - 1) / (total - 1);
                        }
                        else {
                            var total2 = Math.floor(total / 2);
                            if (current <= total2) {
                                total = total2;
                                dy -= 20;
                            }
                            else {
                                current -= total2;
                                total -= total2;
                                dy += 20;
                            }
                            dxtotal = Math.min(80, (total - 1) * 20);
                            dx += -dxtotal + 2 * dxtotal * (current - 1) / (total - 1);
                        }
                        config.current++;
                    }
                    if (node.style.transform && node.style.transform != 'none' && node.style.transform.indexOf('translate') == -1) {
                        node.style.transform += ' translate(' + dx + 'px,' + dy + 'px)';
                    }
                    else {
                        node.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
                    }
                    node.show();
                    node.listenTransition(function () {
                        node.style.transitionDuration = '0.5s';
                        ui.refresh(node);
                        node["delete"]();
                    });
                    var that = this;
                    if (num && num > 1) {
                        if (config && config.total > 1) {
                            setTimeout(function () {
                                if (cards) {
                                    that.$draw(cards, false, config);
                                }
                                else {
                                    that.$draw(num - 1, false, config);
                                }
                            }, 50);
                        }
                        else {
                            setTimeout(function () {
                                if (cards) {
                                    that.$draw(cards, false, config);
                                }
                                else {
                                    that.$draw(num - 1, false, config);
                                }
                            }, 200);
                        }
                    }
                },
                $compareMultiple: function (card1, targets, cards) {
                    game.broadcast(function (player, card1, targets, cards) {
                        player.$compareMultiple(card1, targets, cards);
                    }, this, card1, targets, cards);
                    game.addVideo('compareMultiple', this, [get.cardInfo(card1), get.targetsInfo(targets), get.cardsInfo(cards)]);
                    var player = this;
                    var node1 = player.$throwxy2(card1, 'calc(50% - 52px)', 'calc(50% + 10px)', 'perspective(600px) rotateY(180deg)', true);
                    if (lib.config.cardback_style != 'default') {
                        node1.style.transitionProperty = 'none';
                        ui.refresh(node1);
                        node1.classList.add('infohidden');
                        ui.refresh(node1);
                        node1.style.transitionProperty = '';
                    }
                    else {
                        node1.classList.add('infohidden');
                    }
                    node1.style.transform = 'perspective(600px) rotateY(180deg) translateX(0)';
                    var onEnd01 = function () {
                        node1.removeEventListener('webkitTransitionEnd', onEnd01);
                        setTimeout(function () {
                            node1.style.transition = 'all ease-in 0.3s';
                            node1.style.transform = 'perspective(600px) rotateY(270deg) translateX(52px)';
                            var onEnd = function () {
                                node1.classList.remove('infohidden');
                                node1.style.transition = 'all 0s';
                                ui.refresh(node1);
                                node1.style.transform = 'perspective(600px) rotateY(-90deg) translateX(52px)';
                                ui.refresh(node1);
                                node1.style.transition = '';
                                ui.refresh(node1);
                                node1.style.transform = '';
                                node1.removeEventListener('webkitTransitionEnd', onEnd);
                            };
                            node1.listenTransition(onEnd);
                        }, 300);
                    };
                    node1.listenTransition(onEnd01);
                    setTimeout(function () {
                        var left0 = -targets.length * 52 - (targets.length - 1) * 8;
                        for (var i = 0; i < targets.length; i++) {
                            (function (target, card2, i) {
                                var left = left0 + i * 120;
                                var node2;
                                if (left < 0) {
                                    node2 = target.$throwxy2(card2, 'calc(50% - ' + (-left) + 'px)', 'calc(50% - 114px)', 'perspective(600px) rotateY(180deg)', true);
                                }
                                else {
                                    node2 = target.$throwxy2(card2, 'calc(50% + ' + left + 'px)', 'calc(50% - 114px)', 'perspective(600px) rotateY(180deg)', true);
                                }
                                if (lib.config.cardback_style != 'default') {
                                    node2.style.transitionProperty = 'none';
                                    ui.refresh(node2);
                                    node2.classList.add('infohidden');
                                    ui.refresh(node2);
                                    node2.style.transitionProperty = '';
                                }
                                else {
                                    node2.classList.add('infohidden');
                                }
                                node2.style.transform = 'perspective(600px) rotateY(180deg) translateX(0)';
                                var onEnd02 = function () {
                                    node2.removeEventListener('webkitTransitionEnd', onEnd02);
                                    setTimeout(function () {
                                        node2.style.transition = 'all ease-in 0.3s';
                                        node2.style.transform = 'perspective(600px) rotateY(270deg) translateX(52px)';
                                        var onEnd = function () {
                                            node2.classList.remove('infohidden');
                                            node2.style.transition = 'all 0s';
                                            ui.refresh(node2);
                                            node2.style.transform = 'perspective(600px) rotateY(-90deg) translateX(52px)';
                                            ui.refresh(node2);
                                            node2.style.transition = '';
                                            ui.refresh(node2);
                                            node2.style.transform = '';
                                            node2.removeEventListener('webkitTransitionEnd', onEnd);
                                        };
                                        node2.listenTransition(onEnd);
                                    }, 200);
                                };
                                node2.listenTransition(onEnd02);
                            }(targets[i], cards[i], i));
                        }
                    }, 200);
                },
                $compare: function (card1, target, card2) {
                    game.broadcast(function (player, target, card1, card2) {
                        player.$compare(card1, target, card2);
                    }, this, target, card1, card2);
                    game.addVideo('compare', this, [get.cardInfo(card1), target.dataset.position, get.cardInfo(card2)]);
                    var player = this;
                    var node1 = player.$throwxy2(card1, 'calc(50% - 114px)', 'calc(50% - 52px)', 'perspective(600px) rotateY(180deg)', true);
                    if (lib.config.cardback_style != 'default') {
                        node1.style.transitionProperty = 'none';
                        ui.refresh(node1);
                        node1.classList.add('infohidden');
                        ui.refresh(node1);
                        node1.style.transitionProperty = '';
                    }
                    else {
                        node1.classList.add('infohidden');
                    }
                    node1.style.transform = 'perspective(600px) rotateY(180deg) translateX(0)';
                    var onEnd01 = function () {
                        node1.removeEventListener('webkitTransitionEnd', onEnd01);
                        setTimeout(function () {
                            node1.style.transition = 'all ease-in 0.3s';
                            node1.style.transform = 'perspective(600px) rotateY(270deg) translateX(52px)';
                            var onEnd = function () {
                                node1.classList.remove('infohidden');
                                node1.style.transition = 'all 0s';
                                ui.refresh(node1);
                                node1.style.transform = 'perspective(600px) rotateY(-90deg) translateX(52px)';
                                ui.refresh(node1);
                                node1.style.transition = '';
                                ui.refresh(node1);
                                node1.style.transform = '';
                                node1.removeEventListener('webkitTransitionEnd', onEnd);
                            };
                            node1.listenTransition(onEnd);
                        }, 300);
                    };
                    node1.listenTransition(onEnd01);
                    setTimeout(function () {
                        var node2 = target.$throwxy2(card2, 'calc(50% + 10px)', 'calc(50% - 52px)', 'perspective(600px) rotateY(180deg)', true);
                        if (lib.config.cardback_style != 'default') {
                            node2.style.transitionProperty = 'none';
                            ui.refresh(node2);
                            node2.classList.add('infohidden');
                            ui.refresh(node2);
                            node2.style.transitionProperty = '';
                        }
                        else {
                            node2.classList.add('infohidden');
                        }
                        node2.style.transform = 'perspective(600px) rotateY(180deg) translateX(0)';
                        var onEnd02 = function () {
                            node2.removeEventListener('webkitTransitionEnd', onEnd02);
                            setTimeout(function () {
                                node2.style.transition = 'all ease-in 0.3s';
                                node2.style.transform = 'perspective(600px) rotateY(270deg) translateX(52px)';
                                var onEnd = function () {
                                    node2.classList.remove('infohidden');
                                    node2.style.transition = 'all 0s';
                                    ui.refresh(node2);
                                    node2.style.transform = 'perspective(600px) rotateY(-90deg) translateX(52px)';
                                    ui.refresh(node2);
                                    node2.style.transition = '';
                                    ui.refresh(node2);
                                    node2.style.transform = '';
                                    node2.removeEventListener('webkitTransitionEnd', onEnd);
                                };
                                node2.listenTransition(onEnd);
                            }, 200);
                        };
                        node2.listenTransition(onEnd02);
                    }, 200);
                },
                $throw: function (card, time, init, nosource) {
                    if (typeof card == 'number') {
                        var tmp = card;
                        card = [];
                        while (tmp--) {
                            var cardx = ui.create.card();
                            cardx.classList.add('infohidden');
                            cardx.classList.add('infoflip');
                            card.push(cardx);
                        }
                    }
                    if (init !== false) {
                        if (init !== 'nobroadcast') {
                            game.broadcast(function (player, card, time, init, nosource) {
                                player.$throw(card, time, init, nosource);
                            }, this, card, time, init);
                        }
                        if (get.itemtype(card) != 'cards') {
                            if (get.itemtype(card) == 'card') {
                                card = [card];
                            }
                            else {
                                return;
                            }
                        }
                        game.addVideo('throw', this, [get.cardsInfo(card), time, nosource]);
                    }
                    if (game.chess) {
                        this.chessFocus();
                    }
                    if (get.itemtype(card) == 'cards') {
                        var node;
                        for (var i = 0; i < card.length; i++) {
                            node = this.$throw(card[i], time, false, nosource);
                        }
                        return node;
                    }
                    else {
                        var node;
                        if (card == undefined || card.length == 0)
                            return;
                        node = this.$throwordered(card.copy('thrown'), nosource);
                        if (time != undefined) {
                            node.fixed = true;
                            setTimeout(function () { node["delete"](); }, time);
                        }
                        lib.listenEnd(node);
                        return node;
                    }
                },
                $throwordered: function () {
                    return this.$throwordered2.apply(this, arguments);
                    // if(lib.config.low_performance){
                    //     return this.$throwordered2.apply(this,arguments);
                    // }
                    // else{
                    //     return this.$throwordered1.apply(this,arguments);
                    // }
                },
                $throwordered1: function (node, nosource) {
                    node.classList.add('thrown');
                    node.hide();
                    node.style.transitionProperty = 'left,top,opacity,transform';
                    for (var i = 0; i < ui.thrown.length; i++) {
                        if (ui.thrown[i].parentNode != ui.arena ||
                            ui.thrown[i].classList.contains('removing')) {
                            ui.thrown.splice(i--, 1);
                        }
                    }
                    ui.thrown.push(node);
                    var uithrowns = ui.thrown.slice(0);
                    var tops;
                    if (game.chess) {
                        switch (Math.floor((ui.thrown.length - 1) / 4)) {
                            case 0:
                                tops = ['calc(50% - 82px)'];
                                break;
                            case 1:
                                tops = ['calc(50% - 139px)', 'calc(50% - 25px)'];
                                break;
                            case 2:
                                tops = ['calc(50% - 196px)', 'calc(50% - 82px)', 'calc(50% + 32px)'];
                                break;
                            default:
                                tops = ['calc(50% - 253px)', 'calc(50% - 139px)',
                                    'calc(50% - 25px)', 'calc(50% + 89px)'];
                        }
                    }
                    else {
                        switch (Math.floor((ui.thrown.length - 1) / 4)) {
                            case 0:
                                tops = ['calc(50% - 52px)'];
                                break;
                            case 1:
                                tops = ['calc(50% - 109px)', 'calc(50% + 5px)'];
                                break;
                            case 2:
                                tops = ['calc(50% - 166px)', 'calc(50% - 52px)', 'calc(50% + 62px)'];
                                break;
                            default:
                                tops = ['calc(50% - 223px)', 'calc(50% - 109px)',
                                    'calc(50% + 5px)', 'calc(50% + 119px)'];
                        }
                    }
                    while (uithrowns.length) {
                        var throwns = uithrowns.splice(0, Math.min(uithrowns.length, 4));
                        switch (throwns.length) {
                            case 1:
                                throwns[0].style.left = 'calc(50% - 52px)';
                                break;
                            case 2:
                                throwns[0].style.left = 'calc(50% - 109px)';
                                throwns[1].style.left = 'calc(50% + 5px)';
                                break;
                            case 3:
                                throwns[0].style.left = 'calc(50% - 166px)';
                                throwns[1].style.left = 'calc(50% - 52px)';
                                throwns[2].style.left = 'calc(50% + 62px)';
                                break;
                            case 4:
                                throwns[0].style.left = 'calc(50% - 223px)';
                                throwns[1].style.left = 'calc(50% - 109px)';
                                throwns[2].style.left = 'calc(50% + 5px)';
                                throwns[3].style.left = 'calc(50% + 119px)';
                                break;
                        }
                        var top;
                        if (tops.length) {
                            top = tops.shift();
                        }
                        else {
                            if (game.chess) {
                                top = 'calc(50% - 82px)';
                            }
                            else {
                                top = 'calc(50% - 52px)';
                            }
                        }
                        for (var i = 0; i < throwns.length; i++) {
                            throwns[i].style.top = top;
                        }
                    }
                    if (nosource) {
                        node.style.transform = 'scale(0)';
                        node.classList.add('center');
                    }
                    else {
                        var parseCalc = function (str) {
                            var per = str.slice(str.indexOf('calc(') + 5, str.indexOf('%'));
                            var add = str.slice(str.indexOf('%') + 1, str.indexOf('px')).replace(/\s/g, '');
                            return [parseInt(per), parseInt(add)];
                        };
                        var nx = parseCalc(node.style.left);
                        var ny = parseCalc(node.style.top);
                        nx = nx[0] * ui.arena.offsetWidth / 100 + nx[1];
                        ny = ny[0] * ui.arena.offsetHeight / 100 + ny[1];
                        var dx, dy;
                        if (game.chess) {
                            var rect = this.getBoundingClientRect();
                            dx = rect.left + this.offsetWidth / 2 - 52 - nx;
                            dy = rect.top + this.offsetHeight / 2 - 52 - ny;
                        }
                        else {
                            dx = this.getLeft() + this.offsetWidth / 2 - 52 - nx;
                            dy = this.getTop() + this.offsetHeight / 2 - 52 - ny;
                            if (get.is.mobileMe(this)) {
                                dx += get.cardOffset();
                                if (ui.arena.classList.contains('oblongcard')) {
                                    dy -= 16;
                                }
                            }
                        }
                        if (node.style.transform && node.style.transform != 'none' && node.style.transform.indexOf('translate') == -1) {
                            node.style.transform += ' translate(' + dx + 'px,' + dy + 'px)';
                        }
                        else {
                            node.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
                        }
                    }
                    ui.arena.appendChild(node);
                    ui.refresh(node);
                    node.style.transform = '';
                    node.show();
                    lib.listenEnd(node);
                    return node;
                },
                $throwordered2: function (node, nosource) {
                    node.classList.add('thrown');
                    node.classList.add('center');
                    node.hide();
                    node.style.transitionProperty = 'left,top,opacity,transform';
                    if (nosource) {
                        // node.style.transform='scale(0)';
                    }
                    else {
                        var nx = [50, -52];
                        var ny = [50, -52];
                        nx = nx[0] * ui.arena.offsetWidth / 100 + nx[1];
                        ny = ny[0] * ui.arena.offsetHeight / 100 + ny[1];
                        var dx, dy;
                        if (game.chess) {
                            var rect = this.getBoundingClientRect();
                            dx = rect.left + this.offsetWidth / 2 - 52 - nx;
                            dy = rect.top + this.offsetHeight / 2 - 52 - ny;
                        }
                        else {
                            dx = this.getLeft() + this.offsetWidth / 2 - 52 - nx;
                            dy = this.getTop() + this.offsetHeight / 2 - 52 - ny;
                            if (get.is.mobileMe(this)) {
                                dx += get.cardOffset();
                                if (ui.arena.classList.contains('oblongcard')) {
                                    dy -= 16;
                                }
                            }
                        }
                        if (node.style.transform && node.style.transform != 'none' && node.style.transform.indexOf('translate') == -1) {
                            node.style.transform += ' translate(' + dx + 'px,' + dy + 'px)';
                        }
                        else {
                            node.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
                        }
                    }
                    ui.arena.appendChild(node);
                    ui.refresh(node);
                    for (var i = 0; i < ui.thrown.length; i++) {
                        if (ui.thrown[i].parentNode != ui.arena ||
                            ui.thrown[i].classList.contains('removing')) {
                            ui.thrown.splice(i--, 1);
                        }
                    }
                    ui.thrown.push(node);
                    var uithrowns = ui.thrown.slice(0);
                    var tops;
                    switch (Math.floor((ui.thrown.length - 1) / 4)) {
                        case 0:
                            tops = [0];
                            break;
                        case 1:
                            tops = [-57, 57];
                            break;
                        case 2:
                            tops = [-114, 0, 114];
                            break;
                        default:
                            tops = [-171, -57, 57, 171];
                    }
                    while (uithrowns.length) {
                        var throwns = uithrowns.splice(0, Math.min(uithrowns.length, 4));
                        switch (throwns.length) {
                            case 1:
                                throwns[0]._transthrown = 'translate(0px,';
                                break;
                            case 2:
                                throwns[0]._transthrown = 'translate(-57px,';
                                throwns[1]._transthrown = 'translate(57px,';
                                break;
                            case 3:
                                throwns[0]._transthrown = 'translate(-114px,';
                                throwns[1]._transthrown = 'translate(0,';
                                throwns[2]._transthrown = 'translate(114px,';
                                break;
                            case 4:
                                throwns[0]._transthrown = 'translate(-171px,';
                                throwns[1]._transthrown = 'translate(-57px,';
                                throwns[2]._transthrown = 'translate(57px,';
                                throwns[3]._transthrown = 'translate(171px,';
                                break;
                        }
                        var top;
                        if (tops.length) {
                            top = tops.shift();
                        }
                        else {
                            top = 0;
                        }
                        if (game.chess) {
                            top -= 30;
                        }
                        for (var i = 0; i < throwns.length; i++) {
                            throwns[i].style.transform = throwns[i]._transthrown + top + 'px)';
                            delete throwns[i]._transthrown;
                        }
                    }
                    node.show();
                    lib.listenEnd(node);
                    return node;
                },
                $throwxy: function (card, left, top) {
                    var node = card.copy('thrown', 'thrownhighlight');
                    node.dataset.position = this.dataset.position;
                    node.hide();
                    node.style.transitionProperty = 'left,top,opacity';
                    ui.arena.appendChild(node);
                    ui.refresh(node);
                    node.show();
                    node.style.left = left;
                    node.style.top = top;
                    lib.listenEnd(node);
                    return node;
                },
                $throwxy2: function (card, left, top, trans, flipx, flipy) {
                    if (game.chess) {
                        return this.$throwxy.apply(this, arguments);
                    }
                    var node = card.copy('thrown', 'thrownhighlight');
                    node.style.left = left;
                    node.style.top = top;
                    node.hide();
                    // node.style.transitionProperty='left,top,opacity,transform';
                    var parseCalc = function (str) {
                        var per = str.slice(str.indexOf('calc(') + 5, str.indexOf('%'));
                        var add = str.slice(str.indexOf('%') + 1, str.indexOf('px')).replace(/\s/g, '');
                        return [parseInt(per), parseInt(add)];
                    };
                    var nx = parseCalc(node.style.left);
                    var ny = parseCalc(node.style.top);
                    nx = nx[0] * ui.arena.offsetWidth / 100 + nx[1];
                    ny = ny[0] * ui.arena.offsetHeight / 100 + ny[1];
                    var dx = this.getLeft() + this.offsetWidth / 2 - 52 - nx;
                    var dy = this.getTop() + this.offsetHeight / 2 - 52 - ny;
                    if (flipx)
                        dx = -dx;
                    if (flipy)
                        dy = -dy;
                    if (trans) {
                        node.style.transform = trans + ' translate(' + dx + 'px,' + dy + 'px)';
                    }
                    else {
                        node.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
                    }
                    ui.arena.appendChild(node);
                    ui.refresh(node);
                    node.show();
                    // node.style.transform=trans||'';
                    lib.listenEnd(node);
                    return node;
                },
                throwDice: function (num) {
                    if (typeof num != 'number') {
                        num = get.rand(6) + 1;
                        _status.event.num = num;
                    }
                    if (!game.online) {
                        game.pause();
                    }
                    game.broadcastAll(function (num) {
                        var diceContainer = ui.create.div('.fullsize.dice-container', ui.window);
                        ui.window.classList.add('dicepaused');
                        var dice = ui.create.div('.dice');
                        var side;
                        side = ui.create.div('.side.front', dice);
                        ui.create.div('.dot.center', side);
                        ui.create.div('.side.front.inner', dice);
                        side = ui.create.div('.side.top', dice);
                        ui.create.div('.dot.dtop.dleft', side);
                        ui.create.div('.dot.dbottom.dright', side);
                        ui.create.div('.side.top.inner', dice);
                        side = ui.create.div('.side.right', dice);
                        ui.create.div('.dot.dtop.dleft', side);
                        ui.create.div('.dot.center', side);
                        ui.create.div('.dot.dbottom.dright', side);
                        ui.create.div('.side.right.inner', dice);
                        side = ui.create.div('.side.left', dice);
                        ui.create.div('.dot.dtop.dleft', side);
                        ui.create.div('.dot.dtop.dright', side);
                        ui.create.div('.dot.dbottom.dleft', side);
                        ui.create.div('.dot.dbottom.dright', side);
                        ui.create.div('.side.left.inner', dice);
                        side = ui.create.div('.side.bottom', dice);
                        ui.create.div('.dot.center', side);
                        ui.create.div('.dot.dtop.dleft', side);
                        ui.create.div('.dot.dtop.dright', side);
                        ui.create.div('.dot.dbottom.dleft', side);
                        ui.create.div('.dot.dbottom.dright', side);
                        ui.create.div('.side.bottom.inner', dice);
                        side = ui.create.div('.side.back', dice);
                        ui.create.div('.dot.dtop.dleft', side);
                        ui.create.div('.dot.dtop.dright', side);
                        ui.create.div('.dot.dbottom.dleft', side);
                        ui.create.div('.dot.dbottom.dright', side);
                        ui.create.div('.dot.center dleft', side);
                        ui.create.div('.dot.center dright', side);
                        ui.create.div('.side.back.inner', dice);
                        ui.create.div('.side.cover.x', dice);
                        ui.create.div('.side.cover.y', dice);
                        ui.create.div('.side.cover.z', dice);
                        var map = {
                            1: [75, 0, 45],
                            2: [-15, 45, 0],
                            3: [165, -45, 90],
                            4: [345, -45, 90],
                            5: [345, -45, 180],
                            6: [255, 0, 135]
                        };
                        dice.roll = function (deg) {
                            if (typeof deg == 'number') {
                                dice.current[0] += deg;
                                deg = dice.current;
                            }
                            deg = deg.slice(0);
                            dice.current = deg;
                            this.style.transform = 'rotateX(' + deg[0] + 'deg) rotateY(' + deg[1] + 'deg) rotateZ(' + deg[2] + 'deg)';
                        };
                        dice.roll(map[num]);
                        diceContainer.appendChild(dice);
                        ui.refresh(dice);
                        dice.roll(1025);
                        dice.addEventListener('webkitTransitionEnd', function () {
                            if (!dice.over) {
                                dice.style.transition = 'transform 0.8s ease';
                                dice.roll(-20);
                                dice.over = true;
                            }
                            else if (!dice.resumed) {
                                setTimeout(function () {
                                    diceContainer["delete"]();
                                    ui.window.classList.remove('dicepaused');
                                }, 300);
                                if (!game.online) {
                                    setTimeout(game.resume, 800);
                                }
                                dice.resumed = true;
                            }
                        });
                    }, num);
                },
                $giveAuto: function (card, player) {
                    if (Array.isArray(card) && card.length == 0)
                        return;
                    var args = Array.from(arguments);
                    if (_status.connectMode || (!this.isUnderControl(true) && !player.isUnderControl(true))) {
                        if (Array.isArray(card)) {
                            card = card.length;
                        }
                        else {
                            card = 1;
                        }
                        args[0] = card;
                    }
                    return this.$give.apply(this, args);
                },
                $give: function (card, player, log, init) {
                    if (init !== false) {
                        game.broadcast(function (source, card, player, init) {
                            source.$give(card, player, false, init);
                        }, this, card, player, init);
                        if (typeof card == 'number' && card >= 0) {
                            game.addVideo('give', this, [card, player.dataset.position]);
                        }
                        else {
                            if (get.itemtype(card) == 'card') {
                                card = [card];
                            }
                            if (get.itemtype(card) == 'cards') {
                                game.addVideo('giveCard', this, [get.cardsInfo(card), player.dataset.position]);
                            }
                        }
                    }
                    if (get.itemtype(card) == 'cards') {
                        if (log != false && !_status.video) {
                            game.log(player, '从', this, '获得了', card);
                        }
                        if (this.$givemod) {
                            this.$givemod(card, player);
                        }
                        else {
                            for (var i = 0; i < card.length; i++) {
                                this.$give(card[i], player, false, false);
                            }
                        }
                    }
                    else if (typeof card == 'number' && card >= 0) {
                        if (log != false && !_status.video) {
                            game.log(player, '从', this, '获得了' + get.cnNumber(card) + '张牌');
                        }
                        if (this.$givemod) {
                            this.$givemod(card, player);
                        }
                        else {
                            while (card--)
                                this.$give('', player, false, false);
                        }
                    }
                    else {
                        if (log != false && !_status.video) {
                            if (get.itemtype(card) == 'card' && log != false) {
                                game.log(player, '从', this, '获得了', card);
                            }
                            else {
                                game.log(player, '从', this, '获得了一张牌');
                            }
                        }
                        if (this.$givemod) {
                            this.$givemod(card, player);
                        }
                        else {
                            var node;
                            if (get.itemtype(card) == 'card') {
                                node = card.copy('card', 'thrown', false);
                            }
                            else {
                                node = ui.create.div('.card.thrown');
                            }
                            // node.dataset.position=this.dataset.position;
                            node.fixed = true;
                            this.$throwordered(node);
                            // lib.listenEnd(node);
                            // node.hide();
                            // node.style.transitionProperty='left,top,opacity';
                            //
                            // node.style.transform='rotate('+(Math.random()*16-8)+'deg)';
                            //
                            // ui.arena.appendChild(node);
                            // ui.refresh(node);
                            // node.show();
                            // node.style.left='calc(50% - 52px '+((Math.random()-0.5<0)?'+':'-')+' '+Math.random()*100+'px)';
                            // node.style.top='calc(50% - 52px '+((Math.random()-0.5<0)?'+':'-')+' '+Math.random()*80+'px)';
                            node.listenTransition(function () {
                                var dx = player.getLeft() + player.offsetWidth / 2 - 52 - node.offsetLeft;
                                var dy = player.getTop() + player.offsetHeight / 2 - 52 - node.offsetTop;
                                if (node.style.transform && node.style.transform != 'none' && node.style.transform.indexOf('translate') == -1) {
                                    node.style.transform += ' translate(' + dx + 'px,' + dy + 'px)';
                                }
                                else {
                                    node.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
                                }
                                node["delete"]();
                            });
                            // setTimeout(function(){
                            //     // node.removeAttribute('style');
                            //     // node.dataset.position=player.dataset.position;
                            //     var dx=player.offsetLeft+player.offsetWidth/2-52-node.offsetLeft;
                            //     var dy=player.offsetTop+player.offsetHeight/2-52-node.offsetTop;
                            //     if(node.style.transform&&node.style.transform!='none'&&node.style.transform.indexOf('translate')==-1){
                            //         node.style.transform+=' translate('+dx+'px,'+dy+'px)';
                            //     }
                            //     else{
                            //         node.style.transform='translate('+dx+'px,'+dy+'px)';
                            //     }
                            //
                            //     node.delete();
                            // },700);
                        }
                    }
                },
                $equip: function (card, viewAs) {
                    var originalName = card.originalName;
                    if (viewAs && this.storage.disableEquip != undefined && this.storage.disableEquip.contains(get.subtype(viewAs))) {
                        this.gain(card, 'gain2');
                        game.log(this, '装备失败');
                    }
                    else if (this.storage.disableEquip != undefined && this.storage.disableEquip.contains(get.subtype(card))) {
                        this.gain(card, 'gain2');
                        game.log(this, '装备失败');
                    }
                    else {
                        var player = this;
                        game.broadcast(function (player, card, viewAs) {
                            player.$equip(card, viewAs);
                        }, player, card, viewAs);
                        card.fix();
                        card.style.transform = '';
                        card.classList.remove('drawinghidden');
                        delete card._transform;
                        //已修改
                        card.originalName = originalName;
                        card.viewAs = viewAs;
                        if (viewAs && viewAs != card.name) {
                            if (card.classList.contains('fullskin') || card.classList.contains('fullborder')) {
                                card.classList.add('fakejudge');
                                card.node.background.innerHTML = lib.translate[viewAs.name + '_bg'] || get.translation(viewAs)[0];
                            }
                            card.classList.remove(get.subtype(card));
                            card.classList.add(get.subtype(viewAs));
                            if (typeof viewAs == 'string')
                                card.viewAs = viewAs;
                            else
                                card.viewAs = viewAs.name;
                        }
                        else {
                            card.classList.remove('fakejudge');
                            delete card.viewAs;
                        }
                        //console.log(card.viewAs);
                        if (card.viewAs && card.name != card.viewAs) {
                            if (!card.originalName)
                                card.originalName = card.name;
                            card.name = card.viewAs;
                        }
                        var equipNum = get.equipNum(card);
                        var equipped = false;
                        for (var i = 0; i < player.node.equips.childNodes.length; i++) {
                            if (get.equipNum(player.node.equips.childNodes[i]) >= equipNum) {
                                player.node.equips.insertBefore(card, player.node.equips.childNodes[i]);
                                equipped = true;
                                break;
                            }
                        }
                        if (!equipped) {
                            player.node.equips.appendChild(card);
                            if (_status.discarded) {
                                _status.discarded.remove(card);
                            }
                        }
                        var ecard = viewAs ? { name: viewAs } : card;
                        var info = get.info(ecard);
                        if (info.skills) {
                            for (var i = 0; i < info.skills.length; i++) {
                                player.addSkillTrigger(info.skills[i]);
                            }
                        }
                        return player;
                    }
                    ;
                },
                $gain: function (card, log, init) {
                    if (init !== false) {
                        game.broadcast(function (player, card, init) {
                            player.$gain(card, false, init);
                        }, this, card, init);
                        if (typeof card == 'number' && card >= 0) {
                            game.addVideo('gain', this, card);
                        }
                        else {
                            if (get.itemtype(card) == 'card') {
                                card = [card];
                            }
                            if (get.itemtype(card) == 'cards') {
                                game.addVideo('gainCard', this, get.cardsInfo(card));
                            }
                            else {
                                game.addVideo('gain', this, 1);
                            }
                        }
                    }
                    if (get.itemtype(card) == 'cards') {
                        if (log != false && !_status.video) {
                            game.log(this, '获得了', card);
                        }
                        if (this.$gainmod) {
                            this.$gainmod(card);
                        }
                        else {
                            for (var i = 0; i < card.length; i++) {
                                this.$gain(card[i], false, false);
                            }
                        }
                    }
                    else if (typeof card == 'number' && card > 1) {
                        if (log != false && !_status.video) {
                            game.log(this, '获得了' + get.cnNumber(card) + '张牌');
                        }
                        if (this.$gainmod) {
                            this.$gainmod(card);
                        }
                        else {
                            for (var i = 0; i < card; i++) {
                                this.$gain(1, false, false);
                            }
                        }
                    }
                    else {
                        if (get.itemtype(card) == 'card' && log != false && !_status.video) {
                            game.log(this, '获得了', card);
                        }
                        if (this.$gainmod) {
                            this.$gainmod(card);
                        }
                        else {
                            var node;
                            if (get.itemtype(card) == 'card') {
                                // node=this.$throwordered(card.copy(),true);
                                node = card.copy('thrown', false);
                            }
                            else {
                                // node=this.$throwordered(ui.create.div('.card.thrown'),true);
                                node = ui.create.div('.card.thrown');
                                node.moveTo = lib.element.card.moveTo;
                                node.moveDelete = lib.element.card.moveDelete;
                            }
                            node.fixed = true;
                            node.style.left = 'calc(50% - 52px ' + ((Math.random() - 0.5 < 0) ? '+' : '-') + ' ' + Math.random() * 100 + 'px)';
                            node.style.top = 'calc(50% - 52px ' + ((Math.random() - 0.5 < 0) ? '+' : '-') + ' ' + Math.random() * 100 + 'px)';
                            node.style.transform = 'scale(0)';
                            node.hide();
                            ui.arena.appendChild(node);
                            ui.refresh(node);
                            node.show();
                            node.style.transform = '';
                            lib.listenEnd(node);
                            var player = this;
                            setTimeout(function () {
                                node.moveDelete(player);
                            }, 700);
                        }
                    }
                },
                $gain2: function (cards, log) {
                    if (log === true) {
                        game.log(this, '获得了', cards);
                    }
                    game.broadcast(function (player, cards) {
                        player.$gain2(cards);
                    }, this, cards);
                    if (get.itemtype(cards) == 'card')
                        cards = [cards];
                    else if (get.itemtype(cards) != 'cards')
                        return;
                    var list = [], list2 = [];
                    for (var i = 0; i < cards.length; i++) {
                        if (cards[i].clone &&
                            (cards[i].clone.parentNode == this.parentNode ||
                                cards[i].clone.parentNode == ui.arena) &&
                            parseFloat(getComputedStyle(cards[i].clone).opacity) > 0.3) {
                            cards[i].clone.moveDelete(this);
                            list2.push(cards[i].clone);
                        }
                        else {
                            list.push(cards[i]);
                        }
                    }
                    if (list2.length) {
                        game.addVideo('gain2', this, get.cardsInfo(list2));
                    }
                    if (list.length) {
                        this.$draw(list, 'nobroadcast');
                        return true;
                    }
                },
                /**
                 * 本角色播放技能动画
                 */
                //TODO
                $skill: function (name, type, color, avatar) {
                    if (typeof type != 'string')
                        type = 'legend';
                    if (!avatar) {
                        this.playerfocus(1500);
                        game.delay(2);
                    }
                    else {
                        game.addVideo('playerfocus2');
                        game.broadcastAll(function () {
                            ui.arena.classList.add('playerfocus');
                            setTimeout(function () {
                                ui.arena.classList.remove('playerfocus');
                            }, 1800);
                        });
                        game.delay(3);
                    }
                    var that = this;
                    setTimeout(function () {
                        game.broadcastAll(function (that, type, name, color, avatar) {
                            if (lib.config.animation && !lib.config.low_performance) {
                                if (game.chess) {
                                    that['$' + type + '2'](1200);
                                }
                                else {
                                    that['$' + type](1200);
                                }
                            }
                            if (name) {
                                that.$fullscreenpop(name, color, avatar);
                            }
                        }, that, type, name, color, avatar);
                    }, avatar ? 0 : 300);
                },
                $fire: function () {
                    game.addVideo('flame', this, 'fire');
                    var left, top;
                    if (game.chess) {
                        var rect = this.getBoundingClientRect();
                        left = rect.left;
                        top = rect.top;
                    }
                    else {
                        left = this.getLeft();
                        top = this.getTop();
                    }
                    game.animate.flame(left + this.offsetWidth / 2, top + this.offsetHeight - 20, 700, 'fire');
                },
                $thunder: function () {
                    game.addVideo('flame', this, 'thunder');
                    var left, top;
                    if (game.chess) {
                        var rect = this.getBoundingClientRect();
                        left = rect.left;
                        top = rect.top;
                    }
                    else {
                        left = this.getLeft();
                        top = this.getTop();
                    }
                    game.animate.flame(left + this.offsetWidth / 2, top + this.offsetHeight - 30, 700, 'thunder');
                },
                $rare2: function () {
                    game.addVideo('flame', this, 'rare2');
                    var rect = this.getBoundingClientRect();
                    var left = rect.left;
                    var top = rect.top + 15;
                    game.animate.flame(left + this.offsetWidth / 2, top + this.offsetHeight - 30, 700, 'rare');
                },
                $epic2: function () {
                    game.addVideo('flame', this, 'epic2');
                    var rect = this.getBoundingClientRect();
                    var left = rect.left;
                    var top = rect.top + 15;
                    game.animate.flame(left + this.offsetWidth / 2, top + this.offsetHeight - 30, 700, 'epic');
                },
                $legend2: function () {
                    game.addVideo('flame', this, 'legend2');
                    var rect = this.getBoundingClientRect();
                    var left = rect.left;
                    var top = rect.top + 15;
                    game.animate.flame(left + this.offsetWidth / 2, top + this.offsetHeight - 30, 700, 'legend');
                },
                $rare: function (time) {
                    time = time || 700;
                    game.addVideo('flame', this, 'rare');
                    var left, top;
                    if (game.chess) {
                        left = this.getLeft() - ui.arena.offsetLeft;
                        top = this.getTop() - ui.arena.offsetTop;
                    }
                    else {
                        left = this.getLeft();
                        top = this.getTop();
                    }
                    if (this.classList.contains('minskin')) {
                        top += 15;
                    }
                    game.animate.flame(left + this.offsetWidth / 2, top + this.offsetHeight - 30, time, 'rare');
                },
                $epic: function (time) {
                    time = time || 700;
                    game.addVideo('flame', this, 'epic');
                    var left, top;
                    if (game.chess) {
                        left = this.getLeft() - ui.arena.offsetLeft;
                        top = this.getTop() - ui.arena.offsetTop;
                    }
                    else {
                        left = this.getLeft();
                        top = this.getTop();
                    }
                    if (this.classList.contains('minskin')) {
                        top += 15;
                    }
                    game.animate.flame(left + this.offsetWidth / 2, top + this.offsetHeight - 30, time, 'epic');
                },
                $legend: function (time) {
                    time = time || 700;
                    game.addVideo('flame', this, 'legend');
                    var left, top;
                    if (game.chess) {
                        left = this.getLeft() - ui.arena.offsetLeft;
                        top = this.getTop() - ui.arena.offsetTop;
                    }
                    else {
                        left = this.getLeft();
                        top = this.getTop();
                    }
                    if (this.classList.contains('minskin')) {
                        top += 15;
                    }
                    game.animate.flame(left + this.offsetWidth / 2, top + this.offsetHeight - 30, time, 'legend');
                },
                $coin: function () {
                    game.broadcast(function (player) {
                        if (!lib.config.low_performance) {
                            player.$coin();
                        }
                    }, this);
                    game.addVideo('flame', this, 'coin');
                    var left = this.getLeft() - ui.arena.offsetLeft;
                    var top = this.getTop() - ui.arena.offsetTop;
                    if (this.classList.contains('minskin')) {
                        top += 15;
                    }
                    top -= 25;
                    game.animate.flame(left + this.offsetWidth / 2, top + this.offsetHeight - 30, 700, 'coin');
                },
                $dust: function () {
                    game.broadcast(function (player) {
                        if (!lib.config.low_performance) {
                            player.$dust();
                        }
                    }, this);
                    game.addVideo('flame', this, 'dust');
                    var left = this.getLeft() - ui.arena.offsetLeft;
                    var top = this.getTop() - ui.arena.offsetTop;
                    if (this.classList.contains('minskin')) {
                        top += 15;
                    }
                    top -= 25;
                    game.animate.flame(left + this.offsetWidth / 2, top + this.offsetHeight - 30, 700, 'dust');
                },
                $recover: function () {
                    game.addVideo('flame', this, 'recover');
                    var left, top;
                    if (game.chess) {
                        var rect = this.getBoundingClientRect();
                        left = rect.left;
                        top = rect.top;
                    }
                    else {
                        left = this.getLeft();
                        top = this.getTop();
                    }
                    game.animate.flame(left + this.offsetWidth / 2, top + this.offsetHeight - 30, 700, 'recover');
                },
                $fullscreenpop: function (str, nature, avatar, broadcast) {
                    if (broadcast !== false)
                        game.broadcast(function (player, str, nature, avatar) {
                            player.$fullscreenpop(str, nature, avatar);
                        }, this, str, nature, avatar);
                    game.addVideo('fullscreenpop', this, [str, nature, avatar]);
                    var node = ui.create.div('.damage');
                    if (avatar && this.node) {
                        if (avatar == 'vice') {
                            if (lib.character[this.name2]) {
                                avatar = this.node.avatar2;
                            }
                        }
                        else {
                            if (lib.character[this.name]) {
                                avatar = this.node.avatar;
                            }
                        }
                        if (!get.is.div(avatar)) {
                            avatar = false;
                        }
                    }
                    else {
                        avatar = false;
                    }
                    if (avatar) {
                        node.classList.add('fullscreenavatar');
                        ui.create.div('', ui.create.div(node));
                        // ui.create.div('',str.split('').join('<br>'),ui.create.div('.text.textbg',node));
                        ui.create.div('', '<div>' + str.split('').join('</div><br><div>') + '</div>', ui.create.div('.text', node));
                        node.firstChild.firstChild.style.backgroundImage = avatar.style.backgroundImage;
                        node.dataset.nature = nature || 'unknown';
                        var num = 0;
                        var nodes = node.lastChild.firstChild.querySelectorAll('div');
                        var interval = setInterval(function () {
                            if (num < nodes.length) {
                                nodes[num].classList.add('flashtext');
                                num++;
                            }
                            else {
                                clearInterval(interval);
                            }
                        }, 100);
                    }
                    else {
                        avatar = false;
                        node.innerHTML = str;
                        node.dataset.nature = nature || 'soil';
                    }
                    if (avatar) {
                        var rect1 = ui.window.getBoundingClientRect();
                        var rect2 = this.getBoundingClientRect();
                        var dx = Math.round(2 * rect2.left + rect2.width - rect1.width);
                        var dy = Math.round(2 * rect2.top + rect2.height - rect1.height);
                        node.style.transform = 'scale(0.5) translate(' + dx + 'px,' + dy + 'px)';
                    }
                    ui.window.appendChild(node);
                    ui.refresh(node);
                    if (avatar) {
                        node.style.transform = 'scale(1)';
                        node.style.opacity = 1;
                    }
                    else {
                        node.classList.add('damageadded');
                    }
                    setTimeout(function () {
                        node["delete"]();
                        node.style.transform = 'scale(1.5)';
                    }, avatar ? 1600 : 1000);
                },
                /**
                 * 伤害效果
                 * @param {(string|number)} num 伤害数值或者任意字符串
                 * @param {string} [nature='soil'] 伤害属性
                 * @param {?boolean} font 如果为true，`damage div`添加类`normal-font`；如果为false或未指定，使用伤害默认字体大小
                 * @param {?boolean} nobroadcast 如果为true或未指定，调用`game.broadcast`广播；如果为false，仅在本机
                 */
                $damagepop: function (num, nature, font, nobroadcast) {
                    if (typeof num == 'number' || typeof num == 'string') {
                        game.addVideo('damagepop', this, [num, nature, font]);
                        if (nobroadcast !== false)
                            game.broadcast(function (player, num, nature, font) {
                                player.$damagepop(num, nature, font);
                            }, this, num, nature, font);
                        var node = ui.create.div('.damage');
                        if (font) {
                            node.classList.add('normal-font');
                        }
                        if (typeof num == 'number' && num > 0) {
                            if (num == Infinity)
                                num = '+∞';
                            else
                                num = '+' + num;
                        }
                        else if (num == -Infinity)
                            num = '-∞';
                        node.innerHTML = num;
                        this.damagepopups.push(node);
                        node.dataset.nature = nature || 'soil';
                        if (this.damagepopups.length == 1) {
                            this.$damagepop();
                        }
                    }
                    else if (this.damagepopups.length) {
                        var node = this.damagepopups[0];
                        this.appendChild(node);
                        ui.refresh(node);
                        node.classList.add('damageadded');
                        node.listenTransition(function () {
                            setTimeout(function () {
                                node["delete"]();
                            }, 200);
                        });
                        // setTimeout(function(){
                        //     node.delete();
                        // },500);
                        var that = this;
                        setTimeout(function () {
                            that.damagepopups.shift();
                            that.$damagepop();
                        }, 500);
                    }
                },
                $damage: function (source) {
                    if (get.itemtype(source) == 'player') {
                        game.addVideo('damage', this, source.dataset.position);
                    }
                    else {
                        game.addVideo('damage', this);
                    }
                    game.broadcast(function (player, source) {
                        player.$damage(source);
                    }, this, source);
                    if (source && source != this && lib.config.damage_shake) {
                        var left, top;
                        if (source.getTop() == this.getTop()) {
                            left = 20;
                            top = 0;
                        }
                        else {
                            var ratio = (source.getLeft() - this.getLeft()) / (source.getTop() - this.getTop());
                            left = Math.abs(20 * ratio / Math.sqrt(1 + ratio * ratio));
                            top = Math.abs(20 / Math.sqrt(1 + ratio * ratio));
                        }
                        if (source.getLeft() - this.getLeft() > 0)
                            left = -left;
                        if (source.getTop() - this.getTop() > 0)
                            top = -top;
                        if (get.is.mobileMe(this)) {
                            if (this.classList.contains('linked')) {
                                this.node.avatar.style.transform = 'translate(' + left + 'px,' + top + 'px) rotate(-90deg)';
                                this.node.avatar2.style.transform = 'translate(' + left + 'px,' + top + 'px) rotate(-90deg)';
                            }
                            else {
                                this.node.avatar.style.transform = 'translate(' + left + 'px,' + top + 'px)';
                                this.node.avatar2.style.transform = 'translate(' + left + 'px,' + top + 'px)';
                            }
                        }
                        else if (this.classList.contains('linked') && get.is.newLayout()) {
                            this.style.transform = 'translate(' + left + 'px,' + top + 'px) rotate(-90deg)';
                        }
                        else if (this._chesstransform) {
                            this.style.transform = 'translate(' + (left + this._chesstransform[0]) + 'px,' + (top + this._chesstransform[1]) + 'px)';
                        }
                        else {
                            this.style.transform = 'translate(' + left + 'px,' + top + 'px)';
                        }
                    }
                    else {
                        var zoom1 = 0.9, zoom2 = 0.95;
                        if (arguments[1] == 'phase') {
                            zoom1 = 1.05;
                            zoom2 = 1.05;
                        }
                        if (get.is.mobileMe(this)) {
                            if (this.classList.contains('linked')) {
                                this.node.avatar.style.transform = 'scale(' + zoom1 + ') rotate(-90deg)';
                                this.node.avatar2.style.transform = 'scale(' + zoom1 + ') rotate(-90deg)';
                            }
                            else {
                                this.node.avatar.style.transform = 'scale(' + zoom1 + ')';
                                this.node.avatar2.style.transform = 'scale(' + zoom1 + ')';
                            }
                        }
                        else if (this.classList.contains('linked') && get.is.newLayout()) {
                            this.style.transform = 'scale(' + zoom2 + ') rotate(-90deg)';
                        }
                        else if (game.chess && this._chesstransform) {
                            this.style.transform = 'translate(' + this._chesstransform[0] + 'px,' + this._chesstransform[1] + 'px) scale(' + zoom2 + ')';
                        }
                        else {
                            this.style.transform = 'scale(' + zoom2 + ')';
                        }
                    }
                    this.queue();
                },
                $die: function () {
                    game.addVideo('die', this);
                    game.broadcast(function (player) {
                        player.$die();
                    }, this);
                    if (lib.config.die_move != 'off') {
                        this.$dieflip(lib.config.die_move);
                    }
                    if (lib.element.player.$dieAfter) {
                        lib.element.player.$dieAfter.call(this);
                    }
                },
                $dieflip: function (type) {
                    var top0 = ui.window.offsetHeight / 2;
                    var left0 = ui.window.offsetWidth / 2;
                    var ratio = (left0 - this.getLeft()) / (top0 - this.getTop());
                    var left = Math.abs(50 * ratio / Math.sqrt(1 + ratio * ratio));
                    var top = Math.abs(50 / Math.sqrt(1 + ratio * ratio));
                    if (left0 - this.getLeft() > 0)
                        left = -left;
                    if (top0 - this.getTop() > 0)
                        top = -top;
                    if (get.is.mobileMe(this)) {
                        left = -Math.random() * 5 - 10;
                        top = Math.random() * 5 + 10;
                    }
                    if (this._chesstransform) {
                        left += this._chesstransform[0];
                        top += this._chesstransform[1];
                    }
                    var transform = 'translate(' + left + 'px,' + top + 'px) ' +
                        'rotate(' + (Math.random() * 20 - 10) + 'deg) ';
                    if (type == 'flip') {
                        if (game.layout == 'long' || game.layout == 'long2') {
                            transform += 'rotateY(180deg)';
                        }
                        else {
                            transform += ((Math.random() - 0.5 < 0) ? 'rotateX(180deg)' : 'rotateY(180deg)');
                        }
                    }
                    if (get.is.mobileMe(this)) {
                        this.node.avatar.style.transform = transform;
                        this.node.avatar2.style.transform = transform;
                        this.style.transform = '';
                    }
                    else {
                        this.node.avatar.style.transform = '';
                        this.node.avatar2.style.transform = '';
                        this.style.transform = transform;
                    }
                    this.queue(false);
                },
                $phaseJudge: function (card) {
                    game.addVideo('phaseJudge', this, get.cardInfo(card));
                    var player = this;
                    var clone = player.$throw(card);
                    if (lib.config.low_performance && card && card.clone) {
                        var waitingForTransition = get.time();
                        _status.waitingForTransition = waitingForTransition;
                        card.clone.listenTransition(function () {
                            if (_status.waitingForTransition == waitingForTransition && _status.paused) {
                                game.resume();
                            }
                        });
                        game.pause();
                    }
                    else {
                        game.delay();
                    }
                }
            },
            /**
             * 卡牌方法，.card节点共用的方法（比如检测卡牌是否在区域内【hasPosition】和添加去除标签【add/removeGaintag】）
             * 卡牌
             * @namespace
             * @mixin
             */
            card: {
                /**
                 * 为本游戏牌添加gain标签名；本游戏牌`this.node.gaintag`也会更新
                 * @param {(string|Array<string>)} gaintag gain标签名，如果是一个数组，会**覆盖**本游戏牌的原gain标签数组为此数组，而不是向原数组中添加gain标签
                 */
                addGaintag: function (gaintag) {
                    if (Array.isArray(gaintag))
                        this.gaintag = gaintag.slice(0);
                    else
                        this.gaintag.add(gaintag);
                    var str = '';
                    for (var gi = 0; gi < this.gaintag.length; gi++) {
                        str += get.translation(this.gaintag[gi]);
                        if (gi < this.gaintag.length - 1)
                            str += ' ';
                    }
                    this.node.gaintag.innerHTML = str;
                },
                /**
                 * 为本游戏牌移除gain标签，或置空gain标签数组；本游戏牌`this.node.gaintag`也会更新
                 * @param {(string|true)} tag 要移除的gain标签名，如果此gain标签不在其中则不做任何处理；如果此值为true，置空gain标签数组
                 */
                removeGaintag: function (tag) {
                    if (tag === true) {
                        if (this.gaintag && this.gaintag.length || this.node.gaintag.innerHTML.length)
                            this.addGaintag([]);
                    }
                    else if (this.hasGaintag(tag)) {
                        this.gaintag.remove(tag);
                        this.addGaintag(this.gaintag);
                    }
                },
                /**
                 * 返回本游戏牌是否含有某一个gain标签
                 * @param {!string} tag 要搜索的gain标签
                 * @returns {!boolean}
                 */
                hasGaintag: function (tag) {
                    if (['ming_', 'an_'].contains(tag)) {
                        return this.gaintag && this.gaintag.filter(function (gain) {
                            return gain.indexOf(tag) == 0;
                        }).length;
                    }
                    else
                        return this.gaintag && this.gaintag.contains(tag);
                },
                /**
                 * 初始化
                 * 同时将info.global内的技能添加到{@link lib.skill.global}
                 * @function
                 * @param {(Array|Object)} card TODO
                 * @returns {!GameCores.GameObjects.Card} this self
                 */
                init: function (card) {
                    var _this = this;
                    if (Array.isArray(card)) {
                        if (card[2] == 'huosha') {
                            card[2] = 'sha';
                            card[3] = 'fire';
                        }
                        if (card[2] == 'leisha') {
                            card[2] = 'sha';
                            card[3] = 'thunder';
                        }
                        if (card[2] == 'kamisha') {
                            card[2] = 'sha';
                            card[3] = 'kami';
                        }
                        if (card[2] == 'icesha') {
                            card[2] = 'sha';
                            card[3] = 'ice';
                        }
                        if (card[2] == 'haisha') {
                            card[2] = 'sha';
                            card[3] = 'ocean';
                        }
                        if (card[2] == 'yamisha') {
                            card[2] = 'sha';
                            card[3] = 'yami';
                        }
                        if (card[2] == 'haitao') {
                            card[2] = 'tao';
                            card[3] = 'ocean';
                        }
                        if (card[2] == 'haijiu') {
                            card[2] = 'jiu';
                            card[3] = 'ocean';
                        }
                    }
                    else if (typeof card == 'object') {
                        card = [card.suit, card.number, card.name, card.nature];
                        card[5] = card.specialEffects;
                    }
                    var cardnum = card[1] || '';
                    if (parseInt(cardnum) == cardnum)
                        cardnum = parseInt(cardnum);
                    if ([1, 11, 12, 13, 14].contains(cardnum)) {
                        cardnum = { '1': 'A', '11': 'J', '12': 'Q', '13': 'K', '14': '★' }[cardnum];
                    }
                    if (!lib.card[card[2]]) {
                        lib.card[card[2]] = {};
                    }
                    var info = lib.card[card[2]];
                    if (info.global && !this.classList.contains('button')) {
                        if (Array.isArray(info.global)) {
                            while (info.global.length) {
                                game.addGlobalSkill(info.global.shift());
                            }
                        }
                        else if (typeof info.global == 'string') {
                            game.addGlobalSkill(info.global);
                        }
                        delete info.global;
                    }
                    if (this.name) {
                        this.classList.remove('epic');
                        this.classList.remove('legend');
                        this.classList.remove('gold');
                        this.classList.remove('unique');
                        this.style.background = '';
                        var subtype = get.subtype(this);
                        if (subtype) {
                            this.classList.remove(subtype);
                        }
                    }
                    if (info.epic) {
                        this.classList.add('epic');
                    }
                    else if (info.legend) {
                        this.classList.add('legend');
                    }
                    else if (info.gold) {
                        this.classList.add('gold');
                    }
                    else if (info.unique) {
                        this.classList.add('unique');
                    }
                    var bg = card[2];
                    if (info.cardimage) {
                        bg = info.cardimage;
                    }
                    var img = lib.card[bg].image;
                    if (img) {
                        if (img.indexOf('db:') == 0) {
                            img = img.slice(3);
                        }
                        else if (img.indexOf('ext:') != 0) {
                            img = null;
                        }
                    }
                    this.classList.remove('fullskin');
                    this.classList.remove('fullimage');
                    this.classList.remove('fullborder');
                    this.dataset.cardName = card[2];
                    this.dataset.cardType = info.type || '';
                    this.dataset.cardSubype = info.subtype || '';
                    this.dataset.cardMultitarget = info.multitarget ? '1' : '0';
                    this.node.name.dataset.nature = '';
                    this.node.info.classList.remove('red');
                    if (!lib.config.hide_card_image && lib.card[bg].fullskin) {
                        this.classList.add('fullskin');
                        if (img) {
                            if (img.indexOf('ext:') == 0) {
                                this.node.image.setBackgroundImage(img.replace(/ext:/, 'extension/'));
                            }
                            else {
                                this.node.image.setBackgroundDB(img);
                            }
                        }
                        else {
                            if (lib.card[bg].modeimage) {
                                this.node.image.setBackgroundImage('image/mode/' + lib.card[bg].modeimage + '/card/' + bg + '.png');
                            }
                            else {
                                if (bg.indexOf('rm_') == 0) {
                                    var bg = bg.slice(3);
                                    this.node.image.setBackgroundImage('image/replace/' + bg + '.png');
                                }
                                else if (lib.config.replace_image) {
                                    this.node.image.setBackgroundImage('image/replace/' + bg + '.png');
                                }
                                else {
                                    this.node.image.setBackgroundImage('image/card/' + bg + '.png');
                                }
                            }
                        }
                    }
                    else if (lib.card[bg].image == 'background') {
                        if (card[3])
                            this.node.background.setBackground(bg + '_' + card[3], 'card');
                        else
                            this.node.background.setBackground(bg, 'card');
                    }
                    else if (lib.card[bg].fullimage) {
                        this.classList.add('fullimage');
                        if (img) {
                            if (img.indexOf('ext:') == 0) {
                                this.setBackgroundImage(img.replace(/ext:/, 'extension/'));
                                this.style.backgroundSize = 'cover';
                            }
                            else {
                                this.setBackgroundDB(img);
                            }
                        }
                        else if (lib.card[bg].image) {
                            if (lib.card[bg].image.indexOf('character:') == 0) {
                                this.setBackground(lib.card[bg].image.slice(10), 'character');
                            }
                            else {
                                this.setBackground(lib.card[bg].image);
                            }
                        }
                        else {
                            var cardPack = lib.cardPack['mode_' + get.mode()];
                            if (Array.isArray(cardPack) && cardPack.contains(bg)) {
                                this.setBackground('mode/' + get.mode() + '/card/' + bg);
                            }
                            else {
                                this.setBackground('card/' + bg);
                            }
                        }
                    }
                    else if (lib.card[bg].fullborder) {
                        this.classList.add('fullborder');
                        if (lib.card[bg].fullborder == 'gold') {
                            this.node.name.dataset.nature = 'metalmm';
                        }
                        else if (lib.card[bg].fullborder == 'silver') {
                            this.node.name.dataset.nature = 'watermm';
                        }
                        if (!this.node.avatar) {
                            this.node.avatar = ui.create.div('.cardavatar');
                            this.insertBefore(this.node.avatar, this.firstChild);
                        }
                        if (!this.node.framebg) {
                            this.node.framebg = ui.create.div('.cardframebg');
                            this.node.framebg.dataset.auto = lib.card[bg].fullborder;
                            this.insertBefore(this.node.framebg, this.firstChild);
                        }
                        if (img) {
                            if (img.indexOf('ext:') == 0) {
                                this.node.avatar.setBackgroundImage(img.replace(/ext:/, 'extension/'));
                                this.node.avatar.style.backgroundSize = 'cover';
                            }
                            else {
                                this.node.avatar.setBackgroundDB(img);
                            }
                        }
                        else if (lib.card[bg].image) {
                            if (lib.card[bg].image.indexOf('character:') == 0) {
                                this.node.avatar.setBackground(lib.card[bg].image.slice(10), 'character');
                            }
                            else {
                                this.node.avatar.setBackground(lib.card[bg].image);
                            }
                        }
                        else {
                            var cardPack = lib.cardPack['mode_' + get.mode()];
                            if (Array.isArray(cardPack) && cardPack.contains(bg)) {
                                this.node.avatar.setBackground('mode/' + get.mode() + '/card/' + bg);
                            }
                            else {
                                this.node.avatar.setBackground('card/' + bg);
                            }
                        }
                    }
                    else if (lib.card[bg].image == 'card') {
                        if (card[3])
                            this.setBackground(bg + '_' + card[3], 'card');
                        else
                            this.setBackground(bg, 'card');
                    }
                    else if (typeof lib.card[bg].image == 'string' && !lib.card[bg].fullskin) {
                        if (img) {
                            if (img.indexOf('ext:') == 0) {
                                this.setBackgroundImage(img.replace(/ext:/, 'extension/'));
                                this.style.backgroundSize = 'cover';
                            }
                            else {
                                this.setBackgroundDB(img);
                            }
                        }
                        else {
                            this.setBackground(lib.card[bg].image);
                        }
                    }
                    else {
                        this.node.background.innerHTML = lib.translate[bg + '_cbg'] || lib.translate[bg + '_bg'] || get.translation(bg)[0];
                        // this.node.background.style.fontFamily=lib.config.card_font;
                        if (this.node.background.innerHTML.length > 1)
                            this.node.background.classList.add('tight');
                        else
                            this.node.background.classList.remove('tight');
                    }
                    if ((bg == 'wuxingpan' || !lib.card[bg].fullborder) && this.node.avatar && this.node.framebg) {
                        this.node.avatar.remove();
                        this.node.framebg.remove();
                        delete this.node.avatar;
                        delete this.node.framebg;
                    }
                    if (info.noname && !this.classList.contains('button')) {
                        this.node.name.style.display = 'none';
                    }
                    if (info.color) {
                        this.style.color = info.color;
                    }
                    if (info.textShadow) {
                        this.style.textShadow = info.textShadow;
                    }
                    if (info.opacity) {
                        this.node.info.style.opacity = info.opacity;
                        this.node.name.style.opacity = info.opacity;
                    }
                    if (info.modinfo) {
                        this.node.info.innerHTML = info.modinfo;
                    }
                    else {
                        this.node.info.innerHTML = get.translation(card[0]) + '<span> </span>' + cardnum;
                    }
                    if (info.addinfo) {
                        if (!this.node.addinfo) {
                            this.node.addinfo = ui.create.div('.range', this);
                        }
                        this.node.addinfo.innerHTML = info.addinfo;
                    }
                    else if (this.node.addinfo) {
                        this.node.addinfo.remove();
                        delete this.node.addinfo;
                    }
                    if (card[0] == 'heart' || card[0] == 'diamond') {
                        this.node.info.classList.add('red');
                    }
                    this.node.name.innerHTML = '';
                    this.node.image.className = 'image';
                    var name = get.translation(card[2]);
                    if (name.length == 1) {
                        if (card[3] == 'fire') {
                            name = '火' + name;
                            this.node.image.classList.add('fire');
                        }
                        else if (card[3] == 'thunder') {
                            name = '雷' + name;
                            this.node.image.classList.add('thunder');
                        }
                        else if (card[3] == 'kami') {
                            name = '神' + name;
                            this.node.image.classList.add('kami');
                        }
                        else if (card[3] == 'ice') {
                            name = '冰' + name;
                            this.node.image.classList.add('ice');
                        }
                        else if (card[3] == 'ocean') {
                            name = '海' + name;
                            this.node.image.classList.add('ocean');
                        }
                        else if (card[3] == 'yami') {
                            name = '暗' + name;
                            this.node.image.classList.add('yami');
                        }
                    }
                    else {
                        if (card[3] == 'fire') {
                            this.node.image.classList.add('fire');
                        }
                        else if (card[3] == 'thunder') {
                            this.node.image.classList.add('thunder');
                        }
                        else if (card[3] == 'kami') {
                            this.node.image.classList.add('kami');
                        }
                        else if (card[3] == 'ice') {
                            this.node.image.classList.add('ice');
                        }
                        else if (card[3] == 'ocean') {
                            name = name.replace(name.charAt(0), '海');
                            this.node.image.classList.add('ocean');
                        }
                        else if (card[3] == 'yami') {
                            name = name.replace(name.charAt(0), '暗');
                            this.node.image.classList.add('yami');
                        }
                    }
                    for (var i = 0; i < name.length; i++) {
                        this.node.name.innerHTML += name[i] + '<br/>';
                    }
                    if (name.length >= 5) {
                        this.node.name.classList.add('long');
                        if (name.length >= 7) {
                            this.node.name.classList.add('longlong');
                        }
                    }
                    this.node.name2.innerHTML = get.translation(card[0]) + cardnum + ' ' + name;
                    this.suit = card[0];
                    this.number = parseInt(card[1]) || 0;
                    this.name = card[2];
                    this.classList.add('card');
                    if (card[3]) {
                        if (lib.nature.contains(card[3]))
                            this.nature = card[3];
                        this.classList.add(card[3]);
                    }
                    else if (this.nature) {
                        this.classList.remove(this.nature);
                        delete this.nature;
                    }
                    if (info.subtype)
                        this.classList.add(info.subtype);
                    if (this.inits) {
                        for (var i = 0; i < lib.element.card.inits.length; i++) {
                            lib.element.card.inits[i](this);
                        }
                    }
                    if (typeof info.init == 'function')
                        info.init();
                    this.node.range.innerHTML = '';
                    switch (get.subtype(this)) {
                        case 'equip1':
                            var added = false;
                            if (lib.card[this.name] && lib.card[this.name].distance) {
                                var dist = lib.card[this.name].distance;
                                if (dist.attackFrom) {
                                    added = true;
                                    this.node.range.innerHTML = '范围: ' + (-dist.attackFrom + 1);
                                }
                            }
                            if (!added) {
                                this.node.range.innerHTML = '范围: 1';
                            }
                            break;
                        case 'equip3':
                            if (info.distance && info.distance.globalTo) {
                                this.node.range.innerHTML = '防御: ' + info.distance.globalTo;
                                this.node.name2.innerHTML += '+';
                            }
                            break;
                        case 'equip4':
                            if (info.distance && info.distance.globalFrom) {
                                this.node.range.innerHTML = '进攻: ' + (-info.distance.globalFrom);
                                this.node.name2.innerHTML += '-';
                            }
                            break;
                    }
                    var specialEffects = [];
                    if (Array.isArray(card[5])) {
                        specialEffects.addArray(card[5]);
                    }
                    if (this.node.image.parentNode.classList.length > 0)
                        this.node.image.parentNode.classList.forEach(function (element) {
                            if (element.indexOf("card_") != -1) {
                                _this.node.image.parentNode.classList.remove(element);
                            }
                        });
                    if (specialEffects.length) {
                        for (var i = 0; i < specialEffects.length; i++) {
                            this.node.image.parentNode.classList.add(specialEffects[i]);
                        }
                        this.specialEffects = specialEffects;
                    }
                    if (_status.connectMode && !game.online && lib.cardOL && !this.cardid) {
                        this.cardid = get.id();
                        lib.cardOL[this.cardid] = this;
                    }
                    if (!_status.connectMode && !_status.video) {
                        this.cardid = get.id();
                    }
                    var tags = [];
                    if (Array.isArray(card[4])) {
                        tags.addArray(card[4]);
                    }
                    if (this.cardid) {
                        if (!_status.cardtag) {
                            _status.cardtag = {};
                        }
                        for (var i in _status.cardtag) {
                            if (_status.cardtag[i].contains(this.cardid)) {
                                tags.add(i);
                            }
                        }
                        if (tags.length) {
                            var tagstr = ' <span class="cardtag">';
                            for (var i = 0; i < tags.length; i++) {
                                var tag = tags[i];
                                if (!_status.cardtag[tag]) {
                                    _status.cardtag[tag] = [];
                                }
                                _status.cardtag[tag].add(this.cardid);
                                tagstr += lib.translate[tag + '_tag'];
                            }
                            tagstr += '</span>';
                            this.node.range.innerHTML += tagstr;
                        }
                    }
                    return this;
                },
                /**
                 * 选中状态，更新本游戏牌的位置；仅供`ui.me`中的手牌使用的函数(本机)
                 * @param {?boolean} [bool] 如果为true，translate`translateY(-20px)`
                 * @param {?number} [delay] 延迟`delay`(ms)时长，再更新本游戏牌位置；如果未指定或为0，不调用延迟函数，立即更新
                 */
                updateTransform: function (bool, delay) {
                    if (delay) {
                        var that = this;
                        setTimeout(function () {
                            that.updateTransform(that.classList.contains('selected'));
                        }, delay);
                    }
                    else {
                        if (_status.event.player != game.me)
                            return;
                        if (this._transform && this.parentNode && this.parentNode.parentNode &&
                            this.parentNode.parentNode.parentNode == ui.me &&
                            (!_status.mousedown || _status.mouseleft) &&
                            (!this.parentNode.parentNode.classList.contains('scrollh') || (game.layout == 'long2' || game.layout == 'nova'))) {
                            if (bool) {
                                this.style.transform = this._transform + ' translateY(-20px)';
                            }
                            else {
                                this.style.transform = this._transform || '';
                            }
                        }
                    }
                },
                aiexclude: function () {
                    _status.event._aiexclude.add(this);
                },
                getSource: function (name) {
                    if (this.name == name)
                        return true;
                    var info = lib.card[this.name];
                    if (info && Array.isArray(info.source)) {
                        return info.source.contains(name);
                    }
                    return false;
                },
                moveDelete: function (player) {
                    this.fixed = true;
                    if (!this._listeningEnd || this._transitionEnded) {
                        this.moveTo(player);
                        var that = this;
                        setTimeout(function () {
                            that["delete"]();
                        }, 200);
                    }
                    else {
                        this._onEndMoveDelete = player;
                    }
                },
                moveTo: function (player) {
                    this.fixed = true;
                    var dx, dy;
                    if (this.classList.contains('center')) {
                        var nx = [50, -52];
                        var ny = [50, -52];
                        nx = nx[0] * ui.arena.offsetWidth / 100 + nx[1];
                        ny = ny[0] * ui.arena.offsetHeight / 100 + ny[1];
                        dx = player.getLeft() + player.offsetWidth / 2 - 52 - nx;
                        dy = player.getTop() + player.offsetHeight / 2 - 52 - ny;
                    }
                    else {
                        this.style.left = this.offsetLeft + 'px';
                        this.style.top = this.offsetTop + 'px';
                        dx = player.getLeft() + player.offsetWidth / 2 - 52 - this.offsetLeft;
                        dy = player.getTop() + player.offsetHeight / 2 - 52 - this.offsetTop;
                    }
                    if (get.is.mobileMe(player)) {
                        dx += get.cardOffset();
                        if (ui.arena.classList.contains('oblongcard')) {
                            dy -= 16;
                        }
                    }
                    if (this.style.transform && this.style.transform != 'none' && this.style.transform.indexOf('translate') == -1) {
                        this.style.transform += ' translate(' + dx + 'px,' + dy + 'px)';
                    }
                    else {
                        this.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
                    }
                    return this;
                },
                copy: function () {
                    var node = this.cloneNode(true);
                    node.style.transform = '';
                    node.name = this.name;
                    node.suit = this.suit;
                    node.number = this.number;
                    node.classList.remove('hidden');
                    node.classList.remove('start');
                    node.classList.remove('thrown');
                    node.classList.remove('selectable');
                    node.classList.remove('selected');
                    node.classList.remove('removing');
                    node.classList.remove('drawinghidden');
                    node.classList.remove('glows');
                    node.node = {
                        name: node.querySelector('.name'),
                        info: node.querySelector('.info'),
                        intro: node.querySelector('.intro'),
                        background: node.querySelector('.background'),
                        image: node.querySelector('.image'),
                        gaintag: node.querySelector('.gaintag')
                    };
                    node.node.gaintag.innerHTML = '';
                    var clone = true;
                    var position;
                    for (var i = 0; i < arguments.length; i++) {
                        if (typeof arguments[i] == 'string')
                            node.classList.add(arguments[i]);
                        else if (get.objtype(arguments[i]) == 'div')
                            position = arguments[i];
                        else if (typeof arguments[i] == 'boolean')
                            clone = arguments[i];
                    }
                    node.moveTo = lib.element.card.moveTo;
                    node.moveDelete = lib.element.card.moveDelete;
                    if (clone)
                        this.clone = node;
                    if (position)
                        position.appendChild(node);
                    return node;
                },
                uncheck: function (skill) {
                    if (skill)
                        this._uncheck.add(skill);
                    this.classList.add('uncheck');
                },
                recheck: function (skill) {
                    if (skill)
                        this._uncheck.remove(skill);
                    else
                        this._uncheck.length = 0;
                    if (this._uncheck.length == 0)
                        this.classList.remove('uncheck');
                },
                discard: function (bool) {
                    if (!this.destroyed) {
                        ui.discardPile.appendChild(this);
                    }
                    this.fix();
                    this.classList.remove('glow');
                    if (bool === false) {
                        ui.cardPile.insertBefore(this, ui.cardPile.childNodes[Math.floor(Math.random() * ui.cardPile.childNodes.length)]);
                    }
                    else {
                        if (_status.discarded) {
                            _status.discarded.add(this);
                        }
                    }
                },
                hasTag: function (tag) {
                    if (this.cardid && _status.cardtag && _status.cardtag[tag] && _status.cardtag[tag].contains(this.cardid)) {
                        return true;
                    }
                    return false;
                },
                /**
                 * 判断本卡牌是否在某角色的区域中
                 * @returns {!boolean}
                 */
                hasPosition: function () {
                    return ['h', 'e', 'j'].contains(get.position(this));
                },
                /**
                 * 判断本卡牌是否在牌堆或弃牌堆中
                 * @returns {!boolean}
                 */
                isInPile: function () {
                    return ['c', 'd'].contains(get.position(this));
                }
            },
            /**
             * 按钮方法
             * @name element.button
             * @type {!Object}
             */
            button: {
                exclude: function () {
                    if (_status.event.excludeButton == undefined) {
                        _status.event.excludeButton = [];
                    }
                    _status.event.excludeButton.add(this);
                }
            },
            /**
             * 事件方法，游戏进行过程中每一个事件所具有的方法（比如设置事件内容【setContent】和停止事件【finish】）
             * 事件
             * @namespace
             * @mixin
             */
            event: {
                changeToZero: function () {
                    this.num = 0;
                    this.numFixed = true;
                },
                /**
                 * 结束事件
                 * @function
                 */
                finish: function () {
                    this.finished = true;
                },
                /**
                 * 取消事件
                 * 直接结束事件，也跳过子事件的触发和执行
                 * @function
                 * @param {?boolean} all 见{@link lib.element.event.untrigger}
                 * @param {?GameCores.GameObjects.Player} player 见{@link lib.element.event.untrigger}
                 * @param {?string} notrigger 如果为'notrigger'则**不尝试触发**`${this.name}Cancelled`
                 */
                cancel: function (arg1, arg2, notrigger) {
                    this.untrigger.call(this, arguments); //??
                    this.finish();
                    if (notrigger != 'notrigger') {
                        this.trigger(this.name + 'Cancelled');
                        if (this.player && lib.phaseName.contains(this.name))
                            this.player.getHistory('skipped').add(this.name);
                    }
                },
                /**
                 * 转移状态
                 * @function
                 * @param {!number} step 新状态
                 */
                goto: function (step) {
                    this.step = step - 1;
                },
                /**
                 * 自环(循环)
                 * @function
                 */
                redo: function () {
                    this.step--;
                },
                setHiddenSkill: function (skill) {
                    if (!this.player)
                        return this;
                    var hidden = this.player.hiddenSkills.slice(0);
                    game.expandSkills(hidden);
                    if (hidden.contains(skill))
                        this.set('hsskill', skill);
                    return this;
                },
                /**
                 * 链式函数，为Event的属性赋值
                 * 赋值`this[key] = value`，同时绑定`this._set.push([key, value])`
                 * @function lib.element.event.set
                 * @param {!string} key 键名
                 * @param {?Object} value 键值
                 * @returns {GameCores.GameObjects.Event} this self
                 */
                /**
                 * 为Event的属性赋值
                 * 对每个键值对，调用{@link lib.element.event.set}绑定到Event上
                 * @function lib.element.event.set
                 * @variation 2
                 * @param {!Array<Array>} pairs 要设置键值对数组
                 * @param {!string} pairs[].'[0]' 键名
                 * @param {?Object} pairs[].'[1]' 键值
                 */
                set: function (key, value) {
                    if (arguments.length == 1 && Array.isArray(arguments[0])) {
                        for (var i = 0; i < arguments[0].length; i++) {
                            if (Array.isArray(arguments[0][i])) {
                                this.set(arguments[0][i][0], arguments[0][i][1]);
                            }
                        }
                    }
                    else {
                        if (typeof key != 'string') {
                            console.log('warning: using non-string object as event key');
                            console.log(key, value);
                            console.log(_status.event);
                        }
                        this[key] = value;
                        this._set.push([key, value]);
                    }
                    return this;
                },
                /**
                 * 设置事件的状态机
                 * @function
                 * @param {?GameCores.Bases.StateMachine} stateMachine 状态机，如果未指定则不设置
                 * @returns {GameCores.Bases.Event} this self
                 */
                /**
                 * 设置事件的状态机
                 * @param {?string} name 状态机名，使用`lib.element.content[name]`作为事件的状态机，见{@link lib.element.content}
                 * @returns {GameCores.Bases.Event} this self
                 */
                setContent: function (name) {
                    if (typeof name == 'function') {
                        this.content = lib.init.parse(name);
                    }
                    else {
                        if (!lib.element.content[name]._parsed) {
                            lib.element.content[name] = lib.init.parse(lib.element.content[name]);
                            lib.element.content[name]._parsed = true;
                        }
                        this.content = lib.element.content[name];
                    }
                    return this;
                },
                getLogv: function () {
                    for (var i = 1; i <= 3; i++) {
                        var event = this.getParent(i);
                        if (event && event.logvid)
                            return event.logvid;
                    }
                    return null;
                },
                send: function () {
                    this.player.send(function (name, args, set, event, skills) {
                        game.me.applySkills(skills);
                        var next = game.me[name].apply(game.me, args);
                        for (var i = 0; i < set.length; i++) {
                            next.set(set[i][0], set[i][1]);
                        }
                        if (next._backupevent) {
                            next.backup(next._backupevent);
                        }
                        next._modparent = event;
                        game.resume();
                    }, this.name, this._args || [], this._set, get.stringifiedResult(this.parent, 3), get.skillState(this.player));
                    this.player.wait();
                    game.pause();
                },
                /**
                 * 选择结束，清空事件的选择(card，target, skill)
                 */
                resume: function () {
                    delete this._cardChoice;
                    delete this._targetChoice;
                    delete this._skillChoice;
                },
                /**
                 * 获取本事件的指定父事件
                 * @function
                 * @param {(string|number)} [level] 指定父事件的名称 | 为number值时表示重复取level次_parent
                 * @param {?boolean} [forced] 为true表示强制返回：获取不到指定父事件时返回{null}
                 * @returns {?GameCores.Bases.Event} 通过_parent（_modparent）属性获取本事件的父事件，若父事件不满足要求或重复次数少于level，则取父事件的_parent，依此类推直至获取到满足条件的父事件
                 */
                getParent: function (level, forced) {
                    var parent;
                    if (this._modparent && game.online) {
                        parent = this._modparent;
                    }
                    else {
                        parent = this.parent;
                    }
                    var toreturn = {};
                    if (typeof level == 'string' && forced == true) {
                        toreturn = null;
                    }
                    if (!parent)
                        return toreturn;
                    if (typeof level == 'number') {
                        for (var i = 1; i < level; i++) {
                            if (!parent)
                                return toreturn;
                            parent = parent.parent;
                        }
                    }
                    else if (typeof level == 'string') {
                        for (var i = 0; i < 20; i++) {
                            if (!parent)
                                return toreturn;
                            if (parent.name == level)
                                return parent;
                            parent = parent.parent;
                        }
                        if (!parent)
                            return toreturn;
                    }
                    if (toreturn === null) {
                        return null;
                    }
                    return parent;
                },
                /**
                 * 获取本事件的触发事件
                 * @function
                 * @returns {?GameCores.Bases.Event} 本事件的触发事件，如果本事件没有触发事件，返回undefined/null
                 */
                getTrigger: function () {
                    return this.getParent()._trigger;
                },
                /**
                 * 返回本事件的随机值，如果已经有随机值就返回之前的随机值；未调用该函数时，随机值`this._rand`默认未指定(undefined)
                 * @returns {!number} this._rand
                 */
                getRand: function (name) {
                    if (name) {
                        if (!this._rand_map)
                            this._rand_map = {};
                        if (!this._rand_map[name])
                            this._rand_map[name] = Math.random();
                        return this._rand_map[name];
                    }
                    if (!this._rand)
                        this._rand = Math.random();
                    return this._rand;
                },
                /**
                 * 创建不可触发的`${this.name}Inserted`事件，立即执行
                 * @function
                 * @param {?GameCores.Bases.StateMachine} stateMachine 状态机
                 * @param {?Object<string, Object>} map 键值对对象
                 * @returns {!GameCores.Bases.Event} 创建的事件
                 */
                insert: function (func, map) {
                    var next = game.createEvent(this.name + 'Inserted', false, this);
                    next.setContent(func);
                    for (var i in map) {
                        next.set(i, map[i]);
                    }
                    return next;
                },
                /**
                 * 创建不可触发的`${this.name}Inserted`事件，于本事件结算后执行
                 * @function
                 * @param {?GameCores.Bases.StateMachine} stateMachine 状态机
                 * @param {?Object<string, Object>} map 键值对对象
                 * @returns {!GameCores.Bases.Event} 创建的事件
                 */
                insertAfter: function (func, map) {
                    var next = game.createEvent(this.name + 'Inserted', false, { next: [] });
                    this.after.push(next);
                    next.setContent(func);
                    for (var i in map) {
                        next.set(i, map[i]);
                    }
                    return next;
                },
                /**
                 * 备份
                 * @function
                 * @param {?string} skill 技能ID
                 */
                backup: function (skill) {
                    this._backup = {
                        filterButton: this.filterButton,
                        selectButton: this.selectButton,
                        filterTarget: this.filterTarget,
                        selectTarget: this.selectTarget,
                        filterCard: this.filterCard,
                        selectCard: this.selectCard,
                        position: this.position,
                        forced: this.forced,
                        fakeforce: this.fakeforce,
                        _aiexclude: this._aiexclude,
                        complexSelect: this.complexSelect,
                        complexCard: this.complexCard,
                        complexTarget: this.complexTarget,
                        _cardChoice: this._cardChoice,
                        _targetChoice: this._targetChoice,
                        _skillChoice: this._skillChoice,
                        ai1: this.ai1,
                        ai2: this.ai2
                    };
                    if (skill) {
                        var info = get.info(skill);
                        this.skill = skill;
                        this._aiexclude = [];
                        if (typeof info.viewAs == 'function') {
                            if (info.filterButton != undefined)
                                this.filterButton = get.filter(info.filterButton);
                            if (info.selectButton != undefined)
                                this.selectButton = info.selectButton;
                            if (info.filterTarget != undefined)
                                this.filterTarget = get.filter(info.filterTarget);
                            if (info.selectTarget != undefined)
                                this.selectTarget = info.selectTarget;
                            if (info.filterCard != undefined) {
                                if (info.ignoreMod)
                                    this.ignoreMod = true;
                                this.filterCard2 = get.filter(info.filterCard);
                                this.filterCard = function (card, player, event) {
                                    var evt = event || _status.event;
                                    if (!evt.ignoreMod && player) {
                                        var mod = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
                                        if (mod != 'unchanged')
                                            return mod;
                                        if (evt._backup && evt._backup.filterCard) {
                                            var cardx2 = lib.skill[evt.skill].viewAs(ui.selected.cards.concat([card]), player);
                                            if (get.is.object(cardx2)) {
                                                var cardx = get.autoViewAs(cardx2, ui.selected.cards.concat([card]));
                                                if (!get.filter(evt._backup.filterCard)(cardx, player, evt))
                                                    return false;
                                            }
                                        }
                                    }
                                    return get.filter(evt.filterCard2).apply(this, arguments);
                                };
                            }
                            if (info.selectCard != undefined)
                                this.selectCard = info.selectCard;
                            if (info.position != undefined)
                                this.position = info.position;
                            if (info.forced != undefined)
                                this.forced = info.forced;
                            if (info.complexSelect != undefined)
                                this.complexSelect = info.complexSelect;
                            if (info.complexCard != undefined)
                                this.complexCard = info.complexCard;
                            if (info.complexTarget != undefined)
                                this.complexTarget = info.complexTarget;
                            if (info.ai1 != undefined)
                                this.ai1 = info.ai1;
                            if (info.ai2 != undefined)
                                this.ai2 = info.ai2;
                        }
                        else if (info.viewAs) {
                            if (info.filterButton != undefined)
                                this.filterButton = get.filter(info.filterButton);
                            if (info.selectButton != undefined)
                                this.selectButton = info.selectButton;
                            if (info.filterTarget != undefined)
                                this.filterTarget = get.filter(info.filterTarget);
                            if (info.selectTarget != undefined)
                                this.selectTarget = info.selectTarget;
                            if (info.filterCard != undefined) {
                                if (info.ignoreMod)
                                    this.ignoreMod = true;
                                this.filterCard2 = get.filter(info.filterCard);
                                this.filterCard = function (card, player, event) {
                                    var evt = event || _status.event;
                                    if (!evt.ignoreMod && player) {
                                        var mod = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
                                        if (mod != 'unchanged')
                                            return mod;
                                        if (evt._backup && evt._backup.filterCard) {
                                            var cardx = get.autoViewAs(lib.skill[evt.skill].viewAs, ui.selected.cards.concat([card]));
                                            if (!get.filter(evt._backup.filterCard)(cardx, player, evt))
                                                return false;
                                        }
                                        ;
                                    }
                                    return get.filter(evt.filterCard2).apply(this, arguments);
                                };
                            }
                            if (info.selectCard != undefined)
                                this.selectCard = info.selectCard;
                            if (info.position != undefined)
                                this.position = info.position;
                            if (info.forced != undefined)
                                this.forced = info.forced;
                            if (info.complexSelect != undefined)
                                this.complexSelect = info.complexSelect;
                            if (info.complexCard != undefined)
                                this.complexCard = info.complexCard;
                            if (info.complexTarget != undefined)
                                this.complexTarget = info.complexTarget;
                            if (info.ai1 != undefined)
                                this.ai1 = info.ai1;
                            if (info.ai2 != undefined)
                                this.ai2 = info.ai2;
                        }
                        else {
                            this.filterButton = info.filterButton ? get.filter(info.filterButton) : undefined;
                            this.selectButton = info.selectButton;
                            this.filterTarget = info.filterTarget ? get.filter(info.filterTarget) : undefined;
                            this.selectTarget = info.selectTarget;
                            this.filterCard = info.filterCard ? get.filter(info.filterCard) : undefined;
                            this.selectCard = info.selectCard;
                            this.position = info.position;
                            this.forced = info.forced;
                            this.complexSelect = info.complexSelect;
                            this.complexCard = info.complexCard;
                            this.complexTarget = info.complexTarget;
                            if (info.ai1 != undefined)
                                this.ai1 = info.ai1;
                            if (info.ai2 != undefined)
                                this.ai2 = info.ai2;
                        }
                        delete this.fakeforce;
                    }
                    delete this._cardChoice;
                    delete this._targetChoice;
                    delete this._skillChoice;
                },
                restore: function () {
                    if (this._backup) {
                        this.filterButton = this._backup.filterButton;
                        this.selectButton = this._backup.selectButton;
                        this.filterTarget = this._backup.filterTarget;
                        this.selectTarget = this._backup.selectTarget;
                        this.filterCard = this._backup.filterCard;
                        this.selectCard = this._backup.selectCard;
                        this.position = this._backup.position;
                        this.forced = this._backup.forced;
                        this.fakeforce = this._backup.fakeforce;
                        this._aiexclude = this._backup._aiexclude;
                        this.complexSelect = this._backup.complexSelect;
                        this.complexCard = this._backup.complexCard;
                        this.complexTarget = this._backup.complexTarget;
                        this.ai1 = this._backup.ai1;
                        this.ai2 = this._backup.ai2;
                        this._cardChoice = this._backup._cardChoice;
                        this._targetChoice = this._backup._targetChoice;
                        this._skillChoice = this._backup._skillChoice;
                    }
                    delete this.skill;
                    delete this.ignoreMod;
                    delete this.filterCard2;
                },
                isMine: function () {
                    return (this.player && this.player == game.me && !_status.auto && !this.player.isMad() && !game.notMe);
                },
                isOnline: function () {
                    return (this.player && this.player.isOnline());
                },
                notLink: function () {
                    return this.getParent().name != '_lianhuan' && this.getParent().name != '_lianhuan2';
                },
                isPhaseUsing: function (player) {
                    var evt = this.getParent('phaseUse');
                    if (!evt || evt.name != 'phaseUse')
                        return false;
                    return !player || player == evt.player;
                },
                addTrigger: function (skill, player) {
                    if (!player)
                        return;
                    var evt = this;
                    while (true) {
                        var evt = evt.getParent('arrangeTrigger');
                        if (!evt || evt.name != 'arrangeTrigger' || !evt.map)
                            return;
                        if (typeof skill == 'string')
                            skill = [skill];
                        game.expandSkills(skill);
                        var filter = function (content) {
                            if (typeof content == 'string')
                                return content == triggername;
                            return content.contains(triggername);
                        };
                        var trigger = evt._trigger;
                        var triggername = evt.triggername;
                        var map = false;
                        if (evt.doing && evt.doing.player == player)
                            map = evt.doing;
                        else {
                            for (var i = 0; i < evt.map.length; i++) {
                                if (evt.map[i].player == player) {
                                    map = evt.map[i];
                                    break;
                                }
                            }
                        }
                        if (!map)
                            return;
                        var func = function (skillx) {
                            var info = lib.skill[skillx];
                            var bool = false;
                            for (var i in info.trigger) {
                                if (filter(info.trigger[i])) {
                                    bool = true;
                                    break;
                                }
                            }
                            if (!bool)
                                return;
                            var priority = 0;
                            if (info.priority) {
                                priority = info.priority * 100;
                            }
                            if (info.silent) {
                                priority++;
                            }
                            if (info.equipSkill)
                                priority -= 25;
                            if (info.cardSkill)
                                priority -= 50;
                            if (info.ruleSkill)
                                priority -= 75;
                            var toadd = [skillx, player, priority];
                            if (map.list2) {
                                for (var i = 0; i < map.list2.length; i++) {
                                    if (map.list2[i][0] == toadd[0] && map.list2[i][1] == toadd[1])
                                        return;
                                }
                            }
                            ;
                            for (var i = 0; i < map.list.length; i++) {
                                if (map.list[i][0] == toadd[0] && map.list[i][1] == toadd[1])
                                    return;
                            }
                            map.list.add(toadd);
                            map.list.sort(function (a, b) {
                                return b[2] - a[2];
                            });
                        };
                        for (var j = 0; j < skill.length; j++) {
                            func(skill[j]);
                        }
                    }
                },
                /**
                 * 尝试触发子事件
                 * @param {!string} name trigger name
                 */
                trigger: function (name) {
                    //??
                    if (_status.video)
                        return;
                    //如果是游戏开始前，分发手牌时，一切因获得/失去牌而触发的技能不会触发
                    if ((this.name === 'gain' || this.name === 'lose') && !_status.gameDrawed)
                        return;
                    //分发手牌结束 [recommend] why here//??
                    /**
                     * 如果为true，表示游戏开始前分发手牌结束；如果未指定，则游戏未开始且手牌没有分发完成
                     * @name _status.gameDrawed
                     * @type {?true}
                     */
                    if (name === 'gameDrawEnd')
                        _status.gameDrawed = true;
                    if (name === 'gameStart') {
                        if (_status.brawl && _status.brawl.gameStart) {
                            _status.brawl.gameStart();
                        }
                        if (lib.config.show_cardpile) {
                            ui.cardPileButton.style.display = '';
                        }
                        /**
                         * 如果为true，表示游戏已经开始；如果未指定，则游戏还在分发武将和手牌，尚未开始
                         * @name _status.gameStarted
                         * @type {?true}
                         */
                        _status.gameStarted = true;
                        game.showHistory();
                    }
                    //通过hookmap优化性能，但是hookmap不向下兼容；如果处于兼容模式，则忽略hookmap优化
                    if (!lib.hookmap[name] && !lib.config.compatiblemode)
                        return;
                    //?? 是否需要判空?
                    if (!game.players || !game.players.length)
                        return;
                    var event = this;
                    //?? 是否可以简化?
                    //??
                    var start = false;
                    var starts = [_status.currentPhase, event.source, event.player, game.me, game.players[0]];
                    for (var i = 0; i < starts.length; i++) {
                        if (get.itemtype(starts[i]) == 'player') {
                            start = starts[i];
                            break;
                        }
                    }
                    if (!start)
                        return;
                    //确保start角色在游戏之中
                    if (!game.players.contains(start)) {
                        start = game.findNext(start);
                    }
                    var list = [];
                    var list2 = [];
                    var mapx = [];
                    var allbool = false;
                    var roles = ['player', 'source', 'target'];
                    var listAdded;
                    var mapxx;
                    var addList = function (skill, player) {
                        if (listAdded[skill])
                            return;
                        if (player.forbiddenSkills[skill])
                            return;
                        if (player.disabledSkills[skill])
                            return;
                        listAdded[skill] = true;
                        var info = lib.skill[skill];
                        var num = 0;
                        if (info.priority) {
                            num = info.priority * 100;
                        }
                        if (info.silent) {
                            num++;
                        }
                        if (info.equipSkill)
                            num -= 30;
                        if (info.ruleSkill)
                            num -= 30;
                        if (info.firstDo) {
                            list.push([skill, player, num]);
                            list.sort(function (a, b) {
                                return b[2] - a[2];
                            });
                            allbool = true;
                            return;
                        }
                        else if (info.lastDo) {
                            list2.push([skill, player, num]);
                            list2.sort(function (a, b) {
                                return b[2] - a[2];
                            });
                            allbool = true;
                            return;
                        }
                        mapxx.list.push([skill, player, num]);
                        mapxx.list.sort(function (a, b) {
                            return b[2] - a[2];
                        });
                        allbool = true;
                    };
                    var totalPopulation = game.players.length + game.dead.length + 1;
                    var player = start;
                    var globalskill = 'global_' + name;
                    var map = _status.connectMode ? lib.playerOL : game.playerMap;
                    for (var iwhile = 0; iwhile < totalPopulation; iwhile++) {
                        var id = player.playerid;
                        var mapxx = {
                            player: player,
                            list: [],
                            list2: []
                        };
                        listAdded = {};
                        var notemp = player.skills.slice(0);
                        for (var j in player.additionalSkills) {
                            if (j.indexOf('hidden:') != 0)
                                notemp.addArray(player.additionalSkills[j]);
                        }
                        for (var j in player.tempSkills) {
                            if (notemp.contains(j))
                                return;
                            var expire = player.tempSkills[j];
                            if (expire === name ||
                                (Array.isArray(expire) && expire.contains(name)) ||
                                (typeof expire === 'function' && expire(event, player, name))) {
                                delete player.tempSkills[j];
                                player.removeSkill(j);
                            }
                            else if (get.objtype(expire) === 'object') {
                                for (var i = 0; i < roles.length; i++) {
                                    if (expire[roles[i]] && player === event[roles[i]] &&
                                        (expire[roles[i]] === name || (Array.isArray(expire[roles[i]]) && expire[roles[i]].contains(name)))) {
                                        delete player.tempSkills[j];
                                        player.removeSkill(j);
                                    }
                                }
                            }
                        }
                        if (lib.config.compatiblemode) {
                            (function () {
                                var skills = player.getSkills(true).concat(lib.skill.global);
                                game.expandSkills(skills);
                                for (var i = 0; i < skills.length; i++) {
                                    var info = get.info(skills[i]);
                                    if (info && info.trigger) {
                                        var trigger = info.trigger;
                                        var add = false;
                                        if (trigger.player) {
                                            if (typeof trigger.player === 'string') {
                                                if (trigger.player === name)
                                                    add = true;
                                            }
                                            else if (trigger.player.contains(name))
                                                add = true;
                                        }
                                        if (trigger.target) {
                                            if (typeof trigger.target === 'string') {
                                                if (trigger.target === name)
                                                    add = true;
                                            }
                                            else if (trigger.target.contains(name))
                                                add = true;
                                        }
                                        if (trigger.source) {
                                            if (typeof trigger.source === 'string') {
                                                if (trigger.source === name)
                                                    add = true;
                                            }
                                            else if (trigger.source.contains(name))
                                                add = true;
                                        }
                                        if (trigger.global) {
                                            if (typeof trigger.global === 'string') {
                                                if (trigger.global === name)
                                                    add = true;
                                            }
                                            else if (trigger.global.contains(name))
                                                add = true;
                                        }
                                        if (add) {
                                            addList(skills[i], player);
                                        }
                                    }
                                }
                            }());
                        }
                        else {
                            for (var i = 0; i < roles.length; i++) {
                                var triggername = player.playerid + '_' + roles[i] + '_' + name;
                                if (lib.hook[triggername]) {
                                    for (var j = 0; j < lib.hook[triggername].length; j++) {
                                        addList(lib.hook[triggername][j], player);
                                    }
                                }
                                triggername = roles[i] + '_' + name;
                                if (lib.hook.globalskill[triggername]) {
                                    for (var j = 0; j < lib.hook.globalskill[triggername].length; j++) {
                                        addList(lib.hook.globalskill[triggername][j], player);
                                    }
                                }
                            }
                            if (lib.hook.globalskill[globalskill]) {
                                for (var j = 0; j < lib.hook.globalskill[globalskill].length; j++) {
                                    addList(lib.hook.globalskill[globalskill][j], player);
                                }
                            }
                            for (var i in lib.hook.globaltrigger[name]) {
                                if (map[i] === player) {
                                    for (var j = 0; j < lib.hook.globaltrigger[name][i].length; j++) {
                                        addList(lib.hook.globaltrigger[name][i][j], map[i]);
                                    }
                                }
                            }
                        }
                        mapx.push(mapxx);
                        player = player.nextSeat;
                        if (!player || player === start) {
                            break;
                        }
                    }
                    if (allbool) {
                        var next = game.createEvent('arrangeTrigger', false, event);
                        next.setContent('arrangeTrigger');
                        next.list = list;
                        next.list2 = list2;
                        next.map = mapx;
                        next._trigger = event;
                        next.triggername = name;
                        //next.starter=start;
                        event._triggering = next;
                    }
                },
                /**
                 * 取消将要触发的子事件；如果无参调用，不进行任何处理
                 * @function
                 * @param {?boolean} all 如果为true，取消全部要触发的子事件；如果未指定或为false，忽略该值
                 * @param {?GameCores.GameObjects.Player} player 一个角色，取消所有将要对该角色触发的子事件，如果未指定，忽略该值
                 */
                untrigger: function (all, player) {
                    var evt = this._triggering;
                    if (all) {
                        if (evt && evt.map) {
                            for (var i = 0; i < evt.map.length; i++) {
                                evt.map[i].list = [];
                            }
                            evt.list = [];
                            if (evt.doing)
                                evt.doing.list = [];
                        }
                        ;
                        this._triggered = 5;
                    }
                    else {
                        if (player) {
                            this._notrigger.add(player);
                            if (!evt || !evt.map)
                                return;
                            for (var i = 0; i < evt.map.length; i++) {
                                if (evt.map[i].player == player)
                                    evt.map[i].list.length = 0;
                            }
                        }
                    }
                }
            },
            /**
             * 弹窗方法，.dialog节点共用的方法（比如开启和关闭弹窗【open/close】）
             * 对话框(弹窗)
             * @name element.dialog
             * @type {!Object}
             */
            dialog: {
                add: function (item, noclick, zoom) {
                    if (typeof item == 'string') {
                        if (item.indexOf('###') == 0) {
                            var items = item.slice(3).split('###');
                            this.add(items[0], noclick, zoom);
                            this.addText(items[1], items[1].length <= 20, zoom);
                        }
                        else if (noclick) {
                            var strstr = item;
                            item = ui.create.div('', this.content);
                            item.innerHTML = strstr;
                        }
                        else {
                            item = ui.create.caption(item, this.content);
                        }
                    }
                    else if (get.objtype(item) == 'div') {
                        this.content.appendChild(item);
                    }
                    else if (get.itemtype(item) == 'cards') {
                        var buttons = ui.create.div('.buttons', this.content);
                        if (zoom)
                            buttons.classList.add('smallzoom');
                        this.buttons = this.buttons.concat(ui.create.buttons(item, 'card', buttons, noclick));
                    }
                    else if (get.itemtype(item) == 'players') {
                        var buttons = ui.create.div('.buttons', this.content);
                        if (zoom)
                            buttons.classList.add('smallzoom');
                        this.buttons = this.buttons.concat(ui.create.buttons(item, 'player', buttons, noclick));
                    }
                    else {
                        var buttons = ui.create.div('.buttons', this.content);
                        if (zoom)
                            buttons.classList.add('smallzoom');
                        this.buttons = this.buttons.concat(ui.create.buttons(item[0], item[1], buttons, noclick));
                    }
                    if (this.buttons.length) {
                        if (this.forcebutton !== false)
                            this.forcebutton = true;
                        if (this.buttons.length > 3 || (zoom && this.buttons.length > 5)) {
                            this.classList.remove('forcebutton-auto');
                        }
                        else if (!this.noforcebutton) {
                            this.classList.add('forcebutton-auto');
                        }
                    }
                    ui.update();
                    return item;
                },
                addText: function (str, center) {
                    if (center !== false) {
                        this.add('<div class="text center">' + str + '</div>');
                    }
                    else {
                        this.add('<div class="text">' + str + '</div>');
                    }
                    return this;
                },
                addSmall: function (item, noclick) {
                    return this.add(item, noclick, true);
                },
                addAuto: function (content) {
                    if (content && content.length > 4 && !this._hovercustomed) {
                        this.addSmall(content);
                    }
                    else {
                        this.add(content);
                    }
                },
                open: function () {
                    if (this.noopen)
                        return;
                    for (var i = 0; i < ui.dialogs.length; i++) {
                        if (ui.dialogs[i] == this) {
                            this.show();
                            this.refocus();
                            ui.dialogs.remove(this);
                            ui.dialogs.unshift(this);
                            ui.update();
                            return this;
                        }
                        if (ui.dialogs[i].static)
                            ui.dialogs[i].unfocus();
                        else
                            ui.dialogs[i].hide();
                    }
                    ui.dialog = this;
                    var translate;
                    if (lib.config.remember_dialog && lib.config.dialog_transform && !this.classList.contains('fixed')) {
                        translate = lib.config.dialog_transform;
                        this._dragtransform = translate;
                        this.style.transform = 'translate(' + translate[0] + 'px,' + translate[1] + 'px) scale(0.8)';
                    }
                    else {
                        this.style.transform = 'scale(0.8)';
                    }
                    this.style.transitionProperty = 'opacity,transform';
                    this.style.opacity = 0;
                    ui.arena.appendChild(this);
                    ui.dialogs.unshift(this);
                    ui.update();
                    ui.refresh(this);
                    if (lib.config.remember_dialog && lib.config.dialog_transform && !this.classList.contains('fixed')) {
                        this.style.transform = 'translate(' + translate[0] + 'px,' + translate[1] + 'px) scale(1)';
                    }
                    else {
                        this.style.transform = 'scale(1)';
                    }
                    this.style.opacity = 1;
                    var that = this;
                    setTimeout(function () {
                        that.style.transitionProperty = '';
                    }, 500);
                    return this;
                },
                close: function () {
                    ui.dialogs.remove(this);
                    this["delete"]();
                    if (ui.dialogs.length > 0) {
                        ui.dialog = ui.dialogs[0];
                        ui.dialog.show();
                        ui.dialog.refocus();
                        ui.update();
                    }
                    // if(ui.arenalog){
                    //     ui.arenalog.classList.remove('withdialog');
                    // }
                    return this;
                },
                setCaption: function (str) {
                    this.querySelector('.caption').innerHTML = str;
                    return this;
                }
            },
            /**
             * 选项方法，参考弹窗方法，在创建.control节点时依次为其添加
             * 选择项
             * @name element.control
             * @type {!Object}
             */
            control: {
                open: function () {
                    ui.control.insertBefore(this, _status.createControl || ui.confirm);
                    ui.controls.unshift(this);
                    if (this.childNodes.length) {
                        this.style.transition = 'opacity 0.5s';
                        ui.refresh(this);
                        this.style.transform = 'translateX(-' + (this.offsetWidth / 2) + 'px)';
                        this.style.opacity = 1;
                        ui.refresh(this);
                        this.style.transition = '';
                    }
                    else {
                        this.animate('controlpressdownx', 500);
                    }
                    ui.updatec();
                    return this;
                },
                add: function (item) {
                    var node = document.createElement('div');
                    this.appendChild(node);
                    node.link = item;
                    node.innerHTML = get.translation(item);
                    node.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.control);
                },
                close: function () {
                    this.animate('controlpressdownx', 500);
                    ui.controls.remove(this);
                    this["delete"]();
                    setTimeout(ui.updatec, 100);
                    if (ui.confirm == this)
                        delete ui.confirm;
                    if (ui.skills == this)
                        delete ui.skills;
                    if (ui.skills2 == this)
                        delete ui.skills2;
                    if (ui.skills3 == this)
                        delete ui.skills3;
                },
                replace: function () {
                    // this.animate('controlpressdownx',500);
                    if (this.replaceTransition === false) {
                        this.style.transitionProperty = 'none';
                        ui.refresh(this);
                    }
                    while (this.childNodes.length)
                        this.firstChild.remove();
                    var i, controls;
                    if (Array.isArray(arguments[0]))
                        controls = arguments[0];
                    else
                        controls = arguments;
                    delete this.custom;
                    for (i = 0; i < controls.length; i++) {
                        if (typeof controls[i] == 'function') {
                            this.custom = controls[i];
                        }
                        else {
                            this.add(controls[i]);
                        }
                    }
                    if (this.childNodes.length) {
                        var width = 0;
                        for (i = 0; i < this.childNodes.length; i++)
                            width += this.childNodes[i].offsetWidth;
                        ui.refresh(this);
                        this.style.width = width + 'px';
                    }
                    ui.updatec();
                    if (this.replaceTransition === false) {
                        var that = this;
                        setTimeout(function () {
                            that.style.transitionProperty = '';
                        }, 200);
                    }
                    return this;
                }
            },
            /**
             * 客户端
             * @name element.client
             * @type {!Object}
             */
            client: {
                send: function () {
                    if (this.closed)
                        return this;
                    var args = Array.from(arguments);
                    if (typeof args[0] == 'function') {
                        args.unshift('exec');
                    }
                    for (var i = 1; i < args.length; i++) {
                        args[i] = get.stringifiedResult(args[i]);
                    }
                    try {
                        this.ws.send(JSON.stringify(args));
                    }
                    catch (e) {
                        this.ws.close();
                    }
                    return this;
                },
                close: function () {
                    lib.node.clients.remove(this);
                    lib.node.observing.remove(this);
                    if (ui.removeObserve && !lib.node.observing.length) {
                        ui.removeObserve.remove();
                        delete ui.removeObserve;
                    }
                    this.closed = true;
                    if (_status.waitingForPlayer) {
                        for (var i = 0; i < game.connectPlayers.length; i++) {
                            if (game.connectPlayers[i].playerid == this.id) {
                                game.connectPlayers[i].uninitOL();
                                delete game.connectPlayers[i].playerid;
                            }
                        }
                        if (game.onlinezhu == this.id) {
                            game.onlinezhu = null;
                        }
                        game.updateWaiting();
                    }
                    else if (lib.playerOL[this.id]) {
                        var player = lib.playerOL[this.id];
                        player.setNickname(player.nickname + ' - 离线');
                        game.broadcast(function (player) {
                            player.setNickname(player.nickname + ' - 离线');
                        }, player);
                        player.unwait('ai');
                    }
                    if (window.isNonameServer) {
                        document.querySelector('#server_count').innerHTML = lib.node.clients.length;
                    }
                    return this;
                }
            },
            /**
             * Node Web Server listeners and callbacks
             * @name element.nodews
             * @type {!Object}
             */
            nodews: {
                send: function (message) {
                    game.send('server', 'send', this.wsid, message);
                },
                on: function (type, func) {
                    this['on' + type] = func;
                },
                close: function () {
                    game.send('server', 'close', this.wsid);
                }
            },
            /**
             * Web Server
             * @name element.ws
             * @type {!Object}
             */
            ws: {
                onopen: function () {
                    if (_status.connectCallback) {
                        _status.connectCallback(true);
                        delete _status.connectCallback;
                    }
                },
                onmessage: function (messageevent) {
                    if (messageevent.data == 'heartbeat') {
                        this.send('heartbeat');
                        return;
                    }
                    var message;
                    try {
                        message = JSON.parse(messageevent.data);
                        if (!Array.isArray(message) ||
                            typeof lib.message.client[message[0]] !== 'function') {
                            throw ('err');
                        }
                        for (var i = 1; i < message.length; i++) {
                            message[i] = get.parsedResult(message[i]);
                        }
                    }
                    catch (e) {
                        console.log(e);
                        console.log('invalid message: ' + messageevent.data);
                        return;
                    }
                    lib.message.client[message.shift()].apply(null, message);
                },
                onerror: function (e) {
                    if (this._nocallback)
                        return;
                    if (_status.connectCallback) {
                        _status.connectCallback(false);
                        delete _status.connectCallback;
                    }
                    else {
                        alert('连接失败');
                    }
                },
                onclose: function () {
                    if (this._nocallback)
                        return;
                    if (_status.connectCallback) {
                        _status.connectCallback(false);
                        delete _status.connectCallback;
                    }
                    if (game.online || game.onlineroom) {
                        if ((game.servermode || game.onlinehall) && _status.over) {
                        }
                        else {
                            localStorage.setItem(lib.configprefix + 'directstart', true);
                            game.reload();
                        }
                    }
                    else {
                        // game.saveConfig('reconnect_info');
                    }
                    game.online = false;
                    game.ws = null;
                }
            }
        },
        //全局卡牌
        card: {
            list: [],
            //石头剪刀布
            pss_paper: {
                type: 'pss',
                fullskin: true
            },
            pss_scissor: {
                type: 'pss',
                fullskin: true
            },
            pss_stone: {
                type: 'pss',
                fullskin: true
            },
            //区域废弃标志
            feichu_equip1: {
                type: "equip",
                subtype: "equip1"
            },
            feichu_equip2: {
                type: "equip",
                subtype: "equip2"
            },
            feichu_equip3: {
                type: "equip",
                subtype: "equip3"
            },
            feichu_equip4: {
                type: "equip",
                subtype: "equip4"
            },
            feichu_equip5: {
                type: "equip",
                subtype: "equip5"
            },
            disable_judge: {},
            //势力卡牌
            group_wei: { fullskin: true },
            group_shu: { fullskin: true },
            group_wu: { fullskin: true },
            group_qun: { fullskin: true },
            group_key: { fullskin: true },
            group_jin: { fullskin: true },
            group_holo: { fullskin: true },
            group_nijisanji: { fullskin: true },
            group_VirtuaReal: { fullskin: true },
            group_upd8: { fullskin: true },
            group_paryi: { fullskin: true },
            group_kagura: { fullskin: true },
            group_nanashi: { fullskin: true },
            group_psp: { fullskin: true },
            group_asoul: { fullskin: true },
            group_nori: { fullskin: true },
            group_vwp: { fullskin: true },
            group_chaos: { fullskin: true },
            group_xuyan: { fullskin: true },
            group_xuefeng: { fullskin: true }
        },
        /**
         * 用于简单筛选的回调函数组
         * @namespace
         */
        filter: {
            all: function () {
                return true;
            },
            buttonIncluded: function (button) {
                return !(_status.event.excludeButton && _status.event.excludeButton.contains(button));
            },
            filterButton: function (button) {
                return true;
            },
            /**
             * 检测角色A能否使用某卡牌救治角色B
             * @function
             * @param {!GameCores.GameObjects.Card} card 检测卡牌
             * @param {!GameCores.GameObjects.Player} player 卡牌使用者(角色A)
             * @param {!GameCores.GameObjects.Player} target 卡牌目标(角色B)
             * @returns {!boolean} 如果可触发，返回true；否则返回false
             */
            cardSavable: function (card, player, target) {
                var mod2 = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
                if (mod2 != 'unchanged')
                    return mod2;
                var mod = game.checkMod(card, player, target, 'unchanged', 'cardSavable', player);
                if (mod != 'unchanged')
                    return mod;
                var savable = get.info(card).savable;
                if (typeof savable == 'function')
                    savable = savable(card, player, target);
                return savable;
            },
            /**
             * 检测技能的trigger事件是否可触发
             * @function
             * @param {!GameCores.Bases.Event} event 父事件
             * @param {!GameCores.GameObjects.Player} player 触发对象(角色)
             * @param {!string} name 触发器名/触发条件，即triggername
             * @param {!string} skill 技能ID
             * @returns {!boolean} 如果可触发，返回true；否则返回false
             */
            filterTrigger: function (event, player, name, skill) {
                if (player._hookTrigger) {
                    for (var i = 0; i < player._hookTrigger.length; i++) {
                        var info = lib.skill[player._hookTrigger[i]].hookTrigger;
                        if (info) {
                            if (info.block && info.block(event, player, name, skill)) {
                                return false;
                            }
                        }
                    }
                }
                var fullskills = game.expandSkills(player.getSkills().concat(lib.skill.global));
                var info = get.info(skill);
                if ((info.noHidden || get.mode() != 'guozhan') && !fullskills.contains(skill)) {
                    return false;
                }
                if (!info.trigger)
                    return false;
                var bool = false;
                var has = function (obj) {
                    if (typeof obj == 'string')
                        return obj == name;
                    else if (obj.contains(name))
                        return true;
                    return false;
                };
                for (var i in info.trigger) { //check trigger
                    if ((i == 'global' || player == event[i]) && has(info.trigger[i])) {
                        bool = true;
                        break;
                    }
                }
                if (!bool)
                    return false;
                if (info.filter && !info.filter(event, player, name)) {
                    return false;
                }
                if (event._notrigger.contains(player) && !lib.skill.global.contains(skill)) {
                    return false;
                }
                if (typeof info.usable == 'number' && player.hasSkill('counttrigger') &&
                    player.storage.counttrigger && player.storage.counttrigger[skill] >= info.usable) {
                    return false;
                }
                if (info.round && (info.round - (game.roundNumber - player.storage[skill + '_roundcount']) > 0)) {
                    return false;
                }
                return true;
            },
            characterDisabled: function (i, libCharacter) {
                if (!lib.character[i] || lib.character[i][4] && lib.character[i][4].contains('forbidai'))
                    return true;
                if (lib.character[i][4] && lib.character[i][4].contains('unseen'))
                    return true;
                if (lib.config.forbidai.contains(i))
                    return true;
                if (lib.characterFilter[i] && !lib.characterFilter[i](get.mode()))
                    return true;
                if (_status.connectMode) {
                    if (lib.configOL.banned.contains(i) || lib.connectBanned.contains(i))
                        return true;
                    if (lib.configOL.protect_beginner && get.is.banForBeginner(i))
                        return true;
                    var double_character = false;
                    if (lib.configOL.mode == 'guozhan') {
                        double_character = true;
                    }
                    else if (lib.configOL.double_character && (lib.configOL.mode == 'identity' || lib.configOL.mode == 'stone')) {
                        double_character = true;
                    }
                    else if (lib.configOL.double_character_jiange && (lib.configOL.mode == 'versus' && _status.mode == 'jiange')) {
                        double_character = true;
                    }
                    if (double_character && lib.config.forbiddouble.contains(i)) {
                        return true;
                    }
                    // if(lib.configOL.ban_weak){
                    //     if(lib.config.replacecharacter[i]&&libCharacter&&libCharacter[lib.config.replacecharacter[i]]) return true;
                    //     if(lib.config.forbidall.contains(i)) return true;
                    //     if(!double_character&&get.rank(i,true)<=2){
                    //         return true;
                    //     }
                    // }
                    // if(lib.configOL.ban_strong&&get.rank(i,true)>=8){
                    //     return true;
                    // }
                }
                else {
                    if (lib.config.banned.contains(i))
                        return true;
                    var double_character = false;
                    if (get.mode() == 'guozhan') {
                        double_character = true;
                    }
                    else if (get.config('double_character') && (lib.config.mode == 'identity' || lib.config.mode == 'stone')) {
                        double_character = true;
                    }
                    else if (get.config('double_character_jiange') && (lib.config.mode == 'versus' && _status.mode == 'jiange')) {
                        double_character = true;
                    }
                    if (double_character && lib.config.forbiddouble.contains(i)) {
                        return true;
                    }
                    // if(get.config('ban_weak')){
                    //     if(lib.config.replacecharacter[i]&&lib.character[lib.config.replacecharacter[i]]) return true;
                    //     if(lib.config.forbidall.contains(i)) return true;
                    //     if(!double_character&&get.rank(i,true)<=2){
                    //         return true;
                    //     }
                    // }
                    // if(get.config('ban_strong')&&get.rank(i,true)>=8){
                    //     return true;
                    // }
                }
            },
            characterDisabled2: function (i) {
                var info = lib.character[i];
                if (!info)
                    return true;
                if (info[4]) {
                    if (info[4].contains('boss'))
                        return true;
                    if (info[4].contains('hiddenboss'))
                        return true;
                    if (info[4].contains('minskin'))
                        return true;
                    if (info[4].contains('unseen'))
                        return true;
                    if (info[4].contains('forbidai') && (!_status.event.isMine || !_status.event.isMine()))
                        return true;
                    if (lib.characterFilter[i] && !lib.characterFilter[i](get.mode()))
                        return true;
                }
                return false;
            },
            skillDisabled: function (skill) {
                if (!lib.translate[skill] || !lib.translate[skill + '_info'])
                    return true;
                var info = lib.skill[skill];
                if (info && !info.unique && !info.temp && !info.sub && !info.fixed && !info.vanish) {
                    return false;
                }
                return true;
            },
            cardEnabled: function (card, player, event) {
                if (player == undefined)
                    player = _status.event.player;
                if (!player)
                    return false;
                var mod2 = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
                if (mod2 != 'unchanged')
                    return mod2;
                card = get.autoViewAs(card, null, player);
                if (event === 'forceEnable') {
                    var mod = game.checkMod(card, player, 'unchanged', 'cardEnabled', player);
                    if (mod != 'unchanged')
                        return mod;
                    return true;
                }
                else {
                    var filter = get.info(card).enable;
                    if (!filter)
                        return;
                    var mod = game.checkMod(card, player, 'unchanged', 'cardEnabled', player);
                    if (mod != 'unchanged')
                        return mod;
                    if (typeof filter == 'boolean')
                        return filter;
                    if (typeof filter == 'function')
                        return filter(card, player, event);
                }
            },
            cardRespondable: function (card, player, event) {
                event = event || _status.event;
                if (event.name != 'chooseToRespond')
                    return true;
                var source = event.getParent().player;
                if (source && source != player) {
                    if (source.hasSkillTag('norespond', false, [card, player, event], true)) {
                        return false;
                    }
                }
                if (player == undefined)
                    player = _status.event.player;
                var mod2 = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
                if (mod2 != 'unchanged')
                    return mod2;
                var mod = game.checkMod(card, player, 'unchanged', 'cardRespondable', player);
                if (mod != 'unchanged')
                    return mod;
                return true;
            },
            cardUsable2: function (card, player, event) {
                card = get.autoViewAs(card, null, player);
                var info = get.info(card);
                if (info.updateUsable == 'phaseUse') {
                    event = event || _status.event;
                    if (player != _status.event.player)
                        return true;
                    if (event.getParent().name != 'phaseUse')
                        return true;
                    if (event.getParent().player != player)
                        return true;
                }
                var num = info.usable;
                if (typeof num == 'function')
                    num = num(card, player);
                num = game.checkMod(card, player, num, 'cardUsable', player);
                if (typeof num != 'number')
                    return true;
                else
                    return (player.countUsed(card) < num);
            },
            cardUsable: function (card, player, event) {
                card = get.autoViewAs(card, null, player);
                var info = get.info(card);
                event = event || _status.event;
                if (player != _status.event.player)
                    return true;
                if (info.updateUsable == 'phaseUse') {
                    if (event.getParent().name != 'phaseUse')
                        return true;
                    if (event.getParent().player != player)
                        return true;
                }
                event.addCount_extra = true;
                var num = info.usable;
                if (typeof num == 'function')
                    num = num(card, player);
                num = game.checkMod(card, player, num, 'cardUsable', player);
                if (typeof num != 'number')
                    return true;
                if (player.countUsed(card) < num)
                    return true;
                if (game.hasPlayer(function (current) {
                    return game.checkMod(card, player, current, false, 'cardUsableTarget', player);
                })) {
                    return true;
                }
                return false;
            },
            cardDiscardable: function (card, player, event) {
                event = event || _status.event;
                if (typeof event != 'string')
                    event = event.getParent().name;
                var mod = game.checkMod(card, player, event, 'unchanged', 'cardDiscardable', player);
                if (mod != 'unchanged')
                    return mod;
                return true;
            },
            canBeDiscarded: function (card, player, target, event) {
                event = event || _status.event;
                if (typeof event != 'string')
                    event = event.getParent().name;
                var mod = game.checkMod(card, player, target, event, 'unchanged', 'canBeDiscarded', target);
                if (mod != 'unchanged')
                    return mod;
                return true;
            },
            canBeGained: function (card, player, target, event) {
                event = event || _status.event;
                if (typeof event != 'string')
                    event = event.getParent().name;
                var mod = game.checkMod(card, player, target, event, 'unchanged', 'canBeGained', target);
                if (mod != 'unchanged')
                    return mod;
                return true;
            },
            cardAiIncluded: function (card) {
                if (_status.event.isMine())
                    return true;
                return (_status.event._aiexclude.contains(card) == false);
            },
            filterCard: function (card, player, event) {
                var info = get.info(card);
                //if(info.toself&&!lib.filter.targetEnabled(card,player,player)) return false;
                if (player == undefined)
                    player = _status.event.player;
                if (!lib.filter.cardEnabled(card, player, event) || !lib.filter.cardUsable(card, player, event))
                    return false;
                if (info.notarget)
                    return true;
                var range;
                var select = get.copy(info.selectTarget);
                if (select == undefined) {
                    if (info.filterTarget == undefined)
                        return true;
                    range = [1, 1];
                }
                else if (typeof select == 'number')
                    range = [select, select];
                else if (get.itemtype(select) == 'select')
                    range = select;
                else if (typeof select == 'function')
                    range = select(card, player);
                game.checkMod(card, player, range, 'selectTarget', player);
                if (!range || range[1] != -1)
                    return true;
                var filterTarget = (event && event.filterTarget) ? event.filterTarget : lib.filter.filterTarget;
                return game.hasPlayer(function (current) {
                    return filterTarget(card, player, current);
                });
            },
            targetEnabledx: function (card, player, target) {
                if (!card)
                    return false;
                if (_status.event.addCount_extra && !lib.filter.cardUsable2(card, player) && !game.checkMod(card, player, target, false, 'cardUsableTarget', player))
                    return false;
                return lib.filter.targetEnabled.apply(this, arguments);
            },
            targetEnabled: function (card, player, target) {
                if (!card)
                    return false;
                var info = get.info(card);
                var filter = info.filterTarget;
                var mod = game.checkMod(card, player, target, 'unchanged', 'playerEnabled', player);
                if (mod == false)
                    return false;
                if (!info.singleCard || ui.selected.targets.length == 0) {
                    var mod = game.checkMod(card, player, target, 'unchanged', 'targetEnabled', target);
                    if (mod != 'unchanged')
                        return mod;
                }
                if (typeof filter == 'boolean')
                    return filter;
                if (typeof filter == 'function')
                    return filter(card, player, target);
            },
            targetEnabled2: function (card, player, target) {
                if (lib.filter.targetEnabled(card, player, target))
                    return true;
                if (!card)
                    return false;
                if (game.checkMod(card, player, target, 'unchanged', 'playerEnabled', player) == false)
                    return false;
                if (game.checkMod(card, player, target, 'unchanged', 'targetEnabled', target) == false)
                    return false;
                var filter = get.info(card).modTarget;
                if (typeof filter == 'boolean')
                    return filter;
                if (typeof filter == 'function')
                    return filter(card, player, target);
                return false;
            },
            targetEnabled3: function (card, player, target) {
                if (!card)
                    return false;
                var info = get.info(card);
                if (info.filterTarget == true)
                    return true;
                if (typeof info.filterTarget == 'function' && info.filterTarget(card, player, target))
                    return true;
                if (info.modTarget == true)
                    return true;
                if (typeof info.modTarget == 'function' && info.modTarget(card, player, target))
                    return true;
                return false;
            },
            targetInRange: function (card, player, target) {
                var mod = game.checkMod(card, player, target, 'unchanged', 'targetInRange', player);
                var extra = 0;
                if (mod != 'unchanged') {
                    if (typeof mod == 'boolean')
                        return mod;
                    if (typeof mod == 'number')
                        extra = mod;
                }
                var info = get.info(card);
                var range = info.range;
                var outrange = info.outrange;
                if (range == undefined && outrange == undefined)
                    return true;
                if (player.hasSkill('undist') || target.hasSkill('undist'))
                    return false;
                for (var i in range) {
                    if (i == 'attack') {
                        if (player.inRange(target))
                            return true;
                        var range2 = player.getAttackRange();
                        if (range2 <= 0)
                            return false;
                        var distance = get.distance(player, target) + extra;
                        if (range[i] <= distance - range2)
                            return false;
                    }
                    else {
                        var distance = get.distance(player, target, i) + extra;
                        if (range[i] < distance)
                            return false;
                    }
                }
                for (var i in outrange) {
                    if (i == 'attack') {
                        var range2 = player.getAttackRange();
                        if (range2 <= 0)
                            return false;
                        var distance = get.distance(player, target) + extra;
                        if (outrange[i] > distance - range2 + 1)
                            return false;
                    }
                    else {
                        var distance = get.distance(player, target, i) + extra;
                        if (outrange[i] > distance)
                            return false;
                    }
                }
                return true;
            },
            filterTarget: function (card, player, target) {
                return (lib.filter.targetEnabledx(card, player, target) &&
                    lib.filter.targetInRange(card, player, target));
            },
            filterTarget2: function (card, player, target) {
                return (lib.filter.targetEnabled2(card, player, target) &&
                    lib.filter.targetInRange(card, player, target));
            },
            notMe: function (card, player, target) {
                return player != target;
            },
            isMe: function (card, player, target) {
                return player == target;
            },
            attackFrom: function (card, player, target) {
                return get.distance(player, target, 'attack') <= 1;
            },
            globalFrom: function (card, player, target) {
                return get.distance(player, target) <= 1;
            },
            selectCard: function () {
                return [1, 1];
            },
            selectTarget: function () {
                var card = get.card(), player = get.player();
                if (card == undefined)
                    return;
                var range;
                var select = get.copy(get.info(card).selectTarget);
                if (select == undefined) {
                    if (get.info(card).filterTarget == undefined)
                        return [0, 0];
                    range = [1, 1];
                }
                else if (typeof select == 'number')
                    range = [select, select];
                else if (get.itemtype(select) == 'select')
                    range = select;
                else if (typeof select == 'function')
                    range = select(card, player);
                game.checkMod(card, player, range, 'selectTarget', player);
                return range;
            },
            judge: function (card, player, target) {
                var judges = target.getCards('j');
                for (var i = 0; i < judges.length; i++) {
                    if ((judges[i].viewAs || judges[i].name) == card.name)
                        return false;
                }
                return true;
            },
            autoRespondSha: function () {
                return !this.player.hasSha(true);
            },
            autoRespondShan: function () {
                return !this.player.hasShan();
            },
            wuxieSwap: function (event) {
                if (event.type == 'wuxie') {
                    if (ui.wuxie && ui.wuxie.classList.contains('glow')) {
                        return true;
                    }
                    if (ui.tempnowuxie && ui.tempnowuxie.classList.contains('glow') && event.state > 0) {
                        var triggerevent = event.getTrigger();
                        if (triggerevent) {
                            if (ui.tempnowuxie._origin == triggerevent.parent.id) {
                                return true;
                            }
                        }
                        else if (ui.tempnowuxie._origin == _status.event.id2) {
                            return true;
                        }
                    }
                    if (!_status.connectMode && lib.config.wuxie_self && event.getParent().state) {
                        var tw = event.getTrigger().parent;
                        if (tw.player.isUnderControl(true) && !tw.player.hasSkillTag('noautowuxie') &&
                            tw.targets && tw.targets.length == 1 && !tw.noai) {
                            return true;
                        }
                    }
                }
            }
        },
        /**
         * 用于简单排序的回调函数组
         * @name sort
         * @namespace
         */
        sort: {
            /**
             * 将角色按照势力排列
             * @name sort.character
             * @function
             */
            character: function (a, b) {
                var getGroup = function (name) {
                    var group = get.is.double(name, true);
                    if (group)
                        return group[0];
                    return lib.character[name][1];
                }, groupSort = function (name) {
                    if (!lib.character[name])
                        return 50;
                    var group = getGroup(name);
                    if (group == 'shen')
                        return -1;
                    if (group == 'vtuber')
                        return 40;
                    if (group == 'clubs')
                        return 41;
                    var list = get.groups();
                    if (list.contains(group))
                        return list.indexOf(group);
                    return 49;
                };
                var del = groupSort(a) - groupSort(b);
                if (del != 0)
                    return del;
                var aa = a, bb = b;
                if (a.indexOf('_') != -1) {
                    a = a.slice(a.indexOf('_') + 1);
                }
                if (b.indexOf('_') != -1) {
                    b = b.slice(b.indexOf('_') + 1);
                }
                if (a != b) {
                    return a > b ? 1 : -1;
                }
                return aa > bb ? 1 : -1;
            },
            /**
             * 将卡牌按照类型排列
             * @name sort.card
             * @function
             */
            card: function (a, b) {
                var typeSort = function (name) {
                    var type = get.type(name);
                    if (!type)
                        return 10;
                    if (type == 'basic')
                        return -1;
                    if (type == 'trick')
                        return 0;
                    if (type == 'delay')
                        return 1;
                    if (type == 'equip') {
                        var type2 = get.subtype(name);
                        if (type2 && type2.slice)
                            return 1 + parseInt(type2.slice(5) || 7);
                        return 8.5;
                    }
                    return 9;
                };
                var del = typeSort(a) - typeSort(b);
                if (del != 0)
                    return del;
                var aa = a, bb = b;
                if (a.indexOf('_') != -1) {
                    a = a.slice(a.indexOf('_') + 1);
                }
                if (b.indexOf('_') != -1) {
                    b = b.slice(b.indexOf('_') + 1);
                }
                if (a != b) {
                    return a > b ? 1 : -1;
                }
                return aa > bb ? 1 : -1;
            },
            random: function () {
                return (Math.random() - 0.5);
            },
            /**
             * 将角色按照距离排列
             * @name sort.seat
             * @function
             */
            seat: function (a, b) {
                var player = lib.tempSortSeat || _status.event.player;
                var delta = get.distance(player, a, 'absolute') - get.distance(player, b, 'absolute');
                if (delta)
                    return delta;
                delta = parseInt(a.dataset.position) - parseInt(b.dataset.position);
                if (player.side == game.me.side)
                    return delta;
                return -delta;
            },
            position: function (a, b) {
                return parseInt(a.dataset.position) - parseInt(b.dataset.position);
            },
            priority: function (a, b) {
                var i1 = get.info(a[0]), i2 = get.info(b[0]);
                if (i1.priority == undefined)
                    i1.priority = 0;
                if (i2.priority == undefined)
                    i2.priority = 0;
                if (i1.priority == i2.priority) {
                    if (i1.forced == undefined && i2.forced == undefined)
                        return 0;
                    if (i1.forced && i2.forced)
                        return 0;
                    if (i1.forced)
                        return 1;
                    if (i2.forced)
                        return -1;
                }
                return i2.priority - i1.priority;
            },
            number: function (a, b) {
                return get.number(a) - get.number(b);
            },
            number2: function (a, b) {
                return get.number(b) - get.number(a);
            },
            capt: function (a, b) {
                var aa = a, bb = b;
                if (aa.indexOf('_') != -1) {
                    aa = aa.slice(aa.indexOf('_') + 1);
                }
                if (bb.indexOf('_') != -1) {
                    bb = bb.slice(bb.indexOf('_') + 1);
                }
                if (aa != bb) {
                    return aa > bb ? 1 : -1;
                }
                return a > b ? 1 : -1;
            },
            name: function (a, b) {
                if (a > b)
                    return 1;
                if (a < b)
                    return -1;
                return 0;
            }
        },
        /**
         * {@link GameCores}的公共技能组
         * @namespace
         */
        skill: {
            //升阶
            _shengjie: {
                enable: 'phaseUse',
                usable: 1,
                filter: function (event, player) {
                    return player.canShengjie(player.getCards('h'));
                },
                content: function () {
                    'step 0';
                    player.chooseShengjie(player.getCards('h'));
                    'step 1';
                    if (result.bool) {
                        player.lose(result.cards, ui.discardPile, 'visible');
                        player.$throw(result.cards);
                        game.log(player, '将', result.cards, '置入了弃牌堆');
                        event.star = result.star;
                    }
                    if (!result.bool) {
                        var skill = player.getStat().skill;
                        skill._shengjie--;
                        if (typeof skill._shengjietried == 'number') {
                            skill._shengjietried++;
                        }
                        else {
                            skill._shengjietried = 1;
                        }
                    }
                    'step 2';
                    if (event.star) {
                        player.gain(event.star, 'gain2').gaintag.add('_shengjie');
                    }
                },
                ai: {
                    basic: {
                        order: 6
                    },
                    result: {
                        player: function (player) {
                            if (player.getStat().skill._shengjietried >= 10) {
                                return 0;
                            }
                            return 0;
                        }
                    }
                }
            },
            //搬过来的应变
            _yingbian: {
                trigger: { player: 'useCard1' },
                forced: true,
                popup: false,
                firstDo: true,
                ruleSkill: true,
                forceLoad: true,
                filter: function (event, player) {
                    if (event.card.yingbian)
                        return false;
                    var bool = player.hasSkillTag('forceYingbian');
                    var card = event.card;
                    if (get.cardtag(card, 'yingbian_kongchao') && (!player.countCards('h') || bool))
                        return true;
                    if (get.cardtag(card, 'yingbian_canqu') && (player.hp == 1 || bool))
                        return true;
                    if (get.cardtag(card, 'yingbian_fujia') && (player.isMaxHandcard() || bool))
                        return true;
                    if (get.cardtag(card, 'yingbian_zhuzhan'))
                        return true;
                    return false;
                },
                content: function () {
                    'step 0';
                    var card = trigger.card;
                    event.card = card;
                    var bool = false;
                    if (get.cardtag(card, 'yingbian_kongchao') && !player.countCards('h')) {
                        player.popup('空巢', 'soil');
                        bool = true;
                    }
                    else if (get.cardtag(card, 'yingbian_canqu') && player.hp == 1) {
                        player.popup('残躯', 'fire');
                        bool = true;
                    }
                    else if (get.cardtag(card, 'yingbian_fujia') && player.isMaxHandcard()) {
                        player.popup('富甲', 'orange');
                        bool = true;
                    }
                    else if (player.hasSkillTag('forceYingbian')) {
                        player.popup('应变', 'metal');
                        bool = true;
                    }
                    if (bool) {
                        game.log(player, '触发了', card, '的应变条件');
                        event.goto(10);
                    }
                    'step 1';
                    event._global_waiting = true;
                    event.send = function (player, card, source, targets, id, id2, skillState) {
                        if (skillState) {
                            player.applySkills(skillState);
                        }
                        var type = get.type2(card);
                        var str = get.translation(source);
                        if (targets && targets.length) {
                            str += '对';
                            str += get.translation(targets);
                        }
                        str += '使用了';
                        var next = player.chooseCard({
                            filterCard: function (card) {
                                return get.type2(card) == type && lib.filter.cardDiscardable.apply(this, arguments);
                            },
                            prompt: str += (get.translation(card) + '，是否弃置一张' + get.translation(type) + '为其助战？'),
                            position: 'h',
                            _global_waiting: true,
                            id: id,
                            id2: id2,
                            ai: function (cardx) {
                                var info = get.info(card);
                                if (info && info.ai && info.ai.yingbian) {
                                    var ai = info.ai.yingbian(card, source, targets, player);
                                    if (!ai)
                                        return 0;
                                    return ai - get.value(cardx);
                                }
                                else if (get.attitude(player, source) <= 0)
                                    return 0;
                                return 5 - get.value(cardx);
                            }
                        });
                        if (game.online) {
                            _status.event._resultid = id;
                            game.resume();
                        }
                    };
                    'step 2';
                    var type = get.type2(card);
                    var list = game.filterPlayer(function (current) {
                        if (current == player)
                            return false;
                        if (!current.countCards('h'))
                            return false;
                        return _status.connectMode || current.countCards('h', function (cardx) {
                            return get.type2(cardx) == type;
                        });
                    });
                    event.list = list;
                    event.id = get.id();
                    list.sort(function (a, b) {
                        return get.distance(event.source, a, 'absolute') - get.distance(event.source, b, 'absolute');
                    });
                    'step 3';
                    if (event.list.length == 0) {
                        event.finish();
                        return;
                    }
                    else if (_status.connectMode && (event.list[0].isOnline() || event.list[0] == game.me)) {
                        event.goto(5);
                    }
                    else {
                        event.current = event.list.shift();
                        event.send(event.current, event.card, player, trigger.targets, event.id, trigger.parent.id);
                    }
                    'step 4';
                    if (result.bool) {
                        event.zhuzhanresult = event.current;
                        event.zhuzhanresult2 = result;
                        if (event.current != game.me)
                            game.delayx();
                        event.goto(9);
                    }
                    else {
                        event.goto(3);
                    }
                    'step 5';
                    var id = event.id;
                    var sendback = function (result, player) {
                        if (result && result.id == id && !event.zhuzhanresult && result.bool) {
                            event.zhuzhanresult = player;
                            event.zhuzhanresult2 = result;
                            game.broadcast('cancel', id);
                            if (_status.event.id == id && _status.event.name == 'chooseCard' && _status.paused) {
                                return (function () {
                                    event.resultOL = _status.event.resultOL;
                                    ui.click.cancel();
                                    if (ui.confirm)
                                        ui.confirm.close();
                                });
                            }
                        }
                        else {
                            if (_status.event.id == id && _status.event.name == 'chooseCard' && _status.paused) {
                                return (function () {
                                    event.resultOL = _status.event.resultOL;
                                });
                            }
                        }
                    };
                    var withme = false;
                    var withol = false;
                    var list = event.list;
                    for (var i = 0; i < list.length; i++) {
                        if (list[i].isOnline()) {
                            withol = true;
                            list[i].wait(sendback);
                            list[i].send(event.send, list[i], event.card, player, trigger.targets, event.id, trigger.parent.id, get.skillState(list[i]));
                            list.splice(i--, 1);
                        }
                        else if (list[i] == game.me) {
                            withme = true;
                            event.send(list[i], event.card, player, trigger.targets, event.id, trigger.parent.id);
                            list.splice(i--, 1);
                        }
                    }
                    if (!withme) {
                        event.goto(7);
                    }
                    if (_status.connectMode) {
                        if (withme || withol) {
                            for (var i = 0; i < game.players.length; i++) {
                                if (game.players[i] != player)
                                    game.players[i].showTimer();
                            }
                        }
                    }
                    event.withol = withol;
                    'step 6';
                    if (result && result.bool && !event.zhuzhanresult) {
                        game.broadcast('cancel', event.id);
                        event.zhuzhanresult = game.me;
                        event.zhuzhanresult2 = result;
                    }
                    'step 7';
                    if (event.withol && !event.resultOL) {
                        game.pause();
                    }
                    'step 8';
                    for (var i = 0; i < game.players.length; i++) {
                        game.players[i].hideTimer();
                    }
                    'step 9';
                    if (event.zhuzhanresult) {
                        var target = event.zhuzhanresult;
                        target.line(player, 'green');
                        target.discard(event.zhuzhanresult2.cards);
                        target.popup('助战', 'wood');
                        game.log(target, '响应了', player, '发起的助战');
                        target.addExpose(0.2);
                    }
                    else
                        event.finish();
                    'step 10';
                    trigger.card.yingbian = true;
                    var info = get.info(trigger.card);
                    if (info && info.yingbian)
                        info.yingbian(trigger);
                    player.addTempSkill('yingbian_changeTarget');
                }
            },
            yingbian_changeTarget: {
                trigger: { player: 'useCard2' },
                forced: true,
                popup: false,
                filter: function (event, player) {
                    if (event.yingbian_removeTarget && event.targets && event.targets.length > 1)
                        return true;
                    if (!event.yingbian_addTarget)
                        return false;
                    var info = get.info(event.card);
                    if (info.allowMultiple == false)
                        return false;
                    if (event.targets && !info.multitarget) {
                        if (game.hasPlayer(function (current) {
                            return !event.targets.contains(current) && lib.filter.targetEnabled2(event.card, player, current) && lib.filter.targetInRange(event.card, player, current);
                        })) {
                            return true;
                        }
                    }
                    return false;
                },
                content: function () {
                    'step 0';
                    if (trigger.yingbian_addTarget)
                        player.chooseTarget('应变：是否为' + get.translation(trigger.card) + '增加一个目标？', function (card, player, target) {
                            var trigger = _status.event.getTrigger();
                            var card = trigger.card;
                            return !trigger.targets.contains(target) && lib.filter.targetEnabled2(card, player, target) && lib.filter.targetInRange(card, player, target);
                        }).set('ai', function (target) {
                            var player = _status.event.player;
                            var card = _status.event.getTrigger().card;
                            return get.effect(target, card, player, player);
                        });
                    else
                        event.goto(2);
                    'step 1';
                    if (result.bool) {
                        var target = result.targets[0];
                        player.line(target, 'green');
                        game.log(player, '发动应变效果，令', target, '也成为了', trigger.card, '的目标');
                        trigger.targets.add(target);
                    }
                    'step 2';
                    if (trigger.yingbian_removeTarget && trigger.targets.length > 1)
                        player.chooseTarget('应变：是否为' + get.translation(trigger.card) + '减少一个目标？', function (card, player, target) {
                            var trigger = _status.event.getTrigger();
                            return trigger.targets.contains(target);
                        }).set('ai', function (target) {
                            var player = _status.event.player;
                            var card = _status.event.getTrigger().card;
                            return -get.effect(target, card, player, player);
                        });
                    else
                        event.finish();
                    'step 3';
                    if (result.bool) {
                        var target = result.targets[0];
                        player.line(target, 'green');
                        game.log(player, '发动应变效果，将', target, '从', trigger.card, '的目标中移除了');
                        trigger.targets.remove(target);
                    }
                }
            },
            //
            _showHiddenCharacter: {
                trigger: { player: ['changeHp', 'phaseBeginStart', 'loseMaxHpBegin'] },
                firstDo: true,
                forced: true,
                popup: false,
                priority: 25,
                filter: function (event, player, name) {
                    return player.isUnseen(2) && get.mode() != 'guozhan';
                },
                content: function () {
                    player.showCharacter(2);
                    player.removeSkill('g_hidden_ai');
                }
            },
            _kamisha: {
                trigger: { source: 'damageBegin2' },
                //forced:true,
                popup: false,
                prompt: function (event, player) {
                    return '是否防止即将对' + get.translation(event.player) + '造成的伤害，改为令其减少' + get.cnNumber(event.num) + '点体力上限？';
                },
                filter: function (event, player) {
                    return event.nature == 'kami' && event.num > 0;
                },
                ruleSkill: true,
                check: function (event, player) {
                    var att = get.attitude(player, event.player);
                    if (event.player.hp == event.player.maxHp)
                        return att < 0;
                    if (event.player.hp == event.player.maxHp - 1 &&
                        (event.player.maxHp <= 3 || event.player.hasSkillTag('maixie')))
                        return att < 0;
                    return att > 0;
                },
                content: function () {
                    trigger.cancel();
                    trigger.player.loseMaxHp(trigger.num).source = player;
                }
            },
            //海洋伤害特性
            _oceansha: {
                trigger: { source: 'damageBegin4' },
                forced: true,
                priority: 7,
                logTarget: 'player',
                equipSkill: false,
                ruleSkill: true,
                filter: function (event, player) {
                    return event.nature == 'ocean' && event.num > 0 && event.player.hujia > 0;
                },
                ruleSkill: true,
                content: function () {
                    trigger.num++;
                    trigger.oceanAddDam = true;
                }
            },
            //暗影伤害特性
            _yamisha: {
                trigger: { player: 'useCardToPlayered' },
                forced: true,
                priority: 7,
                logTarget: 'target',
                equipSkill: false,
                ruleSkill: true,
                filter: function (event, player) {
                    return event.card.nature == 'yami' && event.target.countCards('h') > player.countCards('h');
                },
                ruleSkill: true,
                content: function () {
                    trigger.getParent().directHit.add(trigger.target);
                    trigger.getParent().yamiDirect = true;
                }
            },
            _yamisha2: {
                trigger: { player: 'phaseJieshu' },
                priority: 1,
                popup: false,
                forced: true,
                ruleSkill: true,
                filter: function (event, player) {
                    if (event.getParent().noyami)
                        return false;
                    if (event.player.hasSkillTag('playernoyami', false, event))
                        return false;
                    return game.countPlayer(function (cur) {
                        return cur.hasYami();
                    });
                },
                content: function () {
                    'step 0';
                    event.target = trigger.player;
                    event.state = true;
                    event._global_waiting = true;
                    event.filterCard = function (card, player) {
                        if (get.nature(card) != 'yami')
                            return false;
                        return lib.filter.cardEnabled(card, player, 'forceEnable');
                    };
                    event.send = function (player, state, target, id, skillState) {
                        if (skillState) {
                            player.applySkills(skillState);
                        }
                        state = state ? 1 : -1;
                        var str = '';
                        if (target) {
                            str += '在' + get.translation(target);
                        }
                        str += '的结束阶段，是否对其使用暗影属性的牌？';
                        var next = player.chooseToUse({
                            filterCard: function (card, player) {
                                if (get.nature(card) != 'yami')
                                    return false;
                                return player.canUse(card, target, false);
                            },
                            filterTarget: target,
                            prompt: str,
                            type: 'yami',
                            state: state,
                            _global_waiting: true,
                            ai1: function () {
                                if (target) {
                                    var triggerevent = _status.event.getTrigger();
                                    if (triggerevent && triggerevent.parent &&
                                        triggerevent.parent.postAi &&
                                        triggerevent.player.isUnknown(_status.event.player)) {
                                        return 0;
                                    }
                                    if (Math.abs(get.attitude(_status.event.player, target)) < 0)
                                        return Math.random() - 0.2;
                                }
                                else {
                                    return 0;
                                }
                            },
                            id: id
                        });
                        if (event.stateplayer && event.statecard)
                            next.set('respondTo', [event.stateplayer]);
                        if (game.online) {
                            _status.event._resultid = id;
                            game.resume();
                        }
                        else {
                            next.nouse = true;
                        }
                    };
                    event.settle = function () {
                        /*if(!event.state){
                            trigger.cancel();
                            trigger.result = {yamied: true};
                        }*/
                        event.finish();
                    };
                    'step 1';
                    var list = game.filterPlayer(function (current) {
                        if (current == event.target)
                            return false;
                        if (event.noyami)
                            return false;
                        if (event.directHit && event.directHit.contains(current))
                            return false;
                        return current.hasYami();
                    });
                    event.list = list;
                    event.id = get.id();
                    list.sort(function (a, b) {
                        return get.distance(event.target, a, 'absolute') - get.distance(event.target, b, 'absolute');
                    });
                    'step 2';
                    if (event.list.length == 0) {
                        event.settle();
                    }
                    else if (_status.connectMode && (event.list[0].isOnline() || event.list[0] == game.me)) {
                        event.goto(4);
                    }
                    else {
                        event.current = event.list.shift();
                        event.send(event.current, event.state, event.target, event.id);
                    }
                    'step 3';
                    if (result.bool) {
                        event.yamiresult = event.current;
                        event.yamiresult2 = result;
                        event.goto(8);
                    }
                    else {
                        event.goto(2);
                    }
                    'step 4';
                    var id = event.id;
                    var sendback = function (result, player) {
                        if (result && result.id == id && !event.yamiresult && result.bool) {
                            event.yamiresult = player;
                            event.yamiresult2 = result;
                            game.broadcast('cancel', id);
                            if (_status.event.id == id && _status.event.name == 'chooseToUse' && _status.paused) {
                                return (function () {
                                    event.resultOL = _status.event.resultOL;
                                    ui.click.cancel();
                                    if (ui.confirm)
                                        ui.confirm.close();
                                });
                            }
                        }
                        else {
                            if (_status.event.id == id && _status.event.name == 'chooseToUse' && _status.paused) {
                                return (function () {
                                    event.resultOL = _status.event.resultOL;
                                });
                            }
                        }
                    };
                    var withme = false;
                    var withol = false;
                    var list = event.list;
                    for (var i = 0; i < list.length; i++) {
                        if (list[i].isOnline()) {
                            withol = true;
                            list[i].wait(sendback);
                            list[i].send(event.send, list[i], event.state, event.target, event.id, get.skillState(list[i]));
                            list.splice(i--, 1);
                        }
                        else if (list[i] == game.me) {
                            withme = true;
                            event.send(list[i], event.state, event.target, event.id);
                            list.splice(i--, 1);
                        }
                    }
                    if (!withme) {
                        event.goto(6);
                    }
                    if (_status.connectMode) {
                        if (withme || withol) {
                            for (var i = 0; i < game.players.length; i++) {
                                game.players[i].showTimer();
                            }
                        }
                    }
                    event.withol = withol;
                    'step 5';
                    if (result && result.bool && !event.yamiresult) {
                        game.broadcast('cancel', event.id);
                        event.yamiresult = game.me;
                        event.yamiresult2 = result;
                    }
                    'step 6';
                    if (event.withol && !event.resultOL) {
                        game.pause();
                    }
                    'step 7';
                    for (var i = 0; i < game.players.length; i++) {
                        game.players[i].hideTimer();
                    }
                    'step 8';
                    if (event.yamiresult) {
                        var next = event.yamiresult.useResult(event.yamiresult2);
                        if (event.stateplayer)
                            next.respondTo = [event.stateplayer, event];
                    }
                    'step 9';
                    if (event.yamiresult) {
                        if (result) {
                            // event.noyami=result.noyami;
                            // event.directHit=result.directHit;
                            // event.stateplayer=event.yamiresult;
                            // if(event.yamiresult2&&event.yamiresult2.used){
                            // 	event.statecard=event.yamiresult2.used;
                            // }
                            // else{
                            // 	event.statecard=true;
                            // }
                            event.goto(1);
                        }
                        else
                            event.settle();
                    }
                    else if (event.list.length) {
                        event.goto(2);
                    }
                    else {
                        event.settle();
                    }
                    delete event.resultOL;
                    delete event.yamiresult;
                    delete event.yamiresult2;
                }
            },
            aozhan: {
                charlotte: true,
                mod: {
                    targetEnabled: function (card) {
                        if (card.name == 'tao' && (card.isCard && card.cardid || get.itemtype(card) == 'card'))
                            return false;
                    },
                    cardSavable: function (card) {
                        if (card.name == 'tao' && (card.isCard && card.cardid || get.itemtype(card) == 'card'))
                            return false;
                    }
                },
                group: ["aozhan_sha", "aozhan_shan"],
                subSkill: {
                    sha: {
                        enable: ["chooseToUse", "chooseToRespond"],
                        filterCard: {
                            name: "tao"
                        },
                        viewAs: {
                            name: "sha",
                            isCard: true
                        },
                        viewAsFilter: function (player) {
                            if (!player.countCards('hs', 'tao'))
                                return false;
                        },
                        position: 'hs',
                        prompt: "将一张桃当杀使用或打出",
                        check: function () { return 1; },
                        ai: {
                            respondSha: true,
                            skillTagFilter: function (player) {
                                if (!player.countCards('hs', 'tao'))
                                    return false;
                            },
                            order: function () {
                                return get.order({ name: 'sha' }) - 0.1;
                            }
                        },
                        sub: true
                    },
                    shan: {
                        enable: ["chooseToRespond", "chooseToUse"],
                        filterCard: {
                            name: "tao"
                        },
                        viewAs: {
                            name: "shan",
                            isCard: true
                        },
                        prompt: "将一张桃当闪打出",
                        check: function () { return 1; },
                        viewAsFilter: function (player) {
                            if (!player.countCards('hs', 'tao'))
                                return false;
                        },
                        position: 'hs',
                        ai: {
                            respondShan: true,
                            skillTagFilter: function (player) {
                                if (!player.countCards('hs', 'tao'))
                                    return false;
                            }
                        },
                        sub: true
                    }
                }
            },
            /**
             * 特殊_全局技能
             * 将全局技能的技能名储存于此数组中
             * @type {!Array<string>}
             * @see {@link game.addGlobalSkill}
             */
            global: [],
            globalmap: {},
            storage: {},
            undist: {},
            others: {},
            zhu: {},
            zhuSkill: {},
            land_used: {},
            unequip: { ai: { unequip: true } },
            subplayer: {
                trigger: { player: 'dieBefore' },
                forced: true,
                priority: -9,
                onremove: true,
                mark: 'character',
                intro: {
                    content: function (storage, player) {
                        if (typeof storage.intro2 == 'string')
                            return storage.intro2;
                        if (typeof storage.intro2 == 'function')
                            return storage.intro2(storage, player);
                        return '死亡前切换回主武将';
                    },
                    name: function (storage) {
                        return get.rawName(storage.name);
                    }
                },
                content: function () {
                    trigger.cancel();
                    var evt = trigger.getParent('damage');
                    if (evt.player == player) {
                        evt.untrigger(false, player);
                    }
                    player.exitSubPlayer(true);
                },
                ai: {
                    nosave: true
                }
            },
            autoswap: {
                firstDo: true,
                trigger: {
                    player: ['playercontrol', 'chooseToUseBegin', 'chooseToRespondBegin', 'chooseToDiscardBegin', 'chooseToCompareBegin',
                        'chooseButtonBegin', 'chooseCardBegin', 'chooseTargetBegin', 'chooseCardTargetBegin', 'chooseControlBegin',
                        'chooseBoolBegin', 'choosePlayerCardBegin', 'discardPlayerCardBegin', 'gainPlayerCardBegin']
                },
                forced: true,
                priority: 100,
                forceDie: true,
                popup: false,
                filter: function (event, player) {
                    if (event.autochoose && event.autochoose())
                        return false;
                    if (lib.filter.wuxieSwap(event))
                        return false;
                    if (_status.auto || !player.isUnderControl())
                        return false;
                    return true;
                },
                content: function () {
                    game.swapPlayerAuto(player);
                }
            },
            dualside: {
                subSkill: {
                    turn: {
                        trigger: { player: ['turnOverAfter', 'dieBefore'] },
                        silent: true,
                        filter: function (event, player) {
                            if (player.storage.dualside_over)
                                return false;
                            return Array.isArray(player.storage.dualside);
                        },
                        content: function () {
                            var cfg = player.storage.dualside;
                            var bool = player.isTurnedOver();
                            if (trigger.name == 'die') {
                                bool = !bool;
                            }
                            if (bool) {
                                cfg[1] = player.hp;
                                cfg[2] = player.maxHp;
                                player.reinit(cfg[0], cfg[3], [cfg[4], cfg[5]]);
                                player.unmarkSkill('dualside');
                                player.markSkillCharacter('dualside', { name: cfg[0] }, '正面', '当前体力：' + cfg[1] + '/' + cfg[2]);
                            }
                            else {
                                cfg[4] = player.hp;
                                cfg[5] = player.maxHp;
                                player.reinit(cfg[3], cfg[0], [cfg[1], cfg[2]]);
                                player.unmarkSkill('dualside');
                                player.markSkillCharacter('dualside', { name: cfg[3] }, '背面', '当前体力：' + cfg[4] + '/' + cfg[5]);
                            }
                            if (trigger.name == 'die') {
                                trigger.cancel();
                                delete player.storage.dualside;
                                player.storage.dualside_over = true;
                                player.unmarkSkill('dualside');
                            }
                        }
                    },
                    init: {
                        trigger: { global: 'gameStart', player: 'enterGame' },
                        silent: true,
                        content: function () {
                            var list = [player.name, player.name1, player.name2];
                            for (var i = 0; i < list.length; i++) {
                                if (list[i] && lib.character[list[i]]) {
                                    var info = lib.character[list[i]];
                                    if (info[3].contains('dualside') && info[4]) {
                                        player.storage.dualside = [list[i], player.hp, player.maxHp];
                                        for (var j = 0; j < info[4].length; j++) {
                                            if (info[4][j].indexOf('dualside:') == 0) {
                                                var name2 = info[4][j].slice(9);
                                                var info2 = lib.character[name2];
                                                player.storage.dualside.push(name2);
                                                player.storage.dualside.push(get.infoHp(info2[2]));
                                                player.storage.dualside.push(get.infoMaxHp(info2[2]));
                                            }
                                        }
                                    }
                                }
                            }
                            var cfg = player.storage.dualside;
                            if (get.mode() == 'guozhan') {
                                if (player.name1 == cfg[0]) {
                                    player.showCharacter(0);
                                }
                                else {
                                    player.showCharacter(1);
                                }
                            }
                            player.markSkillCharacter('dualside', { name: cfg[3] }, '背面', '当前体力：' + cfg[4] + '/' + cfg[5]);
                        }
                    }
                },
                group: ['dualside_init', 'dualside_turn']
            },
            _disableJudge: {
                marktext: "废",
                intro: {
                    content: "已经废除了判定区"
                },
                mod: {
                    targetEnabled: function (card, player, target) {
                        if (target.storage._disableJudge && get.type(card) == 'delay')
                            return false;
                    }
                }
            },
            "_disableEquip": {
                marktext: "废",
                intro: {
                    content: function (storage, player, skill) {
                        var str = '';
                        for (var i = 0; i < player.storage.disableEquip.length; i++) {
                            str += '、' + get.translation(player.storage.disableEquip[i]) + '栏';
                        }
                        ;
                        str = str.slice(1, str.length);
                        str = '已经废除了' + str;
                        return str;
                    }
                },
                mod: {
                    targetEnabled: function (card, player, target) {
                        if (target.isDisabled(get.subtype(card)))
                            return false;
                    }
                },
                trigger: {
                    player: ['disableEquipBefore', 'enableEquipBefore', 'enterGame'],
                    global: 'gameStart'
                },
                forced: true,
                popup: false,
                filter: function (event, player) {
                    return player.storage.disableEquip == undefined;
                },
                content: function () {
                    player.storage.disableEquip = [];
                }
            },
            /**
             * 技能_封印
             * 使非锁定技失效
             */
            fengyin: {
                init: function (player, skill) {
                    player.addSkillBlocker(skill);
                },
                onremove: function (player, skill) {
                    player.removeSkillBlocker(skill);
                },
                charlotte: true,
                skillBlocker: function (skill, player) {
                    return !lib.skill[skill].charlotte && !get.is.locked(skill, player);
                },
                mark: true,
                intro: {
                    content: function (storage, player, skill) {
                        var list = player.getSkills(null, false, false).filter(function (i) {
                            return lib.skill.fengyin.skillBlocker(i, player);
                        });
                        if (list.length)
                            return '失效技能：' + get.translation(list);
                        return '无失效技能';
                    }
                }
            },
            /**
             * 技能_白板
             * 使全部技能失效
             */
            baiban: {
                init: function (player, skill) {
                    player.addSkillBlocker(skill);
                },
                onremove: function (player, skill) {
                    player.removeSkillBlocker(skill);
                },
                charlotte: true,
                skillBlocker: function (skill, player) {
                    return !lib.skill[skill].charlotte;
                },
                mark: true,
                intro: {
                    content: function (storage, player, skill) {
                        var list = player.getSkills(null, false, false).filter(function (i) {
                            return lib.skill.baiban.skillBlocker(i, player);
                        });
                        if (list.length)
                            return '失效技能：' + get.translation(list);
                        return '无失效技能';
                    }
                }
            },
            qianxing: {
                mark: true,
                nopop: true,
                init: function (player) {
                    game.log(player, '获得了', '【潜行】');
                },
                intro: {
                    content: '锁定技，你不能成为其他角色的卡牌的目标'
                },
                mod: {
                    targetEnabled: function (card, player, target) {
                        if (player != target)
                            return false;
                    }
                }
            },
            /**
             * 技能_免疫
             * 防止受到的伤害
             */
            mianyi: {
                trigger: { player: 'damageBefore' },
                mark: true,
                forced: true,
                init: function (player) {
                    game.log(player, '获得了', '【免疫】');
                },
                content: function () {
                    trigger.cancel();
                },
                ai: {
                    noyami: true,
                    nofire: true,
                    nothunder: true,
                    noocean: true,
                    nodamage: true,
                    effect: {
                        target: function (card, player, target, current) {
                            if (get.tag(card, 'damage'))
                                return [0, 0];
                        }
                    }
                },
                intro: {
                    content: '防止一切伤害'
                }
            },
            mad: {
                mark: true,
                locked: true,
                intro: {
                    content: '已进入混乱状态',
                    name: '混乱',
                    onunmark: function (storage, player) {
                        game.log(player, '解除混乱状态');
                    }
                }
            },
            ghujia: {
                intro: {
                    content: function (content, player) {
                        return '已有' + get.cnNumber(player.hujia) + '点护甲值';
                    }
                }
            },
            counttrigger: {
                trigger: { global: 'phaseAfter' },
                silent: true,
                charlotte: true,
                priority: -100,
                content: function () {
                    player.removeSkill('counttrigger');
                    delete player.storage.counttrigger;
                }
            },
            _recovercheck: {
                trigger: { player: 'recoverBefore' },
                forced: true,
                priority: 100,
                firstDo: true,
                popup: false,
                filter: function (event, player) {
                    return player.hp >= player.maxHp;
                },
                content: function () {
                    trigger.cancel();
                }
            },
            /**
             * 规则技能_翻面
             * 被翻面的角色跳过回合
             */
            _turnover: {
                trigger: { player: 'phaseBefore' },
                forced: true,
                priority: 100,
                popup: false,
                firstDo: true,
                content: function () {
                    'step 0';
                    if ((player == _status.roundStart || _status.roundSkipped) && !trigger.skill) {
                        event.trigger('roundEnd');
                    }
                    'step 1';
                    if (player.isTurnedOver()) {
                        trigger.cancel();
                        player.turnOver();
                        player.phaseSkipped = true;
                    }
                    else {
                        player.phaseSkipped = false;
                    }
                    'step 2';
                    if ((player == _status.roundStart || _status.roundSkipped) && !trigger.skill) {
                        delete _status.roundSkipped;
                        game.roundNumber++;
                        trigger._roundStart = true;
                        game.updateRoundNumber();
                        for (var i = 0; i < game.players.length; i++) {
                            if (game.players[i].isOut() && game.players[i].outCount > 0) {
                                game.players[i].outCount--;
                                if (game.players[i].outCount == 0 && !game.players[i].outSkills) {
                                    game.players[i]["in"]();
                                }
                            }
                        }
                        event.trigger('roundStart');
                    }
                }
            },
            /**
             * 规则技能_使用
             * 使用一张牌结算后，通过{@link ui.clear}清除残留ui
             */
            _usecard: {
                trigger: { global: 'useCardAfter' },
                forced: true,
                popup: false,
                priority: -100,
                lastDo: true,
                filter: function (event) {
                    return !event._cleared && event.card.name != 'wuxie';
                },
                content: function () {
                    game.broadcastAll(function () {
                        ui.clear();
                    });
                    event._cleared = true;
                }
            },
            /**
             * 规则技能_弃牌
             * 弃牌结算后，延时一段时间清除残留弃牌效果
             */
            _discard: {
                trigger: { global: 'discardAfter' },
                forced: true,
                popup: false,
                priority: -100,
                lastDo: true,
                filter: function (event) {
                    return ui.todiscard[event.discardid] ? true : false;
                },
                content: function () {
                    game.broadcastAll(function (id) {
                        var todiscard = ui.todiscard[id];
                        delete ui.todiscard[id];
                        if (todiscard) {
                            var time = 1000;
                            if (typeof todiscard._discardtime == 'number') {
                                time += todiscard._discardtime - get.time();
                            }
                            if (time < 0) {
                                time = 0;
                            }
                            setTimeout(function () {
                                for (var i = 0; i < todiscard.length; i++) {
                                    todiscard[i]["delete"]();
                                }
                            }, time);
                        }
                    }, trigger.discardid);
                }
            },
            _save: {
                //trigger:{source:'dying2',player:'dying2'},
                priority: 5,
                forced: true,
                popup: false,
                filter: function (event, player) {
                    //if(!event.player.isDying()) return false;
                    //if(event.source&&event.source.isIn()&&event.source!=player) return false;
                    //return true;
                    return false;
                },
                content: function () {
                    "step 0";
                    event.dying = trigger.player;
                    if (!event.acted)
                        event.acted = [];
                    "step 1";
                    if (trigger.player.isDead()) {
                        event.finish();
                        return;
                    }
                    event.acted.push(player);
                    var str = get.translation(trigger.player) + '濒死，是否帮助？';
                    var str2 = '当前体力：' + trigger.player.hp;
                    if (lib.config.tao_enemy && event.dying.side != player.side && lib.config.mode != 'identity' && lib.config.mode != 'guozhan' && !event.dying.hasSkillTag('revertsave')) {
                        event._result = { bool: false };
                    }
                    else if (player.canSave(event.dying)) {
                        player.chooseToUse({
                            filterCard: function (card, player, event) {
                                event = event || _status.event;
                                return lib.filter.cardSavable(card, player, event.dying);
                            },
                            filterTarget: trigger.player,
                            prompt: str,
                            prompt2: str2,
                            ai1: function (card) {
                                if (typeof card == 'string') {
                                    var info = get.info(card);
                                    if (info.ai && info.ai.order) {
                                        if (typeof info.ai.order == 'number') {
                                            return info.ai.order;
                                        }
                                        else if (typeof info.ai.order == 'function') {
                                            return info.ai.order();
                                        }
                                    }
                                }
                                return 1;
                            },
                            ai2: get.effect_use,
                            type: 'dying',
                            targetRequired: true,
                            dying: event.dying
                        });
                    }
                    else {
                        event._result = { bool: false };
                    }
                    "step 2";
                    if (result.bool) {
                        if (trigger.player.hp <= 0 && !trigger.player.nodying && trigger.player.isAlive() && !trigger.player.isOut() && !trigger.player.removed)
                            event.goto(0);
                        else
                            trigger.untrigger();
                    }
                    else {
                        for (var i = 0; i < 20; i++) {
                            if (event.acted.contains(event.player.next)) {
                                break;
                            }
                            else {
                                event.player = event.player.next;
                                if (!event.player.isOut()) {
                                    event.goto(1);
                                    break;
                                }
                            }
                        }
                    }
                }
            },
            _ismin: {
                mod: {
                    cardEnabled: function (card, player) {
                        if (player.isMin()) {
                            if (get.type(card) == 'equip')
                                return false;
                        }
                    }
                }
            },
            /**
             * 规则技能_重铸
             * 令角色可以重铸特定的牌
             */
            _chongzhu: {
                enable: 'phaseUse',
                logv: false,
                visible: true,
                prompt: '将要重铸的牌置入弃牌堆并摸一张牌',
                filter: function (event, player) {
                    return player.hasCard(function (card) {
                        return lib.skill._chongzhu.filterCard(card, player);
                    });
                },
                filterCard: function (card, player) {
                    var mod = game.checkMod(card, player, 'unchanged', 'cardChongzhuable', player);
                    if (mod != 'unchanged')
                        return mod;
                    var info = get.info(card);
                    if (typeof info.chongzhu == 'function') {
                        return info.chongzhu(event, player);
                    }
                    return info.chongzhu;
                },
                prepare: function (cards, player) {
                    player.$throw(cards, 1000);
                    game.log(player, '将', cards, '置入了弃牌堆');
                },
                check: function (card) {
                    // if(get.type(card)=='stonecharacter'&&_status.event.player.countCards('h',{type:'stonecharacter'})<=1){
                    //     return 0;
                    // }
                    return 1;
                },
                discard: false,
                loseTo: 'discardPile',
                delay: 0.5,
                content: function () {
                    "step 0";
                    if (lib.config.mode == 'stone' && _status.mode == 'deck' &&
                        !player.isMin() && get.type(cards[0]).indexOf('stone') == 0) {
                        var list = get.stonecard(1, player.career);
                        if (list.length) {
                            player.gain(game.createCard(list.randomGet()), 'draw');
                        }
                        else {
                            player.draw({ drawDeck: 1 });
                        }
                    }
                    else if (get.subtype(cards[0]) == 'spell_gold') {
                        var list = get.libCard(function (info) {
                            return info.subtype == 'spell_silver';
                        });
                        if (list.length) {
                            player.gain(game.createCard(list.randomGet()), 'draw');
                        }
                        else {
                            player.draw();
                        }
                    }
                    else if (get.subtype(cards[0]) == 'spell_silver') {
                        var list = get.libCard(function (info) {
                            return info.subtype == 'spell_bronze';
                        });
                        if (list.length) {
                            player.gain(game.createCard(list.randomGet()), 'draw');
                        }
                        else {
                            player.draw();
                        }
                    }
                    else {
                        player.draw();
                    }
                },
                ai: {
                    basic: {
                        order: 6
                    },
                    result: {
                        player: 1
                    }
                }
            },
            /**
             * 规则技能_连环
             * 被横置的角色传递属性伤害
             */
            _lianhuan: {
                trigger: { player: 'damageAfter' },
                filter: function (event, player) {
                    return event.lianhuanable == true;
                },
                forced: true,
                popup: false,
                logv: false,
                forceDie: true,
                //priority:-5,
                content: function () {
                    "step 0";
                    event.logvid = trigger.getLogv();
                    "step 1";
                    event.targets = game.filterPlayer(function (current) {
                        return current != event.player && current.isLinked();
                    });
                    lib.tempSortSeat = _status.currentPhase || player;
                    event.targets.sort(lib.sort.seat);
                    delete lib.tempSortSeat;
                    event._args = [trigger.num, trigger.nature, trigger.cards, trigger.card];
                    if (trigger.source)
                        event._args.push(trigger.source);
                    else
                        event._args.push("nosource");
                    "step 2";
                    if (event.targets.length) {
                        var target = event.targets.shift();
                        if (target.isLinked())
                            target.damage.apply(target, event._args.slice(0));
                        event.redo();
                    }
                }
            },
            _lianhuan4: {
                trigger: { player: 'changeHp' },
                priority: -10,
                forced: true,
                popup: false,
                forceDie: true,
                filter: function (event, player) {
                    var evt = event.getParent();
                    return evt && evt.name == 'damage' && evt.nature && lib.linked.contains(evt.nature) && player.isLinked();
                },
                content: function () {
                    var overNature = trigger.getParent().oceanAddDam || false;
                    if (trigger.getParent(2).type == 'card' && get.nature(trigger.getParent(2).card) == 'yami' && trigger.getParent(3).yamiDirect)
                        overNature = true;
                    if (!overNature) {
                        player.link();
                        if (trigger.getParent().notLink())
                            trigger.getParent().lianhuanable = true;
                    }
                }
            }
        },
        character: {},
        /**
         * 珠联璧合映射
         * @type {!Object}
         */
        perfectPair: {},
        cardPile: {},
        /**
         * 网络部分的消息处理（回调）函数
         * @type {!Object}
         */
        message: {
            server: {
                init: function (version, config, banned_info) {
                    if (lib.node.banned.contains(banned_info)) {
                        this.send('denied', 'banned');
                    }
                    else if (config.id && lib.playerOL && lib.playerOL[config.id]) {
                        var player = lib.playerOL[config.id];
                        player.setNickname();
                        player.ws = this;
                        player.isAuto = false;
                        this.id = config.id;
                        game.broadcast(function (player) {
                            player.setNickname();
                        }, player);
                        this.send('reinit', lib.configOL, get.arenaState(), game.getState ? game.getState() : {}, game.ip, null, _status.onreconnect, _status.cardtag);
                    }
                    else if (version != lib.versionOL) {
                        this.send('denied', 'version');
                        lib.node.clients.remove(this);
                        this.closed = true;
                    }
                    else if (!_status.waitingForPlayer) {
                        if (game.phaseNumber && lib.configOL.observe) {
                            lib.node.observing.push(this);
                            this.send('reinit', lib.configOL, get.arenaState(), game.getState ? game.getState() : {}, game.ip, game.players[0].playerid, null, _status.cardtag);
                            if (!ui.removeObserve) {
                                ui.removeObserve = ui.create.system('移除旁观', function () {
                                    lib.configOL.observe = false;
                                    if (game.onlineroom) {
                                        game.send('server', 'config', lib.configOL);
                                    }
                                    while (lib.node.observing.length) {
                                        lib.node.observing.shift().ws.close();
                                    }
                                    this.remove();
                                    delete ui.removeObserve;
                                }, true);
                            }
                        }
                        else {
                            this.send('denied', 'gaming');
                            lib.node.clients.remove(this);
                            this.closed = true;
                        }
                    }
                    else if (lib.node.clients.length - (window.isNonameServer ? 1 : 0) >= parseInt(lib.configOL.number)) {
                        this.send('denied', 'number');
                        lib.node.clients.remove(this);
                        this.closed = true;
                    }
                    else {
                        if (config) {
                            this.avatar = config.avatar;
                            this.nickname = config.nickname;
                        }
                        for (var i = 0; i < game.connectPlayers.length; i++) {
                            if (game.connectPlayers[i].classList.contains('unselectable2'))
                                continue;
                            if (game.connectPlayers[i] != game.me && !game.connectPlayers[i].playerid) {
                                game.connectPlayers[i].playerid = this.id;
                                game.connectPlayers[i].initOL(this.nickname, this.avatar);
                                game.connectPlayers[i].ws = this;
                                break;
                            }
                        }
                        this.send('init', this.id, lib.configOL, game.ip, window.isNonameServer, game.roomId);
                    }
                },
                inited: function () {
                    this.inited = true;
                    if (_status.waitingForPlayer) {
                        game.updateWaiting();
                    }
                },
                reinited: function () {
                    this.inited = true;
                },
                result: function (result) {
                    if (lib.node.observing.contains(this))
                        return;
                    var player = lib.playerOL[this.id];
                    if (player) {
                        player.unwait(result);
                    }
                },
                startGame: function () {
                    if (this.id == game.onlinezhu) {
                        game.resume();
                    }
                },
                changeRoomConfig: function (config) {
                    if (this.id == game.onlinezhu) {
                        game.broadcastAll(function (config) {
                            for (var i in config) {
                                lib.configOL[i] = config[i];
                            }
                            if (ui.connectStartBar) {
                                ui.connectStartBar.firstChild.innerHTML = get.modetrans(lib.configOL, true);
                            }
                        }, config);
                        if (lib.configOL.mode == 'identity' && lib.configOL.identity_mode == 'zhong' && game.connectPlayers) {
                            for (var i = 0; i < game.connectPlayers.length; i++) {
                                game.connectPlayers[i].classList.remove('unselectable2');
                            }
                            lib.configOL.number = 8;
                            game.updateWaiting();
                        }
                        if (game.onlineroom) {
                            game.send('server', 'config', lib.configOL);
                        }
                        for (var i = 0; i < game.connectPlayers.length; i++) {
                            if (game.connectPlayers[i].playerid == this.id) {
                                game.connectPlayers[i].chat('房间设置已更改');
                            }
                        }
                    }
                },
                changeNumConfig: function (num, index, bool) {
                    if (this.id == game.onlinezhu) {
                        lib.configOL.number = num;
                        game.send('server', 'config', lib.configOL);
                        if (game.connectPlayers && game.connectPlayers[index]) {
                            if (bool) {
                                game.connectPlayers[index].classList.add('unselectable2');
                            }
                            else {
                                game.connectPlayers[index].classList.remove('unselectable2');
                            }
                            game.updateWaiting();
                        }
                    }
                },
                throwEmotion: function (target, emotion) {
                    if (lib.node.observing.contains(this))
                        return;
                    var player = lib.playerOL[this.id];
                    if (player) {
                        player.throwEmotion(target, emotion);
                    }
                },
                emotion: function (id, pack, emotion) {
                    if (lib.node.observing.contains(this))
                        return;
                    var that = this;
                    if (!this.id || (!lib.playerOL[this.id] && (!game.connectPlayers || !function () {
                        for (var i = 0; i < game.connectPlayers.length; i++) {
                            if (game.connectPlayers[i].playerid == that.id) {
                                return true;
                            }
                        }
                        return false;
                    }())))
                        return;
                    var player;
                    if (lib.playerOL[id]) {
                        player = lib.playerOL[id];
                    }
                    else if (game.connectPlayers) {
                        for (var i = 0; i < game.connectPlayers.length; i++) {
                            if (game.connectPlayers[i].playerid == id) {
                                player = game.connectPlayers[i];
                                break;
                            }
                        }
                    }
                    if (player)
                        lib.element.player.emotion.apply(player, [pack, emotion]);
                },
                chat: function (id, str) {
                    var that = this;
                    if (!this.id || (!lib.playerOL[this.id] && (!game.connectPlayers || !function () {
                        for (var i = 0; i < game.connectPlayers.length; i++) {
                            if (game.connectPlayers[i].playerid == that.id) {
                                return true;
                            }
                        }
                        return false;
                    }())))
                        return;
                    var player;
                    if (lib.playerOL[id]) {
                        player = lib.playerOL[id];
                    }
                    else if (game.connectPlayers) {
                        for (var i = 0; i < game.connectPlayers.length; i++) {
                            if (game.connectPlayers[i].playerid == id) {
                                player = game.connectPlayers[i];
                                break;
                            }
                        }
                    }
                    if (player)
                        lib.element.player.chat.call(player, str);
                },
                giveup: function (player) {
                    if (lib.node.observing.contains(this) || !player || !player._giveUp)
                        return;
                    _status.event.next.length = 0;
                    game.createEvent('giveup', false).setContent(function () {
                        game.log(player, '投降');
                        player.popup('投降');
                        player.die('nosource');
                    }).player = player;
                },
                auto: function () {
                    if (lib.node.observing.contains(this))
                        return;
                    var player = lib.playerOL[this.id];
                    if (player) {
                        player.isAuto = true;
                        player.setNickname(player.nickname + ' - 托管');
                        game.broadcast(function (player) {
                            player.setNickname(player.nickname + ' - 托管');
                        }, player);
                    }
                },
                unauto: function () {
                    if (lib.node.observing.contains(this))
                        return;
                    var player = lib.playerOL[this.id];
                    if (player) {
                        player.isAuto = false;
                        player.setNickname(player.nickname);
                        game.broadcast(function (player) {
                            player.setNickname(player.nickname);
                        }, player);
                    }
                },
                exec: function (func) {
                    // if(typeof func=='function'){
                    //     var args=Array.from(arguments);
                    //     args.shift();
                    //     func.apply(this,args);
                    // }
                },
                log: function () {
                    var items = [];
                    try {
                        for (var i = 0; i < arguments.length; i++) {
                            eval('items.push(' + arguments[i] + ')');
                        }
                    }
                    catch (e) {
                        this.send('log', ['err']);
                        return;
                    }
                    this.send('log', items);
                }
            },
            client: {
                log: function (arr) {
                    if (Array.isArray(arr)) {
                        for (var i = 0; i < arr.length; i++) {
                            console.log(arr[i]);
                        }
                    }
                },
                opened: function () {
                    game.send('init', lib.versionOL, {
                        id: game.onlineID,
                        avatar: lib.config.connect_avatar,
                        nickname: get.connectNickname()
                    }, lib.config.banned_info);
                    if (ui.connecting && !ui.connecting.splashtimeout) {
                        ui.connecting.firstChild.innerHTML = '重连成功';
                    }
                },
                onconnection: function (id) {
                    var ws = { wsid: id };
                    for (var i in lib.element.nodews) {
                        ws[i] = lib.element.nodews[i];
                    }
                    lib.wsOL[id] = ws;
                    lib.init.connection(ws);
                },
                onmessage: function (id, message) {
                    if (lib.wsOL[id]) {
                        lib.wsOL[id].onmessage(message);
                    }
                },
                onclose: function (id) {
                    if (lib.wsOL[id]) {
                        lib.wsOL[id].onclose();
                    }
                },
                selfclose: function () {
                    if (game.online || game.onlineroom) {
                        if ((game.servermode || game.onlinehall) && _status.over) {
                            // later
                        }
                        else {
                            game.saveConfig('tmp_user_roomId');
                        }
                    }
                    game.ws.close();
                },
                reloadroom: function (forced) {
                    if (window.isNonameServer && (forced || !_status.protectingroom)) {
                        game.reload();
                    }
                },
                createroom: function (index, config, mode) {
                    game.online = false;
                    game.onlineroom = true;
                    game.roomId = index;
                    lib.node = {};
                    if (config && mode && window.isNonameServer) {
                        if (mode == 'auto') {
                            mode = lib.configOL.mode;
                        }
                        game.switchMode(mode, config);
                    }
                    else {
                        game.switchMode(lib.configOL.mode);
                    }
                    ui.create.connecting(true);
                },
                enterroomfailed: function () {
                    alert('请稍后再试');
                    _status.enteringroom = false;
                    ui.create.connecting(true);
                },
                roomlist: function (list, events, clients, wsid) {
                    game.send('server', 'key', [game.onlineKey, lib.version]);
                    game.online = true;
                    game.onlinehall = true;
                    lib.config.recentIP.remove(_status.ip);
                    lib.config.recentIP.unshift(_status.ip);
                    lib.config.recentIP.splice(5);
                    if (!lib.config.reconnect_info || lib.config.reconnect_info[0] != _status.ip) {
                        game.saveConfig('reconnect_info', [_status.ip, null]);
                    }
                    game.saveConfig('recentIP', lib.config.recentIP);
                    _status.connectMode = true;
                    game.clearArena();
                    game.clearConnect();
                    ui.pause.hide();
                    ui.auto.hide();
                    clearTimeout(_status.createNodeTimeout);
                    game.send('server', 'changeAvatar', get.connectNickname(), lib.config.connect_avatar);
                    var proceed = function () {
                        game.ip = get.trimip(_status.ip);
                        ui.create.connectRooms(list);
                        if (events) {
                            ui.connectEvents = ui.create.div('.forceopaque.menubutton.large.connectevents.pointerdiv', '约战', ui.window, ui.click.connectEvents);
                            ui.connectEventsCount = ui.create.div('.forceopaque.menubutton.icon.connectevents.highlight.hidden', '', ui.window);
                            ui.connectClients = ui.create.div('.forceopaque.menubutton.large.connectevents.pointerdiv.left', '在线', ui.window, ui.click.connectClients);
                            ui.connectClientsCount = ui.create.div('.forceopaque.menubutton.icon.connectevents.highlight.left', '1', ui.window);
                            ui.createRoomButton = ui.create.div('.forceopaque.menubutton.large.connectevents.pointerdiv.left2', '创建房间', ui.window, function () {
                                if (!_status.creatingroom) {
                                    _status.creatingroom = true;
                                    ui.click.connectMenu();
                                }
                            });
                            if (events.length) {
                                ui.connectEventsCount.innerHTML = events.filter(function (evt) {
                                    return evt.creator == game.onlineKey || !get.is.banWords(evt.content);
                                }).length;
                                ui.connectEventsCount.show();
                            }
                        }
                        game.wsid = wsid;
                        lib.message.client.updaterooms(list, clients);
                        lib.message.client.updateevents(events);
                        ui.exitroom = ui.create.system('退出房间', function () {
                            game.saveConfig('tmp_owner_roomId');
                            game.saveConfig('tmp_user_roomId');
                            if (ui.rooms) {
                                game.saveConfig('reconnect_info');
                            }
                            else {
                                if (lib.config.reconnect_info) {
                                    lib.config.reconnect_info.length = 1;
                                    game.saveConfig('reconnect_info', lib.config.reconnect_info);
                                }
                            }
                            game.reload();
                        }, true);
                        var findRoom = function (id) {
                            for (var _i = 0, _a = ui.rooms; _i < _a.length; _i++) {
                                var room = _a[_i];
                                if (room.key == id)
                                    return room;
                            }
                            return false;
                        };
                        if (typeof lib.config.tmp_owner_roomId == 'string') {
                            if (typeof game.roomId != 'string' && !findRoom(lib.config.tmp_owner_roomId)) {
                                lib.configOL.mode = lib.config.connect_mode;
                                game.roomId = lib.config.tmp_owner_roomId;
                            }
                            game.saveConfig('tmp_owner_roomId');
                        }
                        if (typeof lib.config.tmp_user_roomId == 'string') {
                            if (typeof game.roomId != 'string') {
                                if (findRoom(lib.config.tmp_user_roomId)) {
                                    game.roomId = lib.config.tmp_user_roomId;
                                }
                                else {
                                    ui.create.connecting();
                                    (function () {
                                        var n = 10;
                                        var id = lib.config.tmp_user_roomId;
                                        var interval = setInterval(function () {
                                            if (n > 0) {
                                                n--;
                                                if (findRoom(id)) {
                                                    clearInterval(interval);
                                                    game.send('server', 'enter', id, get.connectNickname(), lib.config.connect_avatar);
                                                }
                                            }
                                            else {
                                                ui.create.connecting(true);
                                                clearInterval(interval);
                                            }
                                        }, 500);
                                    }());
                                }
                            }
                            game.saveConfig('tmp_user_roomId');
                        }
                        if (window.isNonameServer) {
                            var cfg = 'pagecfg' + window.isNonameServer;
                            if (lib.config[cfg]) {
                                lib.configOL = lib.config[cfg][0];
                                game.send('server', 'server', lib.config[cfg].slice(1));
                                game.saveConfig(cfg);
                                _status.protectingroom = true;
                                setTimeout(function () {
                                    _status.protectingroom = false;
                                    if (!lib.node || !lib.node.clients || !lib.node.clients.length) {
                                        game.reload();
                                    }
                                }, 15000);
                            }
                            else {
                                game.send('server', 'server');
                            }
                        }
                        else if (typeof game.roomId == 'string') {
                            var room = findRoom(game.roomId);
                            if (game.roomIdServer && room && (room.serving || !room.version)) {
                                console.log();
                                if (lib.config.reconnect_info) {
                                    lib.config.reconnect_info[2] = null;
                                    game.saveConfig('reconnect_info', lib.config.reconnect_info);
                                }
                            }
                            else {
                                ui.create.connecting();
                                game.send('server', (game.roomId == game.onlineKey) ? 'create' : 'enter', game.roomId, get.connectNickname(), lib.config.connect_avatar);
                            }
                        }
                        lib.init.onfree();
                    };
                    if (_status.event.parent) {
                        game.forceOver('noover', proceed);
                    }
                    else {
                        proceed();
                    }
                },
                updaterooms: function (list, clients) {
                    if (ui.rooms) {
                        var map = {}, map2 = {};
                        for (var _i = 0, _a = ui.rooms; _i < _a.length; _i++) {
                            var i = _a[_i];
                            map2[i.key] = true;
                        }
                        for (var _b = 0, list_2 = list; _b < list_2.length; _b++) {
                            var i = list_2[_b];
                            if (!i)
                                continue;
                            map[i[4]] = i;
                        }
                        ui.window.classList.add('more_room');
                        for (var i = 0; i < ui.rooms.length; i++) {
                            if (!map[ui.rooms[i].key]) {
                                ui.rooms[i].remove();
                                ui.rooms.splice(i--, 1);
                            }
                            else
                                ui.rooms[i].initRoom(list[i]);
                        }
                        for (var _c = 0, list_3 = list; _c < list_3.length; _c++) {
                            var i = list_3[_c];
                            if (!i)
                                continue;
                            map[i[4]] = i;
                            if (!map2[i[4]]) {
                                var player = ui.roombase.add('<div class="popup text pointerdiv" style="width:calc(100% - 10px);display:inline-block;white-space:nowrap">空房间</div>');
                                player.roomindex = i;
                                player.initRoom = lib.element.player.initRoom;
                                player.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.connectroom);
                                player.initRoom(i);
                                ui.rooms.push(player);
                            }
                        }
                    }
                    lib.message.client.updateclients(clients, true);
                },
                updateclients: function (clients, bool) {
                    if (clients && ui.connectClients) {
                        ui.connectClients.info = clients;
                        ui.connectClientsCount.innerHTML = clients.length;
                    }
                    if (_status.connectClientsCallback) {
                        _status.connectClientsCallback();
                    }
                },
                updateevents: function (events) {
                    if (events && ui.connectEvents) {
                        ui.connectEvents.info = events;
                        var num = events.filter(function (evt) {
                            return typeof evt.creator == 'string' && (evt.creator == game.onlineKey || !get.is.banWords(evt.content));
                        }).length;
                        if (num) {
                            ui.connectEventsCount.innerHTML = num;
                            ui.connectEventsCount.show();
                        }
                        else {
                            ui.connectEventsCount.hide();
                        }
                        if (_status.connectEventsCallback) {
                            _status.connectEventsCallback();
                        }
                    }
                },
                eventsdenied: function (reason) {
                    var str = '创建约战失败';
                    if (reason == 'total') {
                        str += '，约战总数不能超过20';
                    }
                    else if (reason == 'time') {
                        str += '，时间已过';
                    }
                    else if (reason == 'ban') {
                        str += '，请注意文明发言';
                    }
                    alert(str);
                },
                init: function (id, config, ip, servermode, roomId) {
                    game.online = true;
                    game.onlineID = id;
                    game.ip = ip;
                    game.servermode = servermode;
                    game.roomId = roomId;
                    if (game.servermode) {
                        game.saveConfig('reconnect_info', [_status.ip, id, game.roomId]);
                    }
                    else {
                        game.saveConfig('reconnect_info', [_status.ip, id]);
                        game.saveConfig('tmp_user_roomId', roomId);
                    }
                    lib.config.recentIP.remove(_status.ip);
                    lib.config.recentIP.unshift(_status.ip);
                    lib.config.recentIP.splice(5);
                    game.saveConfig('recentIP', lib.config.recentIP);
                    _status.connectMode = true;
                    lib.configOL = config;
                    lib.playerOL = {};
                    lib.cardOL = {};
                    game.clearArena();
                    game.finishCards();
                    ui.create.roomInfo();
                    ui.create.chat();
                    if (game.servermode) {
                        ui.create.connectPlayers(get.modetrans(config, true));
                    }
                    else {
                        ui.create.connectPlayers(ip);
                    }
                    ui.pause.hide();
                    ui.auto.hide();
                    game.clearConnect();
                    clearTimeout(_status.createNodeTimeout);
                    var proceed = function () {
                        game.loadModeAsync(config.mode, function (mode) {
                            for (var i in mode.ai) {
                                if (typeof mode.ai[i] == 'object') {
                                    if (ai[i] == undefined)
                                        ai[i] = {};
                                    for (var j in mode.ai[i]) {
                                        ai[i][j] = mode.ai[i][j];
                                    }
                                }
                                else {
                                    ai[i] = mode.ai[i];
                                }
                            }
                            for (var i in mode.get) {
                                if (typeof mode.get[i] == 'object') {
                                    if (get[i] == undefined)
                                        get[i] = {};
                                    for (var j in mode.get[i]) {
                                        get[i][j] = mode.get[i][j];
                                    }
                                }
                                else {
                                    get[i] = mode.get[i];
                                }
                            }
                            for (var i in mode.translate) {
                                lib.translate[i] = mode.translate[i];
                            }
                            if (mode.game) {
                                game.getIdentityList = mode.game.getIdentityList;
                                game.updateState = mode.game.updateState;
                                game.getRoomInfo = mode.game.getRoomInfo;
                            }
                            if (mode.element && mode.element.player) {
                                for (var i in mode.element.player) {
                                    lib.element.player[i] = mode.element.player[i];
                                }
                            }
                            if (mode.skill) {
                                for (var i in mode.skill) {
                                    lib.skill[i] = mode.skill[i];
                                }
                            }
                            if (mode.card) {
                                for (var i in mode.card) {
                                    lib.card[i] = mode.card[i];
                                }
                            }
                            game.finishCards();
                            if (mode.characterPack) {
                                for (var i in mode.characterPack) {
                                    lib.characterPack[i] = mode.characterPack[i];
                                }
                            }
                            _status.event = {
                                finished: true,
                                next: [],
                                after: []
                            };
                            _status.paused = false;
                            game.createEvent('game', false).setContent(lib.init.startOnline);
                            game.loop();
                            game.send('inited');
                            ui.create.connecting(true);
                        });
                    };
                    if (_status.event.parent) {
                        game.forceOver('noover', proceed);
                    }
                    else {
                        proceed();
                    }
                    for (var i in lib.characterPack) {
                        for (var j in lib.characterPack[i]) {
                            lib.character[j] = lib.character[j] || lib.characterPack[i][j];
                        }
                    }
                },
                reinit: function (config, state, state2, ip, observe, onreconnect, cardtag) {
                    ui.auto.show();
                    ui.pause.show();
                    game.clearConnect();
                    clearTimeout(_status.createNodeTimeout);
                    game.online = true;
                    game.ip = ip;
                    game.servermode = state.servermode;
                    game.roomId = state.roomId;
                    if (state.over) {
                        _status.over = true;
                    }
                    if (observe) {
                        game.observe = true;
                        game.onlineID = null;
                        game.roomId = null;
                    }
                    if (game.servermode && !observe) {
                        game.saveConfig('reconnect_info', [_status.ip, game.onlineID, game.roomId]);
                    }
                    else {
                        game.saveConfig('reconnect_info', [_status.ip, game.onlineID]);
                        if (!observe) {
                            game.saveConfig('tmp_user_roomId', game.roomId);
                        }
                    }
                    _status.connectMode = true;
                    lib.configOL = config;
                    lib.playerOL = {};
                    lib.cardOL = {};
                    game.loadModeAsync(config.mode, function (mode) {
                        for (var i in mode.ai) {
                            if (typeof mode.ai[i] == 'object') {
                                if (ai[i] == undefined)
                                    ai[i] = {};
                                for (var j in mode.ai[i]) {
                                    ai[i][j] = mode.ai[i][j];
                                }
                            }
                            else {
                                ai[i] = mode.ai[i];
                            }
                        }
                        for (var i in mode.get) {
                            if (typeof mode.get[i] == 'object') {
                                if (get[i] == undefined)
                                    get[i] = {};
                                for (var j in mode.get[i]) {
                                    get[i][j] = mode.get[i][j];
                                }
                            }
                            else {
                                get[i] = mode.get[i];
                            }
                        }
                        for (var i in mode.translate) {
                            lib.translate[i] = mode.translate[i];
                        }
                        if (mode.game) {
                            game.getIdentityList = mode.game.getIdentityList;
                            game.updateState = mode.game.updateState;
                        }
                        if (mode.element && mode.element.player) {
                            for (var i in mode.element.player) {
                                lib.element.player[i] = mode.element.player[i];
                            }
                        }
                        if (mode.skill) {
                            for (var i in mode.skill) {
                                lib.skill[i] = mode.skill[i];
                            }
                        }
                        game.finishCards();
                        if (mode.characterPack) {
                            for (var i in mode.characterPack) {
                                lib.characterPack[i] = mode.characterPack[i];
                            }
                        }
                        if (mode.onreinit) {
                            mode.onreinit();
                        }
                        _status.cardtag = get.parsedResult(cardtag);
                        state = get.parsedResult(state);
                        game.players = [];
                        game.dead = [];
                        for (var i in lib.characterPack) {
                            for (var j in lib.characterPack[i]) {
                                lib.character[j] = lib.character[j] || lib.characterPack[i][j];
                            }
                        }
                        game.clearArena();
                        game.finishCards();
                        if (!observe) {
                            ui.create.chat();
                            if (ui.exitroom) {
                                ui.exitroom.remove();
                                delete ui.exitroom;
                            }
                        }
                        else {
                            if (!ui.exitroom) {
                                ui.create.system('退出旁观', function () {
                                    game.saveConfig('reconnect_info');
                                    game.reload();
                                }, true);
                            }
                            if (!lib.configOL.observe_handcard) {
                                ui.arena.classList.add('observe');
                            }
                        }
                        ui.arena.setNumber(state.number);
                        _status.mode = state.mode;
                        lib.inpile = state.inpile;
                        var pos = state.players[observe || game.onlineID].position;
                        for (var i in state.players) {
                            var info = state.players[i];
                            var player = ui.create.player(ui.arena).animate('start');
                            player.dataset.position = (info.position < pos) ? info.position - pos + parseInt(state.number) : info.position - pos;
                            if (i == observe || i == game.onlineID) {
                                game.me = player;
                            }
                            if (player.setModeState) {
                                player.setModeState(info);
                            }
                            else {
                                player.init(info.name1, info.name2);
                            }
                            if (!info.unseen)
                                player.classList.remove('unseen');
                            if (!info.unseen2)
                                player.classList.remove('unseen2');
                            if (!player.isUnseen(2) && player.storage.nohp) {
                                delete player.storage.nohp;
                                player.node.hp.show();
                            }
                            player.playerid = i;
                            player.nickname = info.nickname;
                            player.changeGroup(info.group, false, false);
                            player.identity = info.identity;
                            player.identityShown = info.identityShown;
                            player.hp = info.hp;
                            player.maxHp = info.maxHp;
                            player.hujia = info.hujia;
                            player.sex = info.sex;
                            player.side = info.side;
                            player.phaseNumber = info.phaseNumber,
                                player.setNickname();
                            if (info.dead) {
                                player.classList.add('dead');
                                if (lib.config.die_move) {
                                    player.$dieflip();
                                }
                                if (lib.element.player.$dieAfter) {
                                    lib.element.player.$dieAfter.call(player);
                                }
                                game.dead.push(player);
                            }
                            else {
                                game.players.push(player);
                            }
                            if (info.linked) {
                                player.addLink();
                            }
                            if (info.turnedover) {
                                player.classList.add('turnedover');
                            }
                            if (info.disableJudge) {
                                player.$disableJudge();
                            }
                            if (Array.isArray(info.disableEquip)) {
                                for (var ii = 0; ii < info.disableEquip.length; ii++) {
                                    player.$disableEquip(info.disableEquip[ii]);
                                }
                            }
                            player.directgain(info.handcards);
                            lib.playerOL[i] = player;
                            for (var i = 0; i < info.equips.length; i++) {
                                player.$equip(info.equips[i]);
                            }
                            for (var i = 0; i < info.handcards.length; i++) {
                                info.handcards[i].addGaintag(info.gaintag[i]);
                            }
                            for (var i = 0; i < info.specials.length; i++) {
                                info.specials[i].classList.add('glows');
                            }
                            for (var i = 0; i < info.judges.length; i++) {
                                if (info.views[i] && info.views[i] != info.judges[i]) {
                                    info.judges[i].classList.add('fakejudge');
                                    info.judges[i].viewAs = info.views[i];
                                    info.judges[i].node.background.innerHTML = lib.translate[info.views[i] + '_bg'] || get.translation(info.views[i])[0];
                                }
                                player.node.judges.appendChild(info.judges[i]);
                            }
                            ui.updatej(player);
                            if (!player.setModeState) {
                                if (!game.getIdentityList && info.identityNode) {
                                    player.node.identity.innerHTML = info.identityNode[0];
                                    player.node.identity.dataset.color = info.identityNode[1];
                                }
                                else if (player == game.me || player.identityShown || observe) {
                                    player.setIdentity();
                                    player.forceShown = true;
                                }
                                else {
                                    player.setIdentity('cai');
                                }
                                if (!lib.configOL.observe_handcard && (lib.configOL.mode == 'identity' || lib.configOL.mode == 'guozhan')) {
                                    if (observe && !player.identityShown) {
                                        player.setIdentity('cai');
                                        player.forceShown = false;
                                    }
                                }
                            }
                            player.update();
                        }
                        game.arrangePlayers();
                        ui.create.me(true);
                        _status.event = {
                            finished: true,
                            next: [],
                            after: []
                        };
                        _status.paused = false;
                        _status.dying = get.parsedResult(state.dying) || [];
                        if (game.updateState) {
                            game.updateState(state2);
                        }
                        var next = game.createEvent('game', false);
                        next.setContent(lib.init.startOnline);
                        if (observe) {
                            next.custom.replace.target = function (player) {
                                if (!lib.configOL.observe_handcard && lib.configOL.mode == 'guozhan') {
                                    return;
                                }
                                if (player.isAlive()) {
                                    if (!game.me.identityShown && lib.configOL.mode == 'guozhan') {
                                        game.me.node.identity.firstChild.innerHTML = '猜';
                                        game.me.node.identity.dataset.color = 'unknown';
                                    }
                                    game.swapPlayer(player);
                                    if (!game.me.identityShown && lib.configOL.mode == 'guozhan') {
                                        game.me.node.identity.firstChild.innerHTML = '';
                                    }
                                }
                            };
                        }
                        else {
                            if (Array.isArray(onreconnect)) {
                                onreconnect.shift().apply(this, onreconnect);
                            }
                        }
                        game.loop();
                        game.send('reinited');
                        game.showHistory();
                        _status.gameStarted = true;
                        if (lib.config.show_cardpile) {
                            ui.cardPileButton.style.display = '';
                        }
                        if (!observe && game.me && (game.me.isDead() || _status.over)) {
                            ui.create.exit();
                        }
                        ui.updatehl();
                        ui.create.connecting(true);
                    });
                },
                exec: function (func) {
                    var key = game.onlineKey;
                    if (typeof func == 'function') {
                        var args = Array.from(arguments);
                        args.shift();
                        func.apply(this, args);
                    }
                    if (key) {
                        game.onlineKey = key;
                        localStorage.setItem(lib.configprefix + 'key', game.onlineKey);
                    }
                },
                denied: function (reason) {
                    switch (reason) {
                        case 'version':
                            alert('加入失败：版本不匹配，请将游戏更新至最新版');
                            game.saveConfig('tmp_owner_roomId');
                            game.saveConfig('tmp_user_roomId');
                            game.saveConfig('reconnect_info');
                            break;
                        case 'gaming':
                            alert('加入失败：游戏已开始');
                            break;
                        case 'number':
                            alert('加入失败：房间已满');
                            break;
                        case 'banned':
                            alert('加入失败：房间拒绝你加入');
                            break;
                        case 'key':
                            alert('您的游戏版本过低，请升级到最新版');
                            game.saveConfig('tmp_owner_roomId');
                            game.saveConfig('tmp_user_roomId');
                            game.saveConfig('reconnect_info');
                            break;
                        case 'offline':
                            if (_status.paused && _status.event.name == 'game') {
                                setTimeout(game.resume, 500);
                            }
                            break;
                    }
                    game.ws.close();
                    if (_status.connectDenied) {
                        _status.connectDenied();
                    }
                },
                cancel: function (id) {
                    if (_status.event.id == id && _status.event.isMine() && _status.paused && _status.imchoosing) {
                        ui.click.cancel();
                        if (ui.confirm) {
                            ui.confirm.close();
                        }
                        if (_status.event.result) {
                            _status.event.result.id = id;
                        }
                    }
                },
                closeDialog: function (id) {
                    var dialog = get.idDialog(id);
                    if (dialog) {
                        dialog.close();
                    }
                },
                createDialog: function (id) {
                    var args = Array.from(arguments);
                    args.shift();
                    ui.create.dialog.apply(this, args).videoId = id;
                },
                gameStart: function () {
                    for (var i = 0; i < game.connectPlayers.length; i++) {
                        game.connectPlayers[i]["delete"]();
                    }
                    delete game.connectPlayers;
                    if (ui.connectStartButton) {
                        ui.connectStartButton["delete"]();
                        delete ui.connectStartButton;
                    }
                    if (ui.connectStartBar) {
                        ui.connectStartBar["delete"]();
                        delete ui.connectStartBar;
                    }
                    if (ui.roomInfo) {
                        ui.roomInfo.remove();
                        delete ui.roomInfo;
                    }
                    if (ui.exitroom) {
                        ui.exitroom.remove();
                        delete ui.exitroom;
                    }
                    ui.auto.show();
                    ui.pause.show();
                    if (lib.config.show_cardpile) {
                        ui.cardPileButton.style.display = '';
                    }
                    _status.gameStarted = true;
                    game.showHistory();
                },
                updateWaiting: function (map) {
                    if (!game.connectPlayers)
                        return;
                    if (!lib.translate.zhu) {
                        lib.translate.zhu = '主';
                    }
                    game.onlinezhu = false;
                    _status.waitingForPlayer = true;
                    for (var i = 0; i < map.length; i++) {
                        if (map[i] == 'disabled') {
                            game.connectPlayers[i].classList.add('unselectable2');
                        }
                        else {
                            game.connectPlayers[i].classList.remove('unselectable2');
                            if (map[i]) {
                                game.connectPlayers[i].initOL(map[i][0], map[i][1]);
                                game.connectPlayers[i].playerid = map[i][2];
                                if (map[i][3] == 'zhu') {
                                    game.connectPlayers[i].setIdentity('zhu');
                                    if (map[i][2] == game.onlineID) {
                                        game.onlinezhu = true;
                                        if (ui.roomInfo) {
                                            ui.roomInfo.innerHTML = '房间设置';
                                        }
                                        if (ui.connectStartButton) {
                                            ui.connectStartButton.innerHTML = '开始游戏';
                                        }
                                    }
                                }
                                else {
                                    game.connectPlayers[i].node.identity.firstChild.innerHTML = '';
                                }
                            }
                            else {
                                game.connectPlayers[i].uninitOL();
                                delete game.connectPlayers[i].playerid;
                            }
                        }
                    }
                }
            }
        },
        /**
         * 游戏牌颜色
         * @type {('red'|'black'|'none')}
         */
        color: ['red', 'black', 'none'],
        /**
         * 游戏牌花色
         * @type {('club'|'spade'|'diamond'|'heart')}
         */
        suit: ['club', 'spade', 'diamond', 'heart'],
        /**
         * 游戏牌点数
         * @type {('A'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'X'|'J'|'Q'|'K')}
         */
        number: ['A', '2', '3', '4', '5', '6', '7', '8', '9', 'X', 'J', 'Q', 'K'],
        /**
         * 武将牌势力
         * |string|Group Name|
         * |:----:|:--------:|
         * |vtuber|企业|
         * |clubs|社团|
         * |wei|魏|
         * |shu|蜀|
         * |wu|吴|
         * |qun|群|
         * |jin|晋|
         * |shen|神、特典|
         * |holo|Hololive|
         * |nijisanji|虹|
         * |dotlive|点|
         * |upd8|U|
         * |eilene|艾琳|
         * |paryi|帕里|
         * |kagura|神楽|
         * |nori|苔|
         * |vwp|神椿|
         * |nanashi|774 inc.|
         * |VirtuaReal|VirtuaReal|
         * |psp|psplive|
         * |asoul|A-SOUL|
         * |chaos|Chaos Live|
         * |xuefeng|雪风军团|
         * |vshojo|Vshojo|
         * @type {string}
         */
        group: [
            'vtuber', 'clubs',
            'wei', 'shu', 'wu', 'qun', 'jin', 'shen',
            'holo', 'nijisanji', 'dotlive', 'upd8', 'eilene', 'paryi', 'kagura', 'nori', 'vwp', 'nanashi',
            'VirtuaReal', 'HappyElements', 'psp', 'asoul', 'xuyan', 'chaos', 'xuefeng', 'NetEase', 'hunmiao', 'ego', 'chidori', 'lucca',
            'vshojo'
        ],
        /**
         * shen势力可选的武将牌势力
         * 较group去除了企业、社团、三国势力
         * @type {string}
         */
        group2: ['qun', 'holo', 'nijisanji', 'VirtuaReal', 'nori', 'paryi', 'upd8', 'kagura', 'nanashi', 'psp', 'asoul', 'vwp', 'xuyan', 'chaos', 'xuefeng'],
        /**
         * 卡牌属性
         * @type {('fire'|'thunder'|'poison'|'ocean'|'ice'|'kami'|'yami')}
         */
        nature: ['fire', 'thunder', 'poison', 'ocean', 'ice', 'kami', 'yami'],
        /**
         * 铁索属性 - TODO
         * @type {string}
         */
        linked: ['fire', 'thunder', 'ocean', 'ice', 'kami', 'yami'],
        /**
         * 势力对应属性
         * @constant
         */
        groupnature: {
            shen: 'thunder',
            wei: 'water',
            shu: 'soil',
            wu: 'wood',
            qun: 'metal',
            western: 'thunder',
            key: 'key',
            jin: 'thunder',
            ye: 'thunder',
            holo: 'soil',
            upd8: 'metal',
            dotlive: 'wood',
            nijisanji: 'water',
            VirtuaReal: 'ocean',
            HappyElements: 'ocean',
            eilene: 'thunder',
            paryi: 'ice',
            kagura: 'ocean',
            nanashi: 'wood',
            psp: 'fire',
            asoul: 'fire',
            nori: 'key',
            vwp: 'key',
            vshojo: 'metal',
            xuyan: 'ice',
            chaos: 'ocean',
            xuefeng: 'ocean',
            NetEase: 'fire',
            hunmiao: 'ocean',
            ego: 'ocean',
            chidori: 'wood',
            lucca: 'wood',
            vtuber: 'metal',
            clubs: 'ice'
        },
        /**
         * 游戏阶段
         *
         * @type {string}
         */
        phaseName: ['phaseZhunbei', 'phaseJudge', 'phaseDraw', 'phaseUse', 'phaseDiscard', 'phaseJieshu'],
        /**
         * 快捷语音 - TODO
         * @type {string}
         */
        quickVoice: [
            '我从未见过如此厚颜无耻之人！',
            '这波不亏',
            '请收下我的膝盖',
            '你咋不上天呢',
            '放开我的队友，冲我来',
            '你随便杀，闪不了算我输',
            '见证奇迹的时刻到了',
            '能不能快一点啊，兵贵神速啊',
            '主公，别开枪，自己人',
            '小内再不跳，后面还怎么玩儿啊',
            '你们忍心，就这么让我酱油了？',
            '我，我惹你们了吗',
            '姑娘，你真是条汉子',
            '三十六计，走为上，容我去去便回',
            '人心散了，队伍不好带啊',
            '昏君，昏君啊！',
            '风吹鸡蛋壳，牌去人安乐',
            '小内啊，您老悠着点儿',
            '不好意思，刚才卡了',
            '你可以打得再烂一点吗',
            '哥们，给力点儿行嘛',
            '哥哥，交个朋友吧',
            '妹子，交个朋友吧',
        ]
    });
    return lib;
});
